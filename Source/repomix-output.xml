This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
WitchPT.Target.cs
WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp
WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp
WitchPT/Private/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.cpp
WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
WitchPT/Private/Character/WitchPTCharacter.cpp
WitchPT/Private/Character/WitchPTCharacterBase.cpp
WitchPT/Private/Character/WitchPTEnemy.cpp
WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp
WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp
WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp
WitchPT/Private/Equipment/WitchPTQuickBarComponent.cpp
WitchPT/Private/Game/WitchPTGameModeBase.cpp
WitchPT/Private/Input/WitchPTInputComponent.cpp
WitchPT/Private/Input/WitchPTInputConfig.cpp
WitchPT/Private/Inventory/Collectable.cpp
WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
WitchPT/Private/Item/BaseInteractableAltar.cpp
WitchPT/Private/Item/BaseInteractionPosition.cpp
WitchPT/Private/Item/CauldronAltar.cpp
WitchPT/Private/Item/CauldronPosition.cpp
WitchPT/Private/Item/Components/CauldronCraftComponent.cpp
WitchPT/Private/Item/Ingredient/IngredientBase.cpp
WitchPT/Private/Item/Item.cpp
WitchPT/Private/Item/MechanicsInterface.cpp
WitchPT/Private/Item/PositionInterface.cpp
WitchPT/Private/Item/Potion/PotionBase.cpp
WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
WitchPT/Private/Item/RitualAltar.cpp
WitchPT/Private/Item/RitualPosition.cpp
WitchPT/Private/Player/WitchPTPlayerController.cpp
WitchPT/Private/Player/WitchPTPlayerState.cpp
WitchPT/Private/Subsystems/UIManagerSubsystem.cpp
WitchPT/Private/Subsystems/WidgetCommunicatorSubsystem.cpp
WitchPT/Private/UI/HUD/WitchPTHUD.cpp
WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/QuickBarWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
WitchPT/Private/UI/Widgets/Layer/WitchPTUILayer.cpp
WitchPT/Private/UI/Widgets/PointerWidget.cpp
WitchPT/Private/UI/Widgets/QuickBarUserWidget.cpp
WitchPT/Private/UI/Widgets/WitchPTPrimaryLayout.cpp
WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
WitchPT/Private/WitchPTAssetManager.cpp
WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h
WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h
WitchPT/Public/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h
WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
WitchPT/Public/Character/WitchPTCharacter.h
WitchPT/Public/Character/WitchPTCharacterBase.h
WitchPT/Public/Character/WitchPTEnemy.h
WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h
WitchPT/Public/Equipment/WitchPTEquipmentInstance.h
WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h
WitchPT/Public/Equipment/WitchPTQuickBarComponent.h
WitchPT/Public/FWitchPTGameplayTags.cpp
WitchPT/Public/FWitchPTGameplayTags.h
WitchPT/Public/Game/WitchPTGameModeBase.h
WitchPT/Public/Input/WitchPTInputComponent.h
WitchPT/Public/Input/WitchPTInputConfig.h
WitchPT/Public/Inventory/Collectable.h
WitchPT/Public/Inventory/FastArray/FastArrayList.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
WitchPT/Public/Inventory/InventoryFunctionLibrary.h
WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
WitchPT/Public/Item/BaseInteractableAltar.h
WitchPT/Public/Item/BaseInteractionPosition.h
WitchPT/Public/Item/CauldronAltar.h
WitchPT/Public/Item/CauldronPosition.h
WitchPT/Public/Item/Components/CauldronCraftComponent.h
WitchPT/Public/Item/Ingredient/IngredientBase.h
WitchPT/Public/Item/Item.h
WitchPT/Public/Item/MechanicsInterface.h
WitchPT/Public/Item/PositionInterface.h
WitchPT/Public/Item/Potion/PotionBase.h
WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
WitchPT/Public/Item/RitualAltar.h
WitchPT/Public/Item/RitualPosition.h
WitchPT/Public/Player/WitchPTPlayerController.h
WitchPT/Public/Player/WitchPTPlayerState.h
WitchPT/Public/Subsystems/UIManagerSubsystem.h
WitchPT/Public/Subsystems/WidgetCommunicatorSubsystem.h
WitchPT/Public/Systems/GameplayTagStack.cpp
WitchPT/Public/Systems/GameplayTagStack.h
WitchPT/Public/UI/HUD/WitchPTHUD.h
WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
WitchPT/Public/UI/WidgetControllers/QuickBarWidgetController.h
WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
WitchPT/Public/UI/Widgets/CauldronUserWidget.h
WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
WitchPT/Public/UI/Widgets/Layer/WitchPTUILayer.h
WitchPT/Public/UI/Widgets/PointerWidget.h
WitchPT/Public/UI/Widgets/QuickBarUserWidget.h
WitchPT/Public/UI/Widgets/WitchPTPrimaryLayout.h
WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
WitchPT/Public/WitchPTAssetManager.h
WitchPT/WitchPT.Build.cs
WitchPT/WitchPT.cpp
WitchPT/WitchPT.h
WitchPTEditor.Target.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="WitchPT.Target.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class WitchPTTarget : TargetRules
{
	public WitchPTTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V5;

		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/PlayerController.h"
#include "Engine/World.h"
#include "DrawDebugHelpers.h"
#include "TimerManager.h"
#include "GameFramework/Character.h"
#include "Camera/CameraComponent.h"

UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bTickingTask = true;
	TraceDistance = 500.0f;
	TraceRadius = 10.0f;
	bTraceComplex = false;
	bIgnoreBlockingHits = false;
	bShowDebug = false;
	LastHitLocation = FVector::ZeroVector;
	LastHitNormal = FVector::UpVector;
}

UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
	UGameplayAbility* OwningAbility,
	float TraceDistance,
	float TraceRadius,
	bool TraceComplex,
	bool bIgnoreBlockingHits,
	bool bShowDebug)
{
	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
	
	MyObj->TraceDistance = TraceDistance;
	MyObj->TraceRadius = TraceRadius;
	MyObj->bTraceComplex = TraceComplex;
	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
	MyObj->bShowDebug = bShowDebug;
	
	return MyObj;
}

void UAT_WaitForPlacementLocation_SLT::Activate()
{
	Super::Activate();
	
	// Configurar para ejecutar el trace en cada tick
	SetWaitingOnAvatar();
	
	// Realizar un primer trace inmediatamente
	PerformTrace();
}

void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
{
	// Limpiar el temporizador si está activo
	UWorld* World = GetWorld();
	if (World)
	{
		World->GetTimerManager().ClearTimer(TraceTimerHandle);
	}
	
	Super::OnDestroy(bInOwnerFinished);
}

void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
{
	Super::TickTask(DeltaTime);
	
	// Realizar el trace en cada tick
	PerformTrace();
}

void UAT_WaitForPlacementLocation_SLT::PerformTrace()
{
	if (!Ability || !Ability->GetCurrentActorInfo())
	{
		return;
	}
	
	// Obtener el controlador del jugador
	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
	if (!PC)
	{
		return;
	}
	
	// Obtener el personaje del jugador (necesario para obtener la cámara)
	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
	if (!Character)
	{
		return;
	}
	
	// Definir los puntos de inicio y fin del trace
	FVector TraceStart;
	FVector TraceDirection;
	
	// Buscar un componente de cámara en el personaje
	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
	if (CameraComponent)
	{
		// Usar la posición y dirección de la cámara para el trace
		TraceStart = CameraComponent->GetComponentLocation();
		TraceDirection = CameraComponent->GetForwardVector();
	}
	else
	{
		// Si no hay cámara, usar la rotación del controlador
		FRotator ControllerRotation = PC->GetControlRotation();
		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
		TraceDirection = ControllerRotation.Vector();
	}
	
	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
	
	// Configurar parámetros del trace
	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
	QueryParams.AddIgnoredActor(Character);
	
	// Configurar qué tipos de objetos detectar
	ECollisionChannel TraceChannel = ECC_Visibility;
	
	// Realizar el trace
	FHitResult HitResult;
	bool bHit = false;
	
	// Realizar un sphere trace o line trace según el radio
	if (TraceRadius > 0.0f)
	{
		bHit = GetWorld()->SweepSingleByChannel(
			HitResult,
			TraceStart,
			TraceEnd,
			FQuat::Identity,
			TraceChannel,
			FCollisionShape::MakeSphere(TraceRadius),
			QueryParams
		);
	}
	else
	{
		bHit = GetWorld()->LineTraceSingleByChannel(
			HitResult,
			TraceStart,
			TraceEnd,
			TraceChannel,
			QueryParams
		);
	}
	
	// Si encontramos un hit y es diferente al último que reportamos
	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
	{
		// Almacenar los nuevos valores
		LastHitLocation = HitResult.ImpactPoint;
		LastHitNormal = HitResult.ImpactNormal;
		
		// Disparar el delegado con la información del hit
		if (ShouldBroadcastAbilityTaskDelegates())
		{
			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
		}
	}
	
	// Mostrar debug si está habilitado
	if (bShowDebug)
	{
		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
		
		if (bHit)
		{
			// Dibujar una esfera en el punto de impacto
			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
			
			// Dibujar la normal
			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
		}
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/GA_CauldronPlace.h"
#include "Item/CauldronAltar.h"
#include "GameFramework/Character.h"
#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"

UGA_CauldronPlace::UGA_CauldronPlace()
{
    // Configurar entradas para esta habilidad
   
    
    // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    
    // Flags de red
    NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
    
    // No se requiere confirmación para activar
    bServerRespectsRemoteAbilityCancellation = true;
}

void UGA_CauldronPlace::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    // Llamar a la implementación base
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Buscar el caldero que está en modo previsualización
    ACauldronAltar* CauldronAltar = FindPreviewingCauldron();
    if (!CauldronAltar)
    {
        UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlace: No se encontró un caldero en modo previsualización"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Intentar finalizar la colocación
    // CauldronAltar->Server_FinalizePlacement();
    
   
    
    // Terminar la habilidad independientemente del resultado
    EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
}

ACauldronAltar* UGA_CauldronPlace::FindPreviewingCauldron()
{
    // Obtener el personaje que está usando la habilidad
    ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
    if (!Character)
    {
        return nullptr;
    }
    
    // Buscar todos los calderos en el mundo
    TArray<AActor*> FoundCauldrons;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
    
    // Buscar el caldero que está en modo previsualización para este personaje
    for (AActor* Actor : FoundCauldrons)
    {
        ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
        if (Cauldron && Cauldron->IsInPlacementPreview() && Cauldron->GetCarryingCharacter() == Character)
        {
            return Cauldron;
        }
    }
    
    return nullptr;
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h"
#include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
#include "Item/CauldronAltar.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/Character.h"
#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"

UGA_CauldronPlacementPreview::UGA_CauldronPlacementPreview()
{
    // Configurar entradas para esta habilidad
    
    // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    
    // Flags de red
    NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
    
    // No se requiere confirmación para activar
    bServerRespectsRemoteAbilityCancellation = true;
}

void UGA_CauldronPlacementPreview::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    // Llamar a la implementación base
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Buscar el caldero que está llevando el personaje
    CauldronAltar = FindCarriedCauldron();
    if (!CauldronAltar)
    {
        UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlacementPreview: No se encontró un caldero que esté siendo llevado por el personaje"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Iniciar el modo de previsualización en el caldero
    // CauldronAltar->Server_StartPlacementPreview(Cast<ACharacter>(ActorInfo->AvatarActor.Get()));
    
    // Vincular entradas para confirmar/cancelar
    FGameplayAbilityActorInfo* ActorInfoConst = const_cast<FGameplayAbilityActorInfo*>(ActorInfo);
    
    // Configurar vinculaciones de entrada
    if (IsLocallyControlled())
    {
        // Vincular eventos de entrada para confirmar/cancelar
        
    }
    
    // Crear la tarea de seguimiento de ubicación
    UAT_WaitForPlacementLocation_SLT* Task = UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
        this, 
        TraceDistance, 
        TraceRadius, 
        bTraceComplex, 
        false, 
        bShowDebug
    );
    
    if (Task)
    {
        // Configurar el callback para cuando encuentre una ubicación
        Task->OnLocationFound.AddDynamic(this, &UGA_CauldronPlacementPreview::OnLocationFound);
        
        // Activar la tarea
        Task->ReadyForActivation();
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("GA_CauldronPlacementPreview: No se pudo crear la tarea de ubicación"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
    }
    
    // Llamar a la implementación base después de configurar todo
    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UGA_CauldronPlacementPreview::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
    // Si la habilidad fue cancelada y tenemos un caldero, cancelar la colocación
    if (bWasCancelled && CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // CauldronAltar->Server_CancelPlacement();
    }
    
    // Desvincular entradas si es necesario
    if (IsLocallyControlled())
    {
        // TODO: Desvincular eventos de entrada si es necesario
    }
    
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

ACauldronAltar* UGA_CauldronPlacementPreview::FindCarriedCauldron()
{
    // Obtener el personaje que está usando la habilidad
    ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
    if (!Character)
    {
        return nullptr;
    }
    
    // Buscar todos los calderos en el mundo
    TArray<AActor*> FoundCauldrons;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
    
    // Buscar el caldero que está siendo llevado por este personaje
    for (AActor* Actor : FoundCauldrons)
    {
        ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
        if (Cauldron && Cauldron->IsBeingCarried() && Cauldron->GetCarryingCharacter() == Character)
        {
            return Cauldron;
        }
    }
    
    return nullptr;
}

void UGA_CauldronPlacementPreview::OnConfirmPlacement()
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
         // CauldronAltar->Server_FinalizePlacement();
        // if (bSuccess)
        // {
        //     // La colocación fue exitosa, terminar la habilidad
        //     CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
        // }
        // Si no tuvo éxito, seguimos en modo de previsualización
    }
}

void UGA_CauldronPlacementPreview::OnCancelPlacement()
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // Cancelar la colocación y volver a adjuntar el caldero al personaje
        // CauldronAltar->Server_CancelPlacement();
    }
    
    // Terminar la habilidad
    CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
}

void UGA_CauldronPlacementPreview::OnLocationFound(FVector HitLocation, FVector HitNormal)
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // Actualizar la posición de previsualización del caldero
        // CauldronAltar->UpdatePlacementPreview(HitLocation, HitNormal);
    }
}
</file>

<file path="WitchPT/Private/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h"

#include "FWitchPTGameplayTags.h"

UGA_QuickBarSlots::UGA_QuickBarSlots()
{
	
}
</file>

<file path="WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"

#include "AbilitySystemComponent.h"

UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{
	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
}

void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
                                            const FGameplayAbilitySpec& Spec)
{
	Super::OnGiveAbility(ActorInfo, Spec);
	TryActivateAbilityOnSpawn(ActorInfo, Spec);
}

void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayAbilitySpec& Spec) const
{
	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
	{
		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
		AbilitySystem->TryActivateAbility(Spec.Handle);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"

#include "AbilitySystemComponent.h"
#include "Engine/OverlapResult.h"
#include "Engine/World.h"
#include "GameFramework/Controller.h"

#include "TimerManager.h"
#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "AbilitySystem/Interaction/InteractionQuery.h"
#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "WitchPT/WitchPT.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}
void UAbilityTask_GrantNearbyInteraction::Activate()
{
	
	SetWaitingOnAvatar();
	UWorld* World = GetWorld();
	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);

}

void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
{
	Super::OnGameplayTaskActivated(Task);
	
}

UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
                                                                                                             float InteractionScanRange, float InteractionScanRate)
{

	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
	MyObj->InteractionScanRange = InteractionScanRange;
	MyObj->InteractionScanRate = InteractionScanRate;
	return MyObj;
}

void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
{
	// Limpiar el temporizador
	UWorld* World = GetWorld();
	if (World)
	{
		World->GetTimerManager().ClearTimer(QueryTimerHandle);
	}
	
	// Limpiar las habilidades concedidas
	// if (AbilitySystemComponent)
	// {
	// 	// Limpiar habilidades de interacción rápida
	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : InteractionAbilityCache)
	// 	{
	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
	// 	}
	// 	
	// 	// Limpiar habilidades de interacción mantenida
	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : HoldInteractionAbilityCache)
	// 	{
	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
	// 	}
	// }
	//
	// InteractionAbilityCache.Empty();
	// HoldInteractionAbilityCache.Empty();
	
	Super::OnDestroy(AbilityEnded);
}

void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
{
	UWorld* World = GetWorld();
	AActor* ActorOwner = GetAvatarActor();
	
	if (World && ActorOwner)
	{
		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);

		TArray<FOverlapResult> OverlapResults;
		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);

		if (OverlapResults.Num() > 0)
		{
			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
			
			FInteractionQuery InteractionQuery;
			InteractionQuery.RequestingAvatar = ActorOwner;
			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());

			TArray<FInteractionOption> Options;
			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
			{
				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
			}

			// Check if any of the options need to grant the ability to the user before they can be used.
			for (FInteractionOption& Option : Options)
			{
				// Otorgar la habilidad de interacción regular
				if (Option.InteractionAbilityToGrant)
				{
					// Grant the ability to the GAS, otherwise it won't be able to do whatever the interaction is.
					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
					if (!InteractionAbilityCache.Find(ObjectKey))
					{
						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
						InteractionAbilityCache.Add(ObjectKey, Handle);
					}
				}
				
				// Otorgar la habilidad de interacción mantenida si está disponible y soportada
				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
				{
					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
					if (!HoldInteractionAbilityCache.Find(ObjectKey))
					{
						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
					}
				}
			}
		}
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
#include "AbilitySystemComponent.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
struct FInteractionQuery;

UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}
void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
{
	check(World);

	OutHitResult = FHitResult();
	FHitResult HitResult;
	// World->LineTraceMultiByProfile(HitResults, Start, End, CollisionChannel, Params);
	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
	OutHitResult.TraceStart = Start;
	OutHitResult.TraceEnd = End;

	OutHitResult = HitResult;
}

void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
{
	if (!Ability) // Server and launching client only
	{
		return;
	}

	//@TODO: Bots?
	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
	check(PC);

	FVector ViewStart;
	FRotator ViewRot;
	PC->GetPlayerViewPoint(ViewStart, ViewRot);

	const FVector ViewDir = ViewRot.Vector();
	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);

	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);

	FHitResult HitResult;
	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);

	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));

	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;

	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
	if (AdjustedAimDir.IsZero())
	{
		AdjustedAimDir = ViewDir;
	}

	if (!bTraceAffectsAimPitch && bUseTraceResult)
	{
		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();

		if (!OriginalAimDir.IsZero())
		{
			// Convert to angles and use original pitch
			const FRotator OriginalAimRot = OriginalAimDir.Rotation();

			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;

			AdjustedAimDir = AdjustedAimRot.Vector();
		}
	}

	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
}

bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
{
	FVector CameraToCenter = AbilityCenter - CameraLocation;
	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
	if (DotToCenter >= 0)		//If this fails, we're pointed away from the center, but we might be inside the sphere and able to find a good exit point.
	{
		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
		float RadiusSquared = (AbilityRange * AbilityRange);
		if (DistanceSquared <= RadiusSquared)
		{
			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
			float DistanceAlongRay = DotToCenter + DistanceFromCamera;						//Subtracting instead of adding will get the other intersection point
			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);		//Cam aim point clipped to range sphere
			return true;
		}
	}
	return false;
}

void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
{
	TArray<FInteractionOption> NewOptions;

	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
	{
		TArray<FInteractionOption> TempOptions;
		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);

		for (FInteractionOption& Option : TempOptions)
		{
			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;

			// if there is a handle an a target ability system, we're triggering the ability on the target.
			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
			{
				// Find the spec
				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
			}
			// If there's an interaction ability then we're activating it on ourselves.
			else if (Option.InteractionAbilityToGrant)
			{
				// Find the spec
				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);

				if (InteractionAbilitySpec)
				{
					// update the option
					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
				}
			}
			if (Option.HoldInteractionAbilityToGrant)
			{
				// Find the spec
				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);

				if (InteractionAbilitySpec)
				{
					// update the option
					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
				}
			}
			if (InteractionAbilitySpec)
			{
				// Filter any options that we can't activate right now for whatever reason.
				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
				{
					NewOptions.Add(Option);
				}
			}
		}
	}

	bool bOptionsChanged = false;
	if (NewOptions.Num() == CurrentOptions.Num())
	{
		NewOptions.Sort();

		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
		{
			const FInteractionOption& NewOption = NewOptions[OptionIndex];
			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];

			if (NewOption != CurrentOption)
			{
				bOptionsChanged = true;
				break;
			}
		}
	}
	else
	{
		bOptionsChanged = true;
	}

	if (bOptionsChanged)
	{
		CurrentOptions = NewOptions;
		InteractableObjectsChanged.Broadcast(CurrentOptions);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"

#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "Kismet/GameplayStatics.h"

UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
	bool bShowDebug)
{
	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
	MyObj->InteractionScanRange = InteractionScanRange;
	MyObj->InteractionScanRate = InteractionScanRate;
	MyObj->StartLocation = StartLocation;
	MyObj->InteractionQuery = InteractionQuery;
	MyObj->TraceProfile = TraceProfile;
	MyObj->bShowDebug = bShowDebug;

	return MyObj;
}
void UAT_WaitForInteractable_SLT::Activate()
{
	SetWaitingOnAvatar();

	UWorld* World = GetWorld();
	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
}

void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
{
	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().ClearTimer(TimerHandle);
	}

	Super::OnDestroy(AbilityEnded);
}

void UAT_WaitForInteractable_SLT::PerformTrace()
{
	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
	
	if (!AvatarActor)
	{
		return;
	}

	UWorld* World = GetWorld();

	TArray<AActor*> ActorsToIgnore;
	ActorsToIgnore.Add(AvatarActor);

	const bool bTraceComplex = false;
	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
	Params.AddIgnoredActors(ActorsToIgnore);
	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
	FVector2D ViewportSize;
	GEngine->GameViewport->GetViewportSize(ViewportSize);
	const FVector2D ViewportCenter = ViewportSize / 2.f;
	FVector TraceStart;
	FVector Forward;
	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;

	
	FVector TraceEnd;
	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);

	FHitResult OutHitResult;
	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);

	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);

	UpdateInteractableOptions(InteractionQuery, InteractableTargets);

#if ENABLE_DRAW_DEBUG
	if (bShowDebug)
	{
		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
		if (OutHitResult.bBlockingHit)
		{
			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
		}
		else
		{
			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
		}
	}
#endif // ENABLE_DRAW_DEBUG
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/GameplayAbility_Interact.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "NativeGameplayTags.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "Engine/World.h"
#include "Player/WitchPTPlayerController.h"

UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");

UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
}

void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
	const FGameplayEventData* TriggerEventData)
{
	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
	{
		
		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
		Task->ReadyForActivation();
		
	}
}

void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
{
	
	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
	{
		
		
		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
		
		CurrentOptions = InteractiveOptions;
		
		for (const FInteractionOption& InteractionOption : InteractiveOptions)
		{
			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
		
			if (InteractableTargetActor)
			{
				FString ActorName = InteractableTargetActor->GetName();
				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
			}
			
			
		}
		if (InteractiveOptions.Num() == 0)
		{
			WitchPt->HUDWidget->HidePickupMessage();
		}

	}
	
	CurrentOptions = InteractiveOptions;
}

void UGameplayAbility_Interact::TriggerInteraction()
{
	if (CurrentOptions.Num() == 0)
	{
		return;
	}

	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	if (AbilitySystem)
	{
		const FInteractionOption& InteractionOption = CurrentOptions[0];

		AActor* Instigator = GetAvatarActorFromActorInfo();
		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

		// Allow the target to customize the event data we're about to pass in, in case the ability needs custom data
		// that only the actor knows.
		FGameplayEventData Payload;
		Payload.EventTag = TAG_Ability_Interaction_Activate;
		Payload.Instigator = Instigator;
		Payload.Target = InteractableTargetActor;

		// If needed we allow the interactable target to manipulate the event data so that for example, a button on the wall
		// may want to specify a door actor to execute the ability on, so it might choose to override Target to be the
		// door actor.
		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
		

		// Grab the target actor off the payload we're going to use it as the 'avatar' for the interaction, and the
		// source InteractableTarget actor as the owner actor.
		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));

		// The actor info needed for the interaction.
		FGameplayAbilityActorInfo ActorInfo;
		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);

		// Trigger the ability using event tag.
		
		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
			InteractionOption.TargetInteractionAbilityHandle,
			&ActorInfo,
			TAG_Ability_Interaction_Activate,
			&Payload,
			*InteractionOption.TargetAbilitySystem
		);
		
		// Notificar que se completó la interacción
		OnInteractionComplete.Broadcast();
	}
}

void UGameplayAbility_Interact::TriggerHoldInteraction()
{
	if (CurrentOptions.Num() == 0)
	{
		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
		OnInteractionCancelled.Broadcast();
		return;
	}

	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	if (AbilitySystem)
	{
		const FInteractionOption& InteractionOption = CurrentOptions[0];

		// Verificar si la opción de interacción soporta interacción mantenida
		if (!InteractionOption.bSupportsHoldInteraction)
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
			// Si no soporta interacción mantenida, podemos usar la interacción normal en su lugar
			TriggerInteraction();
			return;
		}

		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
		
		AActor* Instigator = GetAvatarActorFromActorInfo();
		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

		// Configurar los datos del evento para la interacción mantenida
		FGameplayEventData Payload;
		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
		Payload.Instigator = Instigator;
		Payload.Target = InteractableTargetActor;

		// Permitir que el objetivo personalice los datos del evento
		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);

		// Obtener el actor objetivo
		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));

		// La información del actor necesaria para la interacción
		FGameplayAbilityActorInfo ActorInfo;
		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);

		// Usar el handle de habilidad específico para interacción mantenida, si está disponible
		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
		
		// Si no hay un handle específico para interacción mantenida, usar el handle normal
		if (!AbilityHandle.IsValid())
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
		}

		// Activar la habilidad usando la etiqueta de evento de interacción mantenida
		// UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Intentando activar habilidad con tag %s"), *TAG_Ability_Interaction_Hold_Activate.ToString());
		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
			AbilityHandle,
			&ActorInfo,
			TAG_Ability_Interaction_Hold_Activate,
			&Payload,
			*InteractionOption.TargetAbilitySystem
		);
		
		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
		
		// Notificar que se completó la interacción mantenida
		OnHoldInteractionComplete.Broadcast();
	}
}

void UGameplayAbility_Interact::OnInteractionButtonPressed()
{
	if (CurrentOptions.Num() == 0)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No hay opciones de interacción disponibles"));
		OnInteractionCancelled.Broadcast();
		return;
	}
	
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción presionado"));
	bIsInteractionButtonHeld = true;
	bHoldInteractionFired = false; // Reiniciamos la bandera al comenzar una nueva interacción
	InteractionStartTime = GetWorld()->GetTimeSeconds();
	
	// Guardar el objetivo interactuable actual para validaciones posteriores
	if (CurrentOptions.Num() > 0)
	{
		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Guardando objetivo inicial de interacción"));
	}
	
	// Configurar un temporizador para detectar si el botón se mantiene presionado durante el tiempo requerido
	GetWorld()->GetTimerManager().SetTimer(
		HoldInteractionTimerHandle,
		this,
		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
		HoldInteractionTime,
		false
	);
	
	// Iniciar comprobación periódica de validez
	GetWorld()->GetTimerManager().SetTimer(
		ValidityCheckTimerHandle,
		this,
		&UGameplayAbility_Interact::CheckInteractionValidity,
		ValidityCheckRate,
		true // Repetitivo
	);
	
	// Configurar el temporizador de seguridad para forzar un reinicio después de un tiempo máximo
	GetWorld()->GetTimerManager().SetTimer(
		MaxInteractionTimeTimerHandle,
		this,
		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
		MaxInteractionTime,
		false // No repetitivo
	);
	
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizadores configurados. Hold: %f segundos, Max: %f segundos"), 
	// 	HoldInteractionTime, MaxInteractionTime);
}

void UGameplayAbility_Interact::OnInteractionButtonReleased()
{
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción liberado"));
	
	if (!bIsInteractionButtonHeld)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón no estaba siendo mantenido, ignorando liberación"));
		return;
	}
	
	bIsInteractionButtonHeld = false;
	
	// Cancelar los temporizadores
	if (GetWorld())
	{
		// Temporizador de validez
		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
		}
		
		// Temporizador de seguridad
		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
		}
		
		// Temporizador de interacción mantenida
		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
		{
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizador de hold cancelado"));
			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
			
			// Verificamos si ya se lanzó una interacción mantenida
			if (bHoldInteractionFired)
			{
				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Ya se disparó una interacción mantenida, ignorando interacción rápida"));
				return; // Si ya se disparó una interacción mantenida, no lanzamos la rápida
			}
			
			// Si el botón se soltó antes del tiempo de interacción mantenida, considerarlo como una pulsación rápida
			float CurrentTime = GetWorld()->GetTimeSeconds();
			float HoldTime = CurrentTime - InteractionStartTime;
			
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo mantenido: %f / Requerido: %f"), HoldTime, HoldInteractionTime);
			
			if (HoldTime < HoldInteractionTime)
			{
				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción rápida"));
				// Llamar a la interacción de pulsación rápida
				TriggerInteraction();
				
				// Llamar a InteractPressScan después de la interacción para restaurar el estado
				// y prepararse para la siguiente interacción
				// Nota: Esto debe implementarse en el blueprint conectando la salida de este nodo
				// a la entrada del nodo InteractPressScan
			}
		}
		else
		{
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No había temporizador activo al liberar el botón"));
		}
	}
	
	// Limpiar la referencia al objetivo inicial
	InitialInteractableTarget = nullptr;
}

void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
{
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo de interacción mantenida alcanzado"));
	
	if (bIsInteractionButtonHeld)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción mantenida"));
		// Marcamos que ya se disparó la interacción mantenida
		bHoldInteractionFired = true;
		
		// El botón se ha mantenido presionado durante el tiempo requerido
		// Llamar a la interacción mantenida
		TriggerHoldInteraction();
		
		// Nota: Después de llamar a TriggerHoldInteraction, 
		// es necesario llamar a InteractPressScan en el blueprint
		// para restaurar el estado y prepararse para la siguiente interacción
		// Esto se logra escuchando al delegado OnHoldInteractionComplete
	}
	else
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón ya no está presionado, no se activa interacción mantenida"));
	}
}

void UGameplayAbility_Interact::CheckInteractionValidity()
{
	// Si no estamos en un estado de interacción, no necesitamos verificar
	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
	{
		return;
	}
	
	// Log adicional para verificar estado actual
	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
	
	// Verificar si aún hay opciones de interacción disponibles
	bool bHasValidInteraction = false;
	
	if (CurrentOptions.Num() > 0)
	{
		// Buscar el objetivo inicial en cualquier posición del array
		for (const FInteractionOption& Option : CurrentOptions)
		{
			if (Option.InteractableTarget == InitialInteractableTarget)
			{
				bHasValidInteraction = true;
				break;
			}
		}
		
		// Log detallado sobre la validación
		if (bHasValidInteraction)
		{
			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
		}
		else
		{
			// Intentar identificar qué cambió
			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
			AActor* CurrentActor = CurrentOptions.Num() > 0 ? 
				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
			
			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"), 
				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
		}
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
	}
	
	// Si no hay una interacción válida, cancelar la interacción actual
	if (!bHasValidInteraction)
	{
		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
		CancelCurrentInteraction();
	}
}

void UGameplayAbility_Interact::CancelCurrentInteraction()
{
	// Si no estamos en un estado de interacción, no hay nada que cancelar
	if (!bIsInteractionButtonHeld)
	{
		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
		return;
	}
	
	// Obtener información del objeto inicial para el log
	FString InitialObjectName = TEXT("Desconocido");
	if (InitialInteractableTarget.GetInterface())
	{
		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
		if (InitialActor)
		{
			InitialObjectName = InitialActor->GetName();
		}
	}
	
	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
	
	// Detener temporizadores
	if (GetWorld())
	{
		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
		}
		
		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
		}
		
		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
		}
	}
	
	// Restablecer variables de estado
	bIsInteractionButtonHeld = false;
	bHoldInteractionFired = false;
	
	// Hacer una copia de la referencia antes de limpiarla para poder notificar
	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
	InitialInteractableTarget = nullptr;
	
	// Log para confirmar que el estado ha sido restablecido
	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
	
	// Notificar la cancelación
	OnInteractionCancelled.Broadcast();
}

void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
{
	// Si todavía estamos en un estado de interacción, forzar una cancelación
	if (bIsInteractionButtonHeld)
	{
		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
		CancelCurrentInteraction();
		
		// Forzar un reinicio del escaneo de interacciones
		OnInteractionCancelled.Broadcast();
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/InteractionStatics.h"

#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "Engine/OverlapResult.h"

UInteractionStatics::UInteractionStatics()
	: Super(FObjectInitializer::Get())
{
}

AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
{
	if (UObject* Object = InteractableTarget.GetObject())
	{
		if (AActor* Actor = Cast<AActor>(Object))
		{
			return Actor;
		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
		{
			AActor* ActorToReturn = ActorComponent->GetOwner();
			return ActorToReturn;
		} else
		{
			unimplemented()
		}
	}
	return nullptr;
}

void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	// If the actor is directly interactable, return that.
	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
	if (InteractableActor)
	{
		OutInteractableTargets.Add(InteractableActor);
	}

	// If the actor isn't interactable, it might have a component that has a interactable interface.
	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
	for (UActorComponent* InteractableComponent : InteractableComponents)
	{
		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
	}
}

void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	for (const FOverlapResult& Overlap : OverlapResults)
	{
		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
		if (InteractableActor)
		{
			OutInteractableTargets.AddUnique(InteractableActor);
		}

		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
		if (InteractableComponent)
		{
			OutInteractableTargets.AddUnique(InteractableComponent);
		}
	}
}

void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
	if (InteractableActor)
	{
		OutInteractableTargets.AddUnique(InteractableActor);
	}

	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
	if (InteractableComponent)
	{
		OutInteractableTargets.AddUnique(InteractableComponent);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemComponent.h"

#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"


void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
{
	if (!AbilitiesToGrant.IsEmpty())
	{
		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
		{
			if (!AbilityClass)
			{
				continue;
			}
			
			// Obtener la clase de habilidad para acceder a la propiedad StartupInputTag
			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
			if (!AbilityCDO)
			{
				continue;
			}
			
			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
			// Source of the ability is the ASC
			AbilitySpec.SourceObject = this;
			// Add the startup input tag to the ability spec
			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
			// Give the ability to the ASC
			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
			// Store the handle of the ability
			GrantedAbilities.Add(AbilitySpecHandle);
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			// print each ability
			
			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
			{
				//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, AbilitySpec.Ability->GetName());
				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
{
	if (!InputTag.IsValid()) return;
	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
	{
		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
		{
			AbilitySpecInputPressed(AbilitySpec);
			if (!AbilitySpec.IsActive())
			{
				TryActivateAbility(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
			{
				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
{
	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
}

void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
{
		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
	AbilitiesToActivate.Reset();
	//
	// Process all abilities that activate when the input is held.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
	{
		
		
		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
			{
				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
				{
					// --- MODIFICACION AQUI ---
					// Solo añadir si la política es WhileInputActive y NO es la nueva On Triggered Event
					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
					{
						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
					}
				}
			}
		}
	}
	//
	// Process all abilities that had their input pressed this frame.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
	{
		
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = true;

				if (AbilitySpec->IsActive())
				{
					
					
					// Ability is active so pass along the input event.
					AbilitySpecInputPressed(*AbilitySpec);
				}
				else
				{
					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);

					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
					{
						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
						{
							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
						}
					}
				}
			}
		}
	}
	//
	// Try to activate all the abilities that are from presses and holds.
	// We do it all at once so that held inputs don't activate the ability
	// and then also send a input event to the ability because of the press.
	//
	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
	{
		TryActivateAbility(AbilitySpecHandle);
	}
	//
	// Process all abilities that had their input released this frame.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
	{
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = false;

				if (AbilitySpec->IsActive())
				{
					// Ability is active so pass along the input event.
					AbilitySpecInputReleased(*AbilitySpec);
				}
			}
		}
	}

	//
	// Clear the cached ability handles.
	//
	InputPressedSpecHandles.Reset();
	InputReleasedSpecHandles.Reset();
	
}

void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputPressed(Spec);
	// We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputPress ability task works.
	if (Spec.IsActive())
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
		PRAGMA_ENABLE_DEPRECATION_WARNINGS

		// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
	}
	
}

void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputReleased(Spec);
	// We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputRelease ability task works.
	if (Spec.IsActive())
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
		PRAGMA_ENABLE_DEPRECATION_WARNINGS

		// Invoke the InputReleased event. This is not replicated here. If someone is listening, they may replicate the InputReleased event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
	}
}

void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
{
	FGameplayTagContainer TagContainer;
	EffectSpec.GetAllAssetTags(TagContainer);

	OnEffectAssetTags.Broadcast(TagContainer);
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemGlobals.h"
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemLibrary.h"

#include "Item/MechanicsInterface.h"

TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
{
	if (!Actor)
	{
		return TScriptInterface<IMechanicsInterface>();
		
	}
	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
	if (ComponentsImplementingInterface.Num() > 0)
	{
		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
	}
	return TScriptInterface<IMechanicsInterface>();
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAttributeSet.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayEffectExtension.h"
#include "GameFramework/Character.h"
#include "Net/UnrealNetwork.h"
#include "WitchPT/WitchPT.h"

void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)


}

UWitchPTAttributeSet::UWitchPTAttributeSet()
{
}

void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);
}

void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
{
	Super::PostGameplayEffectExecute(Data);
	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
	{
		// SetMoveSpeed(FMath::Clamp(GetMoveSpeed(), 0.f, GetMaxMoveSpeed()));
	}
	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
	{
		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
	}
}

void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
}

void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
}
void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
}

void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
}

void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
}

void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
}

void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
}

void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
}

void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
}

void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
}

void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
}

void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
}

void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
}

void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
}

void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
}
</file>

<file path="WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/Components/WitchPTCharacterMovementComponent.h"

#include "AbilitySystemComponent.h"
#include "GameplayTagContainer.h"
#include "Character/WitchPTCharacterBase.h"



UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
{
	
	PrimaryComponentTick.bCanEverTick = true;


}

float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
{
	
	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());

	if (!Owner)
	{
		
		return Super::GetMaxSpeed();
	}

	
	
	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
	{
		
		return 0.0f;
	}

	float FinalSpeed = Owner->GetMoveSpeed();
	if (RequestToStartSprinting)
	{
		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
		
	}
	// else if (RequestToStartCrouching)
	// {
	// 	// FinalSpeed = Owner->GetMoveSpeed() * CrouchSpeedMultiplier;
	// 	// UE_LOG(LogTemp, Warning, TEXT("Character %s is Crouching - Speed: %f"), *GetOwner()->GetName(), FinalSpeed);
	// }

	
	return FinalSpeed;
}

void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
{
	Super::UpdateFromCompressedFlags(Flags);
}

class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
{
	return Super::GetPredictionData_Client();
}


void UWitchPTCharacterMovementComponent::StartSprinting()
{
	RequestToStartSprinting = true;
}

void UWitchPTCharacterMovementComponent::StopSprinting()
{
	RequestToStartSprinting = false;
}

void UWitchPTCharacterMovementComponent::StartAimDownSights()
{
	RequestToStartADS = true;
}

void UWitchPTCharacterMovementComponent::StopAimDownSights()
{
	RequestToStartADS = false;
	
}
</file>

<file path="WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/Components/WitchPTMechanicComponent.h"
#include "Item/CauldronAltar.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h"
#include "Item/Components/CauldronCraftComponent.h"

// Sets default values for this component's properties
UWitchPTMechanicComponent::UWitchPTMechanicComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.
	PrimaryComponentTick.bCanEverTick = true;
	SetIsReplicatedByDefault(true);
}

void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	// Agregar propiedades replicadas aquí si es necesario
}



// --- RITUAL IMPLEMENTATION ---
void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (Character->HasAuthority())
	{
		TargetAltar->StartBrewingPotion(Character);
	}
}

void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->StartCarryCauldron(Character);
	}
	
}

void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->StartPlacementPreview(Character);
	}
}

void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
	}
}

void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->CancelPlacement();
	}
	
}

void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->FinalizePlacement();
	}

}

void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
{
	if (!TargetCauldron) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetCauldron->UnoccupyPosition(Character, nullptr);
	}
}

void UWitchPTMechanicComponent::RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	
	if(GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
	}
	else
	{
		Server_RequestSetIngredientInSlot(TargetAltar, IngredientItemDef);
	}

	
	
}

void UWitchPTMechanicComponent::RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		FVector SpawnLocation = TargetAltar->GetActorLocation();
		FPotionResult Result = TargetAltar->CauldronCraftComponent->CraftPotion(false, nullptr, SpawnLocation);
	}
}

void UWitchPTMechanicComponent::RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
	}
	else
	{
		Server_RequestCraftPotion(TargetAltar);
	}
	
}

void UWitchPTMechanicComponent::Server_RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
                                                                                 TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
	
}

void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
{
	
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->OccupyPosition(Character, Position);
	}
	
}

void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
	ABaseInteractionPosition* Position)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->UnoccupyPosition(Character, Position);
	}
	
}

void UWitchPTMechanicComponent::Server_RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
}

void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->StartRitual(Character);
	}
}

void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->HandlePlayerInput(Character, InputTag);
	}
}
</file>

<file path="WitchPT/Private/Character/WitchPTCharacter.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTCharacter.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Character/Components/WitchPTMechanicComponent.h"
#include "Equipment/WitchPTEquipmentManagerComponent.h"
#include "Item/RitualAltar.h"
#include "Item/RitualPosition.h"
#include "Player/WitchPTPlayerController.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "WitchPT/WitchPT.h"


// Sets default values
AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	// Initialize the MechanicComponent
	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
	// Initialize the EquipmentManagerComponent
	EquipmentManagerComponent = CreateDefaultSubobject<UWitchPTEquipmentManagerComponent>(TEXT("EquipmentManagerComponent"));
	
}

void AWitchPTCharacter::PossessedBy(AController* NewController)
{
	Super::PossessedBy(NewController);

	// Init ability actor info for the Server
	InitAbilityActorInfo();
	

	// Solo conceder habilidades si AbilitySystemComponent fue inicializado correctamente
	if (AbilitySystemComponent)
	{
		GrantStartupAbilities();
		AddStartupEffects();
	}
}

void AWitchPTCharacter::OnRep_PlayerState()
{
	Super::OnRep_PlayerState();
	// Init ability actor info for the Client
	InitAbilityActorInfo();
	AddStartupEffects();
}

void AWitchPTCharacter::InitAbilityActorInfo()
{
	Super::InitAbilityActorInfo();
	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
	
	if (!WitchPtPlayerState)
	{
		return;
	}
	
	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);

	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
	if (!AbilitySystemComponent)
	{
		return;
	}
	
	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
	

	
	/*
	* Here we initialize the Overlay because we have all the data we need: the player controller, player state, ability system component and attribute set.
	* Also, the HUD is accessible from the player controller.
	*/
	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
	{
		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
		{
			// WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
			// WitchPT_HUD->InitRitualWidget(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
			// WitchPT_HUD->InitInventoryWidget(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
			// WitchPT_HUD->InitCauldronWidget(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
			// WitchPT_HUD->InitQuickBarWidget(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
		}
	}
	InitializeDefaultAttributes();
}
</file>

<file path="WitchPT/Private/Character/WitchPTCharacterBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTCharacterBase.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Character/Components/WitchPTCharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"

// Sets default values
AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
{
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);

}

UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}



// Called to bind functionality to input
void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

}

void AWitchPTCharacterBase::InitializeDefaultAttributes()
{
	ApplyGameplayEffectToSelf(DefaultAttributes);
	
	
}

void AWitchPTCharacterBase::GrantStartupAbilities()
{
	if (!HasAuthority()) return;
	
	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
	
	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
}

void AWitchPTCharacterBase::AddStartupEffects()
{
	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
	{
		return;
	}

	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
	EffectContext.AddSourceObject(this);

	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
	{
		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
		if (NewHandle.IsValid())
		{
			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
		}
	}

	AbilitySystemComponent->bStartupEffectsApplied = true;
}

void AWitchPTCharacterBase::InitAbilityActorInfo()
{
}

void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
{
	check(IsValid(GetAbilitySystemComponent()));
	check(GameplayEffectClass);
	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
	EffectContextHandle.AddSourceObject(this);
	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
	
}

float AWitchPTCharacterBase::GetHealth() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetHealth();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxHealth() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxHealth();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetStamina() const
{
	if (IsValid(AttributeSet))	
	{
		return AttributeSet->GetStamina();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxStamina() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxStamina();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetAge() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetAge();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxAge() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxAge();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMana() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMana();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxMana() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxMana();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetSpeedMultiplier() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetSpeedMultiplier();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMoveSpeed() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMoveSpeed();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxMoveSpeed() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxMoveSpeed();
	}
	return 0.f;
}
</file>

<file path="WitchPT/Private/Character/WitchPTEnemy.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTEnemy.h"


// Sets default values
AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AWitchPTEnemy::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AWitchPTEnemy::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

// Called to bind functionality to input
void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
	// Test commit again
}
</file>

<file path="WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Equipment/WitchPTEquipmentDefinition.h"

#include "Equipment/WitchPTEquipmentInstance.h"

UWitchPTEquipmentDefinition::UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	InstanceType = UWitchPTEquipmentInstance::StaticClass();
}
</file>

<file path="WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Equipment/WitchPTEquipmentInstance.h"

#include "Equipment/WitchPTEquipmentDefinition.h"
#include "GameFramework/Character.h"

UWitchPTEquipmentInstance::UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer)
{
}

UWorld* UWitchPTEquipmentInstance::GetWorld() const
{
	if (const APawn* OwningPawn = GetPawn())
	{
		return OwningPawn->GetWorld();
	}
	return nullptr;
}

void UWitchPTEquipmentInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(ThisClass, Instigator);
}

void UWitchPTEquipmentInstance::SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn)
{
	if (APawn* OwningPawn = GetPawn())
	{
		USceneComponent* AttachTarget = OwningPawn->GetRootComponent();
		if (ACharacter* Char = Cast<ACharacter>(OwningPawn))
		{
			AttachTarget = Char->GetMesh();
		}

		for (const FWitchPTEquipmentActorToSpawn& SpawnInfo : ActorsToSpawn)
		{
			AActor* NewActor = GetWorld()->SpawnActorDeferred<AActor>(SpawnInfo.ActorToSpawn, FTransform::Identity, OwningPawn);
			NewActor->FinishSpawning(FTransform::Identity, /*bIsDefaultTransform=*/ true);
			NewActor->SetActorRelativeTransform(SpawnInfo.AttachTransform);
			NewActor->AttachToComponent(AttachTarget, FAttachmentTransformRules::KeepRelativeTransform, SpawnInfo.AttachSocket);

			SpawnedActors.Add(NewActor);
		}
	}
}

void UWitchPTEquipmentInstance::DestroyEquipmentActors()
{
	for (AActor* Actor : SpawnedActors)
	{
		if (Actor)
		{
			Actor->Destroy();
		}
	}
}

void UWitchPTEquipmentInstance::OnEquipped()
{
	UE_LOG(LogTemp, Warning, TEXT("✅ EQUIPPED: %s"), *GetClass()->GetName());
	K2_OnEquipped();
}

void UWitchPTEquipmentInstance::OnUnequipped()
{
	UE_LOG(LogTemp, Warning, TEXT("❌ UNEQUIPPED: %s"), *GetClass()->GetName());
	K2_OnUnequipped();
}

APawn* UWitchPTEquipmentInstance::GetPawn() const
{
	return Cast<APawn>(GetOuter());
}

void UWitchPTEquipmentInstance::OnRep_Instigator()
{
}
</file>

<file path="WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Equipment/WitchPTEquipmentManagerComponent.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "Engine/ActorChannel.h"
#include "Equipment/WitchPTEquipmentDefinition.h"
#include "Equipment/WitchPTEquipmentInstance.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
#include "Net/UnrealNetwork.h"


void FWitchPTEquipmentList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
	if (!IsValid(EquipmentManager)) return;
	
	for (int32 Index : RemovedIndices)
	{
		const FWitchPTEquipmentEntry& Entry = Entries[Index];
		if (Entry.Instance != nullptr)
		{
			Entry.Instance->OnUnequipped();
			EquipmentManager->OnItemUnequipped.Broadcast(Entry.Instance);
		}
	}
}

void FWitchPTEquipmentList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
	if (!IsValid(EquipmentManager)) return;
	
	for (int32 Index : AddedIndices)
	{
		const FWitchPTEquipmentEntry& Entry = Entries[Index];
		if (Entry.Instance != nullptr)
		{
			Entry.Instance->OnEquipped();
			EquipmentManager->OnItemEquipped.Broadcast(Entry.Instance);
		}
	}
}

void FWitchPTEquipmentList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
}

UWitchPTEquipmentInstance* FWitchPTEquipmentList::AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
{
	UWitchPTEquipmentInstance* Result = nullptr;

	check(EquipmentDefinition != nullptr);
	check(OwnerComponent);
	check(OwnerComponent->GetOwner()->HasAuthority());
    
	const UWitchPTEquipmentDefinition* EquipmentCDO = GetDefault<UWitchPTEquipmentDefinition>(EquipmentDefinition);

	TSubclassOf<UWitchPTEquipmentInstance> InstanceType = EquipmentCDO->InstanceType;
	if (InstanceType == nullptr)
	{
		InstanceType = UWitchPTEquipmentInstance::StaticClass();
	}
    
	FWitchPTEquipmentEntry& NewEntry = Entries.AddDefaulted_GetRef();
	NewEntry.EquipmentDefinition = EquipmentDefinition;
	NewEntry.Instance = NewObject<UWitchPTEquipmentInstance>(OwnerComponent->GetOwner(), InstanceType);
	Result = NewEntry.Instance;

	// Grant abilities
	if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
	{
		for (TSubclassOf<UGameplayAbility> AbilityClass : EquipmentCDO->AbilitiesToGrant)
		{
			if (AbilityClass)
			{
				FGameplayAbilitySpec AbilitySpec(AbilityClass, 1, INDEX_NONE, Result);
				FGameplayAbilitySpecHandle Handle = ASC->GiveAbility(AbilitySpec);
				NewEntry.AbilityHandles.GrantedHandles.Add(Handle);
				UE_LOG(LogTemp, Warning, TEXT("🎯 Granted ability: %s"), *AbilityClass->GetName());
			}
		}
	}
	Result->SpawnEquipmentActors(EquipmentCDO->ActorsToSpawn);

	MarkItemDirty(NewEntry);
	return Result;
}

void FWitchPTEquipmentList::RemoveEntry(UWitchPTEquipmentInstance* Instance)
{
	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
	{
		FWitchPTEquipmentEntry& Entry = *EntryIt;
		if (Entry.Instance == Instance)
		{
			// Remove abilities
			if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
			{
				for (const FGameplayAbilitySpecHandle& Handle : Entry.AbilityHandles.GrantedHandles)
				{
					if (Handle.IsValid())
					{
						ASC->ClearAbility(Handle);
						UE_LOG(LogTemp, Warning, TEXT("🚫 Removed ability"));
					}
				}
			}

			EntryIt.RemoveCurrent();
			Instance->DestroyEquipmentActors();
			MarkArrayDirty();
		}
	}
}

UAbilitySystemComponent* FWitchPTEquipmentList::GetAbilitySystemComponent() const
{
	check(OwnerComponent);
	AActor* OwningActor = OwnerComponent->GetOwner();
	return Cast<UAbilitySystemComponent>(UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor));
}

//-------------------------------      UWitchPTEquipmentManagerComponent           -----------------------//
// -------------------------------------------------------------------------------------------------------//
UWitchPTEquipmentManagerComponent::UWitchPTEquipmentManagerComponent()
	: EquipmentList(this)
{
	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
}

void UWitchPTEquipmentManagerComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(ThisClass, EquipmentList);
}

bool UWitchPTEquipmentManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
	FReplicationFlags* RepFlags)
{
	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
	{
		UWitchPTEquipmentInstance* Instance = Entry.Instance;
		if (IsValid(Instance))
		{
			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return WroteSomething;
}

void UWitchPTEquipmentManagerComponent::InitializeComponent()
{
	Super::InitializeComponent();
}

void UWitchPTEquipmentManagerComponent::UninitializeComponent()
{
	TArray<UWitchPTEquipmentInstance*> AllEquipmentInstances;

	// Gather all instances before removal to avoid side effects affecting the equipment list iterator    
	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
	{
		AllEquipmentInstances.Add(Entry.Instance);
	}

	for (UWitchPTEquipmentInstance* EquipInstance : AllEquipmentInstances)
	{
		UnequipItem(EquipInstance);
	}

	Super::UninitializeComponent();
}

void UWitchPTEquipmentManagerComponent::ReadyForReplication()
{
	Super::ReadyForReplication();
	// Register existing equipment instances
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
		{
			UWitchPTEquipmentInstance* Instance = Entry.Instance;
			if (IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}

void UWitchPTEquipmentManagerComponent::EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
{
	if (GetOwner()->GetLocalRole() < ROLE_Authority)
	{
		Server_EquipItem(EquipmentDefinition);
	}
	else
	{
		if (EquipmentDefinition != nullptr)
		{
			UWitchPTEquipmentInstance* NewInstance = EquipmentList.AddEntry(EquipmentDefinition);
			if (NewInstance != nullptr)
			{
				NewInstance->OnEquipped();
				OnItemEquipped.Broadcast(NewInstance);

				if (IsUsingRegisteredSubObjectList())
				{
					AddReplicatedSubObject(NewInstance);
				}
			}
		}
	}
}

void UWitchPTEquipmentManagerComponent::Server_EquipItem_Implementation(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
{
	EquipItem(EquipmentDefinition);
}

void UWitchPTEquipmentManagerComponent::UnequipItem(UWitchPTEquipmentInstance* ItemInstance)
{
	if (GetOwner()->GetLocalRole() < ROLE_Authority)
	{
		Server_UnequipItem(ItemInstance);
	}
	else
	{
		if (ItemInstance != nullptr)
		{
			if (IsUsingRegisteredSubObjectList())
			{
				RemoveReplicatedSubObject(ItemInstance);
			}

			ItemInstance->OnUnequipped();
			OnItemUnequipped.Broadcast(ItemInstance);
			EquipmentList.RemoveEntry(ItemInstance);
		}
	}
}

void UWitchPTEquipmentManagerComponent::Server_UnequipItem_Implementation(UWitchPTEquipmentInstance* ItemInstance)
{
	UnequipItem(ItemInstance);
}


bool UWitchPTEquipmentManagerComponent::IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const
{
	return FindEquipmentByInventoryItem(InventoryItem) != nullptr;
}

UWitchPTEquipmentInstance* UWitchPTEquipmentManagerComponent::FindEquipmentByInventoryItem(
	UWitchPTInventoryItemInstance* InventoryItem) const
{
	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UWitchPTEquipmentInstance* Equipment = Entry.Instance)
		{
			if (Equipment && Equipment->GetInstigator() == InventoryItem)
			{
				return Equipment;
			}
		}
	}
	return nullptr;
}

void UWitchPTEquipmentManagerComponent::PrintEquippedItems()
{
	UE_LOG(LogTemp, Warning, TEXT("📦 EQUIPPED ITEMS: %d total"), EquipmentList.Entries.Num());
	for (int32 i = 0; i < EquipmentList.Entries.Num(); i++)
	{
		const FWitchPTEquipmentEntry& Entry = EquipmentList.Entries[i];
		UE_LOG(LogTemp, Warning, TEXT("  [%d]: %s"), i, Entry.Instance ? *Entry.Instance->GetClass()->GetName() : TEXT("NULL"));
	}
}

UAbilitySystemComponent* UWitchPTEquipmentManagerComponent::GetAbilitySystemComponent() const
{
	if (APawn* OwnerPawn = Cast<APawn>(GetOwner()))
	{
		return UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwnerPawn);
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Equipment/WitchPTQuickBarComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Equipment/WitchPTQuickBarComponent.h"

#include "Net/UnrealNetwork.h"


// Sets default values for this component's properties
UWitchPTQuickBarComponent::UWitchPTQuickBarComponent()
{
	SetIsReplicatedByDefault(true);
}

void UWitchPTQuickBarComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(ThisClass, Slots);
	DOREPLIFETIME(ThisClass, ActiveSlotIndex);
}

void UWitchPTQuickBarComponent::BeginPlay()
{
	Super::BeginPlay();
	
	if (Slots.Num() < NumSlots)
	{
		Slots.AddDefaulted(NumSlots - Slots.Num());
	}
}

void UWitchPTQuickBarComponent::AddItemToSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* Item)
{
	if (Slots.IsValidIndex(SlotIndex) && (Item != nullptr))
	{
		if (Slots[SlotIndex] == nullptr)
		{
			Slots[SlotIndex] = Item;
			OnRep_Slots();
		}
	}
}


void UWitchPTQuickBarComponent::EquipItemInSlot()
{
}

void UWitchPTQuickBarComponent::UnequipItemInSlot()
{
}

void UWitchPTQuickBarComponent::OnRep_Slots()
{
}

void UWitchPTQuickBarComponent::OnRep_ActiveSlotIndex()
{
	OnActiveSlotChanged.Broadcast(ActiveSlotIndex);
}

void UWitchPTQuickBarComponent::SetActiveSlotIndex_Implementation(int32 NewIndex)
{
	UE_LOG(LogTemp, Log, TEXT("Setting active slot index to %d"), NewIndex);
	if (Slots.IsValidIndex(NewIndex) && (ActiveSlotIndex != NewIndex))
	{
		UnequipItemInSlot();
		
		ActiveSlotIndex = NewIndex;
		
		EquipItemInSlot();
		
		OnRep_ActiveSlotIndex();
	}
}
</file>

<file path="WitchPT/Private/Game/WitchPTGameModeBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Game/WitchPTGameModeBase.h"
</file>

<file path="WitchPT/Private/Input/WitchPTInputComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Input/WitchPTInputComponent.h"
</file>

<file path="WitchPT/Private/Input/WitchPTInputConfig.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Input/WitchPTInputConfig.h"

const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
{
	for (const FWitchPTInputAction& Pair: AbilityInputActions)
	{
		if (InputTag == Pair.InputTag)
		{
			return Pair.InputAction;
		}
	}
	if (bLogNotFound)
	{
		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
	}
	return nullptr;
	
}
</file>

<file path="WitchPT/Private/Inventory/Collectable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Collectable.h"

#include "Inventory/WitchPTInventoryManagerComponent.h"

UCollectableStatics::UCollectableStatics()
: Super(FObjectInitializer::Get())
{
}

TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
{
	TScriptInterface<ICollectable> PickupableActor(Actor);
	if (PickupableActor)
	{
		return PickupableActor;
	}
	
	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
	if (PickupableComponents.Num() > 0)
	{
		return TScriptInterface<ICollectable>(PickupableComponents[0]);
	}

	return TScriptInterface<ICollectable>();
}


void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
	TScriptInterface<ICollectable> Collectable)
{
	if (InventoryComponent && Collectable)
	{
		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
	}
}
</file>

<file path="WitchPT/Private/Inventory/FastArray/FastArrayList.cpp">
#pragma once

#include "Inventory/FastArray/FastArrayList.h"

#include "CoreMinimal.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"


class FLifetimeProperty;
struct FReplicationFlags;
//////////////////////////////////////////////////////////////////////
// FWitchPTInventoryEntry
FString FWitchPTInventoryEntry::GetDebugString() const
{
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
	if (Instance != nullptr)
	{
		ItemDef = Instance->GetItemDef();
	}

	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
}



//////////////////////////////////////////////////////////////////////
// FWitchPTInventoryList
void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	for (int32 Index : RemovedIndices)
	{
		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
	}
}

void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	for (int32 Index : AddedIndices)
	{
		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
	}
}

void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	
	for (int32 Index : ChangedIndices)
	{
		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
	}
}

UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	UWitchPTInventoryItemInstance* Result = nullptr;

	check(ItemDef != nullptr);
	check(OwnerComponent);

	AActor* OwningActor = OwnerComponent->GetOwner();
	check(OwningActor->HasAuthority());


	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
	NewEntry.Instance->SetItemDef(ItemDef);
	// ------ Stack stuff
	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
	if (IsValid(StackableFragment))
	{
		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
	}
	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
	{
		if (Fragment != nullptr)
		{
			Fragment->OnInstanceCreated(NewEntry.Instance);
		}
	}

	Result = NewEntry.Instance;
	
	
	MarkItemDirty(NewEntry);

	return Result;
}

void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
{
	unimplemented();
}

void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
{
	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
	{
		FWitchPTInventoryEntry& Entry = *EntryIt;
		if (Entry.Instance == Instance)
		{
			EntryIt.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}
TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
{
	TArray<UWitchPTInventoryItemInstance*> Results;
	Results.Reserve(Entries.Num());
	for (const FWitchPTInventoryEntry& Entry : Entries)
	{
		if (Entry.Instance != nullptr) //@TODO: Would prefer to not deal with this here and hide it further?
		{
			Results.Add(Entry.Instance);
		}
	}
	return Results;
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"

#include "Inventory/WitchPTInventoryItemInstance.h"

void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
{
	
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
#include "Inventory/WitchPTInventoryItemInstance.h"

void UWitchPTInventoryItemFragment_PotionProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
{
	// Basic setup when potion instance is created
	// This could be expanded later for specific potion initialization
}

bool UWitchPTInventoryItemFragment_PotionProperties::IsValidPotion() const
{
	// Basic validation: check if we have essential potion properties
	return PotionEssenceTag.IsValid() && 
		   FinalPotency > 0.0f && 
		   FinalDuration > 0.0f && 
		   FinalCharges > 0;
}

FString UWitchPTInventoryItemFragment_PotionProperties::GetPotionDescription() const
{
	if (!IsValidPotion())
	{
		return TEXT("Invalid Potion");
	}

	// Create a simple description string
	FString Description = FString::Printf(
		TEXT("%s Potion\nPotency: %.1f\nDuration: %.1fs\nCharges: %d"),
		*PotionEssenceTag.GetTagName().ToString(),
		FinalPotency,
		FinalDuration,
		FinalCharges
	);

	// Add tier information if available
	if (PotionTierTag.IsValid())
	{
		Description += FString::Printf(TEXT("\nTier: %s"), *PotionTierTag.GetTagName().ToString());
	}

	// Add base liquid information if available
	if (BaseLiquidTypeTag.IsValid())
	{
		Description += FString::Printf(TEXT("\nBase: %s"), *BaseLiquidTypeTag.GetTagName().ToString());
	}

	// Add effects count if present
	if (GrantedEffectTags.Num() > 0)
	{
		Description += FString::Printf(TEXT("\nEffects: %d"), GrantedEffectTags.Num());
	}

	// Add properties count if present
	if (GrantedPropertyTags.Num() > 0)
	{
		Description += FString::Printf(TEXT("\nProperties: %d"), GrantedPropertyTags.Num());
	}

	return Description;
}

void UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties(
	const FGameplayTag& InPotionEssence,
	const FGameplayTag& InBaseLiquidType,
	float InPotency,
	float InDuration,
	int32 InCharges,
	const FGameplayTag& InTierTag,
	const FGameplayTagContainer& InEffectTags,
	const FGameplayTagContainer& InPropertyTags)
{
	PotionEssenceTag = InPotionEssence;
	BaseLiquidTypeTag = InBaseLiquidType;
	FinalPotency = InPotency;
	FinalDuration = InDuration;
	FinalCharges = InCharges;
	PotionTierTag = InTierTag;
	GrantedEffectTags = InEffectTags;
	GrantedPropertyTags = InPropertyTags;

	UE_LOG(LogTemp, Log, TEXT("UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties: Potion properties set - %s, Potency: %.2f, Duration: %.2f, Charges: %d"), 
		   *PotionEssenceTag.ToString(), 
		   FinalPotency, 
		   FinalDuration, 
		   FinalCharges);
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
#include "Inventory/WitchPTInventoryItemInstance.h"

void UWitchPTInventoryItemFragment_WorldDetails::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
{
	// Basic setup when instance is created
	// This could be expanded later for specific world item initialization
}

bool UWitchPTInventoryItemFragment_WorldDetails::HasValidWorldMesh() const
{
	return WorldStaticMesh != nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
</file>

<file path="WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/InventoryFunctionLibrary.h"

#include "Kismet/GameplayStatics.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/QuickBarWidgetController.h"
#include "UI/WidgetControllers/WitchPTWidgetController.h"

UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			
			return WitchPTHUD->SetInventoryWidgetController(WCParams);
		}
	}
	return nullptr;
}

UQuickBarWidgetController* UInventoryFunctionLibrary::SetQuickBarWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			
			return WitchPTHUD->SetQuickBarWidgetController(WCParams);
		}
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryFunctionLibrary.h"

#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
{
	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
	{
		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryItemDefinition.h"

#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)

{
}

const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
{
	if (FragmentClass != nullptr)
	{
		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
		{
			if (Fragment && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryItemInstance.h"

#include "GameplayTagContainer.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Net/UnrealNetwork.h"
#include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
class FLifetimeProperty;
UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{
}

void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	DOREPLIFETIME(ThisClass, ItemDef);
	DOREPLIFETIME(ThisClass, TotalStackCount);
}



void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
{
	ItemDef = InDef;
}


const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
{
	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
	{
		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}

	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryManagerComponent.h"

#include "Blueprint/UserWidget.h"
#include "Components/PanelWidget.h"
#include "Engine/ActorChannel.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
#include "Net/UnrealNetwork.h"
#include "UI/Widgets/Inventory/InventoryUserWidget.h"
#include "Inventory/InventoryFunctionLibrary.h"
#include "UI/WidgetControllers/InventoryWidgetController.h"


#include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)


void UWitchPTInventoryManagerComponent::BeginPlay()
{
	Super::BeginPlay();

}

UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
	, InventoryList(this)
{
	PrimaryComponentTick.bCanEverTick = false;
	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
}
void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, InventoryList);
}

// --------------- Inventory Manager Component Functions ---------------------------

void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	if(IsValid(ItemDef))
	{
		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
		
		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
		Server_UpdateItemStackCount(FoundItem, NewStackCount);
	}
}

void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
{
	if (IsValid(ItemInstance))
	{
		ItemInstance->SetTotalStackCount(NewCount);
		
		// Marcar la entrada como sucia para la replicación
		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
		{
			if (Entry.Instance == ItemInstance)
			{
				InventoryList.MarkItemDirty(Entry);
				break;
			}
		}
		
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemStackChanged.Broadcast(ItemInstance);
		}
	}
}

void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
{
	if (IsValid(ItemInstance))
	{
		// Notificar antes de eliminar para que los listeners puedan usar la información del item
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemRemoved.Broadcast(ItemInstance);
		}
		
		// Eliminar el item de la lista de inventario
		InventoryList.RemoveEntry(ItemInstance);
		
		// Desregistrar el subobjeto para la replicación
		if (IsUsingRegisteredSubObjectList())
		{
			RemoveReplicatedSubObject(ItemInstance);
		}
	}
}

void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
{
	if (IsValid(ItemInstance))
	{
		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
		
		// Si el nuevo conteo es cero, eliminar el item completamente
		if (NewCount <= 0)
		{
			Server_RemoveItemInstance(ItemInstance);
		}
		else
		{
			// Actualizar el conteo de stacks
			Server_UpdateItemStackCount(ItemInstance, NewCount);
		}
	}
}

TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
{
	return InventoryList.GetAllItems();
}

bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	if (!ItemDef)
	{
		return false;
	}
	
	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
	if (FoundItem)
	{
		Server_AddStacksToItem(ItemDef);
		return false;
	}
	else
	{
		Server_AddItem(ItemDef);
		return true;
	}
}



void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	UWitchPTInventoryItemInstance* NewItem = nullptr;
	if (ItemDef != nullptr)
	{
		NewItem = InventoryList.AddEntry(ItemDef);
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemAdded.Broadcast(NewItem);
		}
	
		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
		{
			AddReplicatedSubObject(NewItem);
		}
	}
	
}



// void UWitchPTInventoryManagerComponent::RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance)
// {
// 	InventoryList.RemoveEntry(ItemInstance);
//
// 	if (ItemInstance && IsUsingRegisteredSubObjectList())
// 	{
// 		RemoveReplicatedSubObject(ItemInstance);
// 	}
// }


UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
{
	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (IsValid(Instance))
		{
			if (Instance->GetItemDef() == ItemDef)
			{
				return Instance;
			}
		}
	}

	return nullptr;
}

int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
{
	int32 TotalCount = 0;
	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (IsValid(Instance))
		{
			if (Instance->GetItemDef() == ItemDef)
			{
				++TotalCount;
			}
		}
	}

	return TotalCount;
}

bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
	int32 NumToConsume)
{
	AActor* OwningActor = GetOwner();
	if (!OwningActor || !OwningActor->HasAuthority())
	{
		return false;
	}

	//@TODO: N squared right now as there's no acceleration structure
	int32 TotalConsumed = 0;
	while (TotalConsumed < NumToConsume)
	{
		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
		{
			InventoryList.RemoveEntry(Instance);
			++TotalConsumed;
		}
		else
		{
			return false;
		}
	}

	return TotalConsumed == NumToConsume;
}


bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
                                                            FReplicationFlags* RepFlags)
{
	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (Instance && IsValid(Instance))
		{
			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return WroteSomething;
}

void UWitchPTInventoryManagerComponent::ReadyForReplication()
{
	Super::ReadyForReplication();
	
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
		{
			UWitchPTInventoryItemInstance* Instance = Entry.Instance;

			if (IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}
</file>

<file path="WitchPT/Private/Item/BaseInteractableAltar.cpp">
#include "Item/BaseInteractableAltar.h"

#include "FWitchPTGameplayTags.h"
#include "Item/BaseInteractionPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h"
#include "Item/RitualPosition.h"

// Sets default values
ABaseInteractableAltar::ABaseInteractableAltar()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;

    // Make sure it replicates
    bReplicates = true;
    bAlwaysRelevant = true;
    
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);

}

void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
    DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
    DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
    DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
  
}

// Called when the game starts or when spawned
void ABaseInteractableAltar::BeginPlay()
{
    Super::BeginPlay();
    
    // Initialize interaction positions
    CreateAltarPositions();
}

// Called every frame
void ABaseInteractableAltar::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    // Child classes will implement specific tick behavior
}



void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
{
    if (!Player || !Position || !HasAuthority())
    {
        return;
    }

    Position->SetOccupied(nullptr);

    // Remove from participating players if they're not in the list
    ParticipatingPlayers.Remove(Player);
    
}
void ABaseInteractableAltar::CreateAltarPositions()
{
    if (!HasAuthority() || !PositionClass)
    {
        return;
    }
    
    // Make sure we have no previous positions
    DestroyAltarPositions();
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
    int positionIndex = 0;
    // Spawn a CauldronPosition for each transform
    for (const FTransform& PosTransform : PositionTransforms)
    {
        // Transform relative to world space
        FTransform WorldTransform = PosTransform * GetActorTransform();
        
        // Get location and rotation from the transform
        FVector Location = WorldTransform.GetLocation();
        FRotator Rotation = WorldTransform.Rotator();
        
        // Spawn parameters
        FActorSpawnParameters SpawnParams;
        SpawnParams.Owner = this;
        SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
        
        // Spawn the brewing position
        ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
            PositionClass, 
            Location, 
            Rotation, 
            SpawnParams);
        
        if (NewPosition)
        {
            // Initialize the position
            // Note: Implement this method in CauldronPosition if needed
            // NewPosition->SetCauldronAltar(this);
            NewPosition->SetPositionTag(TagsPositions[positionIndex]);
            ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
            if (RitualPosition)
            {
                RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
            }
            positionIndex++;

            
            // Add to our array
            InteractionPositions.Add(NewPosition);
            
            UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
        }
    }
}



void ABaseInteractableAltar::DestroyAltarPositions()
{
    // Only destroy positions on the server
    if (!HasAuthority())
    {
        return;
    }
    
    // Destroy all brewing positions
    for (ABaseInteractionPosition* Position : InteractionPositions)
    {
        if (Position)
        {
            Position->Destroy();
        }
    }
    
    // Clear the array
    InteractionPositions.Empty();
    
    UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
}


void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
{
    // Update visuals or play sounds based on state change
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
}

void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
{
    // Play success feedback
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
}

void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
{
    // Play failure feedback
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
}



void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
{
    // Update client-side UI or visuals for players
}


void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
{
    // Base implementation - to be overridden by child classes
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
}

void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
{
   
}

void ABaseInteractableAltar::CheckState()
{
    // Base implementation - to be overridden by child classes
    // This would check if the interaction is complete or failed
}

void ABaseInteractableAltar::CleanupInteraction()
{
   
}

void ABaseInteractableAltar::SpawnReward()
{
   
}

void ABaseInteractableAltar::SpawnDemon()
{
    
}

bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
{
    // Base implementation - to be overridden by child classes
    // Check if the player is valid and in the participating list
    return Player && ParticipatingPlayers.Contains(Player);
}
</file>

<file path="WitchPT/Private/Item/BaseInteractionPosition.cpp">
#include "Item/BaseInteractionPosition.h"
#include "Net/UnrealNetwork.h"
#include "Engine/ActorChannel.h"
#include "AbilitySystemComponent.h"
#include "Components/BoxComponent.h"
#include "GameFramework/Character.h"

ABaseInteractionPosition::ABaseInteractionPosition()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;
    
    // Make sure this actor replicates
    bReplicates = true;
    bAlwaysRelevant = true;
}

void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    
    // Replicate the occupied state and occupying character
    DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
    DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
    DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
    
    // PositionTag and Altar are usually set once and don't need replication unless they can change dynamically
}

void ABaseInteractionPosition::BeginPlay()
{
    Super::BeginPlay();

    // Additional initialization could go here if needed
}

void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    // This should be overridden by derived classes
    Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
}

bool ABaseInteractionPosition::IsOccupied() const
{
    return bIsOccupied;
}

void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
{
    if (GetLocalRole() != ROLE_Authority)
    {
        return;
    }

    OccupyingCharacter = Character;
    bIsOccupied = (Character != nullptr);
}

void ABaseInteractionPosition::SetUnoccupied()
{
    if (GetLocalRole() != ROLE_Authority)
    {
        return;
    }

    RemoveCharacterFromPosition();
}

void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
{
    PositionTag = NewTag;
}

void ABaseInteractionPosition::OnRep_IsOccupied()
{
    // Handle any visuals or sounds when occupation state changes
}

void ABaseInteractionPosition::OnRep_OccupyingCharacter()
{
    // Handle any visuals or sounds when the occupying character changes
}

void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
    // Base implementation - should be overridden by child classes
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
        *GetName(), *InteractingCharacter->GetName());
}

void ABaseInteractionPosition::RemoveCharacterFromPosition()
{
    OccupyingCharacter = nullptr;
    bIsOccupied = false;
}
</file>

<file path="WitchPT/Private/Item/CauldronAltar.cpp">
#include "Item/CauldronAltar.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "Item/CauldronPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Kismet/GameplayStatics.h"
#include "TimerManager.h"
#include "Components/SkeletalMeshComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/World.h"
#include "DrawDebugHelpers.h"
#include "FWitchPTGameplayTags.h"
#include "Engine/ActorChannel.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
#include "Item/Components/CauldronCraftComponent.h"
#include "Player/WitchPTPlayerController.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/Widgets/CauldronUserWidget.h"

// Sets default values
ACauldronAltar::ACauldronAltar()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;

    // Make sure it replicates
    bReplicates = true;
    bAlwaysRelevant = true;
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    bReplicateUsingRegisteredSubObjectList = true;
    
    // Initialize the cauldron craft component in constructor
    CauldronCraftComponent = CreateDefaultSubobject<UCauldronCraftComponent>(TEXT("CauldronCraftComponent"));
}

void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    // Set up the interaction option based on the cauldron state
    FInteractionOption InteractionOption = Option;
    
    // Configure the interaction option to support hold interaction
    InteractionOption.bSupportsHoldInteraction = true;
    
    // Add the interaction option to the builder
    OptionBuilder.AddInteractionOption(InteractionOption);
}

void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    
    DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
    DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
    DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
    DOREPLIFETIME(ACauldronAltar, CauldronCraftComponent);
}

void ACauldronAltar::OnRep_CauldronPhysicState()
{
    // Update visual representation based on the new state
    if (CauldronPhysicState == ECauldronPhysicState::Moving)
    {
        // Cauldron is being carried - update visuals if needed
        SetActorEnableCollision(false);
    }
    else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
    {
        // Cauldron is in preview mode - update visuals
        SetActorEnableCollision(false);
    }
}

// --- Interaction Functions ---

void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
{
    if (!InteractingCharacter)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
        return;
    }
    
    // Si el caldero está en modo de previsualización, finalizar la colocación
    if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
    {
        FinalizePlacement();
        return;
    }
    
    // Otherwise, try to position the character for brewing
    PositionCharacterForBrewing(InteractingCharacter);
}

void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
{
    if (!CauldronCraftComponent)
    {
        UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: CauldronCraftComponent is null"));
        return;
    }

    if (CauldronPhysicState != ECauldronPhysicState::Static)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
        return;
    }

    // Delegate to the craft component
    CauldronCraftComponent->TrySetIngredientInSlot(RequestingCharacter, IngredientItemDef);
}

void ACauldronAltar::BeginPlay()
{
    Super::BeginPlay();
    SetReplicateMovement(true);
}

bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
    FReplicationFlags* RepFlags)
{
    bool bWroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
    
    // Replicate the CauldronCraftComponent
    if (CauldronCraftComponent)
    {
        bWroteSomething |= Channel->ReplicateSubobject(CauldronCraftComponent, *Bunch, *RepFlags);
    }
    
    return bWroteSomething;
}

void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
{
    if (!InteractingCharacter)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
        return;
    }
    
    // Si el caldero está en modo de previsualización, cancelar y volver a adjuntar al personaje
    if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
    {
        CancelPlacement();
        return;
    }
    
    // Check if the cauldron can be picked up
    if (!CanBePickedUp())
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
        return;
    }
    
    // Attach the cauldron to the character
    AttachToCharacter(InteractingCharacter);
}

bool ACauldronAltar::CanBePickedUp() const
{
    // Check if the cauldron is already being carried
    if (IsBeingCarried() || IsInPlacementPreview())
    {
        return false;
    }
    
    // Add any additional conditions here (e.g., cauldron is empty, not brewing, etc.)
    
    return true;
}

bool ACauldronAltar::IsBeingCarried() const
{
    return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
}

bool ACauldronAltar::IsInPlacementPreview() const
{
    return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
}

ACharacter* ACauldronAltar::GetCarryingCharacter() const
{
    return CarryingCharacter;
}

void ACauldronAltar::AttachToCharacter(ACharacter* Character)
{
    if (!Character || !HasAuthority())
    {
        return;
    }
    
    // First destroy any brewing positions
    DestroyAltarPositions();
    
    // Set the cauldron state to moving
    CauldronPhysicState = ECauldronPhysicState::Moving;
    CarryingCharacter = Character;
    
    // Attach the cauldron to the character's back
    FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget, 
                                          EAttachmentRule::KeepWorld, true);
    
    // Find the socket to attach to
    USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
    if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
    {
        // Attach to the socket
        AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
        
        // Disable collision
        SetActorEnableCollision(false);
        
        // Reduce de Scale of the Cauldron
        SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
        
        UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
    }
}

void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
{
    if (!Character || !HasAuthority() || Character != CarryingCharacter)
    {
        return;
    }
    
    // Detach from the character
    DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
    
    // Place the cauldron in front of the character
    FVector CharacterLocation = Character->GetActorLocation();
    FRotator CharacterRotation = Character->GetActorRotation();
    FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
    
    // Set the cauldron's location
    SetActorLocation(CharacterLocation + PlacementOffset);
    
    // Reset the cauldron state
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    
    // Reset cauldron scale to normal
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    
    // Enable collision
    SetActorEnableCollision(true);
    
    // Create brewing positions around the cauldron
    CreateAltarPositions();
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
    
    // Play placement sound or effects
    // PlayPlacementEffects();
}

void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
{
    if (!Character || !HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
        return;
    }
    
    // Obtener una posición disponible
    ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
    
    if (BrewingPosition)
    {
        Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
        ParticipatingPlayers.Add(Character);
        
        if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
        {
            
            if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                // PC->LocalToggleCauldronMenu();
            }
            
        } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
        {
           
            if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                // PC->Client_ToggleCauldronMenu();
            }
        }
        FGameplayEventData Payload;
        Payload.OptionalObject = Character;
        FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
        return BrewingPosition->SetOccupied(Character);

        // Teleport the character to the position facing the cauldron
    }

    // Call the ritual state delegate for Listen Server
}

ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
{
    // Verificar que tengamos posiciones
    if (InteractionPositions.Num() == 0)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
        return nullptr;
    }
    
    // Buscar la primera posición disponible
    for (ABaseInteractionPosition* Position : InteractionPositions)
    {
        if (Position && !Position->IsOccupied())
        {
            return Position;
        }
    }
    
    // Todas las posiciones están ocupadas
    UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
    
    return nullptr;
}

// --- Nueva implementación para colocación del caldero ---

void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
{
    if (!Character || Character != CarryingCharacter || !HasAuthority())
    {
        return;
    }
    
    // Desacoplar el caldero del personaje
    DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
    
    // Establecer el estado de previsualización
    CauldronPhysicState = ECauldronPhysicState::Previewing;
    
    // Guardar los materiales originales para restaurarlos después
    UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
    if (MeshComponent)
    {
        OriginalMaterials.Empty();
        for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
        {
            OriginalMaterials.Add(MeshComponent->GetMaterial(i));
        }
    }
    
    // Aplicar material de previsualización
    CurrentPlacementState = ECauldronPlacementState::Invalid; // Por defecto, inválido hasta que se verifique
    // ApplyPlacementPreviewMaterial();
    
    // Desactivar colisiones durante la previsualización
    SetActorEnableCollision(false);
    
    // Colocar inicialmente el caldero frente al personaje
    FVector CharacterLocation = Character->GetActorLocation();
    FRotator CharacterRotation = Character->GetActorRotation();
    FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);

    // Guardar la posición inicial
    PreviewLocation = CharacterLocation + PlacementOffset;
    // PreviewRotation = CharacterRotation;
    // Reset z rotation
    PreviewRotation.Pitch = 0;
    PreviewRotation.Roll = 0;
    PreviewRotation.Yaw = 0;
    // Establecer la posición del caldero
    SetActorLocation(PreviewLocation);
    SetActorRotation(PreviewRotation);
    
    // Restablecer la escala normal
    Multicast_FinalizePlacement();
}

void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
{
    // Actualizar el material según el estado
    // ApplyPlacementPreviewMaterial();
}

void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
{
    // Llamar a la implementación del cliente para actualizar la previsualización
    // Client_UpdatePlacementPreview(HitLocation, HitNormal);
    if (!IsInPlacementPreview())
    {
        return;
    }
    
    // Guardar la nueva posición de previsualización
    PreviewLocation = HitLocation;
    
    // Calcular la rotación para alinear con la superficie
    FRotator SurfaceAlignedRotation = HitNormal.Rotation();
    
    // Ajustar la rotación para que el caldero se alinee con la superficie pero mantenga su orientación "hacia arriba"
    // Necesitamos solo el componente de inclinación de la superficie
    FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
    
    // Limitar la inclinación máxima
    if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
    {
        AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
    }
    
    if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
    {
        AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
    }
    
    PreviewRotation = AdjustedRotation;
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorLocation(PreviewLocation);
    
    // Verificar si la posición es válida
    CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
}

void ACauldronAltar::FinalizePlacement()
{
    if (!IsInPlacementPreview() || !HasAuthority())
    {
        return;
    }
    
    // Establecer la posición final
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorLocation(PreviewLocation);
    SetActorRotation(PreviewRotation);
    
    // Restaurar los materiales originales
    RestoreOriginalMaterials();
    
    // Activar colisiones
    SetActorEnableCollision(true);
    
    // Cambiar el estado
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    
    OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
    
    // Crear posiciones de elaboración alrededor del caldero
    CreateAltarPositions();

    // Multicast finalizar placement
    Multicast_FinalizePlacement();

    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
}

void ACauldronAltar::CancelPlacement()
{
    if (!IsInPlacementPreview() || !HasAuthority())
    {
        return;
    }
    
    // Restaurar materiales originales
    RestoreOriginalMaterials();
    
    // Recolocar el caldero en el personaje
    ACharacter* Character = CarryingCharacter;
    
    // Reiniciar estado
    CauldronPhysicState = ECauldronPhysicState::Moving;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    
    // Volver a adjuntar el caldero al personaje
    if (Character)
    {
        AttachToCharacter(Character);
    }
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
}

void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
{
    // Find the position occupied by the player
    for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
    {
        if(PositionOccupied->GetOccupyingCharacter() == Character)
        {
            // Close the cauldron menu
             if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
        {
            
            if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                // PC->LocalToggleCauldronMenu();
                AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD());
                if (WitchPTHUD)
                {
                    WitchPTHUD->ToggleGameMenu(UCauldronUserWidget::StaticClass());
                }
            }
        } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
        {
           
            if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                // PC->Client_ToggleCauldronMenu();
                
            }
        }
            PositionOccupied->SetOccupied(nullptr);
            break;
        }
    }
}

void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
{
    // Reset de scale for all clients
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorEnableCollision(true);
}

ECauldronPlacementState ACauldronAltar::GetPlacementState() const
{
    return CurrentPlacementState;
}

void ACauldronAltar::ApplyPlacementPreviewMaterial()
{
    UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
    if (!MeshComponent)
    {
        return;
    }
    
    // Determinar qué material aplicar según el estado
    UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ? 
        ValidPlacementMaterial : InvalidPlacementMaterial;
    
    // Si no tenemos un material específico, no hacemos nada
    if (!MaterialToApply)
    {
        return;
    }
    
    // Aplicar el material a todos los elementos del mesh
    for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
    {
        MeshComponent->SetMaterial(i, MaterialToApply);
    }
}

void ACauldronAltar::RestoreOriginalMaterials()
{
    // Restaurar los materiales originales si estamos fuera del modo de previsualización
    if (CauldronPhysicState != ECauldronPhysicState::Previewing)
    {
        UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
        if (MeshComponent && OriginalMaterials.Num() > 0)
        {
            for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
            {
                if (OriginalMaterials[i])
                {
                    MeshComponent->SetMaterial(i, OriginalMaterials[i]);
                }
            }
        }
    }
}

bool ACauldronAltar::IsPlacementValid() const
{
    if (!GetWorld())
    {
        return false;
    }
    
    // 1. Comprobar si hay objetos en el radio de colisión
    TArray<FOverlapResult> Overlaps;
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);
    
    if (CarryingCharacter)
    {
        QueryParams.AddIgnoredActor(CarryingCharacter);
    }
    
    bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
        Overlaps,
        PreviewLocation,
        FQuat::Identity,
        FCollisionObjectQueryParams::AllObjects,
        FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
        QueryParams
    );
    
    if (bHasOverlaps)
    {
        // Encontramos solapamientos, verificar si son relevantes
        for (const FOverlapResult& Overlap : Overlaps)
        {
            // Ignorar actores que no tienen colisión (podrían ser efectos visuales, etc.)
            if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
            {
                // Si encontramos algún actor con colisión, la posición no es válida
                return false;
            }
        }
    }
    
    // 2. Comprobar si el caldero está alineado con el suelo
    // Hacer un trazado hacia abajo para ver si hay suelo cerca
    FHitResult HitResult;
    FVector TraceStart = PreviewLocation;
    FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
    
    bool bHitGround = GetWorld()->LineTraceSingleByChannel(
        HitResult,
        TraceStart,
        TraceEnd,
        ECC_Visibility,
        QueryParams
    );
    
    if (!bHitGround)
    {
        // No encontramos suelo debajo del caldero
        return false;
    }
    
    // Comprobar la distancia al suelo
    float DistanceToGround = (HitResult.Location - TraceStart).Size();
    if (DistanceToGround > MaxGroundAlignmentHeight)
    {
        // El caldero está demasiado lejos del suelo
        return false;
    }
    
    // La posición es válida
    return true;
}

// ----------------------------------- DEBUG FUNCTIONS ---------------------------------------------- //

void ACauldronAltar::PrintCauldronDebugData() const
{
    UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON ALTAR DEBUG DATA ==="));
    UE_LOG(LogTemp, Warning, TEXT("Cauldron Name: %s"), *GetName());
    UE_LOG(LogTemp, Warning, TEXT("Cauldron Location: %s"), *GetActorLocation().ToString());
    UE_LOG(LogTemp, Warning, TEXT("Cauldron Physics State: %s"), 
           CauldronPhysicState == ECauldronPhysicState::Static ? TEXT("Static") :
           CauldronPhysicState == ECauldronPhysicState::Moving ? TEXT("Moving") :
           CauldronPhysicState == ECauldronPhysicState::Previewing ? TEXT("Previewing") : TEXT("Unknown"));
    UE_LOG(LogTemp, Warning, TEXT("Carrying Character: %s"), 
           CarryingCharacter ? *CarryingCharacter->GetName() : TEXT("None"));
    UE_LOG(LogTemp, Warning, TEXT("Placement State: %s"),
           CurrentPlacementState == ECauldronPlacementState::Valid ? TEXT("Valid") :
           CurrentPlacementState == ECauldronPlacementState::Invalid ? TEXT("Invalid") :
           CurrentPlacementState == ECauldronPlacementState::None ? TEXT("None") : TEXT("Unknown"));
    UE_LOG(LogTemp, Warning, TEXT("Number of Interaction Positions: %d"), InteractionPositions.Num());
    UE_LOG(LogTemp, Warning, TEXT("Number of Participating Players: %d"), ParticipatingPlayers.Num());
    
    // Print CauldronCraftComponent debug data
    if (CauldronCraftComponent)
    {
        UE_LOG(LogTemp, Warning, TEXT("CauldronCraftComponent: Valid"));
        CauldronCraftComponent->PrintIngredientDebugData();
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("CauldronCraftComponent: NULL - This should not happen!"));
    }
    
    UE_LOG(LogTemp, Warning, TEXT("=== END CAULDRON ALTAR DEBUG DATA ==="));
}
</file>

<file path="WitchPT/Private/Item/CauldronPosition.cpp">
#include "Item/CauldronPosition.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/Character.h"
#include "Item/CauldronAltar.h" // Include the Altar header
#include "Kismet/GameplayStatics.h"

ACauldronPosition::ACauldronPosition()
{
    // No need to set up replication here - it's handled by the base class
    bIsOccupied = false;
    OccupyingCharacter = nullptr;
}

void ACauldronPosition::BeginPlay()
{
    Super::BeginPlay();
    
    // // Try to find the CauldronAltar if it wasn't set in the editor
    // if (!CauldronAltar)
    // {
    //     FindCauldronAltar();
    // }
}

void ACauldronPosition::FindCauldronAltar()
{
    // First check if we are attached to an altar
    // AActor* ParentActor = GetAttachParentActor();
    // if (ParentActor)
    // {
    //     ACauldronAltar* PotentialAltar = Cast<ACauldronAltar>(ParentActor);
    //     if (PotentialAltar)
    //     {
    //         CauldronAltar = PotentialAltar;
    //         UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found attached CauldronAltar %s"), 
    //             *GetName(), *CauldronAltar->GetName());
    //         return;
    //     }
    // }
    //
    // // If not attached, try to find any altar in the world
    // TArray<AActor*> FoundAltars;
    // UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundAltars);
    //
    // if (FoundAltars.Num() > 0)
    // {
    //     CauldronAltar = Cast<ACauldronAltar>(FoundAltars[0]);
    //     UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found world CauldronAltar %s"), 
    //         *GetName(), *CauldronAltar->GetName());
    // }
    // else
    // {
    //     UE_LOG(LogTemp, Warning, TEXT("[CauldronPosition] %s couldn't find a CauldronAltar!"), *GetName());
    // }
}

void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
    
    // // Cauldron-specific interaction options
    //
    // ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
    //
    // // If no player is occupying the position, let a player take the position
    // if (!IsOccupied() && InteractingCharacterPtr)
    // {
    //     OptionBuilder.AddDefaultInteraction(
    //         FText::FromString("Take Position"), // Text for the interaction
    //         [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
    //         {
    //             HandleInteraction(InteractingCharacterPtr);
    //         }
    //     );
    // }
    //
    // // Special case: if the character is standing at a position and we're in Inactive state, they can initiate brewing
    // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
    // {
    //     // Check cauldron state
    //     if (CauldronAltar->GetCurrentState() == EInteractionState::Inactive)
    //     {
    //         OptionBuilder.AddDefaultInteraction(
    //             FText::FromString("Start Brewing"), // Text for the interaction
    //             [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
    //             {
    //                 if (CauldronAltar)
    //                 {
    //                     // Cast to the appropriate start brewing function
    //                     CauldronAltar->StartBrewing(InteractingCharacterPtr);
    //                 }
    //             }
    //         );
    //     }
    // }
    //
    // // If this player is at a position and brewing is active, they can add ingredients
    // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
    // {
    //     if (CauldronAltar->GetCurrentState() == EInteractionState::Active)
    //     {
    //         // Get the player's current expected input
    //         FGameplayTag ExpectedInput = CauldronAltar->GetCurrentExpectedInputForPlayer(InteractingCharacterPtr);
    //         
    //         if (ExpectedInput.IsValid())
    //         {
    //             // Determine the ingredient name
    //             FString TagString = ExpectedInput.ToString();
    //             FString IngredientName = "Unknown Ingredient";
    //             
    //             if (TagString.Contains("Ingredient1"))
    //             {
    //                 IngredientName = "Red Mushroom";
    //             }
    //             else if (TagString.Contains("Ingredient2"))
    //             {
    //                 IngredientName = "Frog Leg";
    //             }
    //             else if (TagString.Contains("Ingredient3"))
    //             {
    //                 IngredientName = "Bat Wing";
    //             }
    //             else if (TagString.Contains("Ingredient4"))
    //             {
    //                 IngredientName = "Snake Venom";
    //             }
    //             else if (TagString.Contains("Ingredient5"))
    //             {
    //                 IngredientName = "Dragon Scale";
    //             }
    //             
    //             // Give the player the option to add the correct ingredient
    //             OptionBuilder.AddDefaultInteraction(
    //                 FText::FromString(FString::Printf(TEXT("Add %s"), *IngredientName)),
    //                 [this, InteractingCharacterPtr, ExpectedInput](const FInteractionExecuteContext& Context)
    //                 {
    //                     if (CauldronAltar)
    //                     {
    //                         CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, ExpectedInput);
    //                     }
    //                 }
    //             );
    //             
    //             // Also add wrong ingredient options for fun/challenge
    //             for (int32 i = 1; i <= 5; ++i)
    //             {
    //                 FString WrongTagString = FString::Printf(TEXT("Input.Cauldron.Ingredient%d"), i);
    //                 FGameplayTag WrongTag = FGameplayTag::RequestGameplayTag(FName(*WrongTagString));
    //                 
    //                 // Skip if this is the correct ingredient
    //                 if (WrongTag == ExpectedInput)
    //                 {
    //                     continue;
    //                 }
    //                 
    //                 // Determine wrong ingredient name
    //                 FString WrongIngredientName = "Unknown Ingredient";
    //                 switch (i)
    //                 {
    //                 case 1: WrongIngredientName = "Red Mushroom"; break;
    //                 case 2: WrongIngredientName = "Frog Leg"; break;
    //                 case 3: WrongIngredientName = "Bat Wing"; break;
    //                 case 4: WrongIngredientName = "Snake Venom"; break;
    //                 case 5: WrongIngredientName = "Dragon Scale"; break;
    //                 }
    //                 
    //                 OptionBuilder.AddDefaultInteraction(
    //                     FText::FromString(FString::Printf(TEXT("Add %s"), *WrongIngredientName)),
    //                     [this, InteractingCharacterPtr, WrongTag](const FInteractionExecuteContext& Context)
    //                     {
    //                         if (CauldronAltar)
    //                         {
    //                             CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, WrongTag);
    //                         }
    //                     }
    //                 );
    //             }
    //         }
    //     }
    // }
}

void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
    Super::HandleInteraction(InteractingCharacter);
    
    if (!InteractingCharacter || !CauldronAltar)
    {
        return;
    }
    
    // Call the cauldron altar to handle occupation
    // CauldronAltar->OccupyPosition(InteractingCharacter, this);
}

// bool ACauldronPosition::PositionCharacter(ACharacter* Character)
// {
//     if (!Character)
//     {
//         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Invalid character"));
//         return false;
//     }
//     
//     // No permitir posicionar si ya está ocupado
//     if (bIsOccupied && OccupyingCharacter != Character)
//     {
//         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Position already occupied"));
//         return false;
//     }
//     
//     // Teleportar al personaje a la ubicación de este actor
//     FVector TargetLocation = GetActorLocation();
//     FRotator TargetRotation = GetActorRotation();
//     
//     bool bSuccess = Character->SetActorLocationAndRotation(
//         TargetLocation, 
//         TargetRotation, 
//         false, 
//         nullptr, 
//         ETeleportType::TeleportPhysics);
//     
//     if (bSuccess)
//     {
//         // Marcar esta posición como ocupada
//         SetOccupied(true, Character);
//         
//         UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::PositionCharacter: Character positioned at %s"), 
//                *GetName());
//     }
//     
//     return bSuccess;
// }
//
// bool ACauldronPosition::IsOccupied() const
// {
//     return bIsOccupied && OccupyingCharacter != nullptr;
// }
//
// void ACauldronPosition::SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter)
// {
//     bIsOccupied = bInOccupied;
//     
//     if (bInOccupied)
//     {
//         OccupyingCharacter = InOccupyingCharacter;
//     }
//     else
//     {
//         OccupyingCharacter = nullptr;
//     }
//     
//     UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::SetOccupied: %s is now %s"), 
//            *GetName(), bIsOccupied ? TEXT("occupied") : TEXT("unoccupied"));
// }
</file>

<file path="WitchPT/Private/Item/Components/CauldronCraftComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Item/Components/CauldronCraftComponent.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "FWitchPTGameplayTags.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
#include "Player/WitchPTPlayerController.h"
#include "Item/CauldronAltar.h"
#include "Item/Potion/PotionBase.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/World.h"

// Sets default values for this component's properties
UCauldronCraftComponent::UCauldronCraftComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = true;
	SetIsReplicatedByDefault(true);

	BaseIngredient = nullptr;
	PrincipalIngredient = nullptr;
	ModifierIngredient = nullptr;

	// Initialize default crafting recipe
	DefaultCraftingRecipe.bRequiresBaseIngredient = true;
	DefaultCraftingRecipe.bRequiresPrincipalIngredient = true;
	DefaultCraftingRecipe.bRequiresModifierIngredient = false;
}

// Called when the game starts
void UCauldronCraftComponent::BeginPlay()
{
	Super::BeginPlay();
}

// Called every frame
void UCauldronCraftComponent::TickComponent(float DeltaTime, ELevelTick TickType,
                                            FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
}

void UCauldronCraftComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    
    DOREPLIFETIME(UCauldronCraftComponent, BaseIngredientIcon);
    DOREPLIFETIME(UCauldronCraftComponent, PrincipalIngredientIcon);
    DOREPLIFETIME(UCauldronCraftComponent, ModifierIngredientIcon);
    DOREPLIFETIME(UCauldronCraftComponent, CraftedPotion);
}

void UCauldronCraftComponent::OnRep_BaseIngredientIcon()
{
    BroadcastBaseIngredientIconSet();
}

void UCauldronCraftComponent::OnRep_PrincipalIngredientIcon()
{
    BroadcastPrincipalIngredientIconSet();
}

void UCauldronCraftComponent::OnRep_PotentiatorIngredientIcon()
{
    BroadcastModifierIngredientIconSet();
}

void UCauldronCraftComponent::OnRep_CraftedPotion()
{
    // Broadcast to UI or other systems that a potion has been crafted
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::OnRep_CraftedPotion: Potion crafted with validity: %s"), 
           CraftedPotion.bIsValid ? TEXT("Valid") : TEXT("Invalid"));
}

// ----------------------------------- CRAFTING VALIDATION FUNCTIONS ---------------------------------------------- //

bool UCauldronCraftComponent::CanCraftPotion() const
{
    const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
    
    // Check if required base ingredient is present
    if (Recipe.bRequiresBaseIngredient)
    {
        if (!BaseIngredient || !HasValidCraftingProperties(BaseIngredient))
        {
            UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Base ingredient missing or invalid"));
            return false;
        }
    }
    
    // Check if required principal ingredient is present
    if (Recipe.bRequiresPrincipalIngredient)
    {
        if (!PrincipalIngredient || !HasValidCraftingProperties(PrincipalIngredient))
        {
            UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Principal ingredient missing or invalid"));
            return false;
        }
    }
    
    // Check if required modifier ingredient is present (optional by default)
    if (Recipe.bRequiresModifierIngredient)
    {
        if (!ModifierIngredient || !HasValidCraftingProperties(ModifierIngredient))
        {
            UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Modifier ingredient missing or invalid"));
            return false;
        }
    }
    
    // Validate ingredient combination compatibility
    if (!ValidateIngredientCombination())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Ingredient combination is not valid"));
        return false;
    }
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CanCraftPotion: All requirements met, can craft potion"));
    return true;
}

FPotionCraftingRecipe UCauldronCraftComponent::GetRequiredIngredients() const
{
    // For now, return the default recipe
    // This could be expanded later to support different recipes based on context
    return DefaultCraftingRecipe;
}

bool UCauldronCraftComponent::ValidateIngredientCombination() const
{
    const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
    
    // If we don't have the minimum required ingredients, combination is invalid
    if (Recipe.bRequiresBaseIngredient && !BaseIngredient)
    {
        return false;
    }
    
    if (Recipe.bRequiresPrincipalIngredient && !PrincipalIngredient)
    {
        return false;
    }
    
    // Check base liquid type compatibility if specified in recipe
    if (BaseIngredient && Recipe.AllowedBaseLiquidTypes.Num() > 0)
    {
        const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps = 
            Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
                BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
        
        if (BaseProps && !Recipe.AllowedBaseLiquidTypes.HasTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag))
        {
            UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Base liquid type not allowed"));
            return false;
        }
    }
    
    // Check principal essence compatibility if specified in recipe
    if (PrincipalIngredient && Recipe.AllowedPrincipalEssences.Num() > 0)
    {
        const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps = 
            Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
                PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
        
        if (PrincipalProps && !Recipe.AllowedPrincipalEssences.HasTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag))
        {
            UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Principal essence not allowed"));
            return false;
        }
    }
    
    // Check for incompatible combinations
    if (Recipe.IncompatibleCombinations.Num() > 0)
    {
        // Build current combination tags
        FGameplayTagContainer CurrentCombination;
        
        if (BaseIngredient)
        {
            const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps = 
                Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
                    BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
            if (BaseProps)
            {
                CurrentCombination.AddTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag);
                CurrentCombination.AddTag(BaseProps->CategoryTag);
            }
        }
        
        if (PrincipalIngredient)
        {
            const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps = 
                Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
                    PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
            if (PrincipalProps)
            {
                CurrentCombination.AddTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag);
                CurrentCombination.AddTag(PrincipalProps->CategoryTag);
            }
        }
        
        if (ModifierIngredient)
        {
            const UWitchPTInventoryItemFragment_IngredientCraftingProperties* ModifierProps = 
                Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
                    ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
            if (ModifierProps)
            {
                CurrentCombination.AppendTags(ModifierProps->ModifierIngredientData.ModifierEffectTags);
                CurrentCombination.AddTag(ModifierProps->CategoryTag);
            }
        }
        
        // Check if any incompatible combination exists
        for (const FGameplayTag& IncompatibleTag : Recipe.IncompatibleCombinations)
        {
            if (CurrentCombination.HasTag(IncompatibleTag))
            {
                UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Found incompatible combination: %s"), 
                       *IncompatibleTag.ToString());
                return false;
            }
        }
    }
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Ingredient combination is valid"));
    return true;
}

bool UCauldronCraftComponent::HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const
{
    if (!Ingredient)
    {
        return false;
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps = 
        Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
            Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    
    return CraftingProps != nullptr;
}

// ----------------------------------- DEBUG FUNCTIONS ---------------------------------------------- //

void UCauldronCraftComponent::PrintIngredientDebugData() const
{
    UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON CRAFT COMPONENT DEBUG DATA ==="));
    UE_LOG(LogTemp, Warning, TEXT("Component Owner: %s"), GetOwner() ? *GetOwner()->GetName() : TEXT("None"));
    
    // Print Base Ingredient Data
    if (BaseIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT ---"));
        PrintSpecificIngredientData(BaseIngredient, TEXT("Base"));
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT: EMPTY ---"));
    }
    
    // Print Principal Ingredient Data
    if (PrincipalIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT ---"));
        PrintSpecificIngredientData(PrincipalIngredient, TEXT("Principal"));
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT: EMPTY ---"));
    }
    
    // Print Modifier Ingredient Data
    if (ModifierIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT ---"));
        PrintSpecificIngredientData(ModifierIngredient, TEXT("Modifier"));
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT: EMPTY ---"));
    }
    
    // Print Crafting Status
    UE_LOG(LogTemp, Warning, TEXT("--- CRAFTING STATUS ---"));
    UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), CanCraftPotion() ? TEXT("YES") : TEXT("NO"));
    UE_LOG(LogTemp, Warning, TEXT("Ingredient Combination Valid: %s"), ValidateIngredientCombination() ? TEXT("YES") : TEXT("NO"));
    
    // Print Current Crafted Potion Status
    UE_LOG(LogTemp, Warning, TEXT("--- CURRENT CRAFTED POTION ---"));
    UE_LOG(LogTemp, Warning, TEXT("Crafted Potion Valid: %s"), CraftedPotion.bIsValid ? TEXT("YES") : TEXT("NO"));
    if (CraftedPotion.bIsValid)
    {
        UE_LOG(LogTemp, Warning, TEXT("Potion Essence: %s"), *CraftedPotion.PotionEssenceTag.ToString());
        UE_LOG(LogTemp, Warning, TEXT("Base Liquid: %s"), *CraftedPotion.BaseLiquidTypeTag.ToString());
        UE_LOG(LogTemp, Warning, TEXT("Final Potency: %.2f"), CraftedPotion.FinalPotency);
        UE_LOG(LogTemp, Warning, TEXT("Final Duration: %.2f"), CraftedPotion.FinalDuration);
        UE_LOG(LogTemp, Warning, TEXT("Final Charges: %d"), CraftedPotion.FinalCharges);
    }
    
    UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG DATA ==="));
    CalculatePotionProperties();
}

void UCauldronCraftComponent::PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const
{
    if (!Ingredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("%s Ingredient: NULL"), *SlotName);
        return;
    }
    
    // Print basic ingredient info
    UE_LOG(LogTemp, Warning, TEXT("%s Ingredient Definition: %s"), 
           *SlotName, 
           Ingredient->GetItemDef() ? *Ingredient->GetItemDef()->GetName() : TEXT("None"));
    UE_LOG(LogTemp, Warning, TEXT("%s Stack Count: %d"), *SlotName, Ingredient->GetTotalStackCount());
    
    // Get the crafting properties fragment
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps = 
        Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
            Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    
    if (!CraftingProps)
    {
        UE_LOG(LogTemp, Error, TEXT("%s Ingredient: NO CRAFTING PROPERTIES FRAGMENT FOUND!"), *SlotName);
        return;
    }
    
    // Print common crafting properties
    UE_LOG(LogTemp, Warning, TEXT("%s Slot Usage Tag: %s"), *SlotName, *CraftingProps->SlotUsageTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Tier Tag: %s"), *SlotName, *CraftingProps->TierTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Category Tag: %s"), *SlotName, *CraftingProps->CategoryTag.ToString());
    
    // Print Base Ingredient specific data
    UE_LOG(LogTemp, Warning, TEXT("%s Base Liquid Type: %s"), 
           *SlotName, *CraftingProps->BaseIngredientData.BaseLiquidTypeTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Default Charges: %d"), 
           *SlotName, CraftingProps->BaseIngredientData.DefaultChargesProvided);
    UE_LOG(LogTemp, Warning, TEXT("%s Stability Modifier: %.3f"), 
           *SlotName, CraftingProps->BaseIngredientData.StabilityModifier);
    
    // Print Principal Ingredient specific data
    UE_LOG(LogTemp, Warning, TEXT("%s Principal Essence: %s"), 
           *SlotName, *CraftingProps->PrincipalIngredientData.PrincipalEssenceTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Base Potency: %.3f"), 
           *SlotName, CraftingProps->PrincipalIngredientData.BasePotency);
    UE_LOG(LogTemp, Warning, TEXT("%s Base Duration: %.3f"), 
           *SlotName, CraftingProps->PrincipalIngredientData.BaseDuration);
    UE_LOG(LogTemp, Warning, TEXT("%s Is Ritual Essence: %s"), 
           *SlotName, CraftingProps->PrincipalIngredientData.bIsRitualEssence ? TEXT("YES") : TEXT("NO"));
    
    // Print Modifier Ingredient specific data
    FString ModifierEffectTagsString;
    for (const FGameplayTag& Tag : CraftingProps->ModifierIngredientData.ModifierEffectTags)
    {
        if (!ModifierEffectTagsString.IsEmpty())
        {
            ModifierEffectTagsString += TEXT(", ");
        }
        ModifierEffectTagsString += Tag.ToString();
    }
    UE_LOG(LogTemp, Warning, TEXT("%s Modifier Effect Tags: [%s]"), *SlotName, *ModifierEffectTagsString);
    UE_LOG(LogTemp, Warning, TEXT("%s Potency Modification: %.3f"), 
           *SlotName, CraftingProps->ModifierIngredientData.PotencyModificationValue);
    UE_LOG(LogTemp, Warning, TEXT("%s Duration Modification: %.3f"), 
           *SlotName, CraftingProps->ModifierIngredientData.DurationModificationValue);
    UE_LOG(LogTemp, Warning, TEXT("%s Granted Property Tag: %s"), 
           *SlotName, *CraftingProps->ModifierIngredientData.GrantedPropertyTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Added Effect Tag: %s"), 
           *SlotName, *CraftingProps->ModifierIngredientData.AddedEffectTag.ToString());
    UE_LOG(LogTemp, Warning, TEXT("%s Modifier Strength: %.3f"), 
           *SlotName, CraftingProps->ModifierIngredientData.StrengthOfModifier);
}

void UCauldronCraftComponent::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
{
    if (!GetOwner()->HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Not authority"));
        return;
    }

    AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
    if (!PC)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
        return;
    }

    UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
    if (!InventoryManager)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
        return;
    }
    
    UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);

    if (!InstanceFromInventory)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
        return;
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    if (!IngredientCraftingDetails)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
        return;
    }

    // Determine ingredient type based on SlotUsageTag
    const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
    bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
    bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
    bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);

    // Check if the appropriate slot is already occupied
    if (bIsBaseIngredient && BaseIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
        return;
    }
    
    if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
        return;
    }
    
    if (bIsModifierIngredient && ModifierIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
        return;
    }

    // If none of the slot usage tags match, this ingredient can't be used
    if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
        return;
    }
    
    bool bConsumedSuccessfully = false;
    int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
    
    if (CurrentStackCount > 0)
    {
        UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
        
        if (CurrentStackCount == 1)
        {
            IngredientToSet = InstanceFromInventory;
            InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
            bConsumedSuccessfully = true;
        }
        else
        {
            InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
            IngredientToSet = InstanceFromInventory;
            bConsumedSuccessfully = true;
        }
        
        // Get UI fragment for icon
        const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
        TSubclassOf<UUserWidget> IngredientIcon = nullptr;
        if (IsValid(UIFragment))
        {
            IngredientIcon = UIFragment->IconWidget;
        }
        
        // Set the ingredient in the appropriate slot
        if (bIsBaseIngredient)
        {
            BaseIngredient = IngredientToSet;
            BaseIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient set successfully"));
            
            if (GetOwner()->HasAuthority())
            {
                BroadcastBaseIngredientIconSet();
            }
        }
        else if (bIsPrincipalIngredient)
        {
            PrincipalIngredient = IngredientToSet;
            PrincipalIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient set successfully"));
            
            if (GetOwner()->HasAuthority())
            {
                BroadcastPrincipalIngredientIconSet();
            }
        }
        else if (bIsModifierIngredient)
        {
            ModifierIngredient = IngredientToSet;
            ModifierIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient set successfully"));
            
            if (GetOwner()->HasAuthority())
            {
                BroadcastModifierIngredientIconSet();
            }
        }
    }
}

// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
void UCauldronCraftComponent::BroadcastBaseIngredientDropped() const
{
    OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
}

void UCauldronCraftComponent::BroadcastBaseIngredientIconSet() const
{
    OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
}

void UCauldronCraftComponent::BroadcastPrincipalIngredientDropped() const
{
    OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
}

void UCauldronCraftComponent::BroadcastPrincipalIngredientIconSet() const
{
    OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
}

void UCauldronCraftComponent::BroadcastModifierIngredientDropped() const
{
    OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
}

void UCauldronCraftComponent::BroadcastModifierIngredientIconSet() const
{
    OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
}

UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetBaseIngredient() const
{
    return BaseIngredient;
}

UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetPrincipalIngredient() const
{
    return PrincipalIngredient;
}

UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetModifierIngredient() const
{
    return ModifierIngredient;
}

TSubclassOf<UUserWidget> UCauldronCraftComponent::GetBaseIngredientIcon() const
{
    return BaseIngredientIcon;
}

TSubclassOf<UUserWidget> UCauldronCraftComponent::GetPrincipalIngredientIcon() const
{
    return PrincipalIngredientIcon;
}

TSubclassOf<UUserWidget> UCauldronCraftComponent::GetModifierIngredientIcon() const
{
    return ModifierIngredientIcon;
}


// ----------------------------------- INGREDIENT DATA EXTRACTION FUNCTIONS ---------------------------------------------- //

FExtractedBaseIngredientData UCauldronCraftComponent::ExtractBaseIngredientProperties() const
{
    FExtractedBaseIngredientData ExtractedData;
    
    if (!BaseIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No base ingredient found"));
        return ExtractedData; // bIsValid remains false
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps = 
        Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
            BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    
    if (!CraftingProps)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No crafting properties found"));
        return ExtractedData;
    }
    
    // Extract base ingredient data
    ExtractedData.BaseLiquidTypeTag = CraftingProps->BaseIngredientData.BaseLiquidTypeTag;
    ExtractedData.DefaultChargesProvided = CraftingProps->BaseIngredientData.DefaultChargesProvided;
    ExtractedData.StabilityModifier = CraftingProps->BaseIngredientData.StabilityModifier;
    ExtractedData.TierTag = CraftingProps->TierTag;
    ExtractedData.bIsValid = true;
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: Successfully extracted - Liquid: %s, Charges: %d, Stability: %.3f"), 
           *ExtractedData.BaseLiquidTypeTag.ToString(), 
           ExtractedData.DefaultChargesProvided, 
           ExtractedData.StabilityModifier);
    
    return ExtractedData;
}

FExtractedPrincipalIngredientData UCauldronCraftComponent::ExtractPrincipalIngredientProperties() const
{
    FExtractedPrincipalIngredientData ExtractedData;
    
    if (!PrincipalIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No principal ingredient found"));
        return ExtractedData; // bIsValid remains false
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps = 
        Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
            PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    
    if (!CraftingProps)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No crafting properties found"));
        return ExtractedData;
    }
    
    // Extract principal ingredient data
    ExtractedData.PrincipalEssenceTag = CraftingProps->PrincipalIngredientData.PrincipalEssenceTag;
    ExtractedData.BasePotency = CraftingProps->PrincipalIngredientData.BasePotency;
    ExtractedData.BaseDuration = CraftingProps->PrincipalIngredientData.BaseDuration;
    ExtractedData.bIsRitualEssence = CraftingProps->PrincipalIngredientData.bIsRitualEssence;
    ExtractedData.TierTag = CraftingProps->TierTag;
    ExtractedData.bIsValid = true;
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: Successfully extracted - Essence: %s, Potency: %.3f, Duration: %.3f"), 
           *ExtractedData.PrincipalEssenceTag.ToString(), 
           ExtractedData.BasePotency, 
           ExtractedData.BaseDuration);
    
    return ExtractedData;
}

FExtractedModifierIngredientData UCauldronCraftComponent::ExtractModifierIngredientProperties() const
{
    FExtractedModifierIngredientData ExtractedData;
    
    if (!ModifierIngredient)
    {
        UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No modifier ingredient found (this is optional)"));
        return ExtractedData; // bIsValid remains false, but this is acceptable for optional ingredients
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps = 
        Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
            ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    
    if (!CraftingProps)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No crafting properties found"));
        return ExtractedData;
    }
    
    // Extract modifier ingredient data
    ExtractedData.ModifierEffectTags = CraftingProps->ModifierIngredientData.ModifierEffectTags;
    ExtractedData.PotencyModificationValue = CraftingProps->ModifierIngredientData.PotencyModificationValue;
    ExtractedData.DurationModificationValue = CraftingProps->ModifierIngredientData.DurationModificationValue;
    ExtractedData.GrantedPropertyTag = CraftingProps->ModifierIngredientData.GrantedPropertyTag;
    ExtractedData.AddedEffectTag = CraftingProps->ModifierIngredientData.AddedEffectTag;
    ExtractedData.StrengthOfModifier = CraftingProps->ModifierIngredientData.StrengthOfModifier;
    ExtractedData.TierTag = CraftingProps->TierTag;
    ExtractedData.bIsValid = true;
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: Successfully extracted - Effects: %d, Potency Mod: %.3f, Duration Mod: %.3f"), 
           ExtractedData.ModifierEffectTags.Num(), 
           ExtractedData.PotencyModificationValue, 
           ExtractedData.DurationModificationValue);
    
    return ExtractedData;
}

// ----------------------------------- POTION CALCULATION FUNCTIONS ---------------------------------------------- //

FPotionResult UCauldronCraftComponent::CalculatePotionProperties() const
{
    FPotionResult PotionResult;
    
    // Check if we can craft a potion
    if (!CanCraftPotion())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Cannot craft potion with current ingredients"));
        return PotionResult; // bIsValid remains false
    }
    
    // Extract ingredient data
    FExtractedBaseIngredientData BaseData = ExtractBaseIngredientProperties();
    FExtractedPrincipalIngredientData PrincipalData = ExtractPrincipalIngredientProperties();
    FExtractedModifierIngredientData ModifierData = ExtractModifierIngredientProperties();
    
    // Validate extracted data
    if (!BaseData.bIsValid || !PrincipalData.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Required ingredient data is invalid"));
        return PotionResult;
    }
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Starting potion calculation..."));
    
    // Step 1: Start with base liquid properties
    PotionResult.BaseLiquidTypeTag = BaseData.BaseLiquidTypeTag;
    PotionResult.FinalCharges = BaseData.DefaultChargesProvided;
    float StabilityFactor = BaseData.StabilityModifier;
    
    // Step 2: Apply principal ingredient effects
    PotionResult.PotionEssenceTag = PrincipalData.PrincipalEssenceTag;
    PotionResult.FinalPotency = PrincipalData.BasePotency;
    PotionResult.FinalDuration = PrincipalData.BaseDuration;
    
    // Add principal essence to granted effects
    if (PrincipalData.PrincipalEssenceTag.IsValid())
    {
        PotionResult.GrantedEffectTags.AddTag(PrincipalData.PrincipalEssenceTag);
    }
    
    // Step 3: Apply modifier ingredient effects (if present)
    if (ModifierData.bIsValid)
    {
        UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Applying modifier effects..."));
        
        // Apply potency modification (multiplicative)
        PotionResult.FinalPotency *= ModifierData.PotencyModificationValue;
        
        // Apply duration modification (additive)
        PotionResult.FinalDuration += ModifierData.DurationModificationValue;
        
        // Add modifier effects to granted effects
        PotionResult.GrantedEffectTags.AppendTags(ModifierData.ModifierEffectTags);
        
        // Add granted property
        if (ModifierData.GrantedPropertyTag.IsValid())
        {
            PotionResult.GrantedPropertyTags.AddTag(ModifierData.GrantedPropertyTag);
        }
        
        // Add additional effect
        if (ModifierData.AddedEffectTag.IsValid())
        {
            PotionResult.GrantedEffectTags.AddTag(ModifierData.AddedEffectTag);
        }
        
        // Apply modifier strength to overall potency (additional multiplicative factor)
        PotionResult.FinalPotency *= ModifierData.StrengthOfModifier;
    }
    
    // Step 4: Apply stability modifier to final potency
    PotionResult.FinalPotency *= StabilityFactor;
    
    // Step 5: Calculate final potion tier
    PotionResult.PotionTierTag = CalculatePotionTier(BaseData, PrincipalData, ModifierData);
    
    // Step 6: Ensure minimum values
    PotionResult.FinalPotency = FMath::Max(PotionResult.FinalPotency, 0.1f); // Minimum potency
    PotionResult.FinalDuration = FMath::Max(PotionResult.FinalDuration, 1.0f); // Minimum duration
    PotionResult.FinalCharges = FMath::Max(PotionResult.FinalCharges, 1); // Minimum charges
    
    // Mark as valid
    PotionResult.bIsValid = true;
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Potion calculation complete - Potency: %.2f, Duration: %.2f, Charges: %d"), 
           PotionResult.FinalPotency, 
           PotionResult.FinalDuration, 
           PotionResult.FinalCharges);
    
    return PotionResult;
}

FGameplayTag UCauldronCraftComponent::CalculatePotionTier(const FExtractedBaseIngredientData& BaseData, 
                                                         const FExtractedPrincipalIngredientData& PrincipalData, 
                                                         const FExtractedModifierIngredientData& ModifierData) const
{
    // Simple tier calculation: use the highest tier among all ingredients
    // This could be expanded to use more complex logic later
    
    TArray<FGameplayTag> TierTags;
    
    if (BaseData.bIsValid && BaseData.TierTag.IsValid())
    {
        TierTags.Add(BaseData.TierTag);
    }
    
    if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
    {
        TierTags.Add(PrincipalData.TierTag);
    }
    
    if (ModifierData.bIsValid && ModifierData.TierTag.IsValid())
    {
        TierTags.Add(ModifierData.TierTag);
    }
    
    // For now, return the principal ingredient's tier as the base
    // This could be enhanced to compare tier values and return the highest
    if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
    {
        UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using principal ingredient tier: %s"), 
               *PrincipalData.TierTag.ToString());
        return PrincipalData.TierTag;
    }
    
    // Fallback to base ingredient tier
    if (BaseData.bIsValid && BaseData.TierTag.IsValid())
    {
        UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using base ingredient tier: %s"), 
               *BaseData.TierTag.ToString());
        return BaseData.TierTag;
    }
    
    // No valid tier found
    UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionTier: No valid tier tags found, returning empty tag"));
    return FGameplayTag();
}

// ----------------------------------- POTION ITEMDEFINITION GENERATION FUNCTIONS ---------------------------------------------- //

TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GeneratePotionItemDefinition(const FPotionResult& PotionData) const
{
    if (!PotionData.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Invalid potion data provided"));
        return nullptr;
    }

    TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
    if (!BasePotionItemDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: BasePotionItemDefinition is not set"));
        return nullptr;
    }

    // For now, return the base definition
    // In a full implementation, you might want to create dynamic classes or use a different approach
    // This is a simplified approach where we'll set properties at runtime
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Returning base potion definition for essence: %s"), 
           *PotionData.PotionEssenceTag.ToString());
    
    return BasePotionItemDefinition;
}

UWitchPTInventoryItemDefinition* UCauldronCraftComponent::CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const
{
    if (!PotionData.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Invalid potion data provided"));
        return nullptr;
    }

    TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
    if (!BasePotionItemDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: BasePotionItemDefinition is not set"));
        return nullptr;
    }

    // Create a new instance of the base potion definition
    UWitchPTInventoryItemDefinition* PotionDefinition = NewObject<UWitchPTInventoryItemDefinition>(
        GetTransientPackage(), 
        BasePotionItemDefinition
    );

    if (!PotionDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Failed to create potion definition instance"));
        return nullptr;
    }

    // Find or create the potion properties fragment
    UWitchPTInventoryItemFragment_PotionProperties* PotionPropsFragment = nullptr;
    
    // Check if base definition already has a potion properties fragment
    const UWitchPTInventoryItemFragment_PotionProperties* ExistingFragment = 
        Cast<UWitchPTInventoryItemFragment_PotionProperties>(
            PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_PotionProperties::StaticClass()));

    if (ExistingFragment)
    {
        // Create a new fragment based on the existing one
        PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
        
        // Copy any default values from the existing fragment if needed
        // For now, we'll just set the new properties
    }
    else
    {
        // Create a new potion properties fragment
        PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
        
        // Add the fragment to the definition's fragments array
        PotionDefinition->Fragments.Add(PotionPropsFragment);
    }

    // Set the potion properties from the crafting result
    if (PotionPropsFragment)
    {
        PotionPropsFragment->SetPotionProperties(
            PotionData.PotionEssenceTag,
            PotionData.BaseLiquidTypeTag,
            PotionData.FinalPotency,
            PotionData.FinalDuration,
            PotionData.FinalCharges,
            PotionData.PotionTierTag,
            PotionData.GrantedEffectTags,
            PotionData.GrantedPropertyTags
        );

        UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Created potion definition with properties - %s"), 
               *PotionData.PotionEssenceTag.ToString());
    }

    return PotionDefinition;
}

// ----------------------------------- POTION SPAWNING FUNCTIONS ---------------------------------------------- //

UWitchPTInventoryItemInstance* UCauldronCraftComponent::CreatePotionInstance(const FPotionResult& PotionData) const
{
    if (!PotionData.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Invalid potion data provided"));
        return nullptr;
    }

    // Create the potion definition instance
    UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
    if (!PotionDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion definition"));
        return nullptr;
    }

    // Create a new inventory item instance
    UWitchPTInventoryItemInstance* PotionInstance = NewObject<UWitchPTInventoryItemInstance>();
    if (!PotionInstance)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion instance"));
        return nullptr;
    }

    // Set the item definition and stack count
    PotionInstance->SetItemDef(PotionDefinition->GetClass());
    PotionInstance->SetTotalStackCount(PotionData.FinalCharges);

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionInstance: Successfully created potion instance - %s with %d charges"), 
           *PotionData.PotionEssenceTag.ToString(), 
           PotionData.FinalCharges);

    return PotionInstance;
}

bool UCauldronCraftComponent::SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const
{
    if (!PotionData.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Invalid potion data provided"));
        return false;
    }

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Attempting to spawn at location: %s"), *SpawnLocation.ToString());
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Cauldron owner location: %s"), *GetOwner()->GetActorLocation().ToString());

    // Create the potion definition instance with proper properties
    UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
    if (!PotionDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create potion definition"));
        return false;
    }

    // Get the world for spawning
    UWorld* World = GetWorld();
    if (!World)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No valid world found"));
        return false;
    }

    // Spawn PotionBase actor at the specified location
    FActorSpawnParameters SpawnParams;
    SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
    
    APotionBase* PotionActor = World->SpawnActor<APotionBase>(SpawnLocation, FRotator::ZeroRotator, SpawnParams);
    FItemManifest ItemManifest;
    ItemManifest.ItemDef = PotionDefinition->GetClass();
    PotionActor->StaticInventory = ItemManifest;
    if (!PotionActor)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to spawn PotionBase actor"));
        return false;
    }

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned PotionBase at: %s"), *PotionActor->GetActorLocation().ToString());

    // Set up the static mesh from the world details fragment
    const UWitchPTInventoryItemFragment_WorldDetails* WorldDetails = 
        Cast<UWitchPTInventoryItemFragment_WorldDetails>(
            PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_WorldDetails::StaticClass()));

    if (WorldDetails && WorldDetails->HasValidWorldMesh())
    {
        // Get or create the static mesh component from PotionBase
        UStaticMeshComponent* MeshComponent = PotionActor->FindComponentByClass<UStaticMeshComponent>();
        
        if (!MeshComponent)
        {
            // Create a new StaticMeshComponent if one doesn't exist
            MeshComponent = NewObject<UStaticMeshComponent>(PotionActor);
            MeshComponent->SetupAttachment(PotionActor->GetRootComponent());
            MeshComponent->RegisterComponent();
            
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Created new StaticMeshComponent for PotionBase"));
        }
        
        if (MeshComponent)
        {
            // Set the mesh from the world details fragment
            MeshComponent->SetStaticMesh(WorldDetails->WorldStaticMesh);
            
            // Apply scale if specified
            if (WorldDetails->WorldScale != FVector::OneVector)
            {
                MeshComponent->SetWorldScale3D(WorldDetails->WorldScale);
            }
            
            // Apply material override if specified
            if (WorldDetails->WorldMaterial)
            {
                MeshComponent->SetMaterial(0, WorldDetails->WorldMaterial);
            }
            
            // Set collision profile if specified
            if (!WorldDetails->CollisionProfileName.IsNone())
            {
                MeshComponent->SetCollisionProfileName(WorldDetails->CollisionProfileName);
            }

            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Applied mesh '%s' from WorldDetails fragment"), 
                   *WorldDetails->WorldStaticMesh->GetName());
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create or find StaticMeshComponent"));
        }
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No WorldDetails fragment or invalid mesh - using default appearance"));
    }

    // Set the item definition in the potion actor
    // Note: You may need to add a SetItemDefinition method to PotionBase if it doesn't exist
    // For now, we'll log that the potion was spawned successfully
    
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned potion at location: %s"), 
           *SpawnLocation.ToString());
    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Potion: %s with %d charges, %.2f potency"), 
           *PotionData.PotionEssenceTag.ToString(), 
           PotionData.FinalCharges,
           PotionData.FinalPotency);
    
    return true;
}

UWitchPTInventoryItemInstance* UCauldronCraftComponent::AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const
{
    if (!TargetCharacter)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter is null"));
        return nullptr;
    }

    UWitchPTInventoryItemInstance* PotionInstance = CreatePotionInstance(PotionData);
    if (!PotionInstance)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Failed to create potion instance"));
        return nullptr;
    }

    // Get the player controller and inventory manager
    AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(TargetCharacter->GetController());
    if (!PC)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter does not have a valid PlayerController"));
        return nullptr;
    }

    UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
    if (!InventoryManager)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Could not get InventoryManager from PlayerController"));
        return nullptr;
    }

    // Add the potion to inventory
    // bool bAddedSuccessfully = InventoryManager->Server_AddItem(PotionInstance);
    // if (bAddedSuccessfully)
    // {
    //     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::AddPotionToInventory: Successfully added potion to inventory - %s"), 
    //            *PotionData.PotionEssenceTag.ToString());
    //     return PotionInstance;
    // }
    // else
    // {
    //     UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::AddPotionToInventory: Failed to add potion to inventory"));
    //     return nullptr;
    // }
    return nullptr;
}

// ----------------------------------- MAIN CRAFTING FUNCTION ---------------------------------------------- //

FPotionResult UCauldronCraftComponent::CraftPotion(bool bAddToInventory, ACharacter* TargetCharacter, const FVector& WorldSpawnLocation)
{
    FPotionResult EmptyResult;
    
    // Only allow crafting on the server
    if (!GetOwner()->HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Not authority - crafting not allowed"));
        return EmptyResult;
    }

    // Check if we can perform crafting
    if (!CanPerformCrafting())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Cannot perform crafting with current setup"));
        return EmptyResult;
    }

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Starting potion crafting process..."));

    // Step 1: Calculate potion properties
    FPotionResult CraftingResult = CalculatePotionProperties();
    if (!CraftingResult.bIsValid)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to calculate valid potion properties"));
        return EmptyResult;
    }

    // Step 2: Create and spawn/add the potion
    bool bPotionCreatedSuccessfully = false;
    
    if (bAddToInventory)
    {
        // Determine target character
        ACharacter* Target = TargetCharacter;
        if (!Target)
        {
            // Try to get character from owner (if cauldron is owned by a character)
            Target = Cast<ACharacter>(GetOwner());
            if (!Target)
            {
                // Try to get the closest player character (fallback)
                UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: No target character specified for inventory addition"));
                return EmptyResult;
            }
        }
        
        UWitchPTInventoryItemInstance* CreatedInstance = AddPotionToInventory(CraftingResult, Target);
        bPotionCreatedSuccessfully = (CreatedInstance != nullptr);
    }
    else
    {
        // Calculate spawn location relative to cauldron's current position
        FVector CauldronLocation = GetOwner()->GetActorLocation();
        FVector SpawnLoc;
        
        if (WorldSpawnLocation != FVector::ZeroVector)
        {
            // Use specified location
            SpawnLoc = WorldSpawnLocation;
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Using specified spawn location: %s"), *SpawnLoc.ToString());
        }
        else
        {
            // Calculate offset from cauldron position (spawn slightly in front and up)
            FRotator CauldronRotation = GetOwner()->GetActorRotation();
            FVector ForwardOffset = CauldronRotation.RotateVector(FVector(150.0f, 0.0f, 0.0f)); // 150cm forward
            FVector UpOffset = FVector(0.0f, 0.0f, 50.0f); // 50cm up
            SpawnLoc = CauldronLocation + ForwardOffset + UpOffset;
            
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Cauldron location: %s"), *CauldronLocation.ToString());
            UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Calculated spawn location: %s"), *SpawnLoc.ToString());
        }
        
        bPotionCreatedSuccessfully = SpawnPotionInWorld(CraftingResult, SpawnLoc);
    }

    if (!bPotionCreatedSuccessfully)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to create/spawn potion"));
        return EmptyResult;
    }

    // Step 3: Store the result and clear ingredients
    CraftedPotion = CraftingResult;
    ClearIngredientSlots();

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Successfully crafted potion - %s with potency %.2f"), 
           *CraftingResult.PotionEssenceTag.ToString(), 
           CraftingResult.FinalPotency);

    return CraftingResult;
}

// ----------------------------------- CRAFTING HELPER FUNCTIONS ---------------------------------------------- //

bool UCauldronCraftComponent::CanPerformCrafting() const
{
    // Check basic crafting requirements
    if (!CanCraftPotion())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanPerformCrafting: Basic crafting requirements not met"));
        return false;
    }

    // Check if we have a base potion definition set
    TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
    if (!BasePotionItemDefinition)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CanPerformCrafting: BasePotionItemDefinition is not set"));
        return false;
    }

    // Additional checks could be added here:
    // - Player permissions
    // - Cauldron state
    // - Resource requirements
    // - Cooldowns

    return true;
}

void UCauldronCraftComponent::ClearIngredientSlots()
{
    if (!GetOwner()->HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Not authority"));
        return;
    }

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Clearing all ingredient slots"));

    // Clear base ingredient
    if (BaseIngredient)
    {
        BaseIngredient = nullptr;
        BaseIngredientIcon = nullptr;
        BroadcastBaseIngredientIconSet();
    }

    // Clear principal ingredient
    if (PrincipalIngredient)
    {
        PrincipalIngredient = nullptr;
        PrincipalIngredientIcon = nullptr;
        BroadcastPrincipalIngredientIconSet();
    }

    // Clear modifier ingredient
    if (ModifierIngredient)
    {
        ModifierIngredient = nullptr;
        ModifierIngredientIcon = nullptr;
        BroadcastModifierIngredientIconSet();
    }

    // Clear crafted potion result
    CraftedPotion = FPotionResult();

    UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: All ingredient slots cleared"));
}

// ----------------------------------- DEBUG/TESTING HELPER FUNCTIONS ---------------------------------------------- //

void UCauldronCraftComponent::DebugTestCrafting()
{
    UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON DEBUG TEST CRAFTING ==="));
    
    // Print current state
    PrintIngredientDebugData();
    
    // Test crafting calculations
    UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING CALCULATIONS ---"));
    FPotionResult TestResult = CalculatePotionProperties();
    
    if (TestResult.bIsValid)
    {
        UE_LOG(LogTemp, Warning, TEXT("CALCULATION SUCCESS: %s Potion - Potency: %.2f, Duration: %.2f, Charges: %d"), 
               *TestResult.PotionEssenceTag.ToString(), 
               TestResult.FinalPotency, 
               TestResult.FinalDuration, 
               TestResult.FinalCharges);
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("CALCULATION FAILED: Invalid potion result"));
    }
    
    // Test crafting validation
    UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING VALIDATION ---"));
    bool bCanCraft = CanCraftPotion();
    bool bCanPerform = CanPerformCrafting();
    
    UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), bCanCraft ? TEXT("YES") : TEXT("NO"));
    UE_LOG(LogTemp, Warning, TEXT("Can Perform Crafting: %s"), bCanPerform ? TEXT("YES") : TEXT("NO"));
    
    if (bCanPerform)
    {
        UE_LOG(LogTemp, Warning, TEXT("--- ATTEMPTING WORLD SPAWN CRAFT ---"));
        // Use default location calculation (will be calculated relative to cauldron in CraftPotion)
        FPotionResult CraftResult = CraftPotion(false, nullptr, FVector::ZeroVector);
        
        if (CraftResult.bIsValid)
        {
            UE_LOG(LogTemp, Warning, TEXT("CRAFTING SUCCESS: Potion created and spawned near cauldron"));
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("CRAFTING FAILED: No valid result"));
        }
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("CRAFTING VALIDATION FAILED: Cannot perform crafting"));
    }
    
    UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG TEST ==="));
}

// ----------------------------------- HELPER FUNCTIONS ---------------------------------------------- //

TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GetBasePotionItemDefinition() const
{
    // Get the owning cauldron actor
    ACauldronAltar* CauldronOwner = Cast<ACauldronAltar>(GetOwner());
    if (!CauldronOwner)
    {
        UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GetBasePotionItemDefinition: Owner is not a CauldronAltar"));
        return nullptr;
    }

    return CauldronOwner->BasePotionItemDefinition;
}
</file>

<file path="WitchPT/Private/Item/Ingredient/IngredientBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Ingredient/IngredientBase.h"


// Sets default values
AIngredientBase::AIngredientBase()
{
	
}

void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
	FInteractionOptionBuilder& OptionBuilder)
{
	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
}

FItemManifest AIngredientBase::GetPickupInventory() const
{
	return StaticInventory;
}
</file>

<file path="WitchPT/Private/Item/Item.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Item.h"


// Sets default values
AItem::AItem()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AItem::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AItem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
	OptionBuilder.AddInteractionOption(Option);
}
</file>

<file path="WitchPT/Private/Item/MechanicsInterface.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/MechanicsInterface.h"

// Add default functionality here for any IMechanicsInterface functions that are not pure virtual.
</file>

<file path="WitchPT/Private/Item/PositionInterface.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/PositionInterface.h"

// Add default functionality here for any IPositionInterface functions that are not pure virtual.
</file>

<file path="WitchPT/Private/Item/Potion/PotionBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Potion/PotionBase.h"


// Sets default values
APotionBase::APotionBase()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	// Set default ability path
	InteractionAbilityClass = TSoftClassPtr<UGameplayAbility>(FSoftObjectPath(TEXT("/Game/Blueprints/AbilitySystem/GameplayAbilities/Interact/GA_Interact_Collect.GA_Interact_Collect_C")));
}

void APotionBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
	FInteractionOptionBuilder& OptionBuilder)
{
	// Load the ability class if not already loaded
	if (!LoadedInteractionAbility && !InteractionAbilityClass.IsNull())
	{
		LoadedInteractionAbility = InteractionAbilityClass.LoadSynchronous();
	}
	
	// Set up the interaction option
	if (LoadedInteractionAbility)
	{
		Option.InteractionAbilityToGrant = LoadedInteractionAbility;
		Option.Text = FText::FromString(TEXT("Pick up Potion"));
		// Option.SubText = FText::FromString(TEXT("Add to inventory"));
	}
	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
}

FItemManifest APotionBase::GetPickupInventory() const
{
	return StaticInventory;
}
</file>

<file path="WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Ritual/RitualFunctionLibrary.h"

#include "Kismet/GameplayStatics.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/WitchPTWidgetController.h"

URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			
			return WitchPTHUD->SetRitualWidgetController(WCParams);
		}
	}
	return nullptr;
}

UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			return WitchPTHUD->SetCauldronWidgetController(WCParams);
		}
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Item/RitualAltar.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Item/RitualAltar.h"
#include "Net/UnrealNetwork.h"
#include "Item/RitualPosition.h"
#include "GameFramework/Character.h"
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"
#include "Player/WitchPTPlayerController.h"

// Sets default values
ARitualAltar::ARitualAltar()
{
	// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true; 

	bReplicates = true;
	
	// Default values
	CurrentRitualState = EInteractionState::Inactive;
	CurrentSequenceIndex = -1;
	CurrentInputTimer = 0.0f;
	CorruptionAmount = 0.0f;
	MaxCorruption = 100.0f;
	StartCountdown = 3;
	bRitualCompleted = false;
	bRitualWasSuccessful = false;
}

void ARitualAltar::BeginPlay()
{
	Super::BeginPlay();
	
	// // Auto-discover RitualPositions if not set in editor
	// if (RitualPositions.Num() == 0 && HasAuthority())
	// {
	// 	TArray<AActor*> FoundActors;
	// 	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ARitualPosition::StaticClass(), FoundActors);
	// 	
	// 	for (AActor* Actor : FoundActors)
	// 	{
	// 		ARitualPosition* Position = Cast<ARitualPosition>(Actor);
	// 		if (Position)
	// 		{
	// 			RitualPositions.Add(Position);
	// 			Position->SetRitualAltar(this);
	// 		}
	// 	}
	// }
}

void ARitualAltar::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
	DOREPLIFETIME(ARitualAltar, InputSequence);
	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
	DOREPLIFETIME(ARitualAltar, MaxCorruption);
	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
	DOREPLIFETIME(ARitualAltar, StartCountdown);
	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
}

// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //

void ARitualAltar::OnRep_CurrentRitualState()
{
	BroadcastRitualStateChanged();
}

void ARitualAltar::OnRep_CurrentSequenceIndex()
{
	// Just broadcast sequence progress change - turn data updates are handled by OnRep_TurnData
	BroadcastSequenceProgressChanged();
}

void ARitualAltar::OnRep_ReadyPlayersData()
{
	BroadcastReadyPlayersChanged();
}

void ARitualAltar::OnRep_StartCountdown()
{
	BroadcastCountdownTick();
}

void ARitualAltar::OnRep_CurrentActivePlayer()
{
	// Turn data updates are handled by OnRep_TurnData
	// This OnRep function is kept for potential future use
}

void ARitualAltar::OnRep_TurnData()
{
	BroadcastTurnDataChanged();
}

void ARitualAltar::OnRep_CorruptionAmount()
{
	BroadcastCorruptionChanged();
}

void ARitualAltar::OnRep_RitualCompleted()
{
	if (bRitualCompleted)
	{
		BroadcastRitualCompleted();
	}
}

// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //

void ARitualAltar::BroadcastRitualStateChanged()
{
	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
}

void ARitualAltar::BroadcastReadyPlayersChanged()
{
	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
}

void ARitualAltar::BroadcastCountdownTick()
{
	OnCountdownTickEvent.Broadcast(StartCountdown);
}

void ARitualAltar::BroadcastTurnDataChanged()
{
	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
}

void ARitualAltar::BroadcastCorruptionChanged()
{
	float CorruptionPercentage = GetCorruptionPercentage();
	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
}

void ARitualAltar::BroadcastSequenceProgressChanged()
{
	float Progress = GetCurrentSequenceProgress();
	OnSequenceProgressChangedEvent.Broadcast(Progress);
}

void ARitualAltar::BroadcastRitualCompleted()
{
	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
}

// ----------------------------------- HELPER FUNCTIONS ---------------------------------------------- //

void ARitualAltar::UpdateTurnData()
{
	// This function can be called on both server and clients
	// On server: updates the replicated CurrentTurnData
	// On clients: called from OnRep functions to update local UI data
	
	FUIRitualData NewTurnData;
	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
	
	// Set expected input if we have valid data
	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
	{
		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
	}
	else
	{
		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
	}
	
	// Always set bIsMyTurn to false here - the widget controller will determine the correct value
	NewTurnData.bIsMyTurn = false;
	
	// On server, update the replicated data if it has changed
	if (HasAuthority())
	{
		// Only update if data has changed to avoid unnecessary replication
		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
		{
			CurrentTurnData = NewTurnData;
			// Broadcast on server for local UI updates (OnRep will handle clients)
			BroadcastTurnDataChanged();
		}
	}
	else
	{
		// On clients, just update the local data and broadcast
		CurrentTurnData = NewTurnData;
		BroadcastTurnDataChanged();
	}
}

void ARitualAltar::UpdateReadyPlayersData()
{
	if (!HasAuthority())
	{
		return;
	}
	
	FRitualReadyPlayersData NewData;
	NewData.TotalPlayers = ParticipatingPlayers.Num();
	NewData.ReadyPlayers = ReadyPlayers.Num();
	
	if (ReadyPlayersData != NewData)
	{
		ReadyPlayersData = NewData;
		// Broadcast on server for local UI updates (OnRep will handle clients)
		BroadcastReadyPlayersChanged();
	}
}

// ----------------------------------- EXISTING FUNCTIONS (UPDATED) ---------------------------------------------- //

void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
{
	// This is now handled by OnRep_ReadyPlayersData, but keeping for backward compatibility
	UpdateReadyPlayersData();
}

void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
{
	if (!HasAuthority() || !RequestingCharacter)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
		return;
	}
	
	// Check if the ritual is in a valid state
	if (CurrentRitualState != EInteractionState::Inactive && 
	    CurrentRitualState != EInteractionState::WaitingForPlayers)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
		return;
	}
	
	// Process the ready request
	ProcessRitualReadyRequest(RequestingCharacter);
}

void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
{
	if (!HasAuthority() || !RequestingCharacter)
	{
		return;
	}
	
	// Check if player is already in the ready list
	if (ReadyPlayers.Contains(RequestingCharacter))
	{
		// Player is already ready, could allow them to un-ready if desired
		ReadyPlayers.Remove(RequestingCharacter);
		UpdateReadyPlayersData();
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
		return;
	}
	
	// Add player to ready list
	ReadyPlayers.Add(RequestingCharacter);
	UpdateReadyPlayersData();
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
	
	// Check if all players are ready
	if (AreAllPlayersReady())
	{
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
		StartRitualCountdown();
	}
}

bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
{
	return ReadyPlayers.Contains(Player);
}

bool ARitualAltar::AreAllPlayersReady() const
{
	// Check if all participating players are in the ready list
	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
	{
		return false;
	}
	
	for (ACharacter* Player : ParticipatingPlayers)
	{
		if (!ReadyPlayers.Contains(Player))
		{
			return false;
		}
	}
	
	return true;
}

void ARitualAltar::StartRitualCountdown()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Set the state to preparing
	CurrentRitualState = EInteractionState::Preparing;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastRitualStateChanged();

	// Generate the ritual input sequence
	GenerateInputSequence();
	
	// Reset countdown value
	StartCountdown = 3;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastCountdownTick();
	
	// Start countdown timer
	GetWorldTimerManager().SetTimer(
		RitualStartCountdownHandle,
		this,
		&ARitualAltar::ProcessCountdownTick,
		1.0f,  // Fire every second
		true   // Looping
	);
}

void ARitualAltar::ProcessCountdownTick()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Decrease countdown
	StartCountdown--;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastCountdownTick();
	
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
	
	if (StartCountdown <= 0)
	{
		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
		ActivateRitual();
	}
}

void ARitualAltar::ActivateRitual()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Set initial active player (from ready list)
	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
	
	// Fallback
	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
	CurrentSequenceIndex = 0;
	CurrentRitualState = EInteractionState::Active;
	
	// Start the input timer (this updates CurrentInputTimer)
	StartInputTimer();

	// Now update turn data with all the new values
	UpdateTurnData();
	
	// Broadcast state change on server for local UI updates (OnRep will handle clients)
	BroadcastRitualStateChanged();
}

void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
{
	// This is now handled by OnRep_StartCountdown, but keeping for backward compatibility
	StartCountdown = CountdownValue;
}

void ARitualAltar::GenerateInputSequence()
{
	if (!HasAuthority())
	{
		return;
	}
	
	InputSequence.Empty();
	
	// Number of inputs scales with the number of players and difficulty
	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
	
	// Get gameplay tags from the native tag manager
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	TArray<FGameplayTag> PossibleInputs;
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
	
	// Generate random sequence
	for (int32 i = 0; i < SequenceLength; ++i)
	{
		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
		InputSequence.Add(PossibleInputs[RandomIndex]);
	}
	
	// Reset sequence index
	
	
}

void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
{
	if (!Character || !HasAuthority())
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
		return;
	}
	
	// Check if the ritual is active
	if (CurrentRitualState != EInteractionState::Active)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"), 
			*Character->GetName(), static_cast<int32>(CurrentRitualState));
		return;
	}
	
	// Check if it's this player's turn
	if (Character != CurrentActivePlayer)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"), 
			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
		return;
	}
	
	// Check if we have a valid input to match against
	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
	{
		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"), 
			CurrentSequenceIndex, InputSequence.Num());
		return;
	}
	
	// Get the expected input for the current step
	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
	
	
	// Check if the input matches
	if (InputTag == ExpectedInput)
	{
		HandleInputSuccess(Character);
	}
	else
	{
		HandleInputFailure(Character);
	}
}

void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
{
	
	if (Character)
	{
		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
		if (ASC)
		{
			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
			FGameplayEventData EventData;
			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
			EventData.Instigator = this;
			EventData.Target = Character;
			
			// Buscar el tag de posición del jugador en el array
			FGameplayTag* PositionTag = nullptr;
			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
			{
				if (Entry.Player == Character)
				{
					PositionTag = &Entry.PositionTag;
					break;
				}
			}
			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
			{
				EventData.OptionalObject = PrimaryAnimMontage;
			} else
			{
				EventData.OptionalObject = SecondaryAnimMontage;
			}
			
			
			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
		}
		
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
	}
}

void ARitualAltar::HandleInputSuccess(ACharacter* Player)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Cancel the input timer
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	
	// Advance to the next input
	CurrentSequenceIndex++;

	// Send success feedback
	Multicast_OnInputSuccess(Player);
	
	// Check if the sequence is complete
	if (CurrentSequenceIndex >= InputSequence.Num())
	{
		// Ritual succeeded
		CurrentRitualState = EInteractionState::Succeeded;
		bRitualCompleted = true;
		bRitualWasSuccessful = true;
		
		// Update turn data with final state
		UpdateTurnData();
		
		// Broadcast state and completion on server for local UI updates
		BroadcastRitualStateChanged();
		BroadcastRitualCompleted();
		
		// Spawn reward and notify
		SpawnReward();
		Multicast_OnRitualSucceeded();
		
		// Clean up
		CleanupRitual();
	}
	else
	{
		// Move to the next player's turn (this updates CurrentActivePlayer)
		AdvanceToNextPlayer();
		
		// Start the input timer (this updates CurrentInputTimer)
		StartInputTimer();
		
		// Now update turn data with all the new values
		UpdateTurnData();
	}
}

void ARitualAltar::HandleInputFailure(ACharacter* Player)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Cancel the input timer
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	
	// Increase corruption
	CorruptionAmount += CorruptionIncreasePerFail;
	// Broadcast corruption change on server for local UI updates
	BroadcastCorruptionChanged();
	
	// DO NOT advance to the next input on failure - only on success
	// CurrentSequenceIndex++; // REMOVED: Failed inputs should not advance the sequence

	// Apply age penalty to the player
	ApplyAgePenalty(Player);
	
	// Send failure feedback
	Multicast_OnInputFailed(Player);
	
	// Check if corruption has reached the maximum
	if (CorruptionAmount >= MaxCorruption)
	{
		// Ritual failed catastrophically
		CurrentRitualState = EInteractionState::FailedCatastrophically;
		bRitualCompleted = true;
		bRitualWasSuccessful = false;
		
		// Update turn data with final state
		UpdateTurnData();
		
		// Broadcast state and completion on server for local UI updates
		BroadcastRitualStateChanged();
		BroadcastRitualCompleted();
		
		// Apply catastrophic penalties to all players
		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
		{
			if (ParticipatingPlayer)
			{
				ApplyAgePenalty(ParticipatingPlayer, true);
			}
		}
		
		// Spawn demon and notify
		SpawnDemon();
		Multicast_OnRitualCatastrophicFail();
		
		// Clean up
		CleanupRitual();
	}
	else
	{
		// Move to the next player's turn (this updates CurrentActivePlayer)
		AdvanceToNextPlayer();
		
		// Start the input timer (this updates CurrentInputTimer)
		StartInputTimer();
		
		// Now update turn data with all the new values
		UpdateTurnData();
	}
}

void ARitualAltar::StartInputTimer()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Calculate the time window for this input, possibly scaling down as the sequence progresses
	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f)); // Up to 50% shorter at the end
	
	// Set the timer value for client display
	CurrentInputTimer = ScaledTimeWindow;
	
	
	// Start the timer
	GetWorldTimerManager().SetTimer(
		InputTimerHandle,
		this,
		&ARitualAltar::OnInputTimerExpired,
		ScaledTimeWindow,
		false
	);
	
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"), 
		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"), 
		CurrentSequenceIndex, InputSequence.Num()-1);
	
	// Log the expected input
	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
	{
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"), 
			*InputSequence[CurrentSequenceIndex].ToString());
	}
}

void ARitualAltar::OnInputTimerExpired()
{
	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
	{
		return;
	}
	
	// If we get here, the player failed to input in time
	if (CurrentActivePlayer)
	{
		HandleInputFailure(CurrentActivePlayer);
	}
	else
	{
		// Fallback in case CurrentActivePlayer is null
		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
		AdvanceToNextPlayer();
		StartInputTimer();
	}
}

void ARitualAltar::AdvanceToNextPlayer()
{
	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
	{
		return;
	}
	
	
	// Find the index of the current active player
	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
	
	// If not found or at the end, wrap around to the first player
	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
	{
		CurrentPlayerIndex = 0;
	}
	else
	{
		CurrentPlayerIndex++;
	}
	
	// Safety check for eligible players
	int32 StartIndex = CurrentPlayerIndex;
	bool bFoundEligiblePlayer = false;
	
	// Loop through players starting from CurrentPlayerIndex until we find an eligible one
	do 
	{
		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
		{
			CurrentActivePlayer = NextPlayer;
			bFoundEligiblePlayer = true;
			break;
		}
		
		// Move to next player
		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
	} 
	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
	
	// If we couldn't find an eligible player, just use the first one as fallback
	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
	{
		CurrentActivePlayer = ParticipatingPlayers[0];
	}
}

bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
{
	if (!Player)
	{
		return false;
	}
	
	// Check if the player is still in a ritual position
	bool bIsInPosition = false;
	for (const ABaseInteractionPosition* Position : InteractionPositions)
	{
		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
		{
			bIsInPosition = true;
			break;
		}
	}
	
	// Check if the player has the OccupyingPosition tag
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
	
	return bIsInPosition && bHasPositionTag;
}


void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Get the player's ASC
	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
	if (!ASC)
	{
		return;
	}
	
	// TODO: Apply aging GameplayEffect
	// This would typically be implemented using a GameplayEffect that increases age
	// The effect class would be defined elsewhere and referenced here
	
	// Pseudo-code:
	// TSubclassOf<UGameplayEffect> AgeEffect = bCatastrophic ? CatastrophicAgeEffectClass : StandardAgeEffectClass;
	// if (AgeEffect)
	// {
	//     FGameplayEffectContextHandle ContextHandle = ASC->MakeEffectContext();
	//     ContextHandle.AddSourceObject(this);
	//     FGameplayEffectSpecHandle SpecHandle = ASC->MakeOutgoingSpec(AgeEffect, 1.0f, ContextHandle);
	//     ASC->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
	// }
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"), 
		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
}

void ARitualAltar::SpawnReward()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// TODO: Implement reward spawning logic
	// This would typically create a special item and add it to inventory
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
}

void ARitualAltar::SpawnDemon()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// TODO: Implement demon spawning logic
	// This would typically spawn an enemy character
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
}

void ARitualAltar::CleanupRitual()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Clear timers
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
	
	// Hide ritual widgets for all participating players
	HideRitualWidgetForAllPlayers();
	
	// Reset ritual-specific variables
	CurrentSequenceIndex = 0;
	InputSequence.Empty();
	CurrentActivePlayer = nullptr;
	ReadyPlayers.Empty();
	
	// Don't reset corruption or state - these should persist for UI feedback
	
	// Reset positions? This depends on design - maybe players stay in position
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up and widgets hidden"));
}

float ARitualAltar::GetCurrentSequenceProgress() const
{
	if (InputSequence.Num() == 0)
	{
		return 0.0f;
	}
	
	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
}

FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
{
	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
	{
		
		return FGameplayTag();
	}
	
	return InputSequence[CurrentSequenceIndex];
}



FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
{
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	switch (Input)
	{
	case ERitualInput::Up:
		return WitchPtGameplayTags.Ritual_Input_Up;
	case ERitualInput::Down:
		return WitchPtGameplayTags.Ritual_Input_Down;
	case ERitualInput::Left:
		return WitchPtGameplayTags.Ritual_Input_Left;
	case ERitualInput::Right:
		return WitchPtGameplayTags.Ritual_Input_Right;
	default:
		return FGameplayTag();
	}
}

ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
{
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
		return ERitualInput::Up;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
		return ERitualInput::Down;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
		return ERitualInput::Left;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
		return ERitualInput::Right;
	
	return ERitualInput::None;
}

void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
{
	if (Character)
	{
		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
		if (ASC)
		{
			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
			FGameplayEventData EventData;
			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
			EventData.Instigator = this;
			EventData.Target = Character;
			
			EventData.OptionalObject = FailedAnimMontage;
			
			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
			
		}
		
		
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
	}
	
	
}



void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
{
	// Print the local role por the RitualAltar and the Player
	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
	if (Player->IsLocallyControlled())
	{
		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
	}
	
	if (!Player || !Position || !HasAuthority())
	{
		return;
	}


	if (Position->IsOccupied())
	{
		//broadcast
		return;
	}
	Position->SetOccupied(Player);
    
	bool bFound = false;
	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
	{
		if (Entry.Player == Player)
		{
			Entry.PositionTag = Position->GetPositionTag();
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		FPlayerPositionTagEntry NewEntry;
		NewEntry.Player = Player;
		NewEntry.PositionTag = Position->GetPositionTag();
		PlayerPositionTags.Add(NewEntry);
	}

	// Add to participating players if not already there
	if (!ParticipatingPlayers.Contains(Player))
	{
		ParticipatingPlayers.Add(Player);
	}
	CurrentRitualState = EInteractionState::WaitingForPlayers;
	
	// Broadcast state change on server for local UI updates (OnRep will handle clients)
	if (HasAuthority())
	{
		BroadcastRitualStateChanged();
	}
	
	// Update ready players data
	UpdateReadyPlayersData();

	// Show ritual widget for the player
	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
	if (PC)
	{
		if (Player->IsLocallyControlled())
		{
			// Local player (either Listen Server or Client)
			PC->LocalShowRitualWidget(this);
		}
		else
		{
			// Remote player - use RPC
			PC->Client_ShowRitualWidget(this);
		}
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Showing ritual widget for player %s"), *Player->GetName());
	}
}

void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
{
	// Client-side feedback for ritual success
	// This would typically play sounds, particle effects, etc.
	
	// Example: Play celebratory effects at altar location
	// UGameplayStatics::PlaySoundAtLocation(this, SuccessSound, GetActorLocation());
	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SuccessParticles, GetActorTransform());
	
	// Set completion status for replication
	bRitualCompleted = true;
	bRitualWasSuccessful = true;
	
	// Hide ritual widgets for all players (since this is multicast, each client handles their own widget)
	if (HasAuthority())
	{
		HideRitualWidgetForAllPlayers();
	}
	
	DestroyAltarPositions();
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback and widgets hidden"));
}

void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
{
	// Client-side feedback for catastrophic failure
	// This would typically play sounds, particle effects, etc.
	
	// Example: Play ominous effects at altar location
	// UGameplayStatics::PlaySoundAtLocation(this, CatastrophicFailSound, GetActorLocation());
	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), CatastrophicFailParticles, GetActorTransform());
	
	// Set completion status for replication
	bRitualCompleted = true;
	bRitualWasSuccessful = false;
	
	// Hide ritual widgets for all players (since this is multicast, each client handles their own widget)
	if (HasAuthority())
	{
		HideRitualWidgetForAllPlayers();
	}
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback and widgets hidden"));
}

float ARitualAltar::GetCorruptionPercentage() const
{
	if (MaxCorruption == 0.0f)
	{
		return 0.0f;
	}
	
	return CorruptionAmount / MaxCorruption;
}

void ARitualAltar::HideRitualWidgetForAllPlayers()
{
	// Hide ritual widget for all participating players
	for (ACharacter* Player : ParticipatingPlayers)
	{
		if (Player)
		{
			AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
			if (PC)
			{
							// Hide widget based on player's network role
			if (Player->IsLocallyControlled())
			{
				// Local player (either Listen Server or Client)
				PC->LocalHideRitualWidget();
			}
			else
			{
				// Remote player - use RPC
				PC->Client_HideRitualWidget();
			}
				
				UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for player %s"), *Player->GetName());
			}
		}
	}
}

void ARitualAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
{
	if (!Player || !HasAuthority())
	{
		return;
	}
	
	// Hide the ritual widget for this specific player
	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
	if (PC)
	{
		// Always try to hide the widget - no need to check visibility since it's not replicated
		if (Player->IsLocallyControlled())
		{
			// Local player (either Listen Server or Client)
			PC->LocalHideRitualWidget();
		}
		else
		{
			// Remote player - use RPC
			PC->Client_HideRitualWidget();
		}
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for leaving player %s"), *Player->GetName());
	}
	
	// Call parent implementation to handle the actual position logic
	Super::UnoccupyPosition(Player, Position);
	
	// Update ready players data if needed
	ReadyPlayers.Remove(Player);
	UpdateReadyPlayersData();
	
	// Check if we should change ritual state
	if (ParticipatingPlayers.Num() == 0)
	{
		// No players left, reset to inactive
		CurrentRitualState = EInteractionState::Inactive;
		BroadcastRitualStateChanged();
		
		// Clear any ongoing ritual data
		CurrentSequenceIndex = 0;
		InputSequence.Empty();
		CurrentActivePlayer = nullptr;
		ReadyPlayers.Empty();
		UpdateReadyPlayersData();
		
		// Clear timers
		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
		GetWorldTimerManager().ClearTimer(InputTimerHandle);
	}
}
</file>

<file path="WitchPT/Private/Item/RitualPosition.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Item/RitualPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h" // Include the Altar header
#include "GameplayTagContainer.h" // For tags
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"
#include "GameplayEffect.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Character/Components/WitchPTMechanicComponent.h" // Required for new RPC calls

// Sets default values
ARitualPosition::ARitualPosition()
{
	// No need to set up replication here - it's handled by the base class
}

void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	DOREPLIFETIME(ARitualPosition, RitualAltar);
}

// void ARitualPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
// {
// 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
//
// 	DOREPLIFETIME(ARitualPosition, bIsOccupied);
// 	DOREPLIFETIME(ARitualPosition, OccupyingCharacter);
// 	// RitualAltar and PositionTag are usually set once and don't need replication unless they can change dynamically
// }

void ARitualPosition::BeginPlay()
{
	Super::BeginPlay();
	
	// Try to find the RitualAltar if it wasn't set in the editor
	
}


void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
	
	// Ritual-specific interaction options
	
	// ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
	//
	// // If no player is occupying the position, let a player take the position
	// if (!IsOccupied() && InteractingCharacterPtr)
	// {
	// 	OptionBuilder.AddDefaultInteraction(
	// 		FText::FromString("Take Position"), // Text for the interaction
	// 		[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
	// 		{
	// 			HandleInteraction(InteractingCharacterPtr);
	// 		}
	// 	);
	// }
	//
	// // Special case: if the character is standing at a position and we're in Inactive state, they can initiate the ritual
	// if (IsOccupied() && RitualAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
	// {
	// 	// Check ritual state
	// 	if (RitualAltar->GetCurrentState() == EInteractionState::Inactive)
	// 	{
	// 		OptionBuilder.AddDefaultInteraction(
	// 			FText::FromString("Start Ritual"), // Text for the interaction
	// 			[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
	// 			{
	// 				if (RitualAltar)
	// 				{
	// 					// Cast to the appropriate start ritual function
	// 					RitualAltar->StartRitual(InteractingCharacterPtr);
	// 				}
	// 			}
	// 		);
	// 	}
	// }
}

ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
{
	if (RitualAltar)
	{
		return RitualAltar;
	}
	return nullptr;
}

bool ARitualPosition::IsOccupied_Implementation()
{
	return bIsOccupied;
}


void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
	Super::HandleInteraction(InteractingCharacter);
	
	if (!InteractingCharacter || !RitualAltar)
	{
		return;
	}
	
}





// void ARitualPosition::SetOccupied(ACharacter* Character)
// {
// 	if (!HasAuthority())
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: no authority"));
// 		return;
// 	}
//
// 	if (!Character)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: invalid character"));
// 		return;
// 	}
//
// 	if (bIsOccupied)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: position %s already occupied by %s"), 
// 			*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
// 		return;
// 	}
//
// 	// Set as occupied
// 	bIsOccupied = true;
// 	OccupyingCharacter = Character;
// 	
// 	// Force OnReps if needed immediately on server
// 	OnRep_IsOccupied();
// 	OnRep_OccupyingCharacter();
// 	
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Occupied by %s"), *GetName(), *Character->GetName());
// }

// Called on the Server by the Altar (or potentially a GA)
// void ARitualPosition::RemoveCharacterFromPosition()
// {
// 	if (!HasAuthority())
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: no authority"));
// 		return;
// 	}
//
// 	if (!bIsOccupied || !OccupyingCharacter)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: position %s is not occupied"), *GetName());
// 		return;
// 	}
//
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removing %s from position %s"), 
// 		*OccupyingCharacter->GetName(), *GetName());
// 	
// 	// Remove the occupying position tag from the character
// 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OccupyingCharacter);
// 	if (ASC)
// 	{
// 		const FWitchPTGameplayTags& gameplayTags = FWitchPTGameplayTags::Get();
// 		
// 		// Remove the State.Ritual.OccupyingPosition tag
// 		// This would typically be done by removing the GE that applied it
// 		
// 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removed State.Ritual.OccupyingPosition tag from %s"), *OccupyingCharacter->GetName());
// 	}
// 	
// 	// Clear state
// 	bIsOccupied = false;
// 	ACharacter* OldCharacter = OccupyingCharacter;
// 	OccupyingCharacter = nullptr;
// 	
// 	// Force OnReps if needed immediately on server
// 	OnRep_IsOccupied();
// 	OnRep_OccupyingCharacter();
// 	
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Unoccupied (was %s)"), 
// 		*GetName(), OldCharacter ? *OldCharacter->GetName() : TEXT("nullptr"));
// }
//
// void ARitualPosition::OnRep_IsOccupied()
// {
// 	// Client-side reaction to occupancy change
// 	// Example: Change material, play sound, update UI attached to this position
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupancy changed to: %s"), 
// 		*GetName(), bIsOccupied ? TEXT("OCCUPIED") : TEXT("VACANT"));
// }
//
// void ARitualPosition::OnRep_OccupyingCharacter()
// {
// 	// Client-side reaction to character change
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupying character changed to: %s"), 
// 		*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
// }
</file>

<file path="WitchPT/Private/Player/WitchPTPlayerController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/WitchPTPlayerController.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "Blueprint/UserWidget.h"
#include "Equipment/WitchPTQuickBarComponent.h"
#include "Input/WitchPTInputComponent.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Item/CauldronAltar.h"
#include "Item/RitualAltar.h"
#include "Item/Ritual/RitualFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Net/UnrealNetwork.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/RitualWidgetController.h"
#include "UI/Widgets/CauldronUserWidget.h"
#include "UI/Widgets/Inventory/InventoryUserWidget.h"
#include "UI/Widgets/Inventory/RitualUserWidget.h"
#include "WitchPT/WitchPT.h"

AWitchPTPlayerController::AWitchPTPlayerController()
{
	bReplicates = true;
	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
	InventoryManager->SetIsReplicated(true);
	QuickBarComponent = CreateDefaultSubobject<UWitchPTQuickBarComponent>("QuickBarComponent");
	QuickBarComponent->SetIsReplicated(true);
	
	
}

void AWitchPTPlayerController::PlayerTick(float DeltaTime)
{
	Super::PlayerTick(DeltaTime);
}

void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
{
	Super::PreProcessInput(DeltaTime, bGamePaused);
}

void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
{
	if (WitchPtAbilitySystemComponent)
	{
		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
	}
	Super::PostProcessInput(DeltaTime, bGamePaused);
}

void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
}
void AWitchPTPlayerController::LocalToggleCauldronMenu()
{
	
	if (bCauldronMenuOpen)
	{
		CloseCauldronMenu();
	}
	else
	{
		OpenCauldronMenu();
	}
}
void AWitchPTPlayerController::OpenInventoryMenu()
{
	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
	{
		WitchPTHUD->ShowInventoryWidget();
	}
}

void AWitchPTPlayerController::CloseInventoryMenu()
{
	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
	{
		WitchPTHUD->HideInventoryWidget();
	}
}

void AWitchPTPlayerController::LocalShowRitualWidget(ABaseInteractableAltar* Altar)
{
	if (!Altar || !IsLocalController())
	{
		UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Invalid altar or not local controller!"));
		return;
	}
	
	if (Altar->IsA<ARitualAltar>())
	{
		// Cast the altar to a ritual altar
		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
		
		// Get the HUD and show the ritual widget
		AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
		if (WitchPTHUD)
		{
			WitchPTHUD->ShowRitualWidget(RitualAltar);
			bRitualWidgetVisible = true;
			UE_LOG(LogTemp, Log, TEXT("LocalShowRitualWidget: Ritual widget shown for altar %s"), *RitualAltar->GetName());
		}
		else
		{
			UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Failed to get WitchPTHUD!"));
		}
	}
}

void AWitchPTPlayerController::LocalHideRitualWidget()
{
	if (!IsLocalController())
	{
		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Not local controller!"));
		return;
	}
	
	// Get the HUD and hide the ritual widget
	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
	if (WitchPTHUD)
	{
		WitchPTHUD->HideRitualWidget();
		bRitualWidgetVisible = false;
		UE_LOG(LogTemp, Log, TEXT("LocalHideRitualWidget: Ritual widget hidden"));
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Failed to get WitchPTHUD!"));
	}
}

bool AWitchPTPlayerController::IsRitualWidgetVisible()
{
	return bRitualWidgetVisible;
}

void AWitchPTPlayerController::OpenCauldronMenu()
{
	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
	if (WitchPTHUD)
	{
		// Find cauldron altar in level (or pass as parameter if available)
		ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(
			UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass())
		);
        
		if (CauldronAltar)
		{
			WitchPTHUD->ShowCauldronWithInventory(CauldronAltar);
			bCauldronMenuOpen = true;
		}
	}
}

void AWitchPTPlayerController::CloseCauldronMenu()
{
	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
	if (WitchPTHUD)
	{
		WitchPTHUD->HideCauldronWithInventory();
		bCauldronMenuOpen = false;
	}
}

void AWitchPTPlayerController::Client_ShowRitualWidget_Implementation(ABaseInteractableAltar* Altar)
{
	// Always call LocalShowRitualWidget - it handles the visibility check locally
	LocalShowRitualWidget(Altar);
}

void AWitchPTPlayerController::Client_HideRitualWidget_Implementation()
{
	// Always call LocalHideRitualWidget - it handles the visibility check locally
	LocalHideRitualWidget();
}

void AWitchPTPlayerController::ShowOverlayWidget()
{
	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
	if (WitchPTHUD)
	{
		WitchPTHUD->ShowOverlayWidget();
	}
}

void AWitchPTPlayerController::HideOverlayWidget()
{
	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
	if (WitchPTHUD)
	{
		WitchPTHUD->HideOverlayWidget();
	}
}

void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
{
	LocalToggleCauldronMenu();
}
void AWitchPTPlayerController::BeginPlay()
{
	Super::BeginPlay();
	check(WitchPtiInputMappingContext)
	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
	if (Subsystem)
	{
		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
	}
	CreateHUDWidget();
}

void AWitchPTPlayerController::SetupInputComponent()
{
	Super::SetupInputComponent();
	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
	
}

void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
{
	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
	const FRotator Rotation = GetControlRotation();
	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);

	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

	if (APawn* ControlledPawn = GetPawn<APawn>())
	{
		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
	}
	
}

void AWitchPTPlayerController::Look(const FInputActionValue& Value)
{
	// input is a Vector2D
	FVector2D LookAxisVector = Value.Get<FVector2D>();

	if (APawn* ControlledPawn = GetPawn<APawn>())
	{
		// add yaw and pitch input to controller
		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
	}
}

void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagPressed(InputTag);
	}
}

void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagReleased(InputTag);
	}
}

void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagHeld(InputTag);
	}
}

void AWitchPTPlayerController::CreateHUDWidget()
{
	if (!IsLocalController()) return;
	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
	if (IsValid(HUDWidget))
	{
		HUDWidget->AddToViewport();
	}
}


UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
{
	if (WitchPtAbilitySystemComponent == nullptr)
	{
		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
	}
	return WitchPtAbilitySystemComponent;
}

// Debug console commands for testing Step 4
void AWitchPTPlayerController::ShowRitualWidgetDebug()
{
	// Find a ritual altar in the level for testing
	ARitualAltar* TestAltar = Cast<ARitualAltar>(UGameplayStatics::GetActorOfClass(this, ARitualAltar::StaticClass()));
	if (TestAltar)
	{
		LocalShowRitualWidget(TestAltar);
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: Showing ritual widget for test altar"));
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: No ritual altar found in level"));
	}
}

void AWitchPTPlayerController::HideRitualWidgetDebug()
{
	LocalHideRitualWidget();
	UE_LOG(LogTemp, Warning, TEXT("[DEBUG] HideRitualWidgetDebug: Hiding ritual widget"));
}

void AWitchPTPlayerController::ToggleRitualWidgetDebug()
{
	if (IsRitualWidgetVisible())
	{
		HideRitualWidgetDebug();
	}
	else
	{
		ShowRitualWidgetDebug();
	}
}
</file>

<file path="WitchPT/Private/Player/WitchPTPlayerState.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/WitchPTPlayerState.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Item/RitualPosition.h"

AWitchPTPlayerState::AWitchPTPlayerState()
{
	SetNetUpdateFrequency(100.f);
	
	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
	AbilitySystemComponent->SetIsReplicated(true);
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);

	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");


}

UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}
</file>

<file path="WitchPT/Private/Subsystems/UIManagerSubsystem.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Subsystems/UIManagerSubsystem.h"

#include "GameplayTagContainer.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/Widgets/WitchPTPrimaryLayout.h"
#include "UI/Widgets/WitchPTUserWidget.h"

AWitchPTHUD* UUIManagerSubsystem::GetWitchPTHUD()
{
	if (ULocalPlayer * LocalPlayer = GetLocalPlayer())
	{
		if (APlayerController* PlayerController = LocalPlayer->GetPlayerController(GetWorld()))
		{
			if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PlayerController->GetHUD()))
			{
				return WitchPTHUD;
			}
		}
	}
	return nullptr;
}

bool UUIManagerSubsystem::RegisterLayout(FGameplayTag LayoutTag, UWitchPTUILayer* InLayer)
{
	if (LayoutTag.IsValid() && InLayer != nullptr)
	{
		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
		{
			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
			{
				return PrimaryLayout->RegisterLayer(LayoutTag, InLayer);
			}
		}
	}
	return false;
}

bool UUIManagerSubsystem::UnRegisterLayout(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
		{
			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
			{
				return PrimaryLayout->UnRegisterLayer(LayerTag);
			}
		}
		
	}
	return false;
}

UUserWidget* UUIManagerSubsystem::PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass)
{
	if (LayerTag.IsValid() && WidgetClass.IsValid())
	{
		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
		{
			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
			{
				return PrimaryLayout->PushContentToLayer(LayerTag, WidgetClass);
				
			}
		}
		
	}
	return nullptr;
}

void UUIManagerSubsystem::PopContentFromLayer(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
		{
			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
			{
				// PrimaryLayout->PopContentFromLayer(LayerTag);
				UE_LOG(LogTemp, Log, TEXT("Popping content from layer: %s"), *LayerTag.ToString());
			}
		}
	}
}

void UUIManagerSubsystem::ClearAllLayers()
{
}

void UUIManagerSubsystem::ClearLayerExcept(FGameplayTag LayerTag)
{
}

void UUIManagerSubsystem::ClearLayer(FGameplayTag LayerTag)
{
}

UWitchPTUserWidget* UUIManagerSubsystem::GetPrimaryLayout()
{
	if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
	{
		if (WitchPTHUD->GetPrimaryLayout())
		{
			return WitchPTHUD->GetPrimaryLayout();
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("Primary Layout is not initialized in WitchPTHUD!"));
		}
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Subsystems/WidgetCommunicatorSubsystem.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Subsystems/WidgetCommunicatorSubsystem.h"

void UWidgetCommunicatorSubsystem::OnItemDragged(UWitchPTInventoryItemInstance* ItemInstance)
{
    OnItemDraggedDelegate.Broadcast(ItemInstance);
}
</file>

<file path="WitchPT/Private/UI/HUD/WitchPTHUD.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/HUD/WitchPTHUD.h"

#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Player/WitchPTPlayerController.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/InventoryWidgetController.h"
#include "UI/WidgetControllers/OverlayWidgetController.h"
#include "UI/WidgetControllers/QuickBarWidgetController.h"
#include "UI/WidgetControllers/RitualWidgetController.h"
#include "UI/Widgets/WitchPTPrimaryLayout.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "UI/Widgets/Inventory/RitualUserWidget.h"

void AWitchPTHUD::BeginPlay()
{
	Super::BeginPlay();
	if (PrimaryLayout == nullptr)
	{
		UUserWidget* PrimaryLayoutInstance = CreateWidget<UUserWidget>(GetOwningPlayerController(), PrimaryLayoutClass);
		PrimaryLayout = Cast<UWitchPTPrimaryLayout>(PrimaryLayoutInstance);
		PrimaryLayout->AddToViewport();
		
	}
}

UWitchPTUserWidget* AWitchPTHUD::GetMenuWidgetByCass(TSubclassOf<UWitchPTUserWidget> WidgetClass)
{
	if (WidgetClass)
	{
		for (UUserWidget* Widget : GameMenuWidgets)
		{
			if (Widget && Widget->IsA(WidgetClass))
			{
				return Cast<UWitchPTUserWidget>(Widget);
			}
		}
	}
	return nullptr;
}

UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
{
	if (OverlayWidgetController == nullptr)
	{
		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
		OverlayWidgetController->SetWidgetControllerParams(WCParams);
		OverlayWidgetController->BindCallbacksToDependencies();
	}
	return OverlayWidgetController;
}

UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
{
	if (CauldronWidgetController == nullptr)
	{
		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
		CauldronWidgetController->SetWidgetControllerParams(WCParams);
		// CauldronWidgetController->BindCallbacksToDependencies();
	}
	return CauldronWidgetController;
}

UQuickBarWidgetController* AWitchPTHUD::SetQuickBarWidgetController(const FWidgetControllerParams& WCParams)
{
	if (QuickBarWidgetController == nullptr)
	{
		QuickBarWidgetController = NewObject<UQuickBarWidgetController>(this, QuickBarWidgetControllerClass);
		QuickBarWidgetController->SetWidgetControllerParams(WCParams);
		QuickBarWidgetController->BindCallbacksToDependencies();
		
	}
	return QuickBarWidgetController;
}

UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
{
	if (InventoryWidgetController == nullptr)
	{
		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
		InventoryWidgetController->SetWidgetControllerParams(WCParams);
		InventoryWidgetController->BindCallbacksToDependencies();
	}
	return InventoryWidgetController;
}

URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
{
	if (RitualWidgetController == nullptr)
	{
		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
		RitualWidgetController->SetWidgetControllerParams(WCParams);
	}
	return RitualWidgetController;
}

void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
{
	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));

	// Initialize Overlay Widget
	UUserWidget* OverlayWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
	OverlayWidget = Cast<UWitchPTUserWidget>(OverlayWidgetInstance);

	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);

	OverlayWidget->SetWidgetController(WidgetController);
	WidgetController->BroadcastInitialValues();
	// OverlayWidgetInstance->AddToViewport();

	// GameMenuWidgets.Add(OverlayWidgetInstance);
	
}

void AWitchPTHUD::InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
	UAttributeSet* AS)
{
	if (RitualWidgetClass)
	{
		
		UUserWidget* RitualWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), RitualWidgetClass);
		RitualWidget = Cast<UWitchPTUserWidget>(RitualWidgetInstance);
		
		if (RitualWidget)
		{
			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
			// Create and set the ritual widget controller
			URitualWidgetController* RitualController = SetRitualWidgetController(WidgetControllerParams);
			RitualWidget->SetWidgetController(RitualController);
			
			// Add to viewport but set visibility to collapsed
			RitualWidgetInstance->AddToViewport();
			GameMenuWidgets.Add(RitualWidgetInstance);
		}
	}
}

void AWitchPTHUD::InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
	UAttributeSet* AS)
{
	if (InventoryWidgetClass && !InventoryWidget)
	{
		UUserWidget* InventoryWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), InventoryWidgetClass);
		InventoryWidget = Cast<UWitchPTUserWidget>(InventoryWidgetInstance);
        
		if (InventoryWidget)
		{
			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
			UInventoryWidgetController* Controller = SetInventoryWidgetController(WidgetControllerParams);
			InventoryWidget->SetWidgetController(Controller);
			InventoryWidgetInstance->AddToViewport();
			GameMenuWidgets.Add(InventoryWidgetInstance);
		}
	}
}

void AWitchPTHUD::InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
{
	if (CauldronWidgetClass && !CauldronWidget)
	{
		UUserWidget* CauldronWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), CauldronWidgetClass);
		CauldronWidget = Cast<UWitchPTUserWidget>(CauldronWidgetInstance);
        
		if (CauldronWidget)
		{
			const FWidgetControllerParams WCParams(PC, PS, ASC, AS);
			UCauldronWidgetController* Controller = SetCauldronWidgetController(WCParams);
			CauldronWidget->SetWidgetController(Controller);
			CauldronWidgetInstance->AddToViewport();
			GameMenuWidgets.Add(CauldronWidgetInstance);
		}
	}
}

void AWitchPTHUD::InitQuickBarWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
	UAttributeSet* AS)
{
	if (QuickBarUserWidgetClass && !QuickBarUserWidget)
	{
		UUserWidget* QuickBarWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), QuickBarUserWidgetClass);
		QuickBarUserWidget = Cast<UWitchPTUserWidget>(QuickBarWidgetInstance);
		if (QuickBarUserWidget)
		{
			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
			UQuickBarWidgetController* Controller = SetQuickBarWidgetController(WidgetControllerParams);
			QuickBarUserWidget->SetWidgetController(Controller);
			
			QuickBarWidgetInstance->AddToViewport();
			GameMenuWidgets.Add(QuickBarWidgetInstance);
		}
	}
	
	
}

void AWitchPTHUD::ToggleGameMenu(TSubclassOf<UWitchPTUserWidget> WidgetClass)
{
	// Find the widget by class
	if (WidgetClass)
	{
		UWitchPTUserWidget* WidgetToToggle = nullptr;
		for (UUserWidget* Widget : GameMenuWidgets)
		{
			if (Widget->IsA(WidgetClass))
			{
				WidgetToToggle = Cast<UWitchPTUserWidget>(Widget);
				break;
			}
		}
		if (!WidgetToToggle) return;
		const bool bIsTargetWidgetAlreadyVisible = WidgetToToggle->IsVisible();
		// Hide all game menu widgets first
		for (auto& MenuWidget : GameMenuWidgets)
		{
			if (MenuWidget && MenuWidget->IsVisible())
			{
				MenuWidget->SetVisibility(ESlateVisibility::Collapsed);
			}
		}
		APlayerController* PC = GetOwningPlayerController();
		
		if (bIsTargetWidgetAlreadyVisible)
		{
			if (PC)
			{
				PC->SetInputMode(FInputModeGameOnly());
				PC->bShowMouseCursor = false;
			}
		} else
		{
			
			WidgetToToggle->SetVisibility(ESlateVisibility::Visible);
			FInputModeGameAndUI InputMode;
			InputMode.SetWidgetToFocus(WidgetToToggle->TakeWidget());
			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
			PC->SetInputMode(InputMode);
			PC->SetShowMouseCursor(true);
		}
	}
	
	
}

void AWitchPTHUD::ShowOverlayWidget()
{
	OverlayWidget->SetVisibility(ESlateVisibility::Visible);
}

void AWitchPTHUD::HideOverlayWidget()
{
	OverlayWidget->SetVisibility(ESlateVisibility::Collapsed);
}

void AWitchPTHUD::ShowRitualWidget(class ARitualAltar* RitualAltar)
{
	if (RitualWidget && RitualWidgetController)
	{
		// Set the ritual altar reference in the controller
		// Note: SetRitualAltar() already calls BindCallbacksToDependencies() and BroadcastInitialValues()
		RitualWidgetController->SetRitualAltar(RitualAltar);
		
		// Use enhanced widget show method if available
		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
		if (RitualUserWidget)
		{
			RitualUserWidget->ShowForRitual(RitualAltar);
		}
		
		// Show the widget
		RitualWidget->SetVisibility(ESlateVisibility::Visible);
		
		// Set input mode to allow UI interaction
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			FInputModeGameAndUI InputMode;
			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
			InputMode.SetHideCursorDuringCapture(false);
			PC->SetInputMode(InputMode);
			PC->bShowMouseCursor = true;
		}
	}
}

void AWitchPTHUD::HideRitualWidget()
{
	if (RitualWidget)
	{
		// Use enhanced widget hide method if available
		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
		if (RitualUserWidget)
		{
			RitualUserWidget->HideFromRitual();
		}
		
		// Hide the widget
		RitualWidget->SetVisibility(ESlateVisibility::Collapsed);
		
		// Clear the ritual altar reference in the controller
		if (RitualWidgetController)
		{
			RitualWidgetController->SetRitualAltar(nullptr);
		}
		
		// Restore game-only input mode
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			PC->SetInputMode(FInputModeGameOnly());
			PC->bShowMouseCursor = false;
		}
	}
}

void AWitchPTHUD::ShowInventoryWidget()
{
	if (InventoryWidget)
	{
		InventoryWidget->SetVisibility(ESlateVisibility::Visible);
        
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			FInputModeGameAndUI InputMode;
			PC->SetInputMode(InputMode);
			PC->SetShowMouseCursor(true);
		}
	}
	
}

void AWitchPTHUD::HideInventoryWidget()
{
	if (InventoryWidget)
	{
		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
        
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			PC->SetInputMode(FInputModeGameOnly());
			PC->SetShowMouseCursor(false);
		}
	}
}

void AWitchPTHUD::ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar)
{
	if (CauldronWidget && InventoryWidget && CauldronWidgetController)
	{
		// Set up cauldron altar reference
		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
		CauldronWidgetController->BindCallbacksToDependencies();
		CauldronWidgetController->BroadcastInitialValues();
        
		// Show both widgets
		CauldronWidget->SetVisibility(ESlateVisibility::Visible);
        
		bCauldronWidgetVisible = true;
        
		// Set input mode
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			FInputModeGameAndUI InputMode;
			PC->SetInputMode(InputMode);
			PC->SetShowMouseCursor(true);
		}
	}
}

void AWitchPTHUD::HideCauldronWithInventory()
{
	if (CauldronWidget && InventoryWidget)
	{
		CauldronWidget->SetVisibility(ESlateVisibility::Collapsed);
		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
        
		bCauldronWidgetVisible = false;
        
		// Clear cauldron altar reference
		if (CauldronWidgetController)
		{
			CauldronWidgetController->SetCauldronAltar(nullptr);
			CauldronWidgetController->UnbindCallbacksFromDependencies();
		}
        
		// Restore game input mode
		APlayerController* PC = GetOwningPlayerController();
		if (PC)
		{
			PC->SetInputMode(FInputModeGameOnly());
			PC->SetShowMouseCursor(false);
		}
	}
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/CauldronWidgetController.h"

#include "Item/CauldronAltar.h"
#include "Item/Components/CauldronCraftComponent.h"

UCauldronWidgetController::UCauldronWidgetController()
{
}

void UCauldronWidgetController::BroadcastInitialValues()
{
	if(CauldronAltar)
	{
		OnBaseIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredient());
		OnBaseIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredientIcon());
		OnPrincipalIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredient());
		OnPrincipalIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredientIcon());
		OnModifierIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredient());
		OnModifierIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredientIcon());
	}
	
}

void UCauldronWidgetController::BindCallbacksToDependencies()
{
	Super::BindCallbacksToDependencies();
	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
	{
		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
	}
}

void UCauldronWidgetController::UnbindCallbacksFromDependencies()
{
	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
	{
		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
	}
}
void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
{
	if (InCauldronAltar != nullptr)
	{
		CauldronAltar = InCauldronAltar;
	}
	
}

void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnBaseIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
{
	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
}

void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
{
	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
}

void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnModifierIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
{
	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/InventoryWidgetController.h"

#include "Equipment/WitchPTEquipmentManagerComponent.h"
#include "GameFramework/Character.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
#include "Player/WitchPTPlayerController.h"
#include "Subsystems/WidgetCommunicatorSubsystem.h"

class UWitchPTEquipmentInstance;
class UWitchPTEquipmentManagerComponent;

void UInventoryWidgetController::BindCallbacksToDependencies()
{
	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
	if (WitchPtPlayerController)
	{
		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
		if (InventoryManager)
		{
			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
			{
				OnItemAddedDelegate.Broadcast(ItemAdded);
			});
			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
			{
				OnItemStackChangedDelegate.Broadcast(ItemAdded);
			});
			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
			{
				OnItemRemovedDelegate.Broadcast(ItemRemoved);
			});
		}
	}
}

void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
{
	if (!ItemInstance)
	{
		return;
	}

	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
	if (!WitchPtPlayerController)
	{
		return;
	}

	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
	if (!InventoryManager)
	{
		return;
	}

	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
	
	// If we only have 1 item left and trying to remove 1 or more, remove the item completely
	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
	{
		InventoryManager->Server_RemoveItemInstance(ItemInstance);
	}
	else
	{
		// Otherwise, reduce the stack count by the requested amount
		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
	}
}

void UInventoryWidgetController::OnItemDragStart(UWitchPTInventoryItemInstance* ItemInstance)
{
	
	if (ULocalPlayer* LocalPlayer = PlayerController->GetLocalPlayer())
	{
		if (UWidgetCommunicatorSubsystem* WidgetCommunicator = LocalPlayer->GetSubsystem<UWidgetCommunicatorSubsystem>())
		{
			WidgetCommunicator->OnItemDragged(ItemInstance);
		}
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("WidgetCommunicatorSubsystem not found in the world!"));
	}
}

void UInventoryWidgetController::EquipItem(UWitchPTInventoryItemInstance* ItemInstance)
{
	if (ItemInstance)
	{
		ACharacter* OwningCharacter = Cast<ACharacter>(PlayerController->GetPawn());
		if (OwningCharacter)
		{
			UWitchPTEquipmentManagerComponent* EquipmentManager = OwningCharacter->FindComponentByClass<UWitchPTEquipmentManagerComponent>();
			if (EquipmentManager)
			{
				UWitchPTEquipmentInstance* EquipmentInstance = EquipmentManager->FindEquipmentByInventoryItem(ItemInstance);
				if (EquipmentInstance)
				{
					EquipmentManager->UnequipItem(EquipmentInstance);
				}
				else
				{
					const UWitchPTInventoryItemFragment* BaseFragment = ItemInstance->FindFragmentByClass(UWitchPTInventoryItemFragment_EquippableItem::StaticClass());
					const UWitchPTInventoryItemFragment_EquippableItem* EquippableFragment = Cast<const UWitchPTInventoryItemFragment_EquippableItem>(BaseFragment);
					EquipmentManager->EquipItem(EquippableFragment->EquipmentDefinition);
				}
			}
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("Owning character is not a valid ACharacter instance."));
		}
	}
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/OverlayWidgetController.h"

#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"

void UOverlayWidgetController::BroadcastInitialValues()
{
	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);

	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
}

void UOverlayWidgetController::BindCallbacksToDependencies()
{
	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnHealthChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxHealthChanged.Broadcast(Data.NewValue);
	});
	
	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnStaminaChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxStaminaChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnAgeChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxAgeChanged.Broadcast(Data.NewValue);
	});

	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
	
	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
	
	// Lambda for message delegates
	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
		// [this] is the capture list, in the case of this lambda, we want to capture this (OverlayWidgetController)
		[this](const FGameplayTagContainer& AssetTags)
	{
		for (const auto& Tag : AssetTags)
		{
			// Declare the tag we want to check. In our case "MessageTag"
			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
			if (Tag.MatchesTag(ParentMessageGameplayTag))
			{
				
					
				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
				OnMessageWidgetRow.Broadcast(*Row);
				
			}
			
		}
	});

	

}
void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
{

}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/QuickBarWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/QuickBarWidgetController.h"

#include "Character/WitchPTCharacter.h"
#include "Equipment/WitchPTEquipmentManagerComponent.h"
#include "Equipment/WitchPTQuickBarComponent.h"
#include "GameFramework/Character.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
#include "Player/WitchPTPlayerController.h"
#include "Subsystems/WidgetCommunicatorSubsystem.h"

void UQuickBarWidgetController::BroadcastInitialValues()
{

}

void UQuickBarWidgetController::BindCallbacksToDependencies()
{
	
	if (AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController))
	{
		
		if (UWitchPTQuickBarComponent* QuickBarComponent = WitchPtPlayerController->GetQuickBarComponent())
		{
			QuickBarComponent->OnActiveSlotChanged.AddDynamic(this, &UQuickBarWidgetController::OnActiveSlotChanged);
		}
	}

	// Bind UI changes from WidgetCommunicatorSubsystem
	
	if (ULocalPlayer* LocalPlayer = PlayerController->GetLocalPlayer())
	{
		if (UWidgetCommunicatorSubsystem* WidgetCommunicator = LocalPlayer->GetSubsystem<UWidgetCommunicatorSubsystem>())
		{
			WidgetCommunicator->OnItemDraggedDelegate.AddDynamic(this, &UQuickBarWidgetController::OnEquipableItemDragStart);
		}
	}
	
}

void UQuickBarWidgetController::AddItemToQuickBarSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* ItemInstance)
{
	if (ItemInstance != nullptr)
	{
		if (AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController))
		{
			WitchPtPlayerController->GetQuickBarComponent()->AddItemToSlot(SlotIndex, ItemInstance);
			
			
		}
	}
	
}

void UQuickBarWidgetController::OnActiveSlotChanged(int32 NewActiveSlotIndex)
{
	OnActiveSlotChangedDelegate.Broadcast(NewActiveSlotIndex);
}

void UQuickBarWidgetController::OnEquipableItemDragStart(const UWitchPTInventoryItemInstance* ItemInstance)
{
	if (ItemInstance != nullptr)
	{
		// Find the equipable fragment in the item instance
		const UWitchPTInventoryItemFragment_EquippableItem* EquipableFragment = 
			Cast<UWitchPTInventoryItemFragment_EquippableItem>(
				ItemInstance->FindFragmentByClass(UWitchPTInventoryItemFragment_EquippableItem::StaticClass()));
		if (EquipableFragment)
		{
			OnEquipableItemDragStartDelegate.Broadcast();
		}
		
		
	}
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "UI/WidgetControllers/RitualWidgetController.h"
#include "Item/RitualAltar.h"
#include "GameFramework/Character.h"
#include "GameFramework/PlayerController.h"
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"

URitualWidgetController::URitualWidgetController()
{
    // Constructor
}

void URitualWidgetController::BroadcastInitialValues()
{
    // Enhanced null safety - only broadcast if we have a valid altar
    if (!IsValid(RitualAltar))
    {
        UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BroadcastInitialValues called with invalid altar"));
        return;
    }
    
    // Broadcast current state
    OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
    
    // Broadcast ready players data
    FRitualReadyPlayersData ReadyPlayersData;
    ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
    ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
    OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
    
    // Broadcast current turn data (processed for local player)
    FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
    FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
    OnTurnDataChanged.Broadcast(ProcessedTurnData);
    
    // Broadcast corruption
    OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
    
    // Broadcast sequence progress
    OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
    
    UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Initial values broadcasted"));
}

void URitualWidgetController::BindCallbacksToDependencies()
{
    // Enhanced null safety - only bind if we have a valid altar
    if (!IsValid(RitualAltar))
    {
        UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BindCallbacksToDependencies called with invalid altar"));
        return;
    }
    
    // Bind to all the dynamic multicast delegates
    RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
    RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
    RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
    RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
    RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
    RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
    RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
    
    UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Callbacks bound to dependencies"));
}

void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
{
    // Enhanced null safety and cleanup
    
    // Unbind any existing callbacks first
    if (IsValid(RitualAltar))
    {
        RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
        RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
        RitualAltar->OnCountdownTickEvent.RemoveAll(this);
        RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
        RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
        RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
        RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
        
        UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound callbacks from previous altar"));
    }
    
    // Assign the new altar
    RitualAltar = InRitualAltar;
    
    // Rebind and broadcast if we have a valid altar
    if (IsValid(RitualAltar))
    {
        BindCallbacksToDependencies();
        BroadcastInitialValues();
        UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Set new ritual altar and bound callbacks"));
    }
    else
    {
        UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Cleared ritual altar reference"));
    }
}

bool URitualWidgetController::IsLocalPlayerActive() const
{
    // Enhanced null safety checks
    if (!IsValid(RitualAltar) || !IsValid(PlayerController))
    {
        return false;
    }
    
    // Get the local character
    ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
    if (!IsValid(LocalCharacter))
    {
        return false;
    }
    
    // Check if this character is the active player
    ACharacter* ActivePlayer = RitualAltar->GetCurrentActivePlayer();
    return IsValid(ActivePlayer) && ActivePlayer == LocalCharacter;
}

FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
{
    FUIRitualData ProcessedData = InTurnData;
    
    // Determine if it's the local player's turn
    ProcessedData.bIsMyTurn = IsLocalPlayerActive();
    
    // If it's not the local player's turn, clear sensitive data
    if (!ProcessedData.bIsMyTurn)
    {
        ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
        ProcessedData.CurrentInputTimeRemaining = 0.0f;
    }
    
    return ProcessedData;
}

// ----------------------------------- CALLBACK HANDLERS ---------------------------------------------- //

void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
{
    OnRitualStateChanged.Broadcast(NewState);
}

void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
{
    OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
}

void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
{
    OnRitualCountdownTick.Broadcast(CountdownValue);
}

void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
{
    // Process the turn data for the local player before broadcasting
    FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
    OnTurnDataChanged.Broadcast(ProcessedTurnData);
    
    // Also broadcast the expected input separately for backward compatibility
    if (ProcessedTurnData.bIsMyTurn)
    {
        OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
    }
    else
    {
        OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
    }
}

void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
{
    OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
}

void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
{
    OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
}

void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
{
    OnRitualCompleted.Broadcast(bWasSuccessful);
    
    // Enhanced cleanup: Unbind all delegates when ritual is completed to prevent memory leaks
    if (IsValid(RitualAltar))
    {
        RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
        RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
        RitualAltar->OnCountdownTickEvent.RemoveAll(this);
        RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
        RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
        RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
        RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
        
        UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound all delegates after ritual completion"));
    }
    
    // Clear the altar reference
    RitualAltar = nullptr;
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/WitchPTWidgetController.h"

void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
{
	PlayerController = WCParams.PlayerController;
	PlayerState = WCParams.PlayerState;
	AbilitySystemComponent = WCParams.AbilitySystemComponent;
	AttributeSet = WCParams.AttributeSet;
}

void UWitchPTWidgetController::BroadcastInitialValues()
{
}

void UWitchPTWidgetController::BindCallbacksToDependencies()
{
}
</file>

<file path="WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/CauldronUserWidget.h"

void UCauldronUserWidget::NativeConstruct()
{
	Super::NativeConstruct();
	// Input mode is now managed by HUD's ShowCauldronWithInventory/HideCauldronWithInventory methods
	// Don't set input mode here as this is called during widget creation, not visibility changes
}

FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	return FReply::Handled();
}
</file>

<file path="WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/Inventory/InventoryUserWidget.h"

FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	
	return FReply::Handled();
}
</file>

<file path="WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "UI/Widgets/Inventory/RitualUserWidget.h"
#include "Item/RitualAltar.h"
#include "Components/Widget.h"

URitualUserWidget::URitualUserWidget(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
    , bIsActiveForRitual(false)
    , CurrentRitualAltar(nullptr)
{
    // Constructor
}

void URitualUserWidget::NativeOnInitialized()
{
    Super::NativeOnInitialized();
    
    // Initialize widget state
    ResetWidgetState();
}

void URitualUserWidget::NativeDestruct()
{
    // Clean up when widget is destroyed
    HideFromRitual();
    
    Super::NativeDestruct();
}

void URitualUserWidget::ShowForRitual(ARitualAltar* Altar)
{
    if (!Altar)
    {
        UE_LOG(LogTemp, Warning, TEXT("[RitualUserWidget] ShowForRitual called with null altar"));
        return;
    }
    
    // If we're already active for a different ritual, reset first
    if (bIsActiveForRitual && CurrentRitualAltar != Altar)
    {
        ResetWidgetState();
    }
    
    // Set up for the new ritual
    CurrentRitualAltar = Altar;
    bIsActiveForRitual = true;
    
    // Call Blueprint implementable event
    OnShownForRitual(Altar);
    
    UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Shown for ritual altar"));
}

void URitualUserWidget::HideFromRitual()
{
    if (!bIsActiveForRitual)
    {
        return; // Already hidden
    }
    
    // Clear state
    bIsActiveForRitual = false;
    ARitualAltar* PreviousAltar = CurrentRitualAltar;
    CurrentRitualAltar = nullptr;
    
    // Call Blueprint implementable event
    OnHiddenFromRitual();
    
    // Reset widget state
    ResetWidgetState();
    
    UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Hidden from ritual"));
}

void URitualUserWidget::ResetWidgetState()
{
    // Reset any internal widget state here
    // This ensures the widget is clean for the next use
    
    // Clear any cached data or temporary state
    // Blueprint implementers can override this for custom reset logic
    
    UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Widget state reset"));
}
</file>

<file path="WitchPT/Private/UI/Widgets/Layer/WitchPTUILayer.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/Layer/WitchPTUILayer.h"

#include "Components/Border.h"

UUserWidget* UWitchPTUILayer::PushContent(TSoftClassPtr<UUserWidget> WidgetClass)
{
	if (WidgetClass.IsValid())
	{
		if(UClass* LoadedClass = WidgetClass.Get())
		{
			UUserWidget* NewUserWidgetInstance = CreateWidget<UUserWidget>(GetOwningPlayer(), LoadedClass);
			PushedWidget = NewUserWidgetInstance;
			CollapseTop();
			Border->ClearChildren();
			Stack.Add(NewUserWidgetInstance);
			Border->AddChild(NewUserWidgetInstance);
			ShowTop();
			UE_LOG(LogTemp, Log, TEXT("Pushing widget: %s"), *NewUserWidgetInstance->GetName());
			return PushedWidget;
		}
	}
	return nullptr;
}

void UWitchPTUILayer::PopContent()
{
	if (!Stack.IsEmpty())
	{
		TopWidget = GetTopScreen();
		if (TopWidget)
		{
			TopWidget->RemoveFromParent();
			// remove the top widget from the stack
			Stack.RemoveAt(Stack.Num() - 1);
			Border->ClearChildren();
			TopWidget = GetTopScreen();
			if (TopWidget)
			{
				TopWidget->SetVisibility(ESlateVisibility::Visible);
				Border->AddChild(TopWidget);
			}
		}
		
	}
}

UUserWidget* UWitchPTUILayer::GetTopScreen() const
{
	if (!Stack.IsEmpty())
	{
		return Stack.Last();
	}
	return nullptr;
}

FText UWitchPTUILayer::GetStackListNames()
{
	// Reverse for to get the names in the correct order
	FString StackNames;
	for (int32 i = Stack.Num() - 1; i >= 0; --i)
	{
		if (Stack[i])
		{
			StackNames += Stack[i]->GetName();
			if (i > 0)
			{
				StackNames += TEXT(", ");
			}
		}
	}
	return FText ::FromString(StackNames);
}

void UWitchPTUILayer::ClearStack()
{
	for (auto & Widget : Stack)
	{
		if (Widget)
		{
			Widget->RemoveFromParent();
		}
	}
	Stack.Empty();
	Border->ClearChildren();
	
	
}

void UWitchPTUILayer::CollapseTop()
{
	if (UUserWidget* TopWidgetToCollapse = GetTopScreen())
	{
		TopWidgetToCollapse->SetVisibility(ESlateVisibility::Collapsed);
	}
}

void UWitchPTUILayer::ShowTop()
{
	if (UUserWidget* TopWidgetToShow = GetTopScreen())
	{
		TopWidgetToShow->SetVisibility(ESlateVisibility::Visible);
	}
}
</file>

<file path="WitchPT/Private/UI/Widgets/PointerWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/PointerWidget.h"
</file>

<file path="WitchPT/Private/UI/Widgets/QuickBarUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/QuickBarUserWidget.h"
</file>

<file path="WitchPT/Private/UI/Widgets/WitchPTPrimaryLayout.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/WitchPTPrimaryLayout.h"

#include "FWitchPTGameplayTags.h"
#include "Subsystems/UIManagerSubsystem.h"
#include "UI/Widgets/Layer/WitchPTUILayer.h"

UWitchPTPrimaryLayout::UWitchPTPrimaryLayout()
{
	
	
}

void UWitchPTPrimaryLayout::NativeConstruct()
{
	Super::NativeConstruct();
	// Register all layers
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	if (GameLayer)
	{
		RegisterLayer(WitchPtGameplayTags.UI_Layer_Game, GameLayer);
	}
	if (GameMenuLayer)
	{
		RegisterLayer(WitchPtGameplayTags.UI_Layer_GameMenu, GameMenuLayer);
	}
	if (MenuLayer)
	{
		RegisterLayer(WitchPtGameplayTags.UI_Layer_Menu, MenuLayer);
	}
	if (ModalLayer)
	{
		RegisterLayer(WitchPtGameplayTags.UI_Layer_Modal, ModalLayer);
	}
	PushInitialScreens();
	
}

bool UWitchPTPrimaryLayout::RegisterLayer(FGameplayTag LayerTag, UWitchPTUILayer* InLayer)
{
	
	if (InLayer != nullptr && LayerTag.IsValid())
	{
		if (Layers.Contains(LayerTag))
		{
			UE_LOG(LogTemp, Warning, TEXT("Layer %s is already registered!"), *LayerTag.ToString());
			return false;
		}
		
		// Register the layer
		Layers.Add(LayerTag, InLayer);
		UE_LOG(LogTemp, Log, TEXT("Registered layer: %s"), *LayerTag.ToString());
		
		return true;
	}
	return false;
}

bool UWitchPTPrimaryLayout::UnRegisterLayer(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		if (UWitchPTUILayer* LayerToRemove = Layers.FindRef(LayerTag))
		{
			LayerToRemove->RemoveFromParent();
			Layers.Remove(LayerTag);
			UE_LOG(LogTemp, Log, TEXT("Unregistered layer: %s"), *LayerTag.ToString());
			return true;
		}
	}
	return false;
}
UUserWidget* UWitchPTPrimaryLayout::PushContentToLayer(FGameplayTag LayerTag,
	TSoftClassPtr<UUserWidget> WidgetClass)
{
	if (LayerTag.IsValid() && WidgetClass.IsValid())
	{
		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
		{
			UUserWidget* PushedWidget = Layer->PushContent(WidgetClass);
			return PushedWidget;
		}
	}
	return nullptr;
}

void UWitchPTPrimaryLayout::PopContentFromLayer(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
		{
			Layer->PopContent();
		}
		
	}
}

void UWitchPTPrimaryLayout::ClearAllLayers()
{
	for (auto& LayerPair : Layers)
	{
		if (LayerPair.Value)
		{
			LayerPair.Value->ClearStack();
		}
	}
}

void UWitchPTPrimaryLayout::ClearAllLayersExcept(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		for (auto& LayerPair : Layers)
		{
			if (LayerPair.Key != LayerTag && LayerPair.Value)
			{
				LayerPair.Value->ClearStack();
			}
		}
	}
}

void UWitchPTPrimaryLayout::ClearLayer(FGameplayTag LayerTag)
{
	if (LayerTag.IsValid())
	{
		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
		{
			Layer->ClearStack();
		}
		
	}
}

void UWitchPTPrimaryLayout::PushInitialScreens()
{
	if (InitialScreens.Num())
	{
		for (auto & ScreenPair : InitialScreens)
		{
			if (ScreenPair.Value.IsValid())
			{
				if (ULocalPlayer* LocalPlayer = GetOwningLocalPlayer())
				{
					if (UUIManagerSubsystem* UIManagerSubsystem = LocalPlayer->GetSubsystem<UUIManagerSubsystem>())
					{
						UIManagerSubsystem->PushContentToLayer(ScreenPair.Key, ScreenPair.Value);
					}
				}
			}
		}
	}
}
</file>

<file path="WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/WitchPTUserWidget.h"

void UWitchPTUserWidget::NativeConstruct()
{
	Super::NativeConstruct();
	// SetVisibility(ESlateVisibility::Collapsed);
}

void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
{
	WidgetController = InWidgetController;
	OnWidgetControllerSet();
}
</file>

<file path="WitchPT/Private/WitchPTAssetManager.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "WitchPTAssetManager.h"

#include "AbilitySystemGlobals.h"
#include "FWitchPTGameplayTags.h"

UWitchPTAssetManager& UWitchPTAssetManager::Get()
{
	check(GEngine)
	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
	return *WitchPtAssetManager;
}

void UWitchPTAssetManager::StartInitialLoading()
{
	Super::StartInitialLoading();
	FWitchPTGameplayTags::InitializeGameplayTags();
	/**
	 * 
	 */
	// TODO: What is this function for? 

	UAbilitySystemGlobals::Get().InitGlobalData();
	
}
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "AT_WaitForPlacementLocation_SLT.generated.h"

// Delegado para enviar la información de la ubicación y la normal
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);

/**
 * Task que realiza un line trace continuo para encontrar ubicaciones válidas para colocar el caldero.
 * Similar a UAT_WaitForInteractable_SLT pero devuelve información de ubicación y normal de la superficie.
 */
UCLASS()
class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
{
	GENERATED_BODY()
	
public:
	// Constructor
	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);

	// Crea y configura la tarea
	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
		UGameplayAbility* OwningAbility,
		float TraceDistance = 500.0f,
		float TraceRadius = 10.0f,
		bool TraceComplex = false,
		bool bIgnoreBlockingHits = false,
		bool bShowDebug = false);

	// Delegado llamado cuando se encuentra una ubicación válida
	UPROPERTY(BlueprintAssignable)
	FPlacementLocationFound OnLocationFound;

	// Se llama cuando se activa la tarea
	virtual void Activate() override;

	// Se llama cuando se termina la tarea
	virtual void OnDestroy(bool bInOwnerFinished) override;

private:
	// Realiza el line trace para encontrar ubicaciones
	void PerformTrace();

	// Realiza un line trace cada tick para actualizar la ubicación
	void TickTask(float DeltaTime);

	// Temporizador para realizar el trace
	FTimerHandle TraceTimerHandle;

	// Distancia del trace
	float TraceDistance;

	// Radio del trace (para spheretrace)
	float TraceRadius;

	// Si se debe considerar geometría compleja
	bool bTraceComplex;

	// Si se deben ignorar hits bloqueantes
	bool bIgnoreBlockingHits;

	// Si se debe mostrar debug visual
	bool bShowDebug;

	// Última ubicación de hit encontrada
	FVector LastHitLocation;

	// Última normal encontrada
	FVector LastHitNormal;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "GA_CauldronPlace.generated.h"

class ACauldronAltar;

/**
 * Gameplay Ability que confirma la colocación del caldero en su posición actual
 * Se activa con el botón primario durante la previsualización
 */
UCLASS()
class WITCHPT_API UGA_CauldronPlace : public UGameplayAbility
{
    GENERATED_BODY()
    
public:
    UGA_CauldronPlace();
    
    // Configuración de la habilidad
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
    
protected:
    // Encuentra el caldero que está en modo previsualización
    ACauldronAltar* FindPreviewingCauldron();
};
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "GA_CauldronPlacementPreview.generated.h"

class ACauldronAltar;

/**
 * Gameplay Ability que permite previsualizar la colocación del caldero
 * Realiza un line trace continuo y actualiza la posición del caldero en tiempo real.
 */
UCLASS()
class WITCHPT_API UGA_CauldronPlacementPreview : public UGameplayAbility
{
    GENERATED_BODY()
    
public:
    UGA_CauldronPlacementPreview();
    
    // Configuración de la habilidad
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
    virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;
    
    // Función de entrada para confirmar la colocación
    UFUNCTION()
    void OnConfirmPlacement();
    
    // Función de entrada para cancelar la colocación
    UFUNCTION()
    void OnCancelPlacement();
    
    // Función llamada cuando se encuentra una nueva ubicación válida
    UFUNCTION()
    void OnLocationFound(FVector HitLocation, FVector HitNormal);
    
protected:
    // Encuentra el caldero que el jugador está llevando
    ACauldronAltar* FindCarriedCauldron();
    
    // Distancia máxima del line trace
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    float TraceDistance = 500.0f;
    
    // Radio del trace (para sphere trace)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    float TraceRadius = 10.0f;
    
    // Si se debe usar trace complejo
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    bool bTraceComplex = false;
    
    // Si se deben mostrar los trazos de debug
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    bool bShowDebug = true;
    
private:
    // Referencia al caldero que se está colocando
    UPROPERTY()
    ACauldronAltar* CauldronAltar;
};
</file>

<file path="WitchPT/Public/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTGameplayAbility.h"
#include "GA_QuickBarSlots.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UGA_QuickBarSlots : public UWitchPTGameplayAbility
{
	GENERATED_BODY()
	UGA_QuickBarSlots();
public:
};
</file>

<file path="WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "WitchPTGameplayAbility.generated.h"

/**
 * 
 */
UENUM(BlueprintType)
enum class EPrototypeAbilityActivationPolicy: uint8
{
	// Try to activate the ability when the input is triggered.
	OnInputTriggered,

	// Continually try to activate the ability while the input is active.
	WhileInputActive,

	// Try to activate the ability when an avatar is assigned.
	OnSpawn,
	
	OnTriggeredEvent
};
UCLASS()
class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
{
	GENERATED_BODY()
public:
	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
	UPROPERTY(EditDefaultsOnly, Category="Input")
	FGameplayTag StartupInputTag;
	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
protected:

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
	EPrototypeAbilityActivationPolicy ActivationPolicy;

	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "AbilityTask_GrantNearbyInteraction.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
{
	GENERATED_UCLASS_BODY()

	
	virtual void Activate() override;
	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;

	/** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */
	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);

private:
	virtual void OnDestroy(bool AbilityEnded) override;

	void QueryInteractables();
	float InteractionScanRange = 100;
	float InteractionScanRate = 0.100;
	FTimerHandle QueryTimerHandle;

	// Cache para habilidades de interacción rápida
	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
	
	// Cache para habilidades de interacción mantenida
	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;

};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "Engine/CollisionProfile.h"
#include "InteractionOption.h"
#include "AbilityTask_WaitForInteractable.generated.h"

/**
 * 
 */
class AActor;
class IInteractableTarget;
class UObject;
class UWorld;
struct FCollisionQueryParams;
struct FHitResult;
struct FInteractionQuery;
template <typename InterfaceType> class TScriptInterface;
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);

UCLASS(Abstract)
class UAbilityTask_WaitForInteractable : public UAbilityTask
{
	GENERATED_UCLASS_BODY()

public:
	UPROPERTY(BlueprintAssignable)
	FInteractableObjectsChangedEvent InteractableObjectsChanged;

protected:

	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);

	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;

	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);

	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);

	ECollisionChannel TraceProfile;

	// Does the trace affect the aiming pitch
	bool bTraceAffectsAimPitch = true;

	TArray<FInteractionOption> CurrentOptions;
	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractionQuery.h"
#include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
#include "AT_WaitForInteractable_SLT.generated.h"
struct FCollisionProfileName;

class UGameplayAbility;
class UObject;
struct FFrame;
/**
 * 
 */
UCLASS()
class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
{
	GENERATED_UCLASS_BODY()

	virtual void Activate() override;

	/** Wait until we trace new set of interactables.  This task automatically loops. */
	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);

private:

	virtual void OnDestroy(bool AbilityEnded) override;

	void PerformTrace();

	UPROPERTY()
	FInteractionQuery InteractionQuery;

	UPROPERTY()
	FGameplayAbilityTargetingLocationInfo StartLocation;

	float InteractionScanRange = 100;
	float InteractionScanRate = 0.100;
	bool bShowDebug = false;

	FTimerHandle TimerHandle;
	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractionOption.h"
#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
#include "GameplayAbility_Interact.generated.h"

class UObject;
struct FFrame;
struct FGameplayAbilityActorInfo;
struct FGameplayEventData;

// Delegado para notificar cuando se completa una interacción
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);

/**
 * 
 */
UCLASS(Abstract)
class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
{
	GENERATED_BODY()
	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	UFUNCTION(BlueprintCallable)
	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
	
	// Método para interacción de pulsación rápida
	UFUNCTION(BlueprintCallable)
	void TriggerInteraction();
	
	// Método para interacción manteniendo pulsado
	UFUNCTION(BlueprintCallable)
	void TriggerHoldInteraction();
	
	// Método llamado cuando se presiona el botón de interacción
	UFUNCTION(BlueprintCallable, Category = "Interaction")
	void OnInteractionButtonPressed();
	
	// Método llamado cuando se suelta el botón de interacción
	UFUNCTION(BlueprintCallable, Category = "Interaction")
	void OnInteractionButtonReleased();
	
	// Método llamado cuando se cumple el tiempo de interacción mantenida
	UFUNCTION()
	void OnHoldInteractionTimeElapsed();
    
    // Método que verifica si el objeto bajo el trace sigue siendo el mismo
    UFUNCTION()
    void CheckInteractionValidity();
    
    // Método que cancela una interacción en curso
    UFUNCTION(BlueprintCallable, Category = "Interaction")
    void CancelCurrentInteraction();
    
    // Método de seguridad que se activa si una interacción dura demasiado tiempo
    UFUNCTION()
    void OnMaxInteractionTimeElapsed();

	// Delegado que se dispara cuando se completa una interacción
	UPROPERTY(BlueprintAssignable, Category = "Interaction")
	FOnInteractionComplete OnInteractionComplete;

	// Delegado que se dispara cuando se completa una interacción mantenida
	UPROPERTY(BlueprintAssignable, Category = "Interaction")
	FOnInteractionComplete OnHoldInteractionComplete;
    
    // Delegado que se dispara cuando se cancela una interacción
    UPROPERTY(BlueprintAssignable, Category = "Interaction")
    FOnInteractionComplete OnInteractionCancelled;

protected:

	UPROPERTY(BlueprintReadWrite)
	TArray<FInteractionOption> CurrentOptions;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
	float InteractionScanRate = 0.1f;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
	float InteractionScanRange = 500;
	
	// Tiempo mínimo que debe mantenerse presionado el botón para considerar una interacción mantenida
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
	float HoldInteractionTime = 1.0f;
    
    // Frecuencia para verificar si el objeto interactuable sigue siendo válido durante una interacción mantenida
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
    float ValidityCheckRate = 0.1f;
    
    // Tiempo máximo que puede durar cualquier interacción antes de ser cancelada automáticamente
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
    float MaxInteractionTime = 10.0f;
	
	// Temporizador para detectar interacción mantenida
	FTimerHandle HoldInteractionTimerHandle;
    
    // Temporizador para verificar la validez del objeto interactuable
    FTimerHandle ValidityCheckTimerHandle;
    
    // Temporizador de seguridad para forzar el reinicio después de un tiempo máximo
    FTimerHandle MaxInteractionTimeTimerHandle;
	
	// Estado del botón de interacción (presionado o no)
	bool bIsInteractionButtonHeld = false;
	
	// Tiempo en que se inició la pulsación
	float InteractionStartTime = 0.0f;
	
	// Indica si ya se disparó una interacción mantenida para la pulsación actual
	bool bHoldInteractionFired = false;
    
    // Guarda el objeto con el que se inició la interacción para compararlo
    TScriptInterface<IInteractableTarget> InitialInteractableTarget;

	UPROPERTY(EditDefaultsOnly)
	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;

	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.h"
#include "IInteractableTarget.generated.h"

struct FInteractionQuery;

/**  */
class FInteractionOptionBuilder
{
public:
	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
		: Scope(InterfaceTargetScope)
		, Options(InteractOptions)
	{
	}

	void AddInteractionOption(const FInteractionOption& Option)
	{
		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
		OptionEntry.InteractableTarget = Scope;
	}

private:
	TScriptInterface<IInteractableTarget> Scope;
	TArray<FInteractionOption>& Options;
};

/**  */
UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
class UInteractableTarget : public UInterface
{
	GENERATED_BODY()
};


class IInteractableTarget
{
	GENERATED_BODY()

public:
	/**  */
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;

	/**  */
	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
	
	/**
	 * Determina si este objeto interactuable soporta interacción mantenida
	 * @return Verdadero si el objeto soporta interacción mantenida, falso en caso contrario
	 */
	virtual bool SupportsHoldInteraction() const { return false; }
	
	/**
	 * Obtiene la habilidad que se debe activar cuando se realiza una interacción mantenida
	 * @return El handle de la habilidad para interacción mantenida
	 */
	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h">
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.generated.h"

class IInteractableTarget;
// class UUserWidget;

/**  */
USTRUCT(BlueprintType)
struct FInteractionOption
{
	GENERATED_BODY()

public:
	/** The interactable target */
	UPROPERTY(BlueprintReadWrite)
	TScriptInterface<IInteractableTarget> InteractableTarget;

	/** Simple text the interaction might return */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText Text;

	/** Simple sub-text the interaction might return */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText SubText;

	// METHODS OF INTERACTION
	//--------------------------------------------------------------

	// 1) Place an ability on the avatar that they can activate when they perform interaction.

	/** The ability to grant the avatar when they get near interactable objects. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;

	// - OR -

	// 2) Allow the object we're interacting with to have its own ability system and interaction ability, that we can activate instead.

	/** The ability system on the target that can be used for the TargetInteractionHandle and sending the event, if needed. */
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;

	/** The ability spec to activate on the object for this option. */
	UPROPERTY(BlueprintReadOnly)
	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
	
	/** Indica si esta opción de interacción soporta interacción mantenida */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	bool bSupportsHoldInteraction = false;
	
	/** La habilidad a activar cuando se mantiene presionado el botón de interacción */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
	
	/** La habilidad para interacción mantenida en el objetivo */
	UPROPERTY(BlueprintReadOnly)
	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;

	// UI
	//--------------------------------------------------------------

	/** The widget to show for this kind of interaction. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TSoftClassPtr<UUserWidget> InteractionWidgetClass;

	//--------------------------------------------------------------

public:
	FORCEINLINE bool operator==(const FInteractionOption& Other) const
	{
		return InteractableTarget == Other.InteractableTarget &&
			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
			TargetAbilitySystem == Other.TargetAbilitySystem &&
			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
			// InteractionWidgetClass == Other.InteractionWidgetClass &&
			Text.IdenticalTo(Other.Text) &&
			SubText.IdenticalTo(Other.SubText);
	}

	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
	{
		return !operator==(Other);
	}

	FORCEINLINE bool operator<(const FInteractionOption& Other) const
	{
		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
	}
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionQuery.generated.h"


/**  */
USTRUCT(BlueprintType)
struct FInteractionQuery
{
	GENERATED_BODY()

public:
	/** The requesting pawn. */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<AActor> RequestingAvatar;

	/** Allow us to specify a controller - does not need to match the owner of the requesting avatar. */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<AController> RequestingController;

	/** A generic UObject to shove in extra data required for the interaction */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<UObject> OptionalObjectData;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "InteractionStatics.generated.h"

template <typename InterfaceType> class TScriptInterface;
class AActor;
class IInteractableTarget;
class UObject;

/**
 * 
 */
UCLASS()
class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UInteractionStatics();

public:
	UFUNCTION(BlueprintCallable)
	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);

	UFUNCTION(BlueprintCallable)
	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "WitchPTAbilitySystemComponent.generated.h"

DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& /* Asset tags that the GE have*/)
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
{
	GENERATED_BODY()

public:
	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
	
	void AbilityInputTagPressed(const FGameplayTag& InputTag);
	void AbilityInputTagHeld(const FGameplayTag& InputTag);
	void AbilityInputTagReleased(const FGameplayTag& InputTag);
	void AbilityActorInfoHaveBeenSet();

	FEffectAssetTags OnEffectAssetTags;
	
	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
	
	bool bCharacterAbilitiesGiven = false;
	bool bStartupEffectsApplied = false;

	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;

	// Handles to abilities that had their input pressed this frame.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;

	// Handles to abilities that had their input released this frame.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;

	
	// Handles to abilities that have their input held.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;

protected:
	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
	UFUNCTION(Client, Reliable)
	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);

};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemGlobals.h"
#include "WitchPTAbilitySystemGlobals.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTAbilitySystemLibrary.generated.h"

class IMechanicsInterface;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "AttributeSet.h"
#include "WitchPTAttributeSet.generated.h"

/**
 * 
 */
// Macro for attribute accessors
// Functions: Getter, Setter, Initializer. The initializer set the base and current value!
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

// This syntax is a fucking nightmare, but...ok
UCLASS()
class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	UWitchPTAttributeSet();
	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;


	/**
	 * Vital Attributes
	 */
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
	FGameplayAttributeData Age;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
	FGameplayAttributeData MaxAge;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
	FGameplayAttributeData Health;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
	FGameplayAttributeData MaxHealth;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
	FGameplayAttributeData Strength;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
	FGameplayAttributeData MaxStrength;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
	FGameplayAttributeData Mana;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
	FGameplayAttributeData MaxMana;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
	FGameplayAttributeData Stamina;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
	FGameplayAttributeData MaxStamina;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
	FGameplayAttributeData SpeedMultiplier;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
	FGameplayAttributeData MaxSpeedMultiplier;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MaxMoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MinMoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);

	


	// Replication functions
	UFUNCTION()
	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
	UFUNCTION()
	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
	UFUNCTION()
	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
	UFUNCTION()
	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
	UFUNCTION()
	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
	UFUNCTION()
	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
	UFUNCTION()
	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
	UFUNCTION()
	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
	UFUNCTION()
	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
	UFUNCTION()
	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
	UFUNCTION()
	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
	UFUNCTION()
	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
	UFUNCTION()
	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
	UFUNCTION()
	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
	UFUNCTION()
	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
};
</file>

<file path="WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "WitchPTCharacterMovementComponent.generated.h"


UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
{
	GENERATED_BODY()

public:
	UWitchPTCharacterMovementComponent();
	uint8 RequestToStartSprinting : 1;
	uint8 RequestToStartADS : 1;
	virtual float GetMaxSpeed() const override;
	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
	// Sprint
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	void StartSprinting();
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	void StopSprinting();
	

	// Aim Down Sights
	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
	void StartAimDownSights();
	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
	void StopAimDownSights();
};
</file>

<file path="WitchPT/Public/Character/Components/WitchPTMechanicComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "Item/MechanicsInterface.h"
#include "WitchPTMechanicComponent.generated.h"

class ACauldronAltar;

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	UWitchPTMechanicComponent();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	
	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
	virtual void RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
	virtual void RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar) override;
	
	UFUNCTION(Server, Reliable)
	void Server_RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
	UFUNCTION(Server, Reliable)
	void Server_RequestCraftPotion(ACauldronAltar* TargetAltar);
	
	

	
	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
	
};
</file>

<file path="WitchPT/Public/Character/WitchPTCharacter.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTCharacterBase.h"
#include "Item/CauldronAltar.h"
#include "Item/MechanicsInterface.h"
#include "Blueprint/UserWidget.h"
#include "Components/WidgetComponent.h" // Necesitas un Widget Component
#include "UObject/ConstructorHelpers.h"
#include "WitchPTCharacter.generated.h"

class UWitchPTEquipmentManagerComponent;
class UWitchPTMechanicComponent;
class ACauldronAltar;
class ARitualPosition;

UCLASS()
class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
	virtual void PossessedBy(AController* NewController) override;
	virtual void OnRep_PlayerState() override;

	UWitchPTEquipmentManagerComponent* GetEquipmentManager() const { return EquipmentManagerComponent; }
	
	
	virtual void InitAbilityActorInfo() override;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UWitchPTEquipmentManagerComponent> EquipmentManagerComponent;
	

};
</file>

<file path="WitchPT/Public/Character/WitchPTCharacterBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemInterface.h"
#include "GameFramework/Character.h"
#include "WitchPTCharacterBase.generated.h"

class UWitchPTAbilitySystemComponent;
class UWitchPTAttributeSet;
class UGameplayAbility;
class UGameplayEffect;
class UAttributeSet;

UCLASS(Abstract)
class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);

	// Getter for ASC Main Components
	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }

protected:
	UPROPERTY()
	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
	UPROPERTY()
	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
	TSubclassOf<UGameplayEffect> DefaultAttributes;
	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;

	// These effects are only applied one time on startup
	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;

	virtual void InitializeDefaultAttributes();
	
	virtual void GrantStartupAbilities();

	virtual void AddStartupEffects();

	virtual void InitAbilityActorInfo();
private:
	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);



public:
	/**
	* Getters for attributes from GDAttributeSetBase
	**/
	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetHealth() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxHealth() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetStamina() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxStamina() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetAge() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxAge() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMana() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxMana() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetSpeedMultiplier() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMoveSpeed() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxMoveSpeed() const;

	

	

	

};
</file>

<file path="WitchPT/Public/Character/WitchPTEnemy.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTCharacterBase.h"
#include "WitchPTEnemy.generated.h"

UCLASS()
class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
};
</file>

<file path="WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "WitchPTEquipmentDefinition.generated.h"

class UWitchPTEquipmentInstance;
class UGameplayAbility;

USTRUCT()
struct FWitchPTEquipmentActorToSpawn
{
	GENERATED_BODY()
	FWitchPTEquipmentActorToSpawn() {};

	UPROPERTY(EditAnywhere, Category=Equipment)
	TSubclassOf<AActor> ActorToSpawn;

	UPROPERTY(EditAnywhere, Category=Equipment)
	FName AttachSocket;

	UPROPERTY(EditAnywhere, Category=Equipment)
	FTransform AttachTransform;
};


/**
 * UWitchPTEquipmentDefinition
 * Definition of a piece of equipment that can be applied to a pawn
 */
UCLASS(Blueprintable, BlueprintType)
class WITCHPT_API UWitchPTEquipmentDefinition : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// Class to spawn for equipment instance
	UPROPERTY(EditDefaultsOnly, Category=Equipment)
	TSubclassOf<UWitchPTEquipmentInstance> InstanceType;

	UPROPERTY(EditDefaultsOnly, Category=Equipment)
	TArray<TSubclassOf<UGameplayAbility>> AbilitiesToGrant;

	UPROPERTY(EditDefaultsOnly, Category=Equipment)
	TArray<FWitchPTEquipmentActorToSpawn> ActorsToSpawn;
};
</file>

<file path="WitchPT/Public/Equipment/WitchPTEquipmentInstance.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "Net/UnrealNetwork.h"
#include "WitchPTEquipmentInstance.generated.h"

struct FWitchPTEquipmentActorToSpawn;
/**
 * 
 */
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UWitchPTEquipmentInstance : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	

	// Equipment lifecycle
	// UObject Interface
	virtual bool IsSupportedForNetworking() const override { return true; }
	virtual UWorld* GetWorld() const override final;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// End of UObject Interface
	virtual void SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn);
	virtual void DestroyEquipmentActors();
	virtual void OnEquipped();
	virtual void OnUnequipped();

	UFUNCTION(BlueprintPure, Category=Equipment)
	APawn* GetPawn() const;
	UFUNCTION(BlueprintPure, Category=Equipment)
	UObject* GetInstigator() const { return Instigator; }

	void SetInstigator(UObject* InInstigator) { Instigator = InInstigator; }
protected:
	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
	void K2_OnEquipped();
    
	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
	void K2_OnUnequipped();

private:
	UPROPERTY(ReplicatedUsing=OnRep_Instigator)
	TObjectPtr<UObject> Instigator;
	
	UPROPERTY(Replicated)
	TArray<TObjectPtr<AActor>> SpawnedActors;

	// Add rep notify:
	UFUNCTION()
	void OnRep_Instigator();
	
};
</file>

<file path="WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayAbilitySpecHandle.h"
#include "Components/ActorComponent.h"
#include "Net/Serialization/FastArraySerializer.h"
#include "WitchPTEquipmentManagerComponent.generated.h"


class UWitchPTEquipmentManagerComponent;
class UWitchPTInventoryItemInstance;
class UAbilitySystemComponent;
class UWitchPTEquipmentDefinition;
class UWitchPTEquipmentInstance;

DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemEquipped, UWitchPTEquipmentInstance*);
DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemUnequipped, UWitchPTEquipmentInstance*);

USTRUCT()
struct FEquipmentAbilityHandles
{
	GENERATED_BODY()
	TArray<FGameplayAbilitySpecHandle> GrantedHandles;
};

USTRUCT(BlueprintType)
struct FWitchPTEquipmentEntry: public FFastArraySerializerItem
{
	GENERATED_BODY()
	FWitchPTEquipmentEntry() {};

	UPROPERTY()
	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;

	UPROPERTY()
	TObjectPtr<UWitchPTEquipmentInstance> Instance = nullptr;

	FEquipmentAbilityHandles AbilityHandles;
};

USTRUCT(BlueprintType)
struct FWitchPTEquipmentList : public FFastArraySerializer
{
	GENERATED_BODY()

	FWitchPTEquipmentList() : OwnerComponent(nullptr) {}
	FWitchPTEquipmentList(UActorComponent* InOwnerComponent) : OwnerComponent(InOwnerComponent) {}

	//~FFastArraySerializer contract
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTEquipmentEntry, FWitchPTEquipmentList>(Entries, DeltaParms, *this);
	}

	

	UWitchPTEquipmentInstance* AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
	void RemoveEntry(UWitchPTEquipmentInstance* Instance);

private:
	UAbilitySystemComponent* GetAbilitySystemComponent() const;

	UPROPERTY()
	TArray<FWitchPTEquipmentEntry> Entries;

	UPROPERTY(NotReplicated)
	TObjectPtr<UActorComponent> OwnerComponent;
    
	friend UWitchPTEquipmentManagerComponent;
};

// Add template specialization:
template<>
struct TStructOpsTypeTraits<FWitchPTEquipmentList> : public TStructOpsTypeTraitsBase2<FWitchPTEquipmentList>
{
	enum { WithNetDeltaSerializer = true };
};


UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTEquipmentManagerComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UWitchPTEquipmentManagerComponent();

	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	//~UActorComponent interface
	//virtual void EndPlay() override;
	virtual void InitializeComponent() override;
	virtual void UninitializeComponent() override;
	virtual void ReadyForReplication() override;
	//~End of UActorComponent interface

	UFUNCTION(BlueprintCallable, Category="Equipment")
	void EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);

	UFUNCTION(BlueprintCallable, Category="Equipment")
	void UnequipItem(UWitchPTEquipmentInstance* ItemInstance);

	UFUNCTION(Server, Reliable)
	void Server_EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);

	UFUNCTION(Server, Reliable)
	void Server_UnequipItem(UWitchPTEquipmentInstance* ItemInstance);
	

	UFUNCTION(BlueprintPure, Category="Equipment")
	bool IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const;

	UFUNCTION(BlueprintPure, Category="Equipment")
	UWitchPTEquipmentInstance* FindEquipmentByInventoryItem(UWitchPTInventoryItemInstance* InventoryItem) const;
	

	UFUNCTION(BlueprintCallable, Category="Equipment")
	void PrintEquippedItems();

	FOnItemEquipped OnItemEquipped;
	FOnItemUnequipped OnItemUnequipped;

protected:
	UPROPERTY(Replicated)
	FWitchPTEquipmentList EquipmentList;

	// Add after EquippedItems:
	UPROPERTY()
	TMap<TObjectPtr<UWitchPTEquipmentInstance>, FEquipmentAbilityHandles> EquipmentAbilities;

private:
	UAbilitySystemComponent* GetAbilitySystemComponent() const;


};
</file>

<file path="WitchPT/Public/Equipment/WitchPTQuickBarComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "WitchPTQuickBarComponent.generated.h"


class UWitchPTInventoryItemInstance;
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnActiveSlotChangedSignature, int32, NewActiveSlotIndex);
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTQuickBarComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UWitchPTQuickBarComponent();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	UFUNCTION(Server, Reliable, BlueprintCallable, Category="QuickBar")
	void SetActiveSlotIndex(int32 NewIndex);

	virtual void BeginPlay() override;

	UFUNCTION()
	void AddItemToSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* Item);

	// --------------------- Quick Bar Delegates ---------------------
	FOnActiveSlotChangedSignature OnActiveSlotChanged;

private:
	void EquipItemInSlot();
	void UnequipItemInSlot();

protected:
	UPROPERTY()
	int32 NumSlots = 4;

	UFUNCTION()
	void OnRep_Slots();

	UFUNCTION()
	void OnRep_ActiveSlotIndex();

private:
	UPROPERTY(ReplicatedUsing=OnRep_Slots, VisibleAnywhere, Category="QuickBar")
	TArray<TObjectPtr<UWitchPTInventoryItemInstance>> Slots;
	
	UPROPERTY(ReplicatedUsing=OnRep_ActiveSlotIndex, VisibleAnywhere, Category="QuickBar")
	int32 ActiveSlotIndex = -1; // -1 means no active slot

	UPROPERTY(VisibleAnywhere, Category="QuickBar")
	TObjectPtr<UWitchPTInventoryItemInstance> EquippedItem;
	
};
</file>

<file path="WitchPT/Public/FWitchPTGameplayTags.cpp">
#include "FWitchPTGameplayTags.h"

#include "GameplayTagsManager.h"

FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;

void FWitchPTGameplayTags::InitializeGameplayTags()
{
	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));

	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
	
	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
	// Cauldron Abilities
	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));

	/**
	 * Input Tags
	 */
	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
	// UI Tags
	GameplayTags.UI_Layer_Game = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Game"));
	GameplayTags.UI_Layer_GameMenu = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.GameMenu"));
	GameplayTags.UI_Layer_Menu = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Menu"));
	GameplayTags.UI_Layer_Modal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Modal"));
	// Ritual
	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));

	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));

	// --- Ritual Event Tags ---
	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));

	
	// Cauldron Tags
	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
	// test commit 


	// Communication Messages
	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));

	// --- Items Tags ---
	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));

	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));



	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
	
	// Base Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));

	// Principal Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));

	// Modifier Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
	
	// Modifier Potency Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
	
	// Modifier Duration Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
	
	// Modifier Charges Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
	
	// Modifier Target Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));

}
</file>

<file path="WitchPT/Public/FWitchPTGameplayTags.h">
#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
	/**
	 * @brief Singleton accessor to all native GameplayTags.
	 *
	 * @return Reference to the singleton instance of WitchPTGameplayTags.
	 * @note To use the Singleton:
	 * const FAuraGameplayTags& AuraGameplayTags = FAuraGameplayTags::Get();
	 */
struct FWitchPTGameplayTags
{
public:
	static FWitchPTGameplayTags& Get() { return GameplayTags; }
	static void InitializeGameplayTags();


	/**
	* Attributes Primary Tags
	*/
	FGameplayTag Attributes_Primary_Health;
	FGameplayTag Attributes_Primary_Age;
	FGameplayTag Attributes_Secondary_Mana;
	FGameplayTag Attributes_Secondary_Stamina;
	// State Tags
	FGameplayTag Character_State_Movement_Sprinting;
	FGameplayTag Character_State_Movement_Crouching;
	FGameplayTag Character_State_Movement_MovingToPosition;
	FGameplayTag Character_State_Dead;
	FGameplayTag Character_State_Aim;
	FGameplayTag Character_State_Blocked;
	
	FGameplayTag Character_State_Cauldron_InPosition;
	FGameplayTag Character_State_Cauldron_Carrying;
	FGameplayTag Character_State_Cauldron_Placing;
	FGameplayTag Character_State_Cauldron_InGame;
	FGameplayTag Character_State_Cauldron_BrewingPotion;
	
	FGameplayTag Character_State_Ritual_InPosition;
	FGameplayTag Character_State_Ritual_InGame;

	// Ability Tags
	FGameplayTag Ability_Interact;
	FGameplayTag Ability_Sprint;
	FGameplayTag Ability_Jump;
	FGameplayTag Ability_Crouch;
	FGameplayTag Ability_Ritual_GoToPosition;
	FGameplayTag Ability_Ritual_ParticipatingInRitual;
	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
	FGameplayTag Ability_Ritual_Start;
	FGameplayTag Ability_Ritual_SendInput;





	
	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
	FGameplayTag Ability_Cauldron_CarryingCauldron;
	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
	FGameplayTag Ability_Cauldron_SetInPlace;
	FGameplayTag Ability_Cauldron_CancelSetInPlace;

	
	



	// Input Tags
	FGameplayTag InputTag_LMB;
	FGameplayTag InputTag_RMB;
	FGameplayTag InputTag_1;
	FGameplayTag InputTag_2;
	FGameplayTag InputTag_3;
	FGameplayTag InputTag_4;
	FGameplayTag InputTag_5;
	FGameplayTag InputTag_6;
	FGameplayTag InputTag_7;
	FGameplayTag InputTag_8;
	FGameplayTag InputTag_9;
	FGameplayTag InputTag_0;
	FGameplayTag InputTag_Ctrl;
	FGameplayTag InputTag_Alt;
	FGameplayTag InputTag_Shift;
	FGameplayTag InputTag_Tab;
	// UI Tags
	FGameplayTag UI_Layer_Game;
	FGameplayTag UI_Layer_GameMenu;
	FGameplayTag UI_Layer_Menu;
	FGameplayTag UI_Layer_Modal;


	// --- Ritual Position Tags ---
	FGameplayTag Ritual_Position_1;
	FGameplayTag Ritual_Position_2;
	FGameplayTag Ritual_Position_3;
	FGameplayTag Ritual_Position_4;

	FGameplayTag Ritual_Input_Up;
	FGameplayTag Ritual_Input_Down;
	FGameplayTag Ritual_Input_Left;
	FGameplayTag Ritual_Input_Right;

	// --- Ritual Event Tags ---
	FGameplayTag Event_Ritual_InputSuccess;
	FGameplayTag Event_Ritual_InputFailure;
	FGameplayTag Event_Ritual_SequenceSuccess;
	FGameplayTag Event_Ritual_SequenceFailure;
	FGameplayTag Event_Ritual_CatastrophicFailure;
	
	

	// --- Event Tags ---
	FGameplayTag Event_Ritual_InputReceived;
	FGameplayTag Event_Ritual_TurnAdvanced;
	FGameplayTag Event_Ritual_SequenceFail;
	FGameplayTag Event_Ritual_CatastrophicFail;

	// Cauldron Tags
	FGameplayTag Cauldron_State_Empty;
	FGameplayTag Cauldron_State_Full;
	FGameplayTag Cauldron_State_PotionReady;
	FGameplayTag Event_Cauldron_CharacterPositioned;


	// Communication tags
	FGameplayTag Communication_Message;

	// --- Items Tags ---
	FGameplayTag Item;
	FGameplayTag Item_Consumable;
	FGameplayTag Item_Consumable_Potion;
	FGameplayTag Item_Consumable_Potion_Tier_0;
	FGameplayTag Item_Consumable_Potion_Tier_1;
	FGameplayTag Item_Consumable_Potion_Tier_2;
	FGameplayTag Item_Consumable_Potion_Tier_3;
	
	FGameplayTag Item_Consumable_Ingredient;
	FGameplayTag Item_Consumable_Ingredient_Tier_0;
	FGameplayTag Item_Consumable_Ingredient_Tier_1;
	FGameplayTag Item_Consumable_Ingredient_Tier_2;
	FGameplayTag Item_Consumable_Ingredient_Tier_3;


	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;

	FGameplayTag Item_Consumable_Ingredient_Category_Base;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
	
	
	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;

	




	// --------------------------- Modifier Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
	// --------------------------- Modifier Potency Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
	// --------------------------- Modifier Duration Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
	// --------------------------- Modifier Charges Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
	// --------------------------- Modifier Application Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
	




private:
	static FWitchPTGameplayTags GameplayTags;
	
	
};
</file>

<file path="WitchPT/Public/Game/WitchPTGameModeBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "WitchPTGameModeBase.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/Input/WitchPTInputComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "EnhancedInputComponent.h"
#include "WitchPTInputConfig.h"

#include "WitchPTInputComponent.generated.h"


UCLASS()
class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
{
	GENERATED_BODY()

public:
	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);

};

template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
{
	check(InputConfig);
	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
	{
		if (Action.InputAction && Action.InputTag.IsValid())
		{
			if (PressedFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
			}
			if (ReleasedFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
			}
			if (HeldFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
			}
		}
	}
	
}
</file>

<file path="WitchPT/Public/Input/WitchPTInputConfig.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "WitchPTInputConfig.generated.h"

USTRUCT(BlueprintType)
struct FWitchPTInputAction
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly)
	const class UInputAction* InputAction = nullptr;

	UPROPERTY(EditDefaultsOnly)
	FGameplayTag InputTag = FGameplayTag();
};
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInputConfig : public UDataAsset
{
	GENERATED_BODY()
	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TArray<FWitchPTInputAction> AbilityInputActions;
	
};
</file>

<file path="WitchPT/Public/Inventory/Collectable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "Templates/SubclassOf.h"
#include "UObject/Interface.h"
#include "UObject/ObjectPtr.h"
#include "Collectable.generated.h"
template <typename InterfaceType> class TScriptInterface;
// This class does not need to be modified.

class AActor;
class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
class UObject;
struct FFrame;
// ------------------------- STRUCTS ---------------------- //
USTRUCT(BlueprintType)
struct FItemManifest
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
};


UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UCollectable : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API ICollectable
{
	GENERATED_BODY()

public:
	/**
	 * This is the functions you call from the GA_Interact_Collect
	 */
	UFUNCTION(BlueprintCallable)
	virtual FItemManifest GetPickupInventory() const = 0;
};

UCLASS()
class UCollectableStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UCollectableStatics();
	
	UFUNCTION(BlueprintPure)
	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
};
</file>

<file path="WitchPT/Public/Inventory/FastArray/FastArrayList.h">
#pragma once

#include "CoreMinimal.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "FastArrayList.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
struct FWitchPTInventoryList;

/**
 * FWitchPTInventoryEntry
 * 
 * Represents a single item entry in the inventory.
 * Uses FastArraySerializer for efficient replication.
 */
USTRUCT(BlueprintType)
struct FWitchPTInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FWitchPTInventoryEntry()
	{}

	/**
	 * Get a debug string representation of this inventory entry
	 * @return FString - A string describing the item instance and its definition
	 */
	FString GetDebugString() const;

private:
	friend FWitchPTInventoryList;
	friend UWitchPTInventoryManagerComponent;

	/** The actual item instance this entry represents */
	UPROPERTY()
	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
	
};

/**
 * FWitchPTInventoryList
 * 
 * A collection of inventory entries that supports efficient replication.
 * Uses FastArraySerializer to minimize network traffic when replicating inventory changes.
 * Handles adding, removing, and updating inventory items.
 */
USTRUCT(BlueprintType)
struct FWitchPTInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	/** Default constructor */
	FWitchPTInventoryList()
		: OwnerComponent(nullptr)
	{
	}

	/**
	 * Constructor with owner component
	 * @param InOwnerComponent - The component that owns this inventory list
	 */
	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
		: OwnerComponent(InOwnerComponent)
	{
	}

	/**
	 * Get all item instances in the inventory
	 * @return TArray<UWitchPTInventoryItemInstance*> - Array of all item instances
	 */
	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;

public:
	//~FFastArraySerializer contract
	/**
	 * Called before items are removed during replication
	 * Broadcasts the OnItemRemoved event for each removed item
	 */
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	
	/**
	 * Called after items are added during replication
	 * Broadcasts the OnItemAdded event for each added item
	 */
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	
	/**
	 * Called after items are changed during replication
	 * Broadcasts the OnItemStackChanged event for each changed item
	 */
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	/**
	 * Serializes the delta between two states of the array
	 * Required for FastArraySerializer functionality
	 */
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
	}

	/**
	 * Create a new inventory entry with the specified item definition
	 * Initializes the item instance and sets up its stack count based on the definition
	 *
	 * @param ItemClass The class of the inventory item to add
	 * @return A pointer to the newly created inventory item instance
	 */
	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
	
	/**
	 * Adds an existing item instance to the inventory list
	 *
	 * @param Instance The inventory item instance to add
	 */
	void AddEntry(UWitchPTInventoryItemInstance* Instance);

	/**
	 * Removes an item instance from the inventory list
	 * 
	 * @param Instance The inventory item instance to remove
	 */
	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);

private:
	friend UWitchPTInventoryManagerComponent;

private:
	/** Replicated list of inventory entries */
	UPROPERTY()
	TArray<FWitchPTInventoryEntry> Entries;

	/** Non-replicated reference to the owner component */
	UPROPERTY(NotReplicated)
	TObjectPtr<UActorComponent> OwnerComponent;
};

/**
 * Trait specification for FWitchPTInventoryList
 * Enables network delta serialization for efficient replication
 */
template<>
struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
{
	enum { WithNetDeltaSerializer = true };
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryFragment_Stackable.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	
	int32 GetMaxStackSize() const { return MaxStackSize; }
	int32 GetStackCount() const { return StackCount; }
	void SetStackCount(int32 Count) { StackCount = Count; }

private:

	UPROPERTY(EditAnywhere, Category = "Inventory")
	int32 MaxStackSize{1};

	UPROPERTY(EditAnywhere, Category = "Inventory")
	int32 StackCount{1};
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryFragment_UIDetails.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FText Title;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FText Description;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TSubclassOf<UUserWidget> IconWidget;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag TierTag;
	
	
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryItemFragment_EquippableItem.generated.h"

class UWitchPTEquipmentDefinition;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryItemFragment_EquippableItem : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, Category=Equipment)
	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"

USTRUCT(BlueprintType)
struct FBaseIngredientData
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag BaseLiquidTypeTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	int32 DefaultChargesProvided;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float StabilityModifier;
};

USTRUCT(BlueprintType)
struct FPrincipalIngredientData 
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag PrincipalEssenceTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float BasePotency;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float BaseDuration;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	bool bIsRitualEssence;
};

USTRUCT(BlueprintType)
struct FModifierIngredientData 
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTagContainer ModifierEffectTags;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float PotencyModificationValue;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float DurationModificationValue;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag GrantedPropertyTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag AddedEffectTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float StrengthOfModifier;
	
};
UCLASS()
class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag SlotUsageTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag TierTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag CategoryTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FBaseIngredientData BaseIngredientData;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FPrincipalIngredientData PrincipalIngredientData;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FModifierIngredientData ModifierIngredientData;

	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryItemFragment_PotionProperties.generated.h"

class UGameplayAbility;
/**
 * Fragment that defines potion properties for crafted potions
 * This stores the calculated properties from the cauldron crafting system
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryItemFragment_PotionProperties : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()

public:
	// Core Potion Properties
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	UGameplayAbility* CollectAbility;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	FGameplayTag PotionEssenceTag;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	FGameplayTag BaseLiquidTypeTag;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	float FinalPotency = 0.0f;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	float FinalDuration = 0.0f;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	int32 FinalCharges = 1;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
	FGameplayTag PotionTierTag;

	// Effect and Property Tags
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
	FGameplayTagContainer GrantedEffectTags;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
	FGameplayTagContainer GrantedPropertyTags;

	// Helper functions
	UFUNCTION(BlueprintPure, Category = "Potion Properties")
	bool IsValidPotion() const;

	UFUNCTION(BlueprintPure, Category = "Potion Properties")
	FString GetPotionDescription() const;

	// Function to set properties from crafting system
	UFUNCTION(BlueprintCallable, Category = "Potion Properties")
	void SetPotionProperties(const FGameplayTag& InPotionEssence,
							const FGameplayTag& InBaseLiquidType,
							float InPotency,
							float InDuration,
							int32 InCharges,
							const FGameplayTag& InTierTag,
							const FGameplayTagContainer& InEffectTags,
							const FGameplayTagContainer& InPropertyTags);

	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryItemFragment_WorldDetails.generated.h"

/**
 * Fragment that defines how items appear in the world
 * This stores mesh and visual information for world representation
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryItemFragment_WorldDetails : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()

public:
	// Static mesh used when item is spawned in the world
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
	UStaticMesh* WorldStaticMesh;

	// Optional material override for the world mesh
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
	UMaterialInterface* WorldMaterial;

	// Scale applied to the mesh when spawned in world
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
	FVector WorldScale = FVector(1.0f, 1.0f, 1.0f);

	// Collision profile name for the world object
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
	FName CollisionProfileName = "Item";

	// Helper functions
	UFUNCTION(BlueprintPure, Category = "World Details")
	bool HasValidWorldMesh() const;

	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Templates/SubclassOf.h"
#include "WitchPTInventoryItemFragment.generated.h"

template <typename T> class TSubclassOf;

class UWitchPTInventoryItemInstance;
/**
 * 
 */
UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
{
	GENERATED_BODY()

public:
	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
	
};
</file>

<file path="WitchPT/Public/Inventory/InventoryFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "UI/WidgetControllers/QuickBarWidgetController.h"
#include "InventoryFunctionLibrary.generated.h"

class UInventoryWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, Category="Inventory")
	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);

	UFUNCTION(BlueprintPure, Category="QuickBar")
	static UQuickBarWidgetController* SetQuickBarWidgetController(const UObject* WorldContextObject);
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTInventoryFunctionLibrary.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemFragment;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTInventoryItemDefinition.generated.h"

class UWitchPTInventoryItemFragment;
struct FFrame;
/**
 * 
 */
UCLASS(Blueprintable, Const, Abstract)
class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;

	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Systems/GameplayTagStack.h"
#include "Templates/SubclassOf.h"
#include "WitchPTInventoryItemInstance.generated.h"
class UWitchPTInventoryItemFragment;
class UWitchPTInventoryItemDefinition;
struct FFrame;
struct FGameplayTag;

/**
 * 
 */
UCLASS(BlueprintType)
class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	friend struct FWitchPTInventoryList;
	
	//~UObject interface
	virtual bool IsSupportedForNetworking() const override { return true; }
	//~End of UObject interface


	UFUNCTION(BlueprintCallable)
	int32 GetTotalStackCount() const { return TotalStackCount; }
	
	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
	{
		return ItemDef;
	}

	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;

	template <typename ResultClass>
	const ResultClass* FindFragmentByClass() const
	{
		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
	}

	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);


private:
	UPROPERTY(Replicated)
	int32 TotalStackCount{0};
	
	UPROPERTY(Replicated)
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
	
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "FastArray/FastArrayList.h"
#include "Net/Serialization/FastArraySerializer.h"
#include "WitchPTInventoryManagerComponent.generated.h"

class UInventoryUserWidget;
class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
class UObject;
struct FFrame;
struct FNetDeltaSerializeInfo;
struct FWitchPTInventoryList;
struct FReplicationFlags;

/**
 * Delegate for inventory item events.
 * Used to broadcast when items are added, removed, or their stack counts change.
 * @param UWitchPTInventoryItemInstance* - The item instance that was affected
 */
DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);

/**
 * WitchPTInventoryManagerComponent
 * 
 * A component that manages a player's inventory of items.
 * Handles adding, removing, and stacking items, as well as replicating inventory state across the network.
 * Uses a fast array serializer for efficient replication of inventory items.
 */
UCLASS(BlueprintType)
class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
{
	GENERATED_BODY()
protected:
	virtual void BeginPlay() override;

public:
	
	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());


	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);

	
	UFUNCTION(Server, Reliable)
	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);


	UFUNCTION(Server, Reliable)
	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);

	
	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;

	
	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;

	
	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
	
	
	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);

	// Delegates for inventory events
	
	/** Fired when a new item is added to the inventory */
	FOnItemChanged OnItemAdded;
	
	/** Fired when an item's stack count changes */
	FOnItemChanged OnItemStackChanged;
	
	/** Fired when an item is removed from the inventory */
	FOnItemChanged OnItemRemoved;

	//~UObject interface
	/**
	 * Replicates all inventory item instances as subobjects
	 * Required for proper replication of the inventory system
	 */
	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	
	/**
	 * Called when the component is ready for replication
	 * Registers all existing inventory items for replication
	 */
	virtual void ReadyForReplication() override;




private:
	/**
	 * The replicated list of inventory items
	 * Uses a fast array serializer for efficient replication
	 */
	UPROPERTY(Replicated)
	FWitchPTInventoryList InventoryList;
	

	TWeakObjectPtr<APlayerController> OwningController;
	

};
</file>

<file path="WitchPT/Public/Item/BaseInteractableAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "BaseInteractableAltar.generated.h"

class UWitchPTUserWidget;
class ABaseInteractionPosition;
class ACharacter;

/**
 * Base state enum for interaction state
 */
UENUM(BlueprintType)
enum class EInteractionState : uint8
{
    Inactive    UMETA(DisplayName = "Inactive"),
    WaitingForPlayers UMETA(DisplayName = "Waiting For Players"), // At least one player in position
    Preparing   UMETA(DisplayName = "Preparing"), // Players occupying positions
    Active      UMETA(DisplayName = "Active"),    // Sequence running
    Succeeded   UMETA(DisplayName = "Succeeded"),
    Failed      UMETA(DisplayName = "Failed"),
    FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);

// Estructura para mapear un jugador a su tag de posición
USTRUCT(BlueprintType)
struct FPlayerPositionTagEntry
{
    GENERATED_BODY();

    UPROPERTY(BlueprintReadWrite)
    TObjectPtr<ACharacter> Player = nullptr;

    UPROPERTY(BlueprintReadWrite)
    FGameplayTag PositionTag;
};

/**
 * Base class for interactive altars/cauldrons that players can interact with
 */
UCLASS(Abstract)
class WITCHPT_API ABaseInteractableAltar : public AActor
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ABaseInteractableAltar();
    virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
    
    // Current interaction state
    UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
    EInteractionState CurrentState = EInteractionState::Inactive;

    // Transforms defining brewing positions around the cauldron
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
    TArray<FTransform> PositionTransforms;

    // The class to spawn for brewing positions
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
    TSubclassOf<ABaseInteractionPosition> PositionClass;
    
    UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
    TArray<FGameplayTag> TagsPositions;
    
    // List of players participating in the interaction
    UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
    TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
    
    
    // Positions for interaction
    UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
    TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;

    UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
    TArray<FPlayerPositionTagEntry> PlayerPositionTags;
    
    // Basic interaction methods
  
    virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
    

    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    virtual void CreateAltarPositions();
    

    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    virtual void DestroyAltarPositions();

    
    
    // Multicast RPCs for notifications
    UFUNCTION(NetMulticast, Reliable)
    void Multicast_OnStateChanged(EInteractionState NewState);
    
    UFUNCTION(NetMulticast, Reliable)
    virtual void Multicast_OnInputSuccess(ACharacter* Character);
    
    UFUNCTION(NetMulticast, Reliable)
    virtual void Multicast_OnInputFailed(ACharacter* Character);
    
    
    // Getters for Blueprint/HUD access
    UFUNCTION(BlueprintPure, Category = "Interaction")
    EInteractionState GetCurrentState() const { return CurrentState; }

    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;
    

    
    UFUNCTION()
    virtual void OnRep_ParticipatingPlayers();
    
    
    // Helper functions
    virtual void HandleInputSuccess(ACharacter* Player);
    virtual void HandleInputFailure(ACharacter* Player);
    virtual void CheckState();
    virtual void CleanupInteraction();
    virtual void SpawnReward();
    virtual void SpawnDemon();
    virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
    
};
</file>

<file path="WitchPT/Public/Item/BaseInteractionPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/Item.h"
#include "AbilitySystem/Interaction/InteractionOption.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "MechanicsInterface.h"
#include "BaseInteractionPosition.generated.h"

class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;
class ABaseInteractableAltar;

/**
 * Base class for interaction positions (rituals, cauldrons, etc)
 */
UCLASS(Abstract)
class WITCHPT_API ABaseInteractionPosition : public AItem
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ABaseInteractionPosition();

    //~ Begin AActor Interface
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
    virtual void BeginPlay() override;
    //~ End AActor Interface

    //~ Begin IInteraction Interface (from AItem presumably)
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    //~ End IInteraction Interface

    //~ Getters

    UFUNCTION(BlueprintPure, Category = "Interaction")
    ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }

    UFUNCTION(BlueprintPure, Category = "Interaction")
    FGameplayTag GetPositionTag() const { return PositionTag; }
    //~ End Getters
    virtual bool IsOccupied() const;

    //~ Setters
    UFUNCTION()
    void SetOccupied(ACharacter* Character);

    UFUNCTION()
    void SetUnoccupied();

    UFUNCTION()
    void SetPositionTag(const FGameplayTag& NewTag);

protected:
    // Unique tag identifying this position (e.g., Ritual.Position.1). Set per instance.
    UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
    FGameplayTag PositionTag;

    // Is this position currently occupied by a player? Replicated.
    UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
    bool bIsOccupied = false;

    // Which character is currently occupying this position? Replicated.
    UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
    TObjectPtr<ACharacter> OccupyingCharacter = nullptr;

    // Variables potentially used by the base AItem interaction system
    UPROPERTY()
    TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;

    UPROPERTY()
    TWeakObjectPtr<AController> InteractingController;

    //~ Replication Notifies
    UFUNCTION()
    void OnRep_IsOccupied();

    UFUNCTION()
    void OnRep_OccupyingCharacter();
    //~ End Replication Notifies

    // Interaction Logic Helper (Called from GatherInteractionOptions or a specific interaction GA)
    virtual void HandleInteraction(ACharacter* InteractingCharacter);

private:
    void RemoveCharacterFromPosition();
};
</file>

<file path="WitchPT/Public/Item/CauldronAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractableAltar.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "MechanicsInterface.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "CauldronAltar.generated.h"

class UCauldronCraftComponent;
class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
class UWitchPTInventoryItemFragment;
class UCauldronUserWidget;
class ACauldronPosition;
class ACharacter;

// Estructura para contener secuencias de ingredientes
USTRUCT(BlueprintType)
struct FIngredientSequence
{
    GENERATED_BODY()
    
    UPROPERTY(BlueprintReadOnly)
    TArray<FGameplayTag> Ingredients;
};

// Enum for cauldron inputs
UENUM(BlueprintType)
enum class ECauldronInput : uint8
{
    Ingredient1 UMETA(DisplayName = "Ingredient 1"),
    Ingredient2 UMETA(DisplayName = "Ingredient 2"),
    Ingredient3 UMETA(DisplayName = "Ingredient 3"),
    Ingredient4 UMETA(DisplayName = "Ingredient 4"),
    Ingredient5 UMETA(DisplayName = "Ingredient 5"),
    None        UMETA(DisplayName = "None")
};

UENUM(BlueprintType)
enum ECauldronPhysicState
{
    Static UMETA(DisplayName = "InPlace"),
    Moving UMETA(DisplayName = "Moving"),
    Previewing UMETA(DisplayName = "Previewing")
};

// Enum para el estado de validación de la posición del caldero
UENUM(BlueprintType)
enum class ECauldronPlacementState : uint8
{
    Valid UMETA(DisplayName = "Valid"),
    Invalid UMETA(DisplayName = "Invalid"),
    None UMETA(DisplayName = "None")
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);

/**
 * Cauldron altar allows players to add ingredients in any order (unlike ritual's sequential inputs)
 */
UCLASS()
class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ACauldronAltar();
    
    // Overrides
    virtual void BeginPlay() override;
    virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
    virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
    
    // Core Properties
    UPROPERTY(EditAnywhere)
    FInteractionOption Option;
    
    UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
    TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;

    UPROPERTY(EditAnywhere, Replicated)
    TObjectPtr<UCauldronCraftComponent> CauldronCraftComponent;

    // Base potion definition template used for generating crafted potions
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
    TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition;
    
    
    // ----------------------------------- DELEGATES  ---------------------------------------------- //

    UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
    FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
    
    UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
    FOnCharacterPositioned OnCharacterPositioned;
    
    // UI Properties
    UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
    TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
    
    // Placement Properties
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    UMaterialInterface* ValidPlacementMaterial;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    UMaterialInterface* InvalidPlacementMaterial;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    float PlacementCollisionCheckRadius = 50.0f;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    float MaxGroundAlignmentHeight = 20.0f;
    
    // ----------------------------------- BREWING FUNCTIONS ---------------------------------------------- //
    
    void StartBrewingPotion(ACharacter* InteractingCharacter);
   
    void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
    
    // ----------------------------------- ON REP FUNCTIONS ---------------------------------------------- //
    
    UFUNCTION()
    void OnRep_CauldronPhysicState();
    
    UFUNCTION()
    void PositionCharacterForBrewing(ACharacter* Character);
    
    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
    
    
    // ----------------------------------- CAULDRON MOVEMENT FUNCTIONS ---------------------------------------------- //
    void StartCarryCauldron(ACharacter* InteractingCharacter);
    
    UFUNCTION()
    void AttachToCharacter(ACharacter* Character);
    
    UFUNCTION()
    void DetachFromCharacter(ACharacter* Character);
    
    // ----------------------------------- PLACEMENT FUNCTIONS ---------------------------------------------- //
    void StartPlacementPreview(ACharacter* Character);
    void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
    void FinalizePlacement();
    void CancelPlacement();
    void ApplyPlacementPreviewMaterial();
    
    UFUNCTION(Client, Unreliable)
    void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
    
    UFUNCTION(NetMulticast, Reliable)
    void Multicast_FinalizePlacement();
    
    // ----------------------------------- STATE QUERY FUNCTIONS ---------------------------------------------- //
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    bool CanBePickedUp() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    bool IsBeingCarried() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    ACharacter* GetCarryingCharacter() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
    ECauldronPlacementState GetPlacementState() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
    bool IsInPlacementPreview() const;

    // ----------------------------------- DEBUG FUNCTIONS ---------------------------------------------- //
    UFUNCTION(BlueprintCallable, Category = "Debug|Cauldron")
    void PrintCauldronDebugData() const;
    
private:
    UPROPERTY(Replicated)
    TObjectPtr<ACharacter> CarryingCharacter;
    
    UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
    FName BackAttachSocketName = "BackpackSocket";
    
    UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
    FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
    
    // Placement Properties
    UPROPERTY(Replicated)
    ECauldronPlacementState CurrentPlacementState;
    
    UPROPERTY()
    TArray<UMaterialInterface*> OriginalMaterials;
    
    FVector PreviewLocation;
    FRotator PreviewRotation;
    
    // Private Utility Functions
    void RestoreOriginalMaterials();
    bool IsPlacementValid() const;
};
</file>

<file path="WitchPT/Public/Item/CauldronPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractionPosition.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "CauldronPosition.generated.h"

// Forward Declarations
class ACauldronAltar;
class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;

/**
 * Position for interacting with a Cauldron altar
 */
UCLASS()
class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ACauldronPosition();

    //~ Begin AActor Interface
    virtual void BeginPlay() override;
    //~ End AActor Interface

    //~ Begin IInteraction Interface (from AItem)
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    //~ End IInteraction Interface

    //~ Getters
    UFUNCTION(BlueprintPure, Category = "Cauldron")
    ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
    //~ End Getters

    //~ Setters
    UFUNCTION(BlueprintCallable)
    void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
    //~ End Setters
    //
    // /**
    //  * Posiciona un personaje en esta ubicación
    //  * @param Character El personaje a posicionar
    //  * @return True si el personaje fue posicionado correctamente
    //  */
    // UFUNCTION(BlueprintCallable, Category = "Cauldron|Interaction")
    // bool PositionCharacter(ACharacter* Character);
    //
    // /**
    //  * Comprueba si esta posición está ocupada
    //  * @return True si la posición está ocupada por un personaje
    //  */
    // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    // bool IsOccupied() const;
    //
    // /**
    //  * Establece el estado de ocupación de esta posición
    //  * @param bInOccupied Si la posición está ocupada
    //  * @param InOccupyingCharacter El personaje que ocupa la posición
    //  */
    // UFUNCTION(BlueprintCallable, Category = "Cauldron|State")
    // void SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter = nullptr);
    //
    // /**
    //  * Obtiene el personaje que ocupa esta posición
    //  * @return El personaje que ocupa la posición, o nullptr si no está ocupada
    //  */
    // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    // ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }

protected:
    // Reference to the parent altar
    UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
    TObjectPtr<ACauldronAltar> CauldronAltar;

    // Interaction Logic Helper
    virtual void HandleInteraction(ACharacter* InteractingCharacter) override;

private:
    // Find the CauldronAltar if not set
    void FindCauldronAltar();
    //
    // // Character currently occupying this position
    // UPROPERTY()
    // TObjectPtr<ACharacter> OccupyingCharacter;
    //
    // // Whether this position is currently occupied
    // UPROPERTY()
    // bool bIsOccupied;
};
</file>

<file path="WitchPT/Public/Item/Components/CauldronCraftComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "Net/UnrealNetwork.h"
#include "GameplayTagContainer.h"
#include "CauldronCraftComponent.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class ACharacter;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);

// Core Potion Crafting Structures
USTRUCT(BlueprintType)
struct FPotionResult
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag PotionEssenceTag;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag BaseLiquidTypeTag;

	UPROPERTY(BlueprintReadOnly)
	float FinalPotency = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	float FinalDuration = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	int32 FinalCharges = 0;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag PotionTierTag;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer GrantedEffectTags;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer GrantedPropertyTags;

	UPROPERTY(BlueprintReadOnly)
	bool bIsValid = false;

	UPROPERTY(BlueprintReadOnly)
	TSubclassOf<UWitchPTInventoryItemDefinition> ResultPotionItemDef;
};

USTRUCT(BlueprintType)
struct FPotionCraftingRecipe
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	bool bRequiresBaseIngredient = true;

	UPROPERTY(BlueprintReadOnly)
	bool bRequiresPrincipalIngredient = true;

	UPROPERTY(BlueprintReadOnly)
	bool bRequiresModifierIngredient = false;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer AllowedBaseLiquidTypes;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer AllowedPrincipalEssences;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer IncompatibleCombinations;
};

// Extracted Ingredient Data Structures
USTRUCT(BlueprintType)
struct FExtractedBaseIngredientData
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag BaseLiquidTypeTag;

	UPROPERTY(BlueprintReadOnly)
	int32 DefaultChargesProvided = 0;

	UPROPERTY(BlueprintReadOnly)
	float StabilityModifier = 1.0f;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag TierTag;

	UPROPERTY(BlueprintReadOnly)
	bool bIsValid = false;
};

USTRUCT(BlueprintType)
struct FExtractedPrincipalIngredientData
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag PrincipalEssenceTag;

	UPROPERTY(BlueprintReadOnly)
	float BasePotency = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	float BaseDuration = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	bool bIsRitualEssence = false;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag TierTag;

	UPROPERTY(BlueprintReadOnly)
	bool bIsValid = false;
};

USTRUCT(BlueprintType)
struct FExtractedModifierIngredientData
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer ModifierEffectTags;

	UPROPERTY(BlueprintReadOnly)
	float PotencyModificationValue = 1.0f;

	UPROPERTY(BlueprintReadOnly)
	float DurationModificationValue = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag GrantedPropertyTag;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag AddedEffectTag;

	UPROPERTY(BlueprintReadOnly)
	float StrengthOfModifier = 1.0f;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag TierTag;

	UPROPERTY(BlueprintReadOnly)
	bool bIsValid = false;
};

UCLASS(Blueprintable)
class WITCHPT_API UCauldronCraftComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UCauldronCraftComponent();

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
	                           FActorComponentTickFunction* ThisTickFunction) override;

	// Replication
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	// Ingredient Variables
	UPROPERTY(VisibleAnywhere)
	UWitchPTInventoryItemInstance* BaseIngredient;
	UPROPERTY(VisibleAnywhere)
	UWitchPTInventoryItemInstance* PrincipalIngredient;
	UPROPERTY(VisibleAnywhere)
	UWitchPTInventoryItemInstance* ModifierIngredient;
	
	UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
	TSubclassOf<UUserWidget> BaseIngredientIcon;

	UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
	TSubclassOf<UUserWidget> PrincipalIngredientIcon;

	UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
	TSubclassOf<UUserWidget> ModifierIngredientIcon;

	// Potion Crafting Variables
	UPROPERTY(ReplicatedUsing = OnRep_CraftedPotion, BlueprintReadOnly, Category = "Potion Crafting")
	FPotionResult CraftedPotion;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
	FPotionCraftingRecipe DefaultCraftingRecipe;

	// Delegates
	FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
	FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
	FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
	FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
	FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
	FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;

	// Ingredient Functions
	void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
	
	// OnRep Functions
	UFUNCTION()
	void OnRep_BaseIngredientIcon();
	UFUNCTION()
	void OnRep_PrincipalIngredientIcon();
	UFUNCTION()
	void OnRep_PotentiatorIngredientIcon();
	UFUNCTION()
	void OnRep_CraftedPotion();

	// Crafting Validation Functions
	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
	bool CanCraftPotion() const;

	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
	FPotionCraftingRecipe GetRequiredIngredients() const;

	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
	bool ValidateIngredientCombination() const;

	// Debug Functions
	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
	void PrintIngredientDebugData() const;

	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
	void PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const;

	// Ingredient Data Extraction Functions
	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
	FExtractedBaseIngredientData ExtractBaseIngredientProperties() const;

	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
	FExtractedPrincipalIngredientData ExtractPrincipalIngredientProperties() const;

	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
	FExtractedModifierIngredientData ExtractModifierIngredientProperties() const;

	// Potion Calculation Functions
	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Calculation")
	FPotionResult CalculatePotionProperties() const;

	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Calculation")
	FGameplayTag CalculatePotionTier(const FExtractedBaseIngredientData& BaseData, 
									 const FExtractedPrincipalIngredientData& PrincipalData, 
									 const FExtractedModifierIngredientData& ModifierData) const;

	// Potion ItemDefinition Generation Functions
	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
	TSubclassOf<UWitchPTInventoryItemDefinition> GeneratePotionItemDefinition(const FPotionResult& PotionData) const;

	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
	UWitchPTInventoryItemDefinition* CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const;

	// Potion Spawning Functions
	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
	bool SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const;

	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
	UWitchPTInventoryItemInstance* AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const;

	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
	UWitchPTInventoryItemInstance* CreatePotionInstance(const FPotionResult& PotionData) const;

	// Main Crafting Function
	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Main", CallInEditor, meta = (DisplayName = "Craft Potion"))
	FPotionResult CraftPotion(bool bAddToInventory = true, ACharacter* TargetCharacter = nullptr, const FVector& WorldSpawnLocation = FVector::ZeroVector);

	// Crafting Helper Functions
	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
	bool CanPerformCrafting() const;

	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
	void ClearIngredientSlots();

	// Debug/Testing Helper Functions
	UFUNCTION(BlueprintCallable, Category = "Debug|Testing", CallInEditor, meta = (DisplayName = "Quick Test Craft"))
	void DebugTestCrafting();

	// Getters
	UWitchPTInventoryItemInstance* GetBaseIngredient() const;
	UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
	UWitchPTInventoryItemInstance* GetModifierIngredient() const;
	TSubclassOf<UUserWidget> GetBaseIngredientIcon() const;
	TSubclassOf<UUserWidget> GetPrincipalIngredientIcon() const;
	TSubclassOf<UUserWidget> GetModifierIngredientIcon() const;

protected:
	// Broadcast Helper Functions
	void BroadcastBaseIngredientDropped() const;
	void BroadcastBaseIngredientIconSet() const;
	void BroadcastPrincipalIngredientDropped() const;
	void BroadcastPrincipalIngredientIconSet() const;
	void BroadcastModifierIngredientDropped() const;
	void BroadcastModifierIngredientIconSet() const;

private:
	// Helper function to check if an ingredient has required crafting properties
	bool HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const;

	// Helper function to get the base potion definition from the owning cauldron
	TSubclassOf<UWitchPTInventoryItemDefinition> GetBasePotionItemDefinition() const;
};
</file>

<file path="WitchPT/Public/Item/Ingredient/IngredientBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Inventory/Collectable.h"
#include "Item/Item.h"
#include "IngredientBase.generated.h"

UCLASS()
class WITCHPT_API AIngredientBase : public AItem, public ICollectable
{
	GENERATED_BODY()

public:

	AIngredientBase();
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
	virtual FItemManifest GetPickupInventory() const override;
	
protected:

	UPROPERTY(EditAnywhere)
	FItemManifest StaticInventory;

};
</file>

<file path="WitchPT/Public/Item/Item.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "GameFramework/Actor.h"
#include "Item.generated.h"

UCLASS()
class WITCHPT_API AItem : public AActor, public IInteractableTarget
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AItem();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	UPROPERTY(EditAnywhere)
	FInteractionOption Option;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
};
</file>

<file path="WitchPT/Public/Item/MechanicsInterface.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "UObject/Interface.h"
#include "MechanicsInterface.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class ABaseInteractionPosition;
class ACauldronAltar;
class ARitualPosition;
class ARitualAltar;
class ACharacter;

// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class UMechanicsInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API IMechanicsInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
	
public:
	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestStartRitual(ARitualAltar* TargetAltar);
	

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);


	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
	
	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);

	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestPrintDebugData(ACauldronAltar* TargetAltar);
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestCraftPotion(ACauldronAltar* TargetAltar);
	
	
	// General Queries that might be implemented by positions or other interactables
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
	ARitualAltar* GetRitualAltarActor() const;

	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
	bool IsOccuppied() const;
	
};
</file>

<file path="WitchPT/Public/Item/PositionInterface.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "PositionInterface.generated.h"

class ARitualAltar;
// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class UPositionInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API IPositionInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
	ARitualAltar* GetRitualAltarActor() const;
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
	bool IsOccupied();
};
</file>

<file path="WitchPT/Public/Item/Potion/PotionBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Inventory/Collectable.h"
#include "Item/Item.h"
#include "PotionBase.generated.h"

UCLASS()
class WITCHPT_API APotionBase : public AItem, public ICollectable
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	APotionBase();
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
	virtual FItemManifest GetPickupInventory() const override;

	UPROPERTY(EditAnywhere)
	FItemManifest StaticInventory;
protected:

	// Store the soft reference to the ability
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Interaction")
	TSoftClassPtr<UGameplayAbility> InteractionAbilityClass;

	// Cache the loaded class to avoid repeated loading
	UPROPERTY(Transient)
	TSubclassOf<UGameplayAbility> LoadedInteractionAbility;

};
</file>

<file path="WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "RitualFunctionLibrary.generated.h"

class UWitchPTWidgetController;
class URitualWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(Category="Ritual")
	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
	UFUNCTION(Category="Cauldron")
	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
};
</file>

<file path="WitchPT/Public/Item/RitualAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractableAltar.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "RitualAltar.generated.h"

class URitualUserWidget;
class ARitualPosition;

// Enum defining the possible inputs for the ritual sequence
UENUM(BlueprintType)
enum class ERitualInput : uint8
{
	Up		UMETA(DisplayName = "Up"),
	Down	UMETA(DisplayName = "Down"),
	Left	UMETA(DisplayName = "Left"),
	Right	UMETA(DisplayName = "Right"),
	None	UMETA(DisplayName = "None") // Optional: For default/invalid state
};

USTRUCT(BlueprintType)
struct FUIRitualData
{
	GENERATED_BODY()
	UPROPERTY(BlueprintReadOnly)
	bool bIsMyTurn = false;
	UPROPERTY(BlueprintReadOnly)
	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
	UPROPERTY(BlueprintReadOnly)
	float RitualPercentageCompleted = 0.0f;
	UPROPERTY(BlueprintReadOnly)
	float CorruptionPercentage = 0.0f;
	UPROPERTY(BlueprintReadOnly)
	float CurrentInputTimeRemaining = 0.0f;
};

// Replicated struct for ready players data
USTRUCT(BlueprintType)
struct FRitualReadyPlayersData
{
	GENERATED_BODY()
	
	UPROPERTY(BlueprintReadOnly)
	int32 TotalPlayers = 0;
	
	UPROPERTY(BlueprintReadOnly)
	int32 ReadyPlayers = 0;
	
	bool operator==(const FRitualReadyPlayersData& Other) const
	{
		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
	}
	
	bool operator!=(const FRitualReadyPlayersData& Other) const
	{
		return !(*this == Other);
	}
};

// Delegates for UI updates - these will be called from OnRep functions
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);

UCLASS()
class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ARitualAltar();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	
	// ----------------------------------- REPLICATED PROPERTIES ---------------------------------------------- //
	// Current ritual state
	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
	EInteractionState CurrentRitualState = EInteractionState::Inactive;
	
	// Current sequence of inputs required for the ritual
	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
	TArray<FGameplayTag> InputSequence;

	// Current index in the sequence
	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
	int32 CurrentSequenceIndex = -1;
	
	// Players who have confirmed they're ready to start
	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
	
	// Ready players data for UI
	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
	FRitualReadyPlayersData ReadyPlayersData;
	
	// Current countdown value (when starting ritual)
	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
	int32 StartCountdown = 3;
	
	// Current player whose turn it is to input
	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
	TObjectPtr<ACharacter> CurrentActivePlayer;
	
	// Timer for the current input
	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
	float CurrentInputTimer;
	
	// Current turn data for UI
	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
	FUIRitualData CurrentTurnData;
	
	// Current corruption level
	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
	float CorruptionAmount = 0.0f;

	// Maximum corruption allowed before catastrophic failure
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float MaxCorruption = 100.0f;
	
	// Corruption increase per failure
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float CorruptionIncreasePerFail = 10.0f;
	
	// Base time window for inputs
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float BaseInputTimeWindow = 10.0f;
	
	// Scaling multiplier for difficulty
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float DifficultyScalingMultiplier = 1.0f;
	
	// Ritual completion status
	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
	bool bRitualCompleted = false;
	
	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
	bool bRitualWasSuccessful = false;
	
	// ----------------------------------- DELEGATES ---------------------------------------------- //
	FOnRitualStateChanged OnRitualStateChangedEvent;
	
	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
	
	FOnCountdownTick OnCountdownTickEvent;
	
	FOnTurnDataChanged OnTurnDataChangedEvent;
	
	FOnCorruptionChanged OnCorruptionChangedEvent;
	
	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
	UPROPERTY(BlueprintAssignable)
	FOnRitualCompleted OnRitualCompletedEvent;

	// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
	UFUNCTION()
	void OnRep_CurrentRitualState();
	
	UFUNCTION()
	void OnRep_CurrentSequenceIndex();
	
	UFUNCTION()
	void OnRep_ReadyPlayersData();
	
	UFUNCTION()
	void OnRep_StartCountdown();
	
	UFUNCTION()
	void OnRep_CurrentActivePlayer();
	
	UFUNCTION()
	void OnRep_TurnData();
	
	UFUNCTION()
	void OnRep_CorruptionAmount();
	
	UFUNCTION()
	void OnRep_RitualCompleted();

	// ----------------------------------- MAIN FUNCTIONS ---------------------------------------------- //
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
	
	void StartRitual(ACharacter* RequestingCharacter);
	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
	
	// New function to check player ready status
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool IsPlayerReady(ACharacter* Player) const;
	
	// New function to check if all players are ready
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool AreAllPlayersReady() const;
	
	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
	
	// Multicast RPCs for notifications
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnRitualSucceeded();
	
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnRitualCatastrophicFail();
	
	// New multicast RPC for countdown
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnCountdownTick(int32 CountdownValue);
	
	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
	
	// Override to handle widget hiding when players leave positions
	virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position) override;
	
	// ---------------------------- GETTERS FOR WC ---------------------------- //
	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
	float GetCorruptionPercentage() const;
	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
	float GetCurrentSequenceProgress() const;
	FGameplayTag GetCurrentExpectedInput() const;
	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }


protected:
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaTime) override;
	
	// Timer handle for the ritual start countdown
	FTimerHandle RitualStartCountdownHandle;
	
	// Timer handles
	FTimerHandle InputTimerHandle;
	
	// ----------------------------------- LOGIC FUNCTIONS ---------------------------------------------- //
	void GenerateInputSequence();
	void AdvanceToNextPlayer();
	virtual void HandleInputSuccess(ACharacter* Player) override;
	virtual void HandleInputFailure(ACharacter* Player) override;
	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
	void StartInputTimer();
	void OnInputTimerExpired();
	void CheckRitualState();
	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
	void CleanupRitual();
	void SpawnReward();
	void SpawnDemon();
	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
	void UpdateTurnData();
	void UpdateReadyPlayersData();
	
	// New helper functions for the ready system
	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
	void StartRitualCountdown();
	void ProcessCountdownTick();
	void ActivateRitual();
	
	// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
	void BroadcastRitualStateChanged();
	void BroadcastReadyPlayersChanged();
	void BroadcastCountdownTick();
	void BroadcastTurnDataChanged();
	void BroadcastCorruptionChanged();
	void BroadcastSequenceProgressChanged();
	void BroadcastRitualCompleted();
	
	// ----------------------------------- UI MANAGEMENT HELPER FUNCTIONS ---------------------------------------------- //
	// Helper function to hide ritual widgets for all participating players
	void HideRitualWidgetForAllPlayers();

	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> FailedAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
	
	// Animation montages specifically for ritual
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
};
</file>

<file path="WitchPT/Public/Item/RitualPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractionPosition.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "MechanicsInterface.h" // For GetRitualAltarActor & IsOccuppied if still needed
#include "PositionInterface.h"
#include "RitualPosition.generated.h"

// Forward Declarations
class ARitualAltar;
class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;

UCLASS()
class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ARitualPosition();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	//~ Begin AActor Interface
	virtual void BeginPlay() override;
	//~ End AActor Interface

	//~ Begin IInteraction Interface (from AItem)
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
	//~ End IInteraction Interface
	
	// Still part of IMechanicsInterface if these are general queries
	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
   

	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
	virtual bool IsOccupied_Implementation() override;

protected:
	// Reference to the parent altar
	UPROPERTY(EditInstanceOnly, Replicated)
	TObjectPtr<ARitualAltar> RitualAltar;

	// Interaction Logic Helper
	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;

private:
	// Find the RitualAltar if not set
	
};
</file>

<file path="WitchPT/Public/Player/WitchPTPlayerController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "UI/Widgets/PointerWidget.h"
#include "WitchPTPlayerController.generated.h"

class UWitchPTQuickBarComponent;
class UCauldronUserWidget;
class ABaseInteractableAltar;
class ACauldronAltar;
class ARitualAltar;
class UWitchPTInventoryManagerComponent;
struct FGameplayTag;
class UWitchPTAbilitySystemComponent;
class UWitchPTInputConfig;
struct FInputActionValue;
class UInputAction;
class UInputMappingContext;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTPlayerController : public APlayerController
{
	GENERATED_BODY()
public:
	AWitchPTPlayerController();
	virtual void PlayerTick(float DeltaTime) override;
	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	void LocalShowRitualWidget(ABaseInteractableAltar* Altar);
	void LocalHideRitualWidget();
	bool IsRitualWidgetVisible();
	void LocalToggleCauldronMenu();
	



	UFUNCTION(Client, Reliable)
	void Client_ShowRitualWidget(ABaseInteractableAltar* Altar);

	UFUNCTION(Client, Reliable)
	void Client_HideRitualWidget();

	UFUNCTION(Client, Reliable)
	void Client_ToggleCauldronMenu();

	UFUNCTION(BlueprintCallable, Category= "Overlay")
	void ShowOverlayWidget();
	UFUNCTION(BlueprintCallable, Category= "Overlay")
	void HideOverlayWidget();

	UFUNCTION(BlueprintCallable, Category= "Inventory")
	void OpenInventoryMenu();
	UFUNCTION(BlueprintCallable, Category= "Inventory")
	void CloseInventoryMenu();

	// Debug console commands for testing (Step 4 testing)
	UFUNCTION(Exec, Category = "Debug")
	void ShowRitualWidgetDebug();
	UFUNCTION(Exec, Category = "Debug") 
	void HideRitualWidgetDebug();
	UFUNCTION(Exec, Category = "Debug")
	void ToggleRitualWidgetDebug();


	UPROPERTY(Replicated, VisibleAnywhere)
	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
	UPROPERTY()
	TObjectPtr<UPointerWidget> HUDWidget;
	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
	UWitchPTQuickBarComponent* GetQuickBarComponent() { return QuickBarComponent; }
	UPROPERTY(Replicated, VisibleAnywhere, Category = "QuickBar")
	TObjectPtr<UWitchPTQuickBarComponent> QuickBarComponent;
protected:
	virtual void BeginPlay() override;
	virtual void SetupInputComponent() override;

	// Actions
	UPROPERTY(EditAnywhere, Category="Input")
	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
	UPROPERTY(EditAnywhere, Category="Input")
	TObjectPtr<UInputAction> MoveAction;
	UPROPERTY(EditAnywhere, Category= "Input")
	TObjectPtr<UInputAction> LookAction;
	//InputConfig
	UPROPERTY(EditDefaultsOnly, Category= "Input")
	TObjectPtr<UWitchPTInputConfig> InputConfig;

	// Ability System Component
	UPROPERTY()
	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;

	UWitchPTAbilitySystemComponent* GetASC();
	
	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TSubclassOf<UPointerWidget> HUDWidgetClass;

	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;

	

private:

	void Move(const FInputActionValue& InputActionValue);

	void Look(const FInputActionValue& Value);

	void AbilityInputTagPressed(FGameplayTag InputTag);
	void AbilityInputTagReleased(FGameplayTag InputTag);
	void AbilityInputTagHeld(FGameplayTag InputTag);
	

	void CreateHUDWidget();
	void OpenCauldronMenu();
	void CloseCauldronMenu();
	bool bCauldronMenuOpen = false;
	
	// Track ritual widget visibility state
	bool bRitualWidgetVisible = false;
	
	
};
</file>

<file path="WitchPT/Public/Player/WitchPTPlayerState.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemInterface.h"
#include "GameFramework/PlayerState.h"
#include "WitchPTPlayerState.generated.h"
class ARitualPosition;
class ARitualAltar;
class UAbilitySystemComponent;
class UAttributeSet;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
{
	GENERATED_BODY()
	AWitchPTPlayerState();
public:

	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
	UAttributeSet* GetAttributeSet() const { return AttributeSet; }

protected:
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAttributeSet> AttributeSet;
	
	
};
</file>

<file path="WitchPT/Public/Subsystems/UIManagerSubsystem.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/LocalPlayerSubsystem.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "UIManagerSubsystem.generated.h"

/**
 * 
 */

class UWitchPTUILayer;
struct FGameplayTag;
class UWitchPTPrimaryLayout;
class AWitchPTHUD;

UCLASS()
class WITCHPT_API UUIManagerSubsystem : public ULocalPlayerSubsystem
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	AWitchPTHUD* GetWitchPTHUD();
	
	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	bool RegisterLayout(FGameplayTag LayoutTag, UWitchPTUILayer* InLayer);

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	bool UnRegisterLayout(FGameplayTag LayerTag);

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	UUserWidget* PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass);

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	void PopContentFromLayer(FGameplayTag LayerTag);

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	void ClearAllLayers();

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	void ClearLayerExcept(FGameplayTag LayerTag);

	UFUNCTION(BlueprintCallable, Category = "UI Manager")
	void ClearLayer(FGameplayTag LayerTag);
private:
	
	UWitchPTUserWidget* GetPrimaryLayout();
	
};
</file>

<file path="WitchPT/Public/Subsystems/WidgetCommunicatorSubsystem.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/LocalPlayerSubsystem.h"
#include "WidgetCommunicatorSubsystem.generated.h"

class UWitchPTInventoryItemInstance;

/**
 * 
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemDraggedDelegate, const UWitchPTInventoryItemInstance*, ItemInstance);
UCLASS(BlueprintType)
class WITCHPT_API UWidgetCommunicatorSubsystem : public ULocalPlayerSubsystem
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Category= "WidgetCommunicator")
	void OnItemDragged(UWitchPTInventoryItemInstance* ItemInstance);

	
	UPROPERTY(BlueprintAssignable)
	FOnItemDraggedDelegate OnItemDraggedDelegate;
};
</file>

<file path="WitchPT/Public/Systems/GameplayTagStack.cpp">
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Systems/GameplayTagStack.h"

#include "UObject/Stack.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)

//////////////////////////////////////////////////////////////////////
// FGameplayTagStack

FString FGameplayTagStack::GetDebugString() const
{
	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
}

//////////////////////////////////////////////////////////////////////
// FGameplayTagStackContainer

void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
{
	if (!Tag.IsValid())
	{
		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
		return;
	}

	if (StackCount > 0)
	{
		for (FGameplayTagStack& Stack : Stacks)
		{
			if (Stack.Tag == Tag)
			{
				const int32 NewCount = Stack.StackCount + StackCount;
				Stack.StackCount = NewCount;
				TagToCountMap[Tag] = NewCount;
				MarkItemDirty(Stack);
				return;
			}
		}

		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
		MarkItemDirty(NewStack);
		TagToCountMap.Add(Tag, StackCount);
	}
}

void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
{
	if (!Tag.IsValid())
	{
		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
		return;
	}

	//@TODO: Should we error if you try to remove a stack that doesn't exist or has a smaller count?
	if (StackCount > 0)
	{
		for (auto It = Stacks.CreateIterator(); It; ++It)
		{
			FGameplayTagStack& Stack = *It;
			if (Stack.Tag == Tag)
			{
				if (Stack.StackCount <= StackCount)
				{
					It.RemoveCurrent();
					TagToCountMap.Remove(Tag);
					MarkArrayDirty();
				}
				else
				{
					const int32 NewCount = Stack.StackCount - StackCount;
					Stack.StackCount = NewCount;
					TagToCountMap[Tag] = NewCount;
					MarkItemDirty(Stack);
				}
				return;
			}
		}
	}
}

void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (int32 Index : RemovedIndices)
	{
		const FGameplayTag Tag = Stacks[Index].Tag;
		TagToCountMap.Remove(Tag);
	}
}

void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (int32 Index : AddedIndices)
	{
		const FGameplayTagStack& Stack = Stacks[Index];
		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
	}
}

void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (int32 Index : ChangedIndices)
	{
		const FGameplayTagStack& Stack = Stacks[Index];
		TagToCountMap[Stack.Tag] = Stack.StackCount;
	}
}
</file>

<file path="WitchPT/Public/Systems/GameplayTagStack.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameplayTagContainer.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "GameplayTagStack.generated.h"

struct FGameplayTagStackContainer;
struct FNetDeltaSerializeInfo;

/**
 * Represents one stack of a gameplay tag (tag + count)
 */
USTRUCT(BlueprintType)
struct FGameplayTagStack : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FGameplayTagStack()
	{}

	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
		: Tag(InTag)
		, StackCount(InStackCount)
	{
	}

	FString GetDebugString() const;

private:
	friend FGameplayTagStackContainer;

	UPROPERTY()
	FGameplayTag Tag;

	UPROPERTY()
	int32 StackCount = 0;
};

/** Container of gameplay tag stacks */
USTRUCT(BlueprintType)
struct FGameplayTagStackContainer : public FFastArraySerializer
{
	GENERATED_BODY()

	FGameplayTagStackContainer()
	//	: Owner(nullptr)
	{
	}

public:
	// Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
	void AddStack(FGameplayTag Tag, int32 StackCount);

	// Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
	void RemoveStack(FGameplayTag Tag, int32 StackCount);

	// Returns the stack count of the specified tag (or 0 if the tag is not present)
	int32 GetStackCount(FGameplayTag Tag) const
	{
		return TagToCountMap.FindRef(Tag);
	}

	// Returns true if there is at least one stack of the specified tag
	bool ContainsTag(FGameplayTag Tag) const
	{
		return TagToCountMap.Contains(Tag);
	}

	//~FFastArraySerializer contract
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
	}

private:
	// Replicated list of gameplay tag stacks
	UPROPERTY()
	TArray<FGameplayTagStack> Stacks;
	
	// Accelerated list of tag stacks for queries
	TMap<FGameplayTag, int32> TagToCountMap;
};

template<>
struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
{
	enum
	{
		WithNetDeltaSerializer = true,
	};
};
</file>

<file path="WitchPT/Public/UI/HUD/WitchPTHUD.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "WitchPTHUD.generated.h"

class UWitchPTPrimaryLayout;
class UQuickBarWidgetController;
class UCauldronWidgetController;
class UWitchPTWidgetController;
class URitualWidgetController;
class UAbilitySystemComponent;
class UAttributeSet;
class UWitchPTUserWidget;
class UInventoryWidgetController;
struct FWidgetControllerParams;
class UOverlayWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTHUD : public AHUD
{
	GENERATED_BODY()
public:
	

	virtual void BeginPlay() override;
	
	UPROPERTY(VisibleAnywhere)
	TArray<UUserWidget*> GameMenuWidgets;
	UFUNCTION(BlueprintCallable)
	UWitchPTUserWidget* GetMenuWidgetByCass(TSubclassOf<UWitchPTUserWidget> WidgetClass);
	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
	UQuickBarWidgetController* SetQuickBarWidgetController(const FWidgetControllerParams& WCParams);
	

	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
	void InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
	void InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
	void InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
	void InitQuickBarWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
	UFUNCTION(BlueprintCallable)
	void ToggleGameMenu(TSubclassOf<UWitchPTUserWidget> WidgetClass);
	
	void ShowOverlayWidget();
	void HideOverlayWidget();
	void ShowRitualWidget(class ARitualAltar* RitualAltar);
	void HideRitualWidget();
	void ShowInventoryWidget();
	void HideInventoryWidget();
	void ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar);
	void HideCauldronWithInventory();


	// ----------------------- Getters -----------------------
	UWitchPTPrimaryLayout* GetPrimaryLayout() const { return PrimaryLayout; }




private:
	// ----------------------- User Widgets -----------------------
	UPROPERTY()
	TObjectPtr<UWitchPTPrimaryLayout> PrimaryLayout;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> PrimaryLayoutClass;
	
	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> QuickBarUserWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> QuickBarUserWidgetClass;
	
	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;

	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> InventoryWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> InventoryWidgetClass;

	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> CauldronWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> CauldronWidgetClass;
	bool bCauldronWidgetVisible = false;

	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> RitualWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> RitualWidgetClass;


	// ----------------------- Widget Controllers -----------------------
	UPROPERTY()
	TObjectPtr<UQuickBarWidgetController> QuickBarWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UQuickBarWidgetController> QuickBarWidgetControllerClass;
	
	UPROPERTY()
	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<URitualWidgetController> RitualWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTWidgetController.h"
#include "CauldronWidgetController.generated.h"

class ACauldronAltar;
class UWitchPTInventoryItemInstance;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
/**
 * 
 */
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
public:
	UCauldronWidgetController();
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;
	void UnbindCallbacksFromDependencies();

	// Delegates for widgets to subscribe to
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;

	UFUNCTION(Category = "Cauldron")
	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);

	// Getter for the current ritual altar
	UFUNCTION(BlueprintPure, Category = "Cauldron")
	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }


protected:
	// Reference to the ritual altar that this widget controls
	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
	TObjectPtr<ACauldronAltar> CauldronAltar;

	UFUNCTION(Category = "Cauldron")
	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
	UFUNCTION(Category = "Cauldron")
	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
	UFUNCTION(Category = "Cauldron")
	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTWidgetController.h"
#include "InventoryWidgetController.generated.h"

class UWitchPTInventoryItemInstance;
/**
 * 
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);

UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
	
public:
	UFUNCTION(BlueprintCallable)
	virtual void BindCallbacksToDependencies() override;
						
	/**
	 * Removes a stack or specified amount from an inventory item instance
	 * If there's only one stack left and count is 1, removes the item completely
	 * @param ItemInstance - The item instance to remove from
	 * @param AmountToRemove - The amount to remove, defaults to 1
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);

	UFUNCTION(BlueprintCallable, Category= "UI Utils")
	void OnItemDragStart(UWitchPTInventoryItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, Category = "Equipment")
	void EquipItem(UWitchPTInventoryItemInstance* ItemInstance);

	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemAddedSignature OnItemAddedDelegate;
	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemAddedSignature OnItemStackChangedDelegate;
	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemRemovedSignature OnItemRemovedDelegate;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTWidgetController.h"
#include "OverlayWidgetController.generated.h"
class UWitchPTUserWidget;

USTRUCT()
struct FUIWidgetRow: public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FGameplayTag MessageGameplayTag = FGameplayTag();

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FText Message = FText();

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSubclassOf<UWitchPTUserWidget> MessageWidget;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	UTexture2D* Image = nullptr;
	
};


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);

UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
public:
	/**
	 * Handles the reception of asset gameplay tags from a Gameplay Effect (GE).
	 *
	 * This method is triggered when a Gameplay Effect sends a set of gameplay tags
	 * as part of its asset definition. It usually processes or reacts to the tags
	 * received within the container.
	 *
	 * @param TagContainer A container of gameplay tags associated with the triggered Gameplay Effect.
	 */
	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
	virtual void BroadcastInitialValues() override;

	virtual void BindCallbacksToDependencies() override;



	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnHealthChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxHealthChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnStaminaChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxStaminaChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnAgeChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxAgeChanged;

	UPROPERTY(BlueprintAssignable, Category="Widget Data")
	FOnMessageWidgetRowSignature OnMessageWidgetRow;
protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
	TObjectPtr<UDataTable> MessageWidgetDataTable;

	template<typename T>
T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
};

template <typename T>
T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
{
	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));

}
</file>

<file path="WitchPT/Public/UI/WidgetControllers/QuickBarWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTWidgetController.h"
#include "QuickBarWidgetController.generated.h"

class UWitchPTInventoryItemInstance;
class UWitchPTQuickBarComponent;
/**
 * 
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnQuickBarSlotChangedSignature, int32, NewActiveSlotIndex);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEquipableItemDragStartSignature);
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UQuickBarWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
public:
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;


	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
	void AddItemToQuickBarSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* ItemInstance);

	// --------------------------- DELEGATES ---------------------------
	UPROPERTY(BlueprintAssignable, Category = "QuickBar")
	FOnQuickBarSlotChangedSignature OnActiveSlotChangedDelegate;
	UPROPERTY(BlueprintAssignable, Category = "QuickBar")
	FOnEquipableItemDragStartSignature OnEquipableItemDragStartDelegate;


protected:
	UFUNCTION()
	void OnActiveSlotChanged(int32 NewActiveSlotIndex);


private:
	UFUNCTION()
	void OnEquipableItemDragStart(const UWitchPTInventoryItemInstance* ItemInstance);
	
	
	
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTWidgetController.h"
#include "Item/RitualAltar.h"
#include "RitualWidgetController.generated.h"

enum class ERitualInput : uint8;
class ARitualAltar;
class ACharacter;
enum class EInteractionState : uint8;

// Delegate to notify when the expected input in the ritual changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
// Delegate to notify when the ready players count changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
// Delegate to notify when the countdown ticks
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
// Delegate to notify when turn data changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
// Delegate to notify ritual state changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
// Delegate to notify corruption changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
// Delegate to notify sequence progress changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
// Delegate to notify when the ritual is completed
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);

/**
 * Widget Controller to manage the ritual UI
 */
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
	
public:
	URitualWidgetController();
	
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;
	
	// Method to set the associated ritual altar
	UFUNCTION(Category = "Ritual")
	void SetRitualAltar(ARitualAltar* InRitualAltar);
	
	// Getter for the current ritual altar
	UFUNCTION(BlueprintPure, Category = "Ritual")
	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
	
	// Checks if the current player is the active player in the ritual
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool IsLocalPlayerActive() const;
	
	// Delegates for widgets to subscribe to
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;

	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;

	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCompletedSignature_WC OnRitualCompleted;

protected:
	// Reference to the ritual altar that this widget controls
	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
	TObjectPtr<ARitualAltar> RitualAltar;
	
	// Callbacks for altar changes
	UFUNCTION()
	void HandleRitualStateChanged(EInteractionState NewState);
	
	UFUNCTION()
	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
	
	UFUNCTION()
	void HandleCountdownTick(int32 CountdownValue);
	
	UFUNCTION()
	void HandleTurnDataChanged(FUIRitualData TurnData);
	
	UFUNCTION()
	void HandleCorruptionChanged(float CorruptionPercentage);
	
	UFUNCTION()
	void HandleSequenceProgressChanged(float ProgressPercentage);
	
	UFUNCTION()
	void HandleRitualCompleted(bool bWasSuccessful);
	
private:
	// Helper function to determine if local player's turn and update turn data accordingly
	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "WitchPTWidgetController.generated.h"

class UAbilitySystemComponent;
class UAttributeSet;
/**
 * @struct FWidgetControllerParams
 * @brief A structure that encapsulates parameters required to initialize a widget controller.
 *
 * This structure is designed to pass necessary references into widget controllers for proper functionality,
 * primarily used in player-related widgets to access player-specific systems and attributes.
 *
 * It includes references to the Player Controller, Player State, Ability System Component,
 * and an Attribute Set. These references allow the widget controller to interact with the gameplay systems
 * linked to a player.
 *
 * @note Each of the parameters is a nullable pointer to account for scenarios where specific components
 * may not be initialized or required.
 */
USTRUCT(BlueprintType)
struct FWidgetControllerParams
{
	GENERATED_BODY()
	FWidgetControllerParams() {};
	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
	:
	PlayerController(PC),
	PlayerState(PS),
	AbilitySystemComponent(ASC),
	AttributeSet(AS)
	{}
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerController> PlayerController = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerState> PlayerState = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
	
};
UCLASS()
class WITCHPT_API UWitchPTWidgetController : public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);

	UFUNCTION(BlueprintCallable)
	virtual void BroadcastInitialValues();
	virtual void BindCallbacksToDependencies();
protected:
	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<APlayerController> PlayerController;
	
	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<APlayerState> PlayerState;

	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;

	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<UAttributeSet> AttributeSet;
};
</file>

<file path="WitchPT/Public/UI/Widgets/CauldronUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTUserWidget.h"
#include "CauldronUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
private:
	virtual void NativeConstruct() override;
	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
};
</file>

<file path="WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "InventoryUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
	
};
</file>

<file path="WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "RitualUserWidget.generated.h"

class ARitualAltar;

/**
 * User Widget for ritual interactions - enhanced for visibility management
 */
UCLASS()
class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()

public:
	URitualUserWidget(const FObjectInitializer& ObjectInitializer);

	// Enhanced visibility management methods
	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
	void ShowForRitual(ARitualAltar* Altar);
	
	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
	void HideFromRitual();
	
	// Check if widget is currently active for a ritual
	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
	bool IsActiveForRitual() const { return bIsActiveForRitual; }
	
	// Get the current ritual altar (if any)
	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
	ARitualAltar* GetCurrentRitualAltar() const { return CurrentRitualAltar; }

protected:
	// Override from UWitchPTUserWidget for enhanced visibility management
	virtual void NativeOnInitialized() override;
	virtual void NativeDestruct() override;
	
	// Called when the widget is shown for a ritual
	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
	void OnShownForRitual(ARitualAltar* Altar);
	
	// Called when the widget is hidden from a ritual
	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
	void OnHiddenFromRitual();
	
	// Reset widget state when switching between rituals
	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
	void ResetWidgetState();

private:
	// Track if widget is currently active for a ritual
	UPROPERTY()
	bool bIsActiveForRitual = false;
	
	// Reference to the current ritual altar
	UPROPERTY()
	TObjectPtr<ARitualAltar> CurrentRitualAltar;
};
</file>

<file path="WitchPT/Public/UI/Widgets/Layer/WitchPTUILayer.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "WitchPTUILayer.generated.h"

class UBorder;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTUILayer : public UWitchPTUserWidget
{
	GENERATED_BODY()
	
public:
	
	UFUNCTION(Blueprintable, Category= "UI Layer")
	UUserWidget* PushContent(TSoftClassPtr<UUserWidget> WidgetClass);
	
	UFUNCTION(BlueprintCallable, Category= "UI Layer")
	void PopContent();

	UFUNCTION(BlueprintPure, Category= "UI Layer")
	UUserWidget* GetTopScreen() const;
	UFUNCTION(BlueprintCallable, Category= "UI Layer")
	FText GetStackListNames();
	UFUNCTION(BlueprintCallable, Category= "UI Layer")
	void ClearStack();

protected:
	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UBorder> Border;
private:
	UPROPERTY()
	TArray<TObjectPtr<UUserWidget>> Stack;
	UPROPERTY()
	TObjectPtr<UUserWidget> TopWidget = nullptr;
	UPROPERTY()
	TObjectPtr<UUserWidget> PushedWidget = nullptr;

	// HELPER FUNCTIONS
	void CollapseTop();
	void ShowTop();

	
	
	
};
</file>

<file path="WitchPT/Public/UI/Widgets/PointerWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "PointerWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UPointerWidget : public UUserWidget
{
	GENERATED_BODY()
public:
	
	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
	void ShowPickupMessage(const FString& Message);

	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
	void HidePickupMessage();
};
</file>

<file path="WitchPT/Public/UI/Widgets/QuickBarUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTUserWidget.h"
#include "QuickBarUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UQuickBarUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/UI/Widgets/WitchPTPrimaryLayout.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTUserWidget.h"
#include "GameplayTagContainer.h"
#include "WitchPTPrimaryLayout.generated.h"

class UWitchPTUILayer;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTPrimaryLayout : public UWitchPTUserWidget
{
	GENERATED_BODY()
public:
	UWitchPTPrimaryLayout();
	virtual void NativeConstruct() override;

	UPROPERTY(EditDefaultsOnly, Category = "Layout")
	TMap<FGameplayTag, TSoftClassPtr<UUserWidget>> InitialScreens;

	// ------------------------------- Main functions ------------------------------- //
	UFUNCTION(BlueprintCallable, Category = "UI")
	bool RegisterLayer(FGameplayTag LayerTag, UWitchPTUILayer* InLayer);
	
	UFUNCTION(BlueprintCallable, Category = "UI")
	bool UnRegisterLayer(FGameplayTag LayerTag);
	
	UFUNCTION(BlueprintCallable, Category = "UI")
	UUserWidget* PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass);

	UFUNCTION(BlueprintCallable, Category = "UI")
	void PopContentFromLayer(FGameplayTag LayerTag);

	UFUNCTION(BlueprintCallable, Category = "UI")
	void ClearAllLayers();
	UFUNCTION(BlueprintCallable, Category = "UI")
	void ClearAllLayersExcept(FGameplayTag LayerTag);
	UFUNCTION(BlueprintCallable, Category = "UI")
	void ClearLayer(FGameplayTag LayerTag);
	UFUNCTION(BlueprintCallable, Category = "UI")
	void PushInitialScreens();
	

private:
	
	UPROPERTY(VisibleAnywhere)
	TMap<FGameplayTag, TObjectPtr<UWitchPTUILayer>> Layers;
	
	// Main layer, this displays the Health bar, Mana bar and the QuickBarWidget
	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UWitchPTUILayer> GameLayer;
	
	// This layer displays the inventory menu, the cauldron menu, etc
	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UWitchPTUILayer> GameMenuLayer;
	
	// This layer displays the main menu, the pause menu, etc
	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UWitchPTUILayer> MenuLayer;
	
	// This layer displays the modal windows, like the confirmation dialog, etc
	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UWitchPTUILayer> ModalLayer;
};
</file>

<file path="WitchPT/Public/UI/Widgets/WitchPTUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "WitchPTUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTUserWidget : public UUserWidget
{
	GENERATED_BODY()
public:
	virtual void NativeConstruct() override;
	UFUNCTION(BlueprintCallable)
	void SetWidgetController(UObject* InWidgetController);
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UObject> WidgetController;

	UFUNCTION(BlueprintImplementableEvent)
	void OnWidgetControllerSet();
};
</file>

<file path="WitchPT/Public/WitchPTAssetManager.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/AssetManager.h"
#include "WitchPTAssetManager.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAssetManager : public UAssetManager
{
	GENERATED_BODY()
public:
	static UWitchPTAssetManager& Get();
protected:
	virtual void StartInitialLoading() override;

	
};
</file>

<file path="WitchPT/WitchPT.Build.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;

public class WitchPT : ModuleRules
{
	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });

		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}
</file>

<file path="WitchPT/WitchPT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "WitchPT.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );
</file>

<file path="WitchPT/WitchPT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
#define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
#define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)
</file>

<file path="WitchPTEditor.Target.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class WitchPTEditorTarget : TargetRules
{
	public WitchPTEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V5;

		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
	}
}
</file>

</files>
