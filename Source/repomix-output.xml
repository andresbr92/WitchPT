This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
WitchPT.Target.cs
WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp
WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp
WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
WitchPT/Private/Character/WitchPTCharacter.cpp
WitchPT/Private/Character/WitchPTCharacterBase.cpp
WitchPT/Private/Character/WitchPTEnemy.cpp
WitchPT/Private/Game/WitchPTGameModeBase.cpp
WitchPT/Private/Input/WitchPTInputComponent.cpp
WitchPT/Private/Input/WitchPTInputConfig.cpp
WitchPT/Private/Inventory/Collectable.cpp
WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
WitchPT/Private/Item/BaseInteractableAltar.cpp
WitchPT/Private/Item/BaseInteractionPosition.cpp
WitchPT/Private/Item/CauldronAltar.cpp
WitchPT/Private/Item/CauldronPosition.cpp
WitchPT/Private/Item/Ingredient/IngredientBase.cpp
WitchPT/Private/Item/Item.cpp
WitchPT/Private/Item/MechanicsInterface.cpp
WitchPT/Private/Item/PositionInterface.cpp
WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
WitchPT/Private/Item/RitualAltar.cpp
WitchPT/Private/Item/RitualPosition.cpp
WitchPT/Private/Player/WitchPTPlayerController.cpp
WitchPT/Private/Player/WitchPTPlayerState.cpp
WitchPT/Private/UI/HUD/WitchPTHUD.cpp
WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
WitchPT/Private/UI/Widgets/PointerWidget.cpp
WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
WitchPT/Private/WitchPTAssetManager.cpp
WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h
WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h
WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
WitchPT/Public/Character/WitchPTCharacter.h
WitchPT/Public/Character/WitchPTCharacterBase.h
WitchPT/Public/Character/WitchPTEnemy.h
WitchPT/Public/FWitchPTGameplayTags.cpp
WitchPT/Public/FWitchPTGameplayTags.h
WitchPT/Public/Game/WitchPTGameModeBase.h
WitchPT/Public/Input/WitchPTInputComponent.h
WitchPT/Public/Input/WitchPTInputConfig.h
WitchPT/Public/Inventory/Collectable.h
WitchPT/Public/Inventory/FastArray/FastArrayList.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
WitchPT/Public/Inventory/InventoryFunctionLibrary.h
WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
WitchPT/Public/Item/BaseInteractableAltar.h
WitchPT/Public/Item/BaseInteractionPosition.h
WitchPT/Public/Item/CauldronAltar.h
WitchPT/Public/Item/CauldronPosition.h
WitchPT/Public/Item/Ingredient/IngredientBase.h
WitchPT/Public/Item/Item.h
WitchPT/Public/Item/MechanicsInterface.h
WitchPT/Public/Item/PositionInterface.h
WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
WitchPT/Public/Item/RitualAltar.h
WitchPT/Public/Item/RitualPosition.h
WitchPT/Public/Player/WitchPTPlayerController.h
WitchPT/Public/Player/WitchPTPlayerState.h
WitchPT/Public/Systems/GameplayTagStack.cpp
WitchPT/Public/Systems/GameplayTagStack.h
WitchPT/Public/UI/HUD/WitchPTHUD.h
WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
WitchPT/Public/UI/Widgets/CauldronUserWidget.h
WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
WitchPT/Public/UI/Widgets/PointerWidget.h
WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
WitchPT/Public/WitchPTAssetManager.h
WitchPT/WitchPT.Build.cs
WitchPT/WitchPT.cpp
WitchPT/WitchPT.h
WitchPTEditor.Target.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="WitchPT.Target.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class WitchPTTarget : TargetRules
{
	public WitchPTTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V5;

		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/PlayerController.h"
#include "Engine/World.h"
#include "DrawDebugHelpers.h"
#include "TimerManager.h"
#include "GameFramework/Character.h"
#include "Camera/CameraComponent.h"

UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bTickingTask = true;
	TraceDistance = 500.0f;
	TraceRadius = 10.0f;
	bTraceComplex = false;
	bIgnoreBlockingHits = false;
	bShowDebug = false;
	LastHitLocation = FVector::ZeroVector;
	LastHitNormal = FVector::UpVector;
}

UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
	UGameplayAbility* OwningAbility,
	float TraceDistance,
	float TraceRadius,
	bool TraceComplex,
	bool bIgnoreBlockingHits,
	bool bShowDebug)
{
	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
	
	MyObj->TraceDistance = TraceDistance;
	MyObj->TraceRadius = TraceRadius;
	MyObj->bTraceComplex = TraceComplex;
	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
	MyObj->bShowDebug = bShowDebug;
	
	return MyObj;
}

void UAT_WaitForPlacementLocation_SLT::Activate()
{
	Super::Activate();
	
	// Configurar para ejecutar el trace en cada tick
	SetWaitingOnAvatar();
	
	// Realizar un primer trace inmediatamente
	PerformTrace();
}

void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
{
	// Limpiar el temporizador si está activo
	UWorld* World = GetWorld();
	if (World)
	{
		World->GetTimerManager().ClearTimer(TraceTimerHandle);
	}
	
	Super::OnDestroy(bInOwnerFinished);
}

void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
{
	Super::TickTask(DeltaTime);
	
	// Realizar el trace en cada tick
	PerformTrace();
}

void UAT_WaitForPlacementLocation_SLT::PerformTrace()
{
	if (!Ability || !Ability->GetCurrentActorInfo())
	{
		return;
	}
	
	// Obtener el controlador del jugador
	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
	if (!PC)
	{
		return;
	}
	
	// Obtener el personaje del jugador (necesario para obtener la cámara)
	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
	if (!Character)
	{
		return;
	}
	
	// Definir los puntos de inicio y fin del trace
	FVector TraceStart;
	FVector TraceDirection;
	
	// Buscar un componente de cámara en el personaje
	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
	if (CameraComponent)
	{
		// Usar la posición y dirección de la cámara para el trace
		TraceStart = CameraComponent->GetComponentLocation();
		TraceDirection = CameraComponent->GetForwardVector();
	}
	else
	{
		// Si no hay cámara, usar la rotación del controlador
		FRotator ControllerRotation = PC->GetControlRotation();
		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
		TraceDirection = ControllerRotation.Vector();
	}
	
	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
	
	// Configurar parámetros del trace
	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
	QueryParams.AddIgnoredActor(Character);
	
	// Configurar qué tipos de objetos detectar
	ECollisionChannel TraceChannel = ECC_Visibility;
	
	// Realizar el trace
	FHitResult HitResult;
	bool bHit = false;
	
	// Realizar un sphere trace o line trace según el radio
	if (TraceRadius > 0.0f)
	{
		bHit = GetWorld()->SweepSingleByChannel(
			HitResult,
			TraceStart,
			TraceEnd,
			FQuat::Identity,
			TraceChannel,
			FCollisionShape::MakeSphere(TraceRadius),
			QueryParams
		);
	}
	else
	{
		bHit = GetWorld()->LineTraceSingleByChannel(
			HitResult,
			TraceStart,
			TraceEnd,
			TraceChannel,
			QueryParams
		);
	}
	
	// Si encontramos un hit y es diferente al último que reportamos
	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
	{
		// Almacenar los nuevos valores
		LastHitLocation = HitResult.ImpactPoint;
		LastHitNormal = HitResult.ImpactNormal;
		
		// Disparar el delegado con la información del hit
		if (ShouldBroadcastAbilityTaskDelegates())
		{
			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
		}
	}
	
	// Mostrar debug si está habilitado
	if (bShowDebug)
	{
		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
		
		if (bHit)
		{
			// Dibujar una esfera en el punto de impacto
			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
			
			// Dibujar la normal
			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
		}
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/GA_CauldronPlace.h"
#include "Item/CauldronAltar.h"
#include "GameFramework/Character.h"
#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"

UGA_CauldronPlace::UGA_CauldronPlace()
{
    // Configurar entradas para esta habilidad
   
    
    // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    
    // Flags de red
    NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
    
    // No se requiere confirmación para activar
    bServerRespectsRemoteAbilityCancellation = true;
}

void UGA_CauldronPlace::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    // Llamar a la implementación base
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Buscar el caldero que está en modo previsualización
    ACauldronAltar* CauldronAltar = FindPreviewingCauldron();
    if (!CauldronAltar)
    {
        UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlace: No se encontró un caldero en modo previsualización"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Intentar finalizar la colocación
    // CauldronAltar->Server_FinalizePlacement();
    
   
    
    // Terminar la habilidad independientemente del resultado
    EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
}

ACauldronAltar* UGA_CauldronPlace::FindPreviewingCauldron()
{
    // Obtener el personaje que está usando la habilidad
    ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
    if (!Character)
    {
        return nullptr;
    }
    
    // Buscar todos los calderos en el mundo
    TArray<AActor*> FoundCauldrons;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
    
    // Buscar el caldero que está en modo previsualización para este personaje
    for (AActor* Actor : FoundCauldrons)
    {
        ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
        if (Cauldron && Cauldron->IsInPlacementPreview() && Cauldron->GetCarryingCharacter() == Character)
        {
            return Cauldron;
        }
    }
    
    return nullptr;
}
</file>

<file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h"
#include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
#include "Item/CauldronAltar.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/Character.h"
#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"

UGA_CauldronPlacementPreview::UGA_CauldronPlacementPreview()
{
    // Configurar entradas para esta habilidad
    
    // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    
    // Flags de red
    NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
    
    // No se requiere confirmación para activar
    bServerRespectsRemoteAbilityCancellation = true;
}

void UGA_CauldronPlacementPreview::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    // Llamar a la implementación base
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Buscar el caldero que está llevando el personaje
    CauldronAltar = FindCarriedCauldron();
    if (!CauldronAltar)
    {
        UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlacementPreview: No se encontró un caldero que esté siendo llevado por el personaje"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }
    
    // Iniciar el modo de previsualización en el caldero
    // CauldronAltar->Server_StartPlacementPreview(Cast<ACharacter>(ActorInfo->AvatarActor.Get()));
    
    // Vincular entradas para confirmar/cancelar
    FGameplayAbilityActorInfo* ActorInfoConst = const_cast<FGameplayAbilityActorInfo*>(ActorInfo);
    
    // Configurar vinculaciones de entrada
    if (IsLocallyControlled())
    {
        // Vincular eventos de entrada para confirmar/cancelar
        
    }
    
    // Crear la tarea de seguimiento de ubicación
    UAT_WaitForPlacementLocation_SLT* Task = UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
        this, 
        TraceDistance, 
        TraceRadius, 
        bTraceComplex, 
        false, 
        bShowDebug
    );
    
    if (Task)
    {
        // Configurar el callback para cuando encuentre una ubicación
        Task->OnLocationFound.AddDynamic(this, &UGA_CauldronPlacementPreview::OnLocationFound);
        
        // Activar la tarea
        Task->ReadyForActivation();
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("GA_CauldronPlacementPreview: No se pudo crear la tarea de ubicación"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
    }
    
    // Llamar a la implementación base después de configurar todo
    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UGA_CauldronPlacementPreview::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
    // Si la habilidad fue cancelada y tenemos un caldero, cancelar la colocación
    if (bWasCancelled && CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // CauldronAltar->Server_CancelPlacement();
    }
    
    // Desvincular entradas si es necesario
    if (IsLocallyControlled())
    {
        // TODO: Desvincular eventos de entrada si es necesario
    }
    
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

ACauldronAltar* UGA_CauldronPlacementPreview::FindCarriedCauldron()
{
    // Obtener el personaje que está usando la habilidad
    ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
    if (!Character)
    {
        return nullptr;
    }
    
    // Buscar todos los calderos en el mundo
    TArray<AActor*> FoundCauldrons;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
    
    // Buscar el caldero que está siendo llevado por este personaje
    for (AActor* Actor : FoundCauldrons)
    {
        ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
        if (Cauldron && Cauldron->IsBeingCarried() && Cauldron->GetCarryingCharacter() == Character)
        {
            return Cauldron;
        }
    }
    
    return nullptr;
}

void UGA_CauldronPlacementPreview::OnConfirmPlacement()
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
         // CauldronAltar->Server_FinalizePlacement();
        // if (bSuccess)
        // {
        //     // La colocación fue exitosa, terminar la habilidad
        //     CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
        // }
        // Si no tuvo éxito, seguimos en modo de previsualización
    }
}

void UGA_CauldronPlacementPreview::OnCancelPlacement()
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // Cancelar la colocación y volver a adjuntar el caldero al personaje
        // CauldronAltar->Server_CancelPlacement();
    }
    
    // Terminar la habilidad
    CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
}

void UGA_CauldronPlacementPreview::OnLocationFound(FVector HitLocation, FVector HitNormal)
{
    if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
    {
        // Actualizar la posición de previsualización del caldero
        // CauldronAltar->UpdatePlacementPreview(HitLocation, HitNormal);
    }
}
</file>

<file path="WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"

#include "AbilitySystemComponent.h"

UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{
	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
}

void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
                                            const FGameplayAbilitySpec& Spec)
{
	Super::OnGiveAbility(ActorInfo, Spec);
	TryActivateAbilityOnSpawn(ActorInfo, Spec);
}

void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayAbilitySpec& Spec) const
{
	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
	{
		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
		AbilitySystem->TryActivateAbility(Spec.Handle);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"

#include "AbilitySystemComponent.h"
#include "Engine/OverlapResult.h"
#include "Engine/World.h"
#include "GameFramework/Controller.h"

#include "TimerManager.h"
#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "AbilitySystem/Interaction/InteractionQuery.h"
#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "WitchPT/WitchPT.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}
void UAbilityTask_GrantNearbyInteraction::Activate()
{
	
	SetWaitingOnAvatar();
	UWorld* World = GetWorld();
	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);

}

void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
{
	Super::OnGameplayTaskActivated(Task);
	
}

UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
                                                                                                             float InteractionScanRange, float InteractionScanRate)
{

	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
	MyObj->InteractionScanRange = InteractionScanRange;
	MyObj->InteractionScanRate = InteractionScanRate;
	return MyObj;
}

void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
{
	// Limpiar el temporizador
	UWorld* World = GetWorld();
	if (World)
	{
		World->GetTimerManager().ClearTimer(QueryTimerHandle);
	}
	
	// Limpiar las habilidades concedidas
	// if (AbilitySystemComponent)
	// {
	// 	// Limpiar habilidades de interacción rápida
	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : InteractionAbilityCache)
	// 	{
	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
	// 	}
	// 	
	// 	// Limpiar habilidades de interacción mantenida
	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : HoldInteractionAbilityCache)
	// 	{
	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
	// 	}
	// }
	//
	// InteractionAbilityCache.Empty();
	// HoldInteractionAbilityCache.Empty();
	
	Super::OnDestroy(AbilityEnded);
}

void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
{
	UWorld* World = GetWorld();
	AActor* ActorOwner = GetAvatarActor();
	
	if (World && ActorOwner)
	{
		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);

		TArray<FOverlapResult> OverlapResults;
		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);

		if (OverlapResults.Num() > 0)
		{
			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
			
			FInteractionQuery InteractionQuery;
			InteractionQuery.RequestingAvatar = ActorOwner;
			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());

			TArray<FInteractionOption> Options;
			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
			{
				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
			}

			// Check if any of the options need to grant the ability to the user before they can be used.
			for (FInteractionOption& Option : Options)
			{
				// Otorgar la habilidad de interacción regular
				if (Option.InteractionAbilityToGrant)
				{
					// Grant the ability to the GAS, otherwise it won't be able to do whatever the interaction is.
					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
					if (!InteractionAbilityCache.Find(ObjectKey))
					{
						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
						InteractionAbilityCache.Add(ObjectKey, Handle);
					}
				}
				
				// Otorgar la habilidad de interacción mantenida si está disponible y soportada
				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
				{
					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
					if (!HoldInteractionAbilityCache.Find(ObjectKey))
					{
						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
					}
				}
			}
		}
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
#include "AbilitySystemComponent.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
struct FInteractionQuery;

UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}
void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
{
	check(World);

	OutHitResult = FHitResult();
	FHitResult HitResult;
	// World->LineTraceMultiByProfile(HitResults, Start, End, CollisionChannel, Params);
	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
	OutHitResult.TraceStart = Start;
	OutHitResult.TraceEnd = End;

	OutHitResult = HitResult;
}

void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
{
	if (!Ability) // Server and launching client only
	{
		return;
	}

	//@TODO: Bots?
	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
	check(PC);

	FVector ViewStart;
	FRotator ViewRot;
	PC->GetPlayerViewPoint(ViewStart, ViewRot);

	const FVector ViewDir = ViewRot.Vector();
	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);

	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);

	FHitResult HitResult;
	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);

	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));

	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;

	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
	if (AdjustedAimDir.IsZero())
	{
		AdjustedAimDir = ViewDir;
	}

	if (!bTraceAffectsAimPitch && bUseTraceResult)
	{
		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();

		if (!OriginalAimDir.IsZero())
		{
			// Convert to angles and use original pitch
			const FRotator OriginalAimRot = OriginalAimDir.Rotation();

			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;

			AdjustedAimDir = AdjustedAimRot.Vector();
		}
	}

	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
}

bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
{
	FVector CameraToCenter = AbilityCenter - CameraLocation;
	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
	if (DotToCenter >= 0)		//If this fails, we're pointed away from the center, but we might be inside the sphere and able to find a good exit point.
	{
		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
		float RadiusSquared = (AbilityRange * AbilityRange);
		if (DistanceSquared <= RadiusSquared)
		{
			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
			float DistanceAlongRay = DotToCenter + DistanceFromCamera;						//Subtracting instead of adding will get the other intersection point
			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);		//Cam aim point clipped to range sphere
			return true;
		}
	}
	return false;
}

void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
{
	TArray<FInteractionOption> NewOptions;

	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
	{
		TArray<FInteractionOption> TempOptions;
		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);

		for (FInteractionOption& Option : TempOptions)
		{
			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;

			// if there is a handle an a target ability system, we're triggering the ability on the target.
			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
			{
				// Find the spec
				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
			}
			// If there's an interaction ability then we're activating it on ourselves.
			else if (Option.InteractionAbilityToGrant)
			{
				// Find the spec
				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);

				if (InteractionAbilitySpec)
				{
					// update the option
					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
				}
			}
			if (Option.HoldInteractionAbilityToGrant)
			{
				// Find the spec
				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);

				if (InteractionAbilitySpec)
				{
					// update the option
					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
				}
			}
			if (InteractionAbilitySpec)
			{
				// Filter any options that we can't activate right now for whatever reason.
				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
				{
					NewOptions.Add(Option);
				}
			}
		}
	}

	bool bOptionsChanged = false;
	if (NewOptions.Num() == CurrentOptions.Num())
	{
		NewOptions.Sort();

		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
		{
			const FInteractionOption& NewOption = NewOptions[OptionIndex];
			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];

			if (NewOption != CurrentOption)
			{
				bOptionsChanged = true;
				break;
			}
		}
	}
	else
	{
		bOptionsChanged = true;
	}

	if (bOptionsChanged)
	{
		CurrentOptions = NewOptions;
		InteractableObjectsChanged.Broadcast(CurrentOptions);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"

#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "Kismet/GameplayStatics.h"

UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
	bool bShowDebug)
{
	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
	MyObj->InteractionScanRange = InteractionScanRange;
	MyObj->InteractionScanRate = InteractionScanRate;
	MyObj->StartLocation = StartLocation;
	MyObj->InteractionQuery = InteractionQuery;
	MyObj->TraceProfile = TraceProfile;
	MyObj->bShowDebug = bShowDebug;

	return MyObj;
}
void UAT_WaitForInteractable_SLT::Activate()
{
	SetWaitingOnAvatar();

	UWorld* World = GetWorld();
	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
}

void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
{
	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().ClearTimer(TimerHandle);
	}

	Super::OnDestroy(AbilityEnded);
}

void UAT_WaitForInteractable_SLT::PerformTrace()
{
	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
	
	if (!AvatarActor)
	{
		return;
	}

	UWorld* World = GetWorld();

	TArray<AActor*> ActorsToIgnore;
	ActorsToIgnore.Add(AvatarActor);

	const bool bTraceComplex = false;
	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
	Params.AddIgnoredActors(ActorsToIgnore);
	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
	FVector2D ViewportSize;
	GEngine->GameViewport->GetViewportSize(ViewportSize);
	const FVector2D ViewportCenter = ViewportSize / 2.f;
	FVector TraceStart;
	FVector Forward;
	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;

	
	FVector TraceEnd;
	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);

	FHitResult OutHitResult;
	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);

	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);

	UpdateInteractableOptions(InteractionQuery, InteractableTargets);

#if ENABLE_DRAW_DEBUG
	if (bShowDebug)
	{
		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
		if (OutHitResult.bBlockingHit)
		{
			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
		}
		else
		{
			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
		}
	}
#endif // ENABLE_DRAW_DEBUG
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/GameplayAbility_Interact.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
#include "AbilitySystem/Interaction/InteractionStatics.h"
#include "NativeGameplayTags.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "Engine/World.h"
#include "Player/WitchPTPlayerController.h"

UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");

UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
}

void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
	const FGameplayEventData* TriggerEventData)
{
	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
	{
		
		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
		Task->ReadyForActivation();
		
	}
}

void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
{
	
	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
	{
		
		
		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
		
		CurrentOptions = InteractiveOptions;
		
		for (const FInteractionOption& InteractionOption : InteractiveOptions)
		{
			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
		
			if (InteractableTargetActor)
			{
				FString ActorName = InteractableTargetActor->GetName();
				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
			}
			
			
		}
		if (InteractiveOptions.Num() == 0)
		{
			WitchPt->HUDWidget->HidePickupMessage();
		}

	}
	
	CurrentOptions = InteractiveOptions;
}

void UGameplayAbility_Interact::TriggerInteraction()
{
	if (CurrentOptions.Num() == 0)
	{
		return;
	}

	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	if (AbilitySystem)
	{
		const FInteractionOption& InteractionOption = CurrentOptions[0];

		AActor* Instigator = GetAvatarActorFromActorInfo();
		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

		// Allow the target to customize the event data we're about to pass in, in case the ability needs custom data
		// that only the actor knows.
		FGameplayEventData Payload;
		Payload.EventTag = TAG_Ability_Interaction_Activate;
		Payload.Instigator = Instigator;
		Payload.Target = InteractableTargetActor;

		// If needed we allow the interactable target to manipulate the event data so that for example, a button on the wall
		// may want to specify a door actor to execute the ability on, so it might choose to override Target to be the
		// door actor.
		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
		

		// Grab the target actor off the payload we're going to use it as the 'avatar' for the interaction, and the
		// source InteractableTarget actor as the owner actor.
		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));

		// The actor info needed for the interaction.
		FGameplayAbilityActorInfo ActorInfo;
		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);

		// Trigger the ability using event tag.
		
		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
			InteractionOption.TargetInteractionAbilityHandle,
			&ActorInfo,
			TAG_Ability_Interaction_Activate,
			&Payload,
			*InteractionOption.TargetAbilitySystem
		);
		
		// Notificar que se completó la interacción
		OnInteractionComplete.Broadcast();
	}
}

void UGameplayAbility_Interact::TriggerHoldInteraction()
{
	if (CurrentOptions.Num() == 0)
	{
		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
		OnInteractionCancelled.Broadcast();
		return;
	}

	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
	if (AbilitySystem)
	{
		const FInteractionOption& InteractionOption = CurrentOptions[0];

		// Verificar si la opción de interacción soporta interacción mantenida
		if (!InteractionOption.bSupportsHoldInteraction)
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
			// Si no soporta interacción mantenida, podemos usar la interacción normal en su lugar
			TriggerInteraction();
			return;
		}

		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
		
		AActor* Instigator = GetAvatarActorFromActorInfo();
		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

		// Configurar los datos del evento para la interacción mantenida
		FGameplayEventData Payload;
		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
		Payload.Instigator = Instigator;
		Payload.Target = InteractableTargetActor;

		// Permitir que el objetivo personalice los datos del evento
		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);

		// Obtener el actor objetivo
		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));

		// La información del actor necesaria para la interacción
		FGameplayAbilityActorInfo ActorInfo;
		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);

		// Usar el handle de habilidad específico para interacción mantenida, si está disponible
		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
		
		// Si no hay un handle específico para interacción mantenida, usar el handle normal
		if (!AbilityHandle.IsValid())
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
		}

		// Activar la habilidad usando la etiqueta de evento de interacción mantenida
		// UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Intentando activar habilidad con tag %s"), *TAG_Ability_Interaction_Hold_Activate.ToString());
		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
			AbilityHandle,
			&ActorInfo,
			TAG_Ability_Interaction_Hold_Activate,
			&Payload,
			*InteractionOption.TargetAbilitySystem
		);
		
		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
		
		// Notificar que se completó la interacción mantenida
		OnHoldInteractionComplete.Broadcast();
	}
}

void UGameplayAbility_Interact::OnInteractionButtonPressed()
{
	if (CurrentOptions.Num() == 0)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No hay opciones de interacción disponibles"));
		OnInteractionCancelled.Broadcast();
		return;
	}
	
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción presionado"));
	bIsInteractionButtonHeld = true;
	bHoldInteractionFired = false; // Reiniciamos la bandera al comenzar una nueva interacción
	InteractionStartTime = GetWorld()->GetTimeSeconds();
	
	// Guardar el objetivo interactuable actual para validaciones posteriores
	if (CurrentOptions.Num() > 0)
	{
		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Guardando objetivo inicial de interacción"));
	}
	
	// Configurar un temporizador para detectar si el botón se mantiene presionado durante el tiempo requerido
	GetWorld()->GetTimerManager().SetTimer(
		HoldInteractionTimerHandle,
		this,
		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
		HoldInteractionTime,
		false
	);
	
	// Iniciar comprobación periódica de validez
	GetWorld()->GetTimerManager().SetTimer(
		ValidityCheckTimerHandle,
		this,
		&UGameplayAbility_Interact::CheckInteractionValidity,
		ValidityCheckRate,
		true // Repetitivo
	);
	
	// Configurar el temporizador de seguridad para forzar un reinicio después de un tiempo máximo
	GetWorld()->GetTimerManager().SetTimer(
		MaxInteractionTimeTimerHandle,
		this,
		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
		MaxInteractionTime,
		false // No repetitivo
	);
	
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizadores configurados. Hold: %f segundos, Max: %f segundos"), 
	// 	HoldInteractionTime, MaxInteractionTime);
}

void UGameplayAbility_Interact::OnInteractionButtonReleased()
{
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción liberado"));
	
	if (!bIsInteractionButtonHeld)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón no estaba siendo mantenido, ignorando liberación"));
		return;
	}
	
	bIsInteractionButtonHeld = false;
	
	// Cancelar los temporizadores
	if (GetWorld())
	{
		// Temporizador de validez
		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
		}
		
		// Temporizador de seguridad
		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
		}
		
		// Temporizador de interacción mantenida
		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
		{
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizador de hold cancelado"));
			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
			
			// Verificamos si ya se lanzó una interacción mantenida
			if (bHoldInteractionFired)
			{
				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Ya se disparó una interacción mantenida, ignorando interacción rápida"));
				return; // Si ya se disparó una interacción mantenida, no lanzamos la rápida
			}
			
			// Si el botón se soltó antes del tiempo de interacción mantenida, considerarlo como una pulsación rápida
			float CurrentTime = GetWorld()->GetTimeSeconds();
			float HoldTime = CurrentTime - InteractionStartTime;
			
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo mantenido: %f / Requerido: %f"), HoldTime, HoldInteractionTime);
			
			if (HoldTime < HoldInteractionTime)
			{
				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción rápida"));
				// Llamar a la interacción de pulsación rápida
				TriggerInteraction();
				
				// Llamar a InteractPressScan después de la interacción para restaurar el estado
				// y prepararse para la siguiente interacción
				// Nota: Esto debe implementarse en el blueprint conectando la salida de este nodo
				// a la entrada del nodo InteractPressScan
			}
		}
		else
		{
			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No había temporizador activo al liberar el botón"));
		}
	}
	
	// Limpiar la referencia al objetivo inicial
	InitialInteractableTarget = nullptr;
}

void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
{
	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo de interacción mantenida alcanzado"));
	
	if (bIsInteractionButtonHeld)
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción mantenida"));
		// Marcamos que ya se disparó la interacción mantenida
		bHoldInteractionFired = true;
		
		// El botón se ha mantenido presionado durante el tiempo requerido
		// Llamar a la interacción mantenida
		TriggerHoldInteraction();
		
		// Nota: Después de llamar a TriggerHoldInteraction, 
		// es necesario llamar a InteractPressScan en el blueprint
		// para restaurar el estado y prepararse para la siguiente interacción
		// Esto se logra escuchando al delegado OnHoldInteractionComplete
	}
	else
	{
		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón ya no está presionado, no se activa interacción mantenida"));
	}
}

void UGameplayAbility_Interact::CheckInteractionValidity()
{
	// Si no estamos en un estado de interacción, no necesitamos verificar
	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
	{
		return;
	}
	
	// Log adicional para verificar estado actual
	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
	
	// Verificar si aún hay opciones de interacción disponibles
	bool bHasValidInteraction = false;
	
	if (CurrentOptions.Num() > 0)
	{
		// Buscar el objetivo inicial en cualquier posición del array
		for (const FInteractionOption& Option : CurrentOptions)
		{
			if (Option.InteractableTarget == InitialInteractableTarget)
			{
				bHasValidInteraction = true;
				break;
			}
		}
		
		// Log detallado sobre la validación
		if (bHasValidInteraction)
		{
			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
		}
		else
		{
			// Intentar identificar qué cambió
			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
			AActor* CurrentActor = CurrentOptions.Num() > 0 ? 
				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
			
			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"), 
				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
		}
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
	}
	
	// Si no hay una interacción válida, cancelar la interacción actual
	if (!bHasValidInteraction)
	{
		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
		CancelCurrentInteraction();
	}
}

void UGameplayAbility_Interact::CancelCurrentInteraction()
{
	// Si no estamos en un estado de interacción, no hay nada que cancelar
	if (!bIsInteractionButtonHeld)
	{
		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
		return;
	}
	
	// Obtener información del objeto inicial para el log
	FString InitialObjectName = TEXT("Desconocido");
	if (InitialInteractableTarget.GetInterface())
	{
		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
		if (InitialActor)
		{
			InitialObjectName = InitialActor->GetName();
		}
	}
	
	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
	
	// Detener temporizadores
	if (GetWorld())
	{
		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
		}
		
		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
		}
		
		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
		{
			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
		}
	}
	
	// Restablecer variables de estado
	bIsInteractionButtonHeld = false;
	bHoldInteractionFired = false;
	
	// Hacer una copia de la referencia antes de limpiarla para poder notificar
	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
	InitialInteractableTarget = nullptr;
	
	// Log para confirmar que el estado ha sido restablecido
	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
	
	// Notificar la cancelación
	OnInteractionCancelled.Broadcast();
}

void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
{
	// Si todavía estamos en un estado de interacción, forzar una cancelación
	if (bIsInteractionButtonHeld)
	{
		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
		CancelCurrentInteraction();
		
		// Forzar un reinicio del escaneo de interacciones
		OnInteractionCancelled.Broadcast();
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/Interaction/InteractionStatics.h"

#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "Engine/OverlapResult.h"

UInteractionStatics::UInteractionStatics()
	: Super(FObjectInitializer::Get())
{
}

AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
{
	if (UObject* Object = InteractableTarget.GetObject())
	{
		if (AActor* Actor = Cast<AActor>(Object))
		{
			return Actor;
		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
		{
			AActor* ActorToReturn = ActorComponent->GetOwner();
			return ActorToReturn;
		} else
		{
			unimplemented()
		}
	}
	return nullptr;
}

void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	// If the actor is directly interactable, return that.
	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
	if (InteractableActor)
	{
		OutInteractableTargets.Add(InteractableActor);
	}

	// If the actor isn't interactable, it might have a component that has a interactable interface.
	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
	for (UActorComponent* InteractableComponent : InteractableComponents)
	{
		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
	}
}

void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	for (const FOverlapResult& Overlap : OverlapResults)
	{
		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
		if (InteractableActor)
		{
			OutInteractableTargets.AddUnique(InteractableActor);
		}

		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
		if (InteractableComponent)
		{
			OutInteractableTargets.AddUnique(InteractableComponent);
		}
	}
}

void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
	if (InteractableActor)
	{
		OutInteractableTargets.AddUnique(InteractableActor);
	}

	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
	if (InteractableComponent)
	{
		OutInteractableTargets.AddUnique(InteractableComponent);
	}
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemComponent.h"

#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"


void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
{
	if (!AbilitiesToGrant.IsEmpty())
	{
		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
		{
			if (!AbilityClass)
			{
				continue;
			}
			
			// Obtener la clase de habilidad para acceder a la propiedad StartupInputTag
			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
			if (!AbilityCDO)
			{
				continue;
			}
			
			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
			// Source of the ability is the ASC
			AbilitySpec.SourceObject = this;
			// Add the startup input tag to the ability spec
			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
			// Give the ability to the ASC
			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
			// Store the handle of the ability
			GrantedAbilities.Add(AbilitySpecHandle);
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			// print each ability
			
			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
			{
				//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, AbilitySpec.Ability->GetName());
				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
{
	if (!InputTag.IsValid()) return;
	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
	{
		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
		{
			AbilitySpecInputPressed(AbilitySpec);
			if (!AbilitySpec.IsActive())
			{
				TryActivateAbility(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
			{
				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
			}
		}
	}
}

void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
{
	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
}

void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
{
		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
	AbilitiesToActivate.Reset();
	//
	// Process all abilities that activate when the input is held.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
	{
		
		
		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
			{
				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
				{
					// --- MODIFICACION AQUI ---
					// Solo añadir si la política es WhileInputActive y NO es la nueva On Triggered Event
					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
					{
						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
					}
				}
			}
		}
	}
	//
	// Process all abilities that had their input pressed this frame.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
	{
		
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = true;

				if (AbilitySpec->IsActive())
				{
					
					
					// Ability is active so pass along the input event.
					AbilitySpecInputPressed(*AbilitySpec);
				}
				else
				{
					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);

					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
					{
						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
						{
							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
						}
					}
				}
			}
		}
	}
	//
	// Try to activate all the abilities that are from presses and holds.
	// We do it all at once so that held inputs don't activate the ability
	// and then also send a input event to the ability because of the press.
	//
	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
	{
		TryActivateAbility(AbilitySpecHandle);
	}
	//
	// Process all abilities that had their input released this frame.
	//
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
	{
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = false;

				if (AbilitySpec->IsActive())
				{
					// Ability is active so pass along the input event.
					AbilitySpecInputReleased(*AbilitySpec);
				}
			}
		}
	}

	//
	// Clear the cached ability handles.
	//
	InputPressedSpecHandles.Reset();
	InputReleasedSpecHandles.Reset();
	
}

void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputPressed(Spec);
	// We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputPress ability task works.
	if (Spec.IsActive())
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
		PRAGMA_ENABLE_DEPRECATION_WARNINGS

		// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
	}
	
}

void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputReleased(Spec);
	// We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputRelease ability task works.
	if (Spec.IsActive())
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
		PRAGMA_ENABLE_DEPRECATION_WARNINGS

		// Invoke the InputReleased event. This is not replicated here. If someone is listening, they may replicate the InputReleased event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
	}
}

void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
{
	FGameplayTagContainer TagContainer;
	EffectSpec.GetAllAssetTags(TagContainer);

	OnEffectAssetTags.Broadcast(TagContainer);
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemGlobals.h"
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAbilitySystemLibrary.h"

#include "Item/MechanicsInterface.h"

TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
{
	if (!Actor)
	{
		return TScriptInterface<IMechanicsInterface>();
		
	}
	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
	if (ComponentsImplementingInterface.Num() > 0)
	{
		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
	}
	return TScriptInterface<IMechanicsInterface>();
}
</file>

<file path="WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "AbilitySystem/WitchPTAttributeSet.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayEffectExtension.h"
#include "GameFramework/Character.h"
#include "Net/UnrealNetwork.h"
#include "WitchPT/WitchPT.h"

void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
	
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)

	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)


}

UWitchPTAttributeSet::UWitchPTAttributeSet()
{
}

void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);
}

void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
{
	Super::PostGameplayEffectExecute(Data);
	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
	{
		// SetMoveSpeed(FMath::Clamp(GetMoveSpeed(), 0.f, GetMaxMoveSpeed()));
	}
	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
	{
		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
	}
}

void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
}

void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
}
void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
}

void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
}

void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
}

void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
}

void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
}

void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
}

void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
}

void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
}

void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
}

void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
}

void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
}

void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
}

void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
}
</file>

<file path="WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/Components/WitchPTCharacterMovementComponent.h"

#include "AbilitySystemComponent.h"
#include "GameplayTagContainer.h"
#include "Character/WitchPTCharacterBase.h"



UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
{
	
	PrimaryComponentTick.bCanEverTick = true;


}

float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
{
	
	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());

	if (!Owner)
	{
		
		return Super::GetMaxSpeed();
	}

	
	
	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
	{
		
		return 0.0f;
	}

	float FinalSpeed = Owner->GetMoveSpeed();
	if (RequestToStartSprinting)
	{
		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
		
	}
	// else if (RequestToStartCrouching)
	// {
	// 	// FinalSpeed = Owner->GetMoveSpeed() * CrouchSpeedMultiplier;
	// 	// UE_LOG(LogTemp, Warning, TEXT("Character %s is Crouching - Speed: %f"), *GetOwner()->GetName(), FinalSpeed);
	// }

	
	return FinalSpeed;
}

void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
{
	Super::UpdateFromCompressedFlags(Flags);
}

class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
{
	return Super::GetPredictionData_Client();
}


void UWitchPTCharacterMovementComponent::StartSprinting()
{
	RequestToStartSprinting = true;
}

void UWitchPTCharacterMovementComponent::StopSprinting()
{
	RequestToStartSprinting = false;
}

void UWitchPTCharacterMovementComponent::StartAimDownSights()
{
	RequestToStartADS = true;
}

void UWitchPTCharacterMovementComponent::StopAimDownSights()
{
	RequestToStartADS = false;
	
}
</file>

<file path="WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/Components/WitchPTMechanicComponent.h"
#include "Item/CauldronAltar.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h"

// Sets default values for this component's properties
UWitchPTMechanicComponent::UWitchPTMechanicComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.
	PrimaryComponentTick.bCanEverTick = true;
	SetIsReplicatedByDefault(true);
}

void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	// Agregar propiedades replicadas aquí si es necesario
}

// Called when the game starts
void UWitchPTMechanicComponent::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void UWitchPTMechanicComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
}

// --- RITUAL IMPLEMENTATION ---
void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (Character->HasAuthority())
	{
		TargetAltar->StartBrewingPotion(Character);
	}
}

void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->StartCarryCauldron(Character);
	}
	
}

void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}

	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (!Character)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->StartPlacementPreview(Character);
	}
}

void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
	}
}

void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->CancelPlacement();
	}
	
}

void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
{
	if (!TargetAltar)
	{
		return;
	}
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		// Si estamos en el servidor, llamamos directamente
		TargetAltar->FinalizePlacement();
	}

}

void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
{
	if (!TargetCauldron) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetCauldron->UnoccupyPosition(Character, nullptr);
	}
}

void UWitchPTMechanicComponent::RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	
	if(GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
	}
	else
	{
		Server_RequestSetBaseIngredient(TargetAltar, IngredientItemDef);
	}

	
	
}

void UWitchPTMechanicComponent::Server_RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
	
}

void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
{
	
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->OccupyPosition(Character, Position);
	}
	
}

void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
	ABaseInteractionPosition* Position)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->UnoccupyPosition(Character, Position);
	}
	
}

void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->StartRitual(Character);
	}
}

void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
{
	if (!TargetAltar) return;
	ACharacter* Character = Cast<ACharacter>(GetOwner());
	if (GetOwnerRole() == ROLE_Authority)
	{
		TargetAltar->HandlePlayerInput(Character, InputTag);
	}
}
</file>

<file path="WitchPT/Private/Character/WitchPTCharacter.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTCharacter.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Character/Components/WitchPTMechanicComponent.h"
#include "Item/RitualAltar.h"
#include "Item/RitualPosition.h"
#include "Player/WitchPTPlayerController.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "WitchPT/WitchPT.h"


// Sets default values
AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	// Initialize the MechanicComponent
	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
	
}

void AWitchPTCharacter::PossessedBy(AController* NewController)
{
	Super::PossessedBy(NewController);

	// Init ability actor info for the Server
	InitAbilityActorInfo();
	

	// Solo conceder habilidades si AbilitySystemComponent fue inicializado correctamente
	if (AbilitySystemComponent)
	{
		GrantStartupAbilities();
		AddStartupEffects();
	}
}

void AWitchPTCharacter::OnRep_PlayerState()
{
	Super::OnRep_PlayerState();
	// Init ability actor info for the Client
	InitAbilityActorInfo();
	AddStartupEffects();
}

void AWitchPTCharacter::InitAbilityActorInfo()
{
	Super::InitAbilityActorInfo();
	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
	
	if (!WitchPtPlayerState)
	{
		return;
	}
	
	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);

	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
	if (!AbilitySystemComponent)
	{
		return;
	}
	
	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
	

	
	/*
	* Here we initialize the Overlay because we have all the data we need: the player controller, player state, ability system component and attribute set.
	* Also, the HUD is accessible from the player controller.
	*/
	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
	{
		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
		{
			WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
		}
	}
	InitializeDefaultAttributes();
}
</file>

<file path="WitchPT/Private/Character/WitchPTCharacterBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTCharacterBase.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Character/Components/WitchPTCharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"

// Sets default values
AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
{
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);

}

UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}



// Called to bind functionality to input
void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

}

void AWitchPTCharacterBase::InitializeDefaultAttributes()
{
	ApplyGameplayEffectToSelf(DefaultAttributes);
	
	
}

void AWitchPTCharacterBase::GrantStartupAbilities()
{
	if (!HasAuthority()) return;
	
	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
	
	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
}

void AWitchPTCharacterBase::AddStartupEffects()
{
	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
	{
		return;
	}

	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
	EffectContext.AddSourceObject(this);

	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
	{
		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
		if (NewHandle.IsValid())
		{
			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
		}
	}

	AbilitySystemComponent->bStartupEffectsApplied = true;
}

void AWitchPTCharacterBase::InitAbilityActorInfo()
{
}

void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
{
	check(IsValid(GetAbilitySystemComponent()));
	check(GameplayEffectClass);
	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
	EffectContextHandle.AddSourceObject(this);
	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
	
}

float AWitchPTCharacterBase::GetHealth() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetHealth();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxHealth() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxHealth();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetStamina() const
{
	if (IsValid(AttributeSet))	
	{
		return AttributeSet->GetStamina();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxStamina() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxStamina();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetAge() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetAge();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxAge() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxAge();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMana() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMana();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxMana() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxMana();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetSpeedMultiplier() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetSpeedMultiplier();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMoveSpeed() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMoveSpeed();
	}
	return 0.f;
}

float AWitchPTCharacterBase::GetMaxMoveSpeed() const
{
	if (IsValid(AttributeSet))
	{
		return AttributeSet->GetMaxMoveSpeed();
	}
	return 0.f;
}
</file>

<file path="WitchPT/Private/Character/WitchPTEnemy.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/WitchPTEnemy.h"


// Sets default values
AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AWitchPTEnemy::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AWitchPTEnemy::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

// Called to bind functionality to input
void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
	// Test commit again
}
</file>

<file path="WitchPT/Private/Game/WitchPTGameModeBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Game/WitchPTGameModeBase.h"
</file>

<file path="WitchPT/Private/Input/WitchPTInputComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Input/WitchPTInputComponent.h"
</file>

<file path="WitchPT/Private/Input/WitchPTInputConfig.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Input/WitchPTInputConfig.h"

const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
{
	for (const FWitchPTInputAction& Pair: AbilityInputActions)
	{
		if (InputTag == Pair.InputTag)
		{
			return Pair.InputAction;
		}
	}
	if (bLogNotFound)
	{
		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
	}
	return nullptr;
	
}
</file>

<file path="WitchPT/Private/Inventory/Collectable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Collectable.h"

#include "Inventory/WitchPTInventoryManagerComponent.h"

UCollectableStatics::UCollectableStatics()
: Super(FObjectInitializer::Get())
{
}

TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
{
	TScriptInterface<ICollectable> PickupableActor(Actor);
	if (PickupableActor)
	{
		return PickupableActor;
	}
	
	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
	if (PickupableComponents.Num() > 0)
	{
		return TScriptInterface<ICollectable>(PickupableComponents[0]);
	}

	return TScriptInterface<ICollectable>();
}


void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
	TScriptInterface<ICollectable> Collectable)
{
	if (InventoryComponent && Collectable)
	{
		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
	}
}
</file>

<file path="WitchPT/Private/Inventory/FastArray/FastArrayList.cpp">
#pragma once

#include "Inventory/FastArray/FastArrayList.h"

#include "CoreMinimal.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"


class FLifetimeProperty;
struct FReplicationFlags;
//////////////////////////////////////////////////////////////////////
// FWitchPTInventoryEntry
FString FWitchPTInventoryEntry::GetDebugString() const
{
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
	if (Instance != nullptr)
	{
		ItemDef = Instance->GetItemDef();
	}

	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
}



//////////////////////////////////////////////////////////////////////
// FWitchPTInventoryList
void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	for (int32 Index : RemovedIndices)
	{
		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
	}
}

void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	for (int32 Index : AddedIndices)
	{
		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
	}
}

void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
	if (!IsValid(IMC)) return;
	
	for (int32 Index : ChangedIndices)
	{
		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
	}
}

UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	UWitchPTInventoryItemInstance* Result = nullptr;

	check(ItemDef != nullptr);
	check(OwnerComponent);

	AActor* OwningActor = OwnerComponent->GetOwner();
	check(OwningActor->HasAuthority());


	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
	NewEntry.Instance->SetItemDef(ItemDef);
	// ------ Stack stuff
	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
	if (IsValid(StackableFragment))
	{
		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
	}
	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
	{
		if (Fragment != nullptr)
		{
			Fragment->OnInstanceCreated(NewEntry.Instance);
		}
	}

	Result = NewEntry.Instance;
	
	
	MarkItemDirty(NewEntry);

	return Result;
}

void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
{
	unimplemented();
}

void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
{
	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
	{
		FWitchPTInventoryEntry& Entry = *EntryIt;
		if (Entry.Instance == Instance)
		{
			EntryIt.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}
TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
{
	TArray<UWitchPTInventoryItemInstance*> Results;
	Results.Reserve(Entries.Num());
	for (const FWitchPTInventoryEntry& Entry : Entries)
	{
		if (Entry.Instance != nullptr) //@TODO: Would prefer to not deal with this here and hide it further?
		{
			Results.Add(Entry.Instance);
		}
	}
	return Results;
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"

#include "Inventory/WitchPTInventoryItemInstance.h"

void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
{
	
}
</file>

<file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
</file>

<file path="WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/InventoryFunctionLibrary.h"

#include "Kismet/GameplayStatics.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/WitchPTWidgetController.h"

UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			
			return WitchPTHUD->SetInventoryWidgetController(WCParams);
		}
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryFunctionLibrary.h"

#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
{
	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
	{
		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryItemDefinition.h"

#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)

{
}

const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
{
	if (FragmentClass != nullptr)
	{
		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
		{
			if (Fragment && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryItemInstance.h"

#include "GameplayTagContainer.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Net/UnrealNetwork.h"
#include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
class FLifetimeProperty;
UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{
}

void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	DOREPLIFETIME(ThisClass, ItemDef);
	DOREPLIFETIME(ThisClass, TotalStackCount);
}



void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
{
	ItemDef = InDef;
}


const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
{
	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
	{
		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}

	return nullptr;
}
</file>

<file path="WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Inventory/WitchPTInventoryManagerComponent.h"

#include "Blueprint/UserWidget.h"
#include "Engine/ActorChannel.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
#include "Net/UnrealNetwork.h"
#include "UI/Widgets/Inventory/InventoryUserWidget.h"


#include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)


void UWitchPTInventoryManagerComponent::BeginPlay()
{
	Super::BeginPlay();
	ConstructInventory();
}

UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
	, InventoryList(this)
{
	PrimaryComponentTick.bCanEverTick = false;
	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
}
void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, InventoryList);
}

// --------------- Inventory Manager Component Functions ---------------------------

void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	if(IsValid(ItemDef))
	{
		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
		
		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
		Server_UpdateItemStackCount(FoundItem, NewStackCount);
	}
}

void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
{
	if (IsValid(ItemInstance))
	{
		ItemInstance->SetTotalStackCount(NewCount);
		
		// Marcar la entrada como sucia para la replicación
		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
		{
			if (Entry.Instance == ItemInstance)
			{
				InventoryList.MarkItemDirty(Entry);
				break;
			}
		}
		
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemStackChanged.Broadcast(ItemInstance);
		}
	}
}

void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
{
	if (IsValid(ItemInstance))
	{
		// Notificar antes de eliminar para que los listeners puedan usar la información del item
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemRemoved.Broadcast(ItemInstance);
		}
		
		// Eliminar el item de la lista de inventario
		InventoryList.RemoveEntry(ItemInstance);
		
		// Desregistrar el subobjeto para la replicación
		if (IsUsingRegisteredSubObjectList())
		{
			RemoveReplicatedSubObject(ItemInstance);
		}
	}
}

void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
{
	if (IsValid(ItemInstance))
	{
		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
		
		// Si el nuevo conteo es cero, eliminar el item completamente
		if (NewCount <= 0)
		{
			Server_RemoveItemInstance(ItemInstance);
		}
		else
		{
			// Actualizar el conteo de stacks
			Server_UpdateItemStackCount(ItemInstance, NewCount);
		}
	}
}

TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
{
	return InventoryList.GetAllItems();
}

bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	if (!ItemDef)
	{
		return false;
	}
	
	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
	if (FoundItem)
	{
		Server_AddStacksToItem(ItemDef);
		return false;
	}
	else
	{
		Server_AddItem(ItemDef);
		return true;
	}
}



void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
{
	UWitchPTInventoryItemInstance* NewItem = nullptr;
	if (ItemDef != nullptr)
	{
		NewItem = InventoryList.AddEntry(ItemDef);
		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
		{
			OnItemAdded.Broadcast(NewItem);
		}
	
		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
		{
			AddReplicatedSubObject(NewItem);
		}
	}
	
}



// void UWitchPTInventoryManagerComponent::RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance)
// {
// 	InventoryList.RemoveEntry(ItemInstance);
//
// 	if (ItemInstance && IsUsingRegisteredSubObjectList())
// 	{
// 		RemoveReplicatedSubObject(ItemInstance);
// 	}
// }


UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
{
	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (IsValid(Instance))
		{
			if (Instance->GetItemDef() == ItemDef)
			{
				return Instance;
			}
		}
	}

	return nullptr;
}

int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
{
	int32 TotalCount = 0;
	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (IsValid(Instance))
		{
			if (Instance->GetItemDef() == ItemDef)
			{
				++TotalCount;
			}
		}
	}

	return TotalCount;
}

bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
	int32 NumToConsume)
{
	AActor* OwningActor = GetOwner();
	if (!OwningActor || !OwningActor->HasAuthority())
	{
		return false;
	}

	//@TODO: N squared right now as there's no acceleration structure
	int32 TotalConsumed = 0;
	while (TotalConsumed < NumToConsume)
	{
		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
		{
			InventoryList.RemoveEntry(Instance);
			++TotalConsumed;
		}
		else
		{
			return false;
		}
	}

	return TotalConsumed == NumToConsume;
}


bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
                                                            FReplicationFlags* RepFlags)
{
	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
	{
		UWitchPTInventoryItemInstance* Instance = Entry.Instance;

		if (Instance && IsValid(Instance))
		{
			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return WroteSomething;
}

void UWitchPTInventoryManagerComponent::ReadyForReplication()
{
	Super::ReadyForReplication();
	
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
		{
			UWitchPTInventoryItemInstance* Instance = Entry.Instance;

			if (IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}

void UWitchPTInventoryManagerComponent::ToggleInventoryMenu()
{
	if (bInventoryMenuOpen)
	{
		CloseInventoryMenu();
	}
	else
	{
		OpenInventoryMenu();
	}
}

void UWitchPTInventoryManagerComponent::ConstructInventory()
{
	OwningController = Cast<APlayerController>(GetOwner());
	checkf(OwningController.IsValid(), TEXT("Inventory Component should have a Player Controller as Owner."))
	if (!OwningController->IsLocalController()) return;
	InventoryMenu = CreateWidget<UInventoryUserWidget>(OwningController.Get(), InventoryMenuClass);
	InventoryMenu->AddToViewport();
	CloseInventoryMenu();
}

void UWitchPTInventoryManagerComponent::OpenInventoryMenu()
{
	if (!IsValid(InventoryMenu)) return;

	InventoryMenu->SetVisibility(ESlateVisibility::Visible);
	bInventoryMenuOpen = true;

	if (!OwningController.IsValid()) return;

	FInputModeGameAndUI InputMode;
	
	OwningController->SetInputMode(InputMode);
	OwningController->SetShowMouseCursor(true);
}

void UWitchPTInventoryManagerComponent::CloseInventoryMenu()
{
	if (!IsValid(InventoryMenu)) return;

	InventoryMenu->SetVisibility(ESlateVisibility::Collapsed);
	bInventoryMenuOpen = false;

	if (!OwningController.IsValid()) return;

	FInputModeGameOnly InputMode;
	OwningController->SetInputMode(InputMode);
	OwningController->SetShowMouseCursor(false);
}
</file>

<file path="WitchPT/Private/Item/BaseInteractableAltar.cpp">
#include "Item/BaseInteractableAltar.h"

#include "FWitchPTGameplayTags.h"
#include "Item/BaseInteractionPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h"
#include "Item/RitualPosition.h"

// Sets default values
ABaseInteractableAltar::ABaseInteractableAltar()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;

    // Make sure it replicates
    bReplicates = true;
    bAlwaysRelevant = true;
    
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
    TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);

}

void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
    DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
    DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
    DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
  
}

// Called when the game starts or when spawned
void ABaseInteractableAltar::BeginPlay()
{
    Super::BeginPlay();
    
    // Initialize interaction positions
    CreateAltarPositions();
}

// Called every frame
void ABaseInteractableAltar::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    // Child classes will implement specific tick behavior
}



void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
{
    if (!Player || !Position || !HasAuthority())
    {
        return;
    }

    Position->SetOccupied(nullptr);

    // Remove from participating players if they're not in the list
    ParticipatingPlayers.Remove(Player);
    
}
void ABaseInteractableAltar::CreateAltarPositions()
{
    if (!HasAuthority() || !PositionClass)
    {
        return;
    }
    
    // Make sure we have no previous positions
    DestroyAltarPositions();
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
    int positionIndex = 0;
    // Spawn a CauldronPosition for each transform
    for (const FTransform& PosTransform : PositionTransforms)
    {
        // Transform relative to world space
        FTransform WorldTransform = PosTransform * GetActorTransform();
        
        // Get location and rotation from the transform
        FVector Location = WorldTransform.GetLocation();
        FRotator Rotation = WorldTransform.Rotator();
        
        // Spawn parameters
        FActorSpawnParameters SpawnParams;
        SpawnParams.Owner = this;
        SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
        
        // Spawn the brewing position
        ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
            PositionClass, 
            Location, 
            Rotation, 
            SpawnParams);
        
        if (NewPosition)
        {
            // Initialize the position
            // Note: Implement this method in CauldronPosition if needed
            // NewPosition->SetCauldronAltar(this);
            NewPosition->SetPositionTag(TagsPositions[positionIndex]);
            ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
            if (RitualPosition)
            {
                RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
            }
            positionIndex++;

            
            // Add to our array
            InteractionPositions.Add(NewPosition);
            
            UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
        }
    }
}



void ABaseInteractableAltar::DestroyAltarPositions()
{
    // Only destroy positions on the server
    if (!HasAuthority())
    {
        return;
    }
    
    // Destroy all brewing positions
    for (ABaseInteractionPosition* Position : InteractionPositions)
    {
        if (Position)
        {
            Position->Destroy();
        }
    }
    
    // Clear the array
    InteractionPositions.Empty();
    
    UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
}


void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
{
    // Update visuals or play sounds based on state change
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
}

void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
{
    // Play success feedback
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
}

void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
{
    // Play failure feedback
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
}



void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
{
    // Update client-side UI or visuals for players
}


void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
{
    // Base implementation - to be overridden by child classes
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
}

void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
{
   
}

void ABaseInteractableAltar::CheckState()
{
    // Base implementation - to be overridden by child classes
    // This would check if the interaction is complete or failed
}

void ABaseInteractableAltar::CleanupInteraction()
{
   
}

void ABaseInteractableAltar::SpawnReward()
{
   
}

void ABaseInteractableAltar::SpawnDemon()
{
    
}

bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
{
    // Base implementation - to be overridden by child classes
    // Check if the player is valid and in the participating list
    return Player && ParticipatingPlayers.Contains(Player);
}
</file>

<file path="WitchPT/Private/Item/BaseInteractionPosition.cpp">
#include "Item/BaseInteractionPosition.h"
#include "Net/UnrealNetwork.h"
#include "Engine/ActorChannel.h"
#include "AbilitySystemComponent.h"
#include "Components/BoxComponent.h"
#include "GameFramework/Character.h"

ABaseInteractionPosition::ABaseInteractionPosition()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;
    
    // Make sure this actor replicates
    bReplicates = true;
    bAlwaysRelevant = true;
}

void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    
    // Replicate the occupied state and occupying character
    DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
    DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
    DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
    
    // PositionTag and Altar are usually set once and don't need replication unless they can change dynamically
}

void ABaseInteractionPosition::BeginPlay()
{
    Super::BeginPlay();

    // Additional initialization could go here if needed
}

void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    // This should be overridden by derived classes
    Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
}

bool ABaseInteractionPosition::IsOccupied() const
{
    return bIsOccupied;
}

void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
{
    if (GetLocalRole() != ROLE_Authority)
    {
        return;
    }

    OccupyingCharacter = Character;
    bIsOccupied = (Character != nullptr);
}

void ABaseInteractionPosition::SetUnoccupied()
{
    if (GetLocalRole() != ROLE_Authority)
    {
        return;
    }

    RemoveCharacterFromPosition();
}

void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
{
    PositionTag = NewTag;
}

void ABaseInteractionPosition::OnRep_IsOccupied()
{
    // Handle any visuals or sounds when occupation state changes
}

void ABaseInteractionPosition::OnRep_OccupyingCharacter()
{
    // Handle any visuals or sounds when the occupying character changes
}

void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
    // Base implementation - should be overridden by child classes
    UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
        *GetName(), *InteractingCharacter->GetName());
}

void ABaseInteractionPosition::RemoveCharacterFromPosition()
{
    OccupyingCharacter = nullptr;
    bIsOccupied = false;
}
</file>

<file path="WitchPT/Private/Item/CauldronAltar.cpp">
#include "Item/CauldronAltar.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "Item/CauldronPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Kismet/GameplayStatics.h"
#include "TimerManager.h"
#include "Components/SkeletalMeshComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/World.h"
#include "DrawDebugHelpers.h"
#include "FWitchPTGameplayTags.h"
#include "Engine/ActorChannel.h"
#include "Inventory/WitchPTInventoryItemDefinition.h"
#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
#include "Player/WitchPTPlayerController.h"

// Sets default values
ACauldronAltar::ACauldronAltar()
{
    // Set this actor to call Tick() every frame
    PrimaryActorTick.bCanEverTick = true;

    // Make sure it replicates
    bReplicates = true;
    bAlwaysRelevant = true;
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    bReplicateUsingRegisteredSubObjectList = true;
    
}

void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    // Set up the interaction option based on the cauldron state
    FInteractionOption InteractionOption = Option;
    
    // Configure the interaction option to support hold interaction
    InteractionOption.bSupportsHoldInteraction = true;
    
    // Add the interaction option to the builder
    OptionBuilder.AddInteractionOption(InteractionOption);
}

void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    
    DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
    DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
    DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
    DOREPLIFETIME(ACauldronAltar, BaseIngredientIcon);
    DOREPLIFETIME(ACauldronAltar, PrincipalIngredientIcon);
    DOREPLIFETIME(ACauldronAltar, ModifierIngredientIcon);
    
}


void ACauldronAltar::OnRep_CauldronPhysicState()
{
    // Update visual representation based on the new state
    if (CauldronPhysicState == ECauldronPhysicState::Moving)
    {
        // Cauldron is being carried - update visuals if needed
        SetActorEnableCollision(false);
    }
    else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
    {
        // Cauldron is in preview mode - update visuals
        SetActorEnableCollision(false);
        
        
    }
    
}



void ACauldronAltar::OnRep_BaseIngredientIcon()
{
    BroadcastBaseIngredientIconSet();
}

void ACauldronAltar::OnRep_PrincipalIngredientIcon()
{
    BroadcastPrincipalIngredientIconSet();
}

void ACauldronAltar::OnRep_PotentiatorIngredientIcon()
{
    BroadcastModifierIngredientIconSet();
}

// --- Interaction Functions ---

void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
{
    if (!InteractingCharacter)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
        return;
    }
    
    // Si el caldero está en modo de previsualización, finalizar la colocación
    if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
    {
        FinalizePlacement();
        return;
    }
    
    // Otherwise, try to position the character for brewing
    PositionCharacterForBrewing(InteractingCharacter);
}

void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
{
    if (!HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Not authority"));
        return;
    }

    if (CauldronPhysicState != ECauldronPhysicState::Static)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
        return;
    }

    AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
    if (!PC)
    {
        UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
        return;
    }

    UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
    if (!InventoryManager)
    {
        UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
        return;
    }
    
    UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);

    if (!InstanceFromInventory)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
        return;
    }
    
    const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
    if (!IngredientCraftingDetails)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
        return;
    }

    // Determine ingredient type based on SlotUsageTag
    const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
    bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
    bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
    bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);

    // Check if the appropriate slot is already occupied
    if (bIsBaseIngredient && BaseIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
        return;
    }
    
    if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
        return;
    }
    
    if (bIsModifierIngredient && ModifierIngredient != nullptr)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
        return;
    }

    // If none of the slot usage tags match, this ingredient can't be used
    if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
        return;
    }
    
    bool bConsumedSuccessfully = false;
    int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
    
    if (CurrentStackCount > 0)
    {
        UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
        
        if (CurrentStackCount == 1)
        {
            IngredientToSet = InstanceFromInventory;
            InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
            bConsumedSuccessfully = true;
        }
        else
        {
            InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
            IngredientToSet = InstanceFromInventory;
            bConsumedSuccessfully = true;
        }
        
        // Get UI fragment for icon
        const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
        TSubclassOf<UUserWidget> IngredientIcon = nullptr;
        if (IsValid(UIFragment))
        {
            IngredientIcon = UIFragment->IconWidget;
        }
        
        // Set the ingredient in the appropriate slot
        if (bIsBaseIngredient)
        {
            BaseIngredient = IngredientToSet;
            BaseIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient set successfully"));
            
            if (HasAuthority())
            {
                BroadcastBaseIngredientIconSet();
            }
        }
        else if (bIsPrincipalIngredient)
        {
            PrincipalIngredient = IngredientToSet;
            PrincipalIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient set successfully"));
            
            if (HasAuthority())
            {
                BroadcastPrincipalIngredientIconSet();
            }
        }
        else if (bIsModifierIngredient)
        {
            ModifierIngredient = IngredientToSet;
            ModifierIngredientIcon = IngredientIcon;
            UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient set successfully"));
            
            if (HasAuthority())
            {
                BroadcastModifierIngredientIconSet();
            }
        }
    }
}


void ACauldronAltar::BeginPlay()
{
    Super::BeginPlay();
    SetReplicateMovement(true);
}

bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
    FReplicationFlags* RepFlags)
{
    return Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
}


void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
{
    if (!InteractingCharacter)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
        return;
    }
    
    // Si el caldero está en modo de previsualización, cancelar y volver a adjuntar al personaje
    if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
    {
        CancelPlacement();
        return;
    }
    
    // Check if the cauldron can be picked up
    if (!CanBePickedUp())
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
        return;
    }
    
    // Attach the cauldron to the character
    AttachToCharacter(InteractingCharacter);
}

bool ACauldronAltar::CanBePickedUp() const
{
    // Check if the cauldron is already being carried
    if (IsBeingCarried() || IsInPlacementPreview())
    {
        return false;
    }
    
    // Add any additional conditions here (e.g., cauldron is empty, not brewing, etc.)
    
    return true;
}

bool ACauldronAltar::IsBeingCarried() const
{
    return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
}

bool ACauldronAltar::IsInPlacementPreview() const
{
    return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
}


ACharacter* ACauldronAltar::GetCarryingCharacter() const
{
    return CarryingCharacter;
}

void ACauldronAltar::AttachToCharacter(ACharacter* Character)
{
    if (!Character || !HasAuthority())
    {
        return;
    }
    
    // First destroy any brewing positions
    DestroyAltarPositions();
    
    // Set the cauldron state to moving
    CauldronPhysicState = ECauldronPhysicState::Moving;
    CarryingCharacter = Character;
    
    // Attach the cauldron to the character's back
    FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget, 
                                          EAttachmentRule::KeepWorld, true);
    
    // Find the socket to attach to
    USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
    if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
    {
        // Attach to the socket
        AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
        
        // Disable collision
        SetActorEnableCollision(false);
        
        // Reduce de Scale of the Cauldron
        SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
        
        UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
    }
    

}

void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
{
    if (!Character || !HasAuthority() || Character != CarryingCharacter)
    {
        return;
    }
    
    // Detach from the character
    DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
    
    // Place the cauldron in front of the character
    FVector CharacterLocation = Character->GetActorLocation();
    FRotator CharacterRotation = Character->GetActorRotation();
    FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
    
    // Set the cauldron's location
    SetActorLocation(CharacterLocation + PlacementOffset);
    
    // Reset the cauldron state
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    
    // Reset cauldron scale to normal
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    
    // Enable collision
    SetActorEnableCollision(true);
    
    // Create brewing positions around the cauldron
    CreateAltarPositions();
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
    
    // Play placement sound or effects
    // PlayPlacementEffects();
}

void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
{
    if (!Character || !HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
        return;
    }
    
    // Obtener una posición disponible
    ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
    
    if (BrewingPosition)
    {
        Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
        ParticipatingPlayers.Add(Character);
        
        if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
        {
            
            if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                PC->LocalToggleCauldronMenu();
            }
        } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
        {
           
            if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                PC->Client_ToggleCauldronMenu();
            }
        }
        FGameplayEventData Payload;
        Payload.OptionalObject = Character;
        FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
        UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
        return BrewingPosition->SetOccupied(Character);

        // Teleport the character to the position facing the cauldron
        

    }
  

    

    // Call the ritual state delegate for Listen Server
  
}


ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
{
    // Verificar que tengamos posiciones
    if (InteractionPositions.Num() == 0)
    {
        UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
        return nullptr;
    }
    
    // Buscar la primera posición disponible
    for (ABaseInteractionPosition* Position : InteractionPositions)
    {
        if (Position && !Position->IsOccupied())
        {
            return Position;
        }
    }
    
    // Todas las posiciones están ocupadas
    UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
    
    return nullptr;
}

// --- Nueva implementación para colocación del caldero ---

void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
{
    if (!Character || Character != CarryingCharacter || !HasAuthority())
    {
        return;
    }
    
    // Desacoplar el caldero del personaje
    DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
    
    // Establecer el estado de previsualización
    CauldronPhysicState = ECauldronPhysicState::Previewing;
    
    // Guardar los materiales originales para restaurarlos después
    UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
    if (MeshComponent)
    {
        OriginalMaterials.Empty();
        for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
        {
            OriginalMaterials.Add(MeshComponent->GetMaterial(i));
        }
    }
    
    // Aplicar material de previsualización
    CurrentPlacementState = ECauldronPlacementState::Invalid; // Por defecto, inválido hasta que se verifique
    // ApplyPlacementPreviewMaterial();
    
    // Desactivar colisiones durante la previsualización
    SetActorEnableCollision(false);
    
    // Colocar inicialmente el caldero frente al personaje
    FVector CharacterLocation = Character->GetActorLocation();
    FRotator CharacterRotation = Character->GetActorRotation();
    FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);

    // Guardar la posición inicial
    PreviewLocation = CharacterLocation + PlacementOffset;
    // PreviewRotation = CharacterRotation;
    // Reset z rotation
    PreviewRotation.Pitch = 0;
    PreviewRotation.Roll = 0;
    PreviewRotation.Yaw = 0;
    // Establecer la posición del caldero
    SetActorLocation(PreviewLocation);
    SetActorRotation(PreviewRotation);
    
    // Restablecer la escala normal
    Multicast_FinalizePlacement();
    
    
}

void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
{
   
    
    // Actualizar el material según el estado
    // ApplyPlacementPreviewMaterial();
}

void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
{
    // Llamar a la implementación del cliente para actualizar la previsualización
    // Client_UpdatePlacementPreview(HitLocation, HitNormal);
    if (!IsInPlacementPreview())
    {
        return;
    }
    
    // Guardar la nueva posición de previsualización
    PreviewLocation = HitLocation;
    
    // Calcular la rotación para alinear con la superficie
    FRotator SurfaceAlignedRotation = HitNormal.Rotation();
    
    // Ajustar la rotación para que el caldero se alinee con la superficie pero mantenga su orientación "hacia arriba"
    // Necesitamos solo el componente de inclinación de la superficie
    FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
    
    // Limitar la inclinación máxima
    if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
    {
        AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
    }
    
    if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
    {
        AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
    }
    
    PreviewRotation = AdjustedRotation;
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorLocation(PreviewLocation);
    
    
    // Verificar si la posición es válida
    CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
}



void ACauldronAltar::FinalizePlacement()
{
    if (!IsInPlacementPreview() || !HasAuthority())
    {
        return;
    }
    
    // Establecer la posición final
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorLocation(PreviewLocation);
    SetActorRotation(PreviewRotation);
    
    // Restaurar los materiales originales
    RestoreOriginalMaterials();
    
    // Activar colisiones
    SetActorEnableCollision(true);
    
    // Cambiar el estado
    CauldronPhysicState = ECauldronPhysicState::Static;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    
    OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
    
    // Crear posiciones de elaboración alrededor del caldero
    CreateAltarPositions();

    // Multicast finalizar placement
    Multicast_FinalizePlacement();

    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
}

void ACauldronAltar::CancelPlacement()
{
    if (!IsInPlacementPreview() || !HasAuthority())
    {
        return;
    }
    
    // Restaurar materiales originales
    RestoreOriginalMaterials();
    
    // Recolocar el caldero en el personaje
    ACharacter* Character = CarryingCharacter;
    
    // Reiniciar estado
    CauldronPhysicState = ECauldronPhysicState::Moving;
    CarryingCharacter = nullptr;
    CurrentPlacementState = ECauldronPlacementState::None;
    
    // Volver a adjuntar el caldero al personaje
    if (Character)
    {
        AttachToCharacter(Character);
    }
    
    UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
}

void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
{
    // Find the position occupied by the player
    for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
    {
        if(PositionOccupied->GetOccupyingCharacter() == Character)
        {
            // Close the cauldron menu
             if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
        {
            
            if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                PC->LocalToggleCauldronMenu();
                
            }
        } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
        {
           
            if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
            {
                PC->Client_ToggleCauldronMenu();
                
            }
        }
            PositionOccupied->SetOccupied(nullptr);
            break;
        }
    }
    
}




void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
{
    // Reset de scale for all clients
    SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
    SetActorEnableCollision(true);
}

ECauldronPlacementState ACauldronAltar::GetPlacementState() const
{
    return CurrentPlacementState;
}

void ACauldronAltar::ApplyPlacementPreviewMaterial()
{
    UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
    if (!MeshComponent)
    {
        return;
    }
    
    // Determinar qué material aplicar según el estado
    UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ? 
        ValidPlacementMaterial : InvalidPlacementMaterial;
    
    // Si no tenemos un material específico, no hacemos nada
    if (!MaterialToApply)
    {
        return;
    }
    
    // Aplicar el material a todos los elementos del mesh
    for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
    {
        MeshComponent->SetMaterial(i, MaterialToApply);
    }
}

void ACauldronAltar::RestoreOriginalMaterials()
{
    // Restaurar los materiales originales si estamos fuera del modo de previsualización
    if (CauldronPhysicState != ECauldronPhysicState::Previewing)
    {
        UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
        if (MeshComponent && OriginalMaterials.Num() > 0)
        {
            for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
            {
                if (OriginalMaterials[i])
                {
                    MeshComponent->SetMaterial(i, OriginalMaterials[i]);
                }
            }
        }
    }
}

bool ACauldronAltar::IsPlacementValid() const
{
    if (!GetWorld())
    {
        return false;
    }
    
    // 1. Comprobar si hay objetos en el radio de colisión
    TArray<FOverlapResult> Overlaps;
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);
    
    if (CarryingCharacter)
    {
        QueryParams.AddIgnoredActor(CarryingCharacter);
    }
    
    bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
        Overlaps,
        PreviewLocation,
        FQuat::Identity,
        FCollisionObjectQueryParams::AllObjects,
        FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
        QueryParams
    );
    
    if (bHasOverlaps)
    {
        // Encontramos solapamientos, verificar si son relevantes
        for (const FOverlapResult& Overlap : Overlaps)
        {
            // Ignorar actores que no tienen colisión (podrían ser efectos visuales, etc.)
            if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
            {
                // Si encontramos algún actor con colisión, la posición no es válida
                return false;
            }
        }
    }
    
    // 2. Comprobar si el caldero está alineado con el suelo
    // Hacer un trazado hacia abajo para ver si hay suelo cerca
    FHitResult HitResult;
    FVector TraceStart = PreviewLocation;
    FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
    
    bool bHitGround = GetWorld()->LineTraceSingleByChannel(
        HitResult,
        TraceStart,
        TraceEnd,
        ECC_Visibility,
        QueryParams
    );
    
    if (!bHitGround)
    {
        // No encontramos suelo debajo del caldero
        return false;
    }
    
    // Comprobar la distancia al suelo
    float DistanceToGround = (HitResult.Location - TraceStart).Size();
    if (DistanceToGround > MaxGroundAlignmentHeight)
    {
        // El caldero está demasiado lejos del suelo
        return false;
    }
    
    // La posición es válida
    return true;
} 
// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
void ACauldronAltar::BroadcastBaseIngredientDropped() const
{
    OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
}

void ACauldronAltar::BroadcastBaseIngredientIconSet() const
{
    OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
}

void ACauldronAltar::BroadcastPrincipalIngredientDropped() const
{
    OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
}

void ACauldronAltar::BroadcastPrincipalIngredientIconSet() const
{
    OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
}

void ACauldronAltar::BroadcastModifierIngredientDropped() const
{
    OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
}

void ACauldronAltar::BroadcastModifierIngredientIconSet() const
{
    OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
}

UWitchPTInventoryItemInstance* ACauldronAltar::GetBaseIngredient() const
{
    return BaseIngredient;
}

UWitchPTInventoryItemInstance* ACauldronAltar::GetPrincipalIngredient() const
{
    return PrincipalIngredient;
}

UWitchPTInventoryItemInstance* ACauldronAltar::GetModifierIngredient() const
{
    return ModifierIngredient;
}
</file>

<file path="WitchPT/Private/Item/CauldronPosition.cpp">
#include "Item/CauldronPosition.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/Character.h"
#include "Item/CauldronAltar.h" // Include the Altar header
#include "Kismet/GameplayStatics.h"

ACauldronPosition::ACauldronPosition()
{
    // No need to set up replication here - it's handled by the base class
    bIsOccupied = false;
    OccupyingCharacter = nullptr;
}

void ACauldronPosition::BeginPlay()
{
    Super::BeginPlay();
    
    // // Try to find the CauldronAltar if it wasn't set in the editor
    // if (!CauldronAltar)
    // {
    //     FindCauldronAltar();
    // }
}

void ACauldronPosition::FindCauldronAltar()
{
    // First check if we are attached to an altar
    // AActor* ParentActor = GetAttachParentActor();
    // if (ParentActor)
    // {
    //     ACauldronAltar* PotentialAltar = Cast<ACauldronAltar>(ParentActor);
    //     if (PotentialAltar)
    //     {
    //         CauldronAltar = PotentialAltar;
    //         UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found attached CauldronAltar %s"), 
    //             *GetName(), *CauldronAltar->GetName());
    //         return;
    //     }
    // }
    //
    // // If not attached, try to find any altar in the world
    // TArray<AActor*> FoundAltars;
    // UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundAltars);
    //
    // if (FoundAltars.Num() > 0)
    // {
    //     CauldronAltar = Cast<ACauldronAltar>(FoundAltars[0]);
    //     UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found world CauldronAltar %s"), 
    //         *GetName(), *CauldronAltar->GetName());
    // }
    // else
    // {
    //     UE_LOG(LogTemp, Warning, TEXT("[CauldronPosition] %s couldn't find a CauldronAltar!"), *GetName());
    // }
}

void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
    Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
    
    // // Cauldron-specific interaction options
    //
    // ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
    //
    // // If no player is occupying the position, let a player take the position
    // if (!IsOccupied() && InteractingCharacterPtr)
    // {
    //     OptionBuilder.AddDefaultInteraction(
    //         FText::FromString("Take Position"), // Text for the interaction
    //         [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
    //         {
    //             HandleInteraction(InteractingCharacterPtr);
    //         }
    //     );
    // }
    //
    // // Special case: if the character is standing at a position and we're in Inactive state, they can initiate brewing
    // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
    // {
    //     // Check cauldron state
    //     if (CauldronAltar->GetCurrentState() == EInteractionState::Inactive)
    //     {
    //         OptionBuilder.AddDefaultInteraction(
    //             FText::FromString("Start Brewing"), // Text for the interaction
    //             [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
    //             {
    //                 if (CauldronAltar)
    //                 {
    //                     // Cast to the appropriate start brewing function
    //                     CauldronAltar->StartBrewing(InteractingCharacterPtr);
    //                 }
    //             }
    //         );
    //     }
    // }
    //
    // // If this player is at a position and brewing is active, they can add ingredients
    // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
    // {
    //     if (CauldronAltar->GetCurrentState() == EInteractionState::Active)
    //     {
    //         // Get the player's current expected input
    //         FGameplayTag ExpectedInput = CauldronAltar->GetCurrentExpectedInputForPlayer(InteractingCharacterPtr);
    //         
    //         if (ExpectedInput.IsValid())
    //         {
    //             // Determine the ingredient name
    //             FString TagString = ExpectedInput.ToString();
    //             FString IngredientName = "Unknown Ingredient";
    //             
    //             if (TagString.Contains("Ingredient1"))
    //             {
    //                 IngredientName = "Red Mushroom";
    //             }
    //             else if (TagString.Contains("Ingredient2"))
    //             {
    //                 IngredientName = "Frog Leg";
    //             }
    //             else if (TagString.Contains("Ingredient3"))
    //             {
    //                 IngredientName = "Bat Wing";
    //             }
    //             else if (TagString.Contains("Ingredient4"))
    //             {
    //                 IngredientName = "Snake Venom";
    //             }
    //             else if (TagString.Contains("Ingredient5"))
    //             {
    //                 IngredientName = "Dragon Scale";
    //             }
    //             
    //             // Give the player the option to add the correct ingredient
    //             OptionBuilder.AddDefaultInteraction(
    //                 FText::FromString(FString::Printf(TEXT("Add %s"), *IngredientName)),
    //                 [this, InteractingCharacterPtr, ExpectedInput](const FInteractionExecuteContext& Context)
    //                 {
    //                     if (CauldronAltar)
    //                     {
    //                         CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, ExpectedInput);
    //                     }
    //                 }
    //             );
    //             
    //             // Also add wrong ingredient options for fun/challenge
    //             for (int32 i = 1; i <= 5; ++i)
    //             {
    //                 FString WrongTagString = FString::Printf(TEXT("Input.Cauldron.Ingredient%d"), i);
    //                 FGameplayTag WrongTag = FGameplayTag::RequestGameplayTag(FName(*WrongTagString));
    //                 
    //                 // Skip if this is the correct ingredient
    //                 if (WrongTag == ExpectedInput)
    //                 {
    //                     continue;
    //                 }
    //                 
    //                 // Determine wrong ingredient name
    //                 FString WrongIngredientName = "Unknown Ingredient";
    //                 switch (i)
    //                 {
    //                 case 1: WrongIngredientName = "Red Mushroom"; break;
    //                 case 2: WrongIngredientName = "Frog Leg"; break;
    //                 case 3: WrongIngredientName = "Bat Wing"; break;
    //                 case 4: WrongIngredientName = "Snake Venom"; break;
    //                 case 5: WrongIngredientName = "Dragon Scale"; break;
    //                 }
    //                 
    //                 OptionBuilder.AddDefaultInteraction(
    //                     FText::FromString(FString::Printf(TEXT("Add %s"), *WrongIngredientName)),
    //                     [this, InteractingCharacterPtr, WrongTag](const FInteractionExecuteContext& Context)
    //                     {
    //                         if (CauldronAltar)
    //                         {
    //                             CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, WrongTag);
    //                         }
    //                     }
    //                 );
    //             }
    //         }
    //     }
    // }
}

void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
    Super::HandleInteraction(InteractingCharacter);
    
    if (!InteractingCharacter || !CauldronAltar)
    {
        return;
    }
    
    // Call the cauldron altar to handle occupation
    // CauldronAltar->OccupyPosition(InteractingCharacter, this);
}

// bool ACauldronPosition::PositionCharacter(ACharacter* Character)
// {
//     if (!Character)
//     {
//         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Invalid character"));
//         return false;
//     }
//     
//     // No permitir posicionar si ya está ocupado
//     if (bIsOccupied && OccupyingCharacter != Character)
//     {
//         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Position already occupied"));
//         return false;
//     }
//     
//     // Teleportar al personaje a la ubicación de este actor
//     FVector TargetLocation = GetActorLocation();
//     FRotator TargetRotation = GetActorRotation();
//     
//     bool bSuccess = Character->SetActorLocationAndRotation(
//         TargetLocation, 
//         TargetRotation, 
//         false, 
//         nullptr, 
//         ETeleportType::TeleportPhysics);
//     
//     if (bSuccess)
//     {
//         // Marcar esta posición como ocupada
//         SetOccupied(true, Character);
//         
//         UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::PositionCharacter: Character positioned at %s"), 
//                *GetName());
//     }
//     
//     return bSuccess;
// }
//
// bool ACauldronPosition::IsOccupied() const
// {
//     return bIsOccupied && OccupyingCharacter != nullptr;
// }
//
// void ACauldronPosition::SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter)
// {
//     bIsOccupied = bInOccupied;
//     
//     if (bInOccupied)
//     {
//         OccupyingCharacter = InOccupyingCharacter;
//     }
//     else
//     {
//         OccupyingCharacter = nullptr;
//     }
//     
//     UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::SetOccupied: %s is now %s"), 
//            *GetName(), bIsOccupied ? TEXT("occupied") : TEXT("unoccupied"));
// }
</file>

<file path="WitchPT/Private/Item/Ingredient/IngredientBase.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Ingredient/IngredientBase.h"


// Sets default values
AIngredientBase::AIngredientBase()
{
	
}

void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
	FInteractionOptionBuilder& OptionBuilder)
{
	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
}

FItemManifest AIngredientBase::GetPickupInventory() const
{
	return StaticInventory;
}
</file>

<file path="WitchPT/Private/Item/Item.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Item.h"


// Sets default values
AItem::AItem()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AItem::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AItem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
	OptionBuilder.AddInteractionOption(Option);
}
</file>

<file path="WitchPT/Private/Item/MechanicsInterface.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/MechanicsInterface.h"

// Add default functionality here for any IMechanicsInterface functions that are not pure virtual.
</file>

<file path="WitchPT/Private/Item/PositionInterface.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/PositionInterface.h"

// Add default functionality here for any IPositionInterface functions that are not pure virtual.
</file>

<file path="WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/Ritual/RitualFunctionLibrary.h"

#include "Kismet/GameplayStatics.h"
#include "Player/WitchPTPlayerState.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/WitchPTWidgetController.h"

URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			
			return WitchPTHUD->SetRitualWidgetController(WCParams);
		}
	}
	return nullptr;
}

UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
		{
			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();
			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
			return WitchPTHUD->SetCauldronWidgetController(WCParams);
		}
	}
	return nullptr;
}
</file>

<file path="WitchPT/Private/Item/RitualAltar.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Item/RitualAltar.h"
#include "Net/UnrealNetwork.h"
#include "Item/RitualPosition.h"
#include "GameFramework/Character.h"
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"
#include "Player/WitchPTPlayerController.h"

// Sets default values
ARitualAltar::ARitualAltar()
{
	// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true; 

	bReplicates = true;
	
	// Default values
	CurrentRitualState = EInteractionState::Inactive;
	CurrentSequenceIndex = -1;
	CurrentInputTimer = 0.0f;
	CorruptionAmount = 0.0f;
	MaxCorruption = 100.0f;
	StartCountdown = 3;
	bRitualCompleted = false;
	bRitualWasSuccessful = false;
}

void ARitualAltar::BeginPlay()
{
	Super::BeginPlay();
	
	// // Auto-discover RitualPositions if not set in editor
	// if (RitualPositions.Num() == 0 && HasAuthority())
	// {
	// 	TArray<AActor*> FoundActors;
	// 	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ARitualPosition::StaticClass(), FoundActors);
	// 	
	// 	for (AActor* Actor : FoundActors)
	// 	{
	// 		ARitualPosition* Position = Cast<ARitualPosition>(Actor);
	// 		if (Position)
	// 		{
	// 			RitualPositions.Add(Position);
	// 			Position->SetRitualAltar(this);
	// 		}
	// 	}
	// }
}

void ARitualAltar::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
	DOREPLIFETIME(ARitualAltar, InputSequence);
	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
	DOREPLIFETIME(ARitualAltar, MaxCorruption);
	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
	DOREPLIFETIME(ARitualAltar, StartCountdown);
	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
}

// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //

void ARitualAltar::OnRep_CurrentRitualState()
{
	BroadcastRitualStateChanged();
}

void ARitualAltar::OnRep_CurrentSequenceIndex()
{
	// Just broadcast sequence progress change - turn data updates are handled by OnRep_TurnData
	BroadcastSequenceProgressChanged();
}

void ARitualAltar::OnRep_ReadyPlayersData()
{
	BroadcastReadyPlayersChanged();
}

void ARitualAltar::OnRep_StartCountdown()
{
	BroadcastCountdownTick();
}

void ARitualAltar::OnRep_CurrentActivePlayer()
{
	// Turn data updates are handled by OnRep_TurnData
	// This OnRep function is kept for potential future use
}

void ARitualAltar::OnRep_TurnData()
{
	BroadcastTurnDataChanged();
}

void ARitualAltar::OnRep_CorruptionAmount()
{
	BroadcastCorruptionChanged();
}

void ARitualAltar::OnRep_RitualCompleted()
{
	if (bRitualCompleted)
	{
		BroadcastRitualCompleted();
	}
}

// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //

void ARitualAltar::BroadcastRitualStateChanged()
{
	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
}

void ARitualAltar::BroadcastReadyPlayersChanged()
{
	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
}

void ARitualAltar::BroadcastCountdownTick()
{
	OnCountdownTickEvent.Broadcast(StartCountdown);
}

void ARitualAltar::BroadcastTurnDataChanged()
{
	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
}

void ARitualAltar::BroadcastCorruptionChanged()
{
	float CorruptionPercentage = GetCorruptionPercentage();
	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
}

void ARitualAltar::BroadcastSequenceProgressChanged()
{
	float Progress = GetCurrentSequenceProgress();
	OnSequenceProgressChangedEvent.Broadcast(Progress);
}

void ARitualAltar::BroadcastRitualCompleted()
{
	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
}

// ----------------------------------- HELPER FUNCTIONS ---------------------------------------------- //

void ARitualAltar::UpdateTurnData()
{
	// This function can be called on both server and clients
	// On server: updates the replicated CurrentTurnData
	// On clients: called from OnRep functions to update local UI data
	
	FUIRitualData NewTurnData;
	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
	
	// Set expected input if we have valid data
	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
	{
		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
	}
	else
	{
		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
	}
	
	// Always set bIsMyTurn to false here - the widget controller will determine the correct value
	NewTurnData.bIsMyTurn = false;
	
	// On server, update the replicated data if it has changed
	if (HasAuthority())
	{
		// Only update if data has changed to avoid unnecessary replication
		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
		{
			CurrentTurnData = NewTurnData;
			// Broadcast on server for local UI updates (OnRep will handle clients)
			BroadcastTurnDataChanged();
		}
	}
	else
	{
		// On clients, just update the local data and broadcast
		CurrentTurnData = NewTurnData;
		BroadcastTurnDataChanged();
	}
}

void ARitualAltar::UpdateReadyPlayersData()
{
	if (!HasAuthority())
	{
		return;
	}
	
	FRitualReadyPlayersData NewData;
	NewData.TotalPlayers = ParticipatingPlayers.Num();
	NewData.ReadyPlayers = ReadyPlayers.Num();
	
	if (ReadyPlayersData != NewData)
	{
		ReadyPlayersData = NewData;
		// Broadcast on server for local UI updates (OnRep will handle clients)
		BroadcastReadyPlayersChanged();
	}
}

// ----------------------------------- EXISTING FUNCTIONS (UPDATED) ---------------------------------------------- //

void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
{
	// This is now handled by OnRep_ReadyPlayersData, but keeping for backward compatibility
	UpdateReadyPlayersData();
}

void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
{
	if (!HasAuthority() || !RequestingCharacter)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
		return;
	}
	
	// Check if the ritual is in a valid state
	if (CurrentRitualState != EInteractionState::Inactive && 
	    CurrentRitualState != EInteractionState::WaitingForPlayers)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
		return;
	}
	
	// Process the ready request
	ProcessRitualReadyRequest(RequestingCharacter);
}

void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
{
	if (!HasAuthority() || !RequestingCharacter)
	{
		return;
	}
	
	// Check if player is already in the ready list
	if (ReadyPlayers.Contains(RequestingCharacter))
	{
		// Player is already ready, could allow them to un-ready if desired
		ReadyPlayers.Remove(RequestingCharacter);
		UpdateReadyPlayersData();
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
		return;
	}
	
	// Add player to ready list
	ReadyPlayers.Add(RequestingCharacter);
	UpdateReadyPlayersData();
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
	
	// Check if all players are ready
	if (AreAllPlayersReady())
	{
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
		StartRitualCountdown();
	}
}

bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
{
	return ReadyPlayers.Contains(Player);
}

bool ARitualAltar::AreAllPlayersReady() const
{
	// Check if all participating players are in the ready list
	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
	{
		return false;
	}
	
	for (ACharacter* Player : ParticipatingPlayers)
	{
		if (!ReadyPlayers.Contains(Player))
		{
			return false;
		}
	}
	
	return true;
}

void ARitualAltar::StartRitualCountdown()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Set the state to preparing
	CurrentRitualState = EInteractionState::Preparing;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastRitualStateChanged();

	// Generate the ritual input sequence
	GenerateInputSequence();
	
	// Reset countdown value
	StartCountdown = 3;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastCountdownTick();
	
	// Start countdown timer
	GetWorldTimerManager().SetTimer(
		RitualStartCountdownHandle,
		this,
		&ARitualAltar::ProcessCountdownTick,
		1.0f,  // Fire every second
		true   // Looping
	);
}

void ARitualAltar::ProcessCountdownTick()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Decrease countdown
	StartCountdown--;
	// Broadcast on server for local UI updates (OnRep will handle clients)
	BroadcastCountdownTick();
	
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
	
	if (StartCountdown <= 0)
	{
		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
		ActivateRitual();
	}
}

void ARitualAltar::ActivateRitual()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Set initial active player (from ready list)
	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
	
	// Fallback
	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
	CurrentSequenceIndex = 0;
	CurrentRitualState = EInteractionState::Active;
	
	// Start the input timer (this updates CurrentInputTimer)
	StartInputTimer();

	// Now update turn data with all the new values
	UpdateTurnData();
	
	// Broadcast state change on server for local UI updates (OnRep will handle clients)
	BroadcastRitualStateChanged();
}

void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
{
	// This is now handled by OnRep_StartCountdown, but keeping for backward compatibility
	StartCountdown = CountdownValue;
}

void ARitualAltar::GenerateInputSequence()
{
	if (!HasAuthority())
	{
		return;
	}
	
	InputSequence.Empty();
	
	// Number of inputs scales with the number of players and difficulty
	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
	
	// Get gameplay tags from the native tag manager
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	TArray<FGameplayTag> PossibleInputs;
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
	
	// Generate random sequence
	for (int32 i = 0; i < SequenceLength; ++i)
	{
		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
		InputSequence.Add(PossibleInputs[RandomIndex]);
	}
	
	// Reset sequence index
	
	
}

void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
{
	if (!Character || !HasAuthority())
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
		return;
	}
	
	// Check if the ritual is active
	if (CurrentRitualState != EInteractionState::Active)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"), 
			*Character->GetName(), static_cast<int32>(CurrentRitualState));
		return;
	}
	
	// Check if it's this player's turn
	if (Character != CurrentActivePlayer)
	{
		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"), 
			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
		return;
	}
	
	// Check if we have a valid input to match against
	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
	{
		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"), 
			CurrentSequenceIndex, InputSequence.Num());
		return;
	}
	
	// Get the expected input for the current step
	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
	
	
	// Check if the input matches
	if (InputTag == ExpectedInput)
	{
		HandleInputSuccess(Character);
	}
	else
	{
		HandleInputFailure(Character);
	}
}

void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
{
	
	if (Character)
	{
		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
		if (ASC)
		{
			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
			FGameplayEventData EventData;
			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
			EventData.Instigator = this;
			EventData.Target = Character;
			
			// Buscar el tag de posición del jugador en el array
			FGameplayTag* PositionTag = nullptr;
			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
			{
				if (Entry.Player == Character)
				{
					PositionTag = &Entry.PositionTag;
					break;
				}
			}
			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
			{
				EventData.OptionalObject = PrimaryAnimMontage;
			} else
			{
				EventData.OptionalObject = SecondaryAnimMontage;
			}
			
			
			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
		}
		
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
	}
}

void ARitualAltar::HandleInputSuccess(ACharacter* Player)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Cancel the input timer
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	
	// Advance to the next input
	CurrentSequenceIndex++;

	// Send success feedback
	Multicast_OnInputSuccess(Player);
	
	// Check if the sequence is complete
	if (CurrentSequenceIndex >= InputSequence.Num())
	{
		// Ritual succeeded
		CurrentRitualState = EInteractionState::Succeeded;
		bRitualCompleted = true;
		bRitualWasSuccessful = true;
		
		// Update turn data with final state
		UpdateTurnData();
		
		// Broadcast state and completion on server for local UI updates
		BroadcastRitualStateChanged();
		BroadcastRitualCompleted();
		
		// Spawn reward and notify
		SpawnReward();
		Multicast_OnRitualSucceeded();
		
		// Clean up
		CleanupRitual();
	}
	else
	{
		// Move to the next player's turn (this updates CurrentActivePlayer)
		AdvanceToNextPlayer();
		
		// Start the input timer (this updates CurrentInputTimer)
		StartInputTimer();
		
		// Now update turn data with all the new values
		UpdateTurnData();
	}
}

void ARitualAltar::HandleInputFailure(ACharacter* Player)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Cancel the input timer
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	
	// Increase corruption
	CorruptionAmount += CorruptionIncreasePerFail;
	// Broadcast corruption change on server for local UI updates
	BroadcastCorruptionChanged();
	
	// DO NOT advance to the next input on failure - only on success
	// CurrentSequenceIndex++; // REMOVED: Failed inputs should not advance the sequence

	// Apply age penalty to the player
	ApplyAgePenalty(Player);
	
	// Send failure feedback
	Multicast_OnInputFailed(Player);
	
	// Check if corruption has reached the maximum
	if (CorruptionAmount >= MaxCorruption)
	{
		// Ritual failed catastrophically
		CurrentRitualState = EInteractionState::FailedCatastrophically;
		bRitualCompleted = true;
		bRitualWasSuccessful = false;
		
		// Update turn data with final state
		UpdateTurnData();
		
		// Broadcast state and completion on server for local UI updates
		BroadcastRitualStateChanged();
		BroadcastRitualCompleted();
		
		// Apply catastrophic penalties to all players
		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
		{
			if (ParticipatingPlayer)
			{
				ApplyAgePenalty(ParticipatingPlayer, true);
			}
		}
		
		// Spawn demon and notify
		SpawnDemon();
		Multicast_OnRitualCatastrophicFail();
		
		// Clean up
		CleanupRitual();
	}
	else
	{
		// Move to the next player's turn (this updates CurrentActivePlayer)
		AdvanceToNextPlayer();
		
		// Start the input timer (this updates CurrentInputTimer)
		StartInputTimer();
		
		// Now update turn data with all the new values
		UpdateTurnData();
	}
}

void ARitualAltar::StartInputTimer()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Calculate the time window for this input, possibly scaling down as the sequence progresses
	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f)); // Up to 50% shorter at the end
	
	// Set the timer value for client display
	CurrentInputTimer = ScaledTimeWindow;
	
	
	// Start the timer
	GetWorldTimerManager().SetTimer(
		InputTimerHandle,
		this,
		&ARitualAltar::OnInputTimerExpired,
		ScaledTimeWindow,
		false
	);
	
	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"), 
		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"), 
		CurrentSequenceIndex, InputSequence.Num()-1);
	
	// Log the expected input
	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
	{
		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"), 
			*InputSequence[CurrentSequenceIndex].ToString());
	}
}

void ARitualAltar::OnInputTimerExpired()
{
	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
	{
		return;
	}
	
	// If we get here, the player failed to input in time
	if (CurrentActivePlayer)
	{
		HandleInputFailure(CurrentActivePlayer);
	}
	else
	{
		// Fallback in case CurrentActivePlayer is null
		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
		AdvanceToNextPlayer();
		StartInputTimer();
	}
}

void ARitualAltar::AdvanceToNextPlayer()
{
	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
	{
		return;
	}
	
	
	// Find the index of the current active player
	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
	
	// If not found or at the end, wrap around to the first player
	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
	{
		CurrentPlayerIndex = 0;
	}
	else
	{
		CurrentPlayerIndex++;
	}
	
	// Safety check for eligible players
	int32 StartIndex = CurrentPlayerIndex;
	bool bFoundEligiblePlayer = false;
	
	// Loop through players starting from CurrentPlayerIndex until we find an eligible one
	do 
	{
		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
		{
			CurrentActivePlayer = NextPlayer;
			bFoundEligiblePlayer = true;
			break;
		}
		
		// Move to next player
		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
	} 
	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
	
	// If we couldn't find an eligible player, just use the first one as fallback
	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
	{
		CurrentActivePlayer = ParticipatingPlayers[0];
	}
}

bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
{
	if (!Player)
	{
		return false;
	}
	
	// Check if the player is still in a ritual position
	bool bIsInPosition = false;
	for (const ABaseInteractionPosition* Position : InteractionPositions)
	{
		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
		{
			bIsInPosition = true;
			break;
		}
	}
	
	// Check if the player has the OccupyingPosition tag
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
	
	return bIsInPosition && bHasPositionTag;
}


void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
{
	if (!HasAuthority() || !Player)
	{
		return;
	}
	
	// Get the player's ASC
	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
	if (!ASC)
	{
		return;
	}
	
	// TODO: Apply aging GameplayEffect
	// This would typically be implemented using a GameplayEffect that increases age
	// The effect class would be defined elsewhere and referenced here
	
	// Pseudo-code:
	// TSubclassOf<UGameplayEffect> AgeEffect = bCatastrophic ? CatastrophicAgeEffectClass : StandardAgeEffectClass;
	// if (AgeEffect)
	// {
	//     FGameplayEffectContextHandle ContextHandle = ASC->MakeEffectContext();
	//     ContextHandle.AddSourceObject(this);
	//     FGameplayEffectSpecHandle SpecHandle = ASC->MakeOutgoingSpec(AgeEffect, 1.0f, ContextHandle);
	//     ASC->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
	// }
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"), 
		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
}

void ARitualAltar::SpawnReward()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// TODO: Implement reward spawning logic
	// This would typically create a special item and add it to inventory
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
}

void ARitualAltar::SpawnDemon()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// TODO: Implement demon spawning logic
	// This would typically spawn an enemy character
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
}

void ARitualAltar::CleanupRitual()
{
	if (!HasAuthority())
	{
		return;
	}
	
	// Clear timers
	GetWorldTimerManager().ClearTimer(InputTimerHandle);
	
	// Reset ritual-specific variables
	CurrentSequenceIndex = 0;
	InputSequence.Empty();
	CurrentActivePlayer = nullptr;
	
	// Don't reset corruption or state - these should persist for UI feedback
	
	// Reset positions? This depends on design - maybe players stay in position
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up"));
}

float ARitualAltar::GetCurrentSequenceProgress() const
{
	if (InputSequence.Num() == 0)
	{
		return 0.0f;
	}
	
	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
}

FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
{
	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
	{
		
		return FGameplayTag();
	}
	
	return InputSequence[CurrentSequenceIndex];
}



FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
{
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	switch (Input)
	{
	case ERitualInput::Up:
		return WitchPtGameplayTags.Ritual_Input_Up;
	case ERitualInput::Down:
		return WitchPtGameplayTags.Ritual_Input_Down;
	case ERitualInput::Left:
		return WitchPtGameplayTags.Ritual_Input_Left;
	case ERitualInput::Right:
		return WitchPtGameplayTags.Ritual_Input_Right;
	default:
		return FGameplayTag();
	}
}

ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
{
	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
	
	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
		return ERitualInput::Up;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
		return ERitualInput::Down;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
		return ERitualInput::Left;
	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
		return ERitualInput::Right;
	
	return ERitualInput::None;
}

void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
{
	if (Character)
	{
		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
		if (ASC)
		{
			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
			FGameplayEventData EventData;
			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
			EventData.Instigator = this;
			EventData.Target = Character;
			
			EventData.OptionalObject = FailedAnimMontage;
			
			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
			
		}
		
		
		
		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
	}
	
	
}



void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
{
	// Print the local role por the RitualAltar and the Player
	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
	if (Player->IsLocallyControlled())
	{
		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
	}
	
	if (!Player || !Position || !HasAuthority())
	{
		return;
	}


	if (Position->IsOccupied())
	{
		//broadcast
		return;
	}
	Position->SetOccupied(Player);
    
	bool bFound = false;
	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
	{
		if (Entry.Player == Player)
		{
			Entry.PositionTag = Position->GetPositionTag();
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		FPlayerPositionTagEntry NewEntry;
		NewEntry.Player = Player;
		NewEntry.PositionTag = Position->GetPositionTag();
		PlayerPositionTags.Add(NewEntry);
	}

	// Add to participating players if not already there
	if (!ParticipatingPlayers.Contains(Player))
	{
		ParticipatingPlayers.Add(Player);
	}
	CurrentRitualState = EInteractionState::WaitingForPlayers;
	
	// Broadcast state change on server for local UI updates (OnRep will handle clients)
	if (HasAuthority())
	{
		BroadcastRitualStateChanged();
	}
	
	// Update ready players data
	UpdateReadyPlayersData();

	// Call the ritual state delegate for Listen Server
	if (Player->GetLocalRole() == ROLE_Authority && Player->IsLocallyControlled()) // Im the listen server
	{
		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
		if (!PC->HasRitualWidgetInitialized(this))
		{
			PC->LocalInitializeRitualUserWidget(this);
		}
	} else if (Player->HasAuthority() && !Player->IsLocallyControlled()) // The call is from the client
	{
		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
		if (!PC->HasRitualWidgetInitialized(this))
		{
			PC->Client_InitializeRitualUserWidget(this);
		}
	}
}

void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
{
	// Client-side feedback for ritual success
	// This would typically play sounds, particle effects, etc.
	
	// Example: Play celebratory effects at altar location
	// UGameplayStatics::PlaySoundAtLocation(this, SuccessSound, GetActorLocation());
	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SuccessParticles, GetActorTransform());
	
	// Set completion status for replication
	bRitualCompleted = true;
	bRitualWasSuccessful = true;
	
	DestroyAltarPositions();
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback"));
}

void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
{
	// Client-side feedback for catastrophic failure
	// This would typically play sounds, particle effects, etc.
	
	// Example: Play ominous effects at altar location
	// UGameplayStatics::PlaySoundAtLocation(this, CatastrophicFailSound, GetActorLocation());
	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), CatastrophicFailParticles, GetActorTransform());
	
	// Set completion status for replication
	bRitualCompleted = true;
	bRitualWasSuccessful = false;
	
	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback"));
}

float ARitualAltar::GetCorruptionPercentage() const
{
	if (MaxCorruption == 0.0f)
	{
		return 0.0f;
	}
	
	return CorruptionAmount / MaxCorruption;
}
</file>

<file path="WitchPT/Private/Item/RitualPosition.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "Item/RitualPosition.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "Item/RitualAltar.h" // Include the Altar header
#include "GameplayTagContainer.h" // For tags
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"
#include "GameplayEffect.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Character/Components/WitchPTMechanicComponent.h" // Required for new RPC calls

// Sets default values
ARitualPosition::ARitualPosition()
{
	// No need to set up replication here - it's handled by the base class
}

void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	DOREPLIFETIME(ARitualPosition, RitualAltar);
}

// void ARitualPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
// {
// 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
//
// 	DOREPLIFETIME(ARitualPosition, bIsOccupied);
// 	DOREPLIFETIME(ARitualPosition, OccupyingCharacter);
// 	// RitualAltar and PositionTag are usually set once and don't need replication unless they can change dynamically
// }

void ARitualPosition::BeginPlay()
{
	Super::BeginPlay();
	
	// Try to find the RitualAltar if it wasn't set in the editor
	
}


void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
{
	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
	
	// Ritual-specific interaction options
	
	// ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
	//
	// // If no player is occupying the position, let a player take the position
	// if (!IsOccupied() && InteractingCharacterPtr)
	// {
	// 	OptionBuilder.AddDefaultInteraction(
	// 		FText::FromString("Take Position"), // Text for the interaction
	// 		[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
	// 		{
	// 			HandleInteraction(InteractingCharacterPtr);
	// 		}
	// 	);
	// }
	//
	// // Special case: if the character is standing at a position and we're in Inactive state, they can initiate the ritual
	// if (IsOccupied() && RitualAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
	// {
	// 	// Check ritual state
	// 	if (RitualAltar->GetCurrentState() == EInteractionState::Inactive)
	// 	{
	// 		OptionBuilder.AddDefaultInteraction(
	// 			FText::FromString("Start Ritual"), // Text for the interaction
	// 			[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
	// 			{
	// 				if (RitualAltar)
	// 				{
	// 					// Cast to the appropriate start ritual function
	// 					RitualAltar->StartRitual(InteractingCharacterPtr);
	// 				}
	// 			}
	// 		);
	// 	}
	// }
}

ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
{
	if (RitualAltar)
	{
		return RitualAltar;
	}
	return nullptr;
}

bool ARitualPosition::IsOccupied_Implementation()
{
	return bIsOccupied;
}


void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
{
	Super::HandleInteraction(InteractingCharacter);
	
	if (!InteractingCharacter || !RitualAltar)
	{
		return;
	}
	
}





// void ARitualPosition::SetOccupied(ACharacter* Character)
// {
// 	if (!HasAuthority())
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: no authority"));
// 		return;
// 	}
//
// 	if (!Character)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: invalid character"));
// 		return;
// 	}
//
// 	if (bIsOccupied)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: position %s already occupied by %s"), 
// 			*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
// 		return;
// 	}
//
// 	// Set as occupied
// 	bIsOccupied = true;
// 	OccupyingCharacter = Character;
// 	
// 	// Force OnReps if needed immediately on server
// 	OnRep_IsOccupied();
// 	OnRep_OccupyingCharacter();
// 	
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Occupied by %s"), *GetName(), *Character->GetName());
// }

// Called on the Server by the Altar (or potentially a GA)
// void ARitualPosition::RemoveCharacterFromPosition()
// {
// 	if (!HasAuthority())
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: no authority"));
// 		return;
// 	}
//
// 	if (!bIsOccupied || !OccupyingCharacter)
// 	{
// 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: position %s is not occupied"), *GetName());
// 		return;
// 	}
//
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removing %s from position %s"), 
// 		*OccupyingCharacter->GetName(), *GetName());
// 	
// 	// Remove the occupying position tag from the character
// 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OccupyingCharacter);
// 	if (ASC)
// 	{
// 		const FWitchPTGameplayTags& gameplayTags = FWitchPTGameplayTags::Get();
// 		
// 		// Remove the State.Ritual.OccupyingPosition tag
// 		// This would typically be done by removing the GE that applied it
// 		
// 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removed State.Ritual.OccupyingPosition tag from %s"), *OccupyingCharacter->GetName());
// 	}
// 	
// 	// Clear state
// 	bIsOccupied = false;
// 	ACharacter* OldCharacter = OccupyingCharacter;
// 	OccupyingCharacter = nullptr;
// 	
// 	// Force OnReps if needed immediately on server
// 	OnRep_IsOccupied();
// 	OnRep_OccupyingCharacter();
// 	
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Unoccupied (was %s)"), 
// 		*GetName(), OldCharacter ? *OldCharacter->GetName() : TEXT("nullptr"));
// }
//
// void ARitualPosition::OnRep_IsOccupied()
// {
// 	// Client-side reaction to occupancy change
// 	// Example: Change material, play sound, update UI attached to this position
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupancy changed to: %s"), 
// 		*GetName(), bIsOccupied ? TEXT("OCCUPIED") : TEXT("VACANT"));
// }
//
// void ARitualPosition::OnRep_OccupyingCharacter()
// {
// 	// Client-side reaction to character change
// 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupying character changed to: %s"), 
// 		*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
// }
</file>

<file path="WitchPT/Private/Player/WitchPTPlayerController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/WitchPTPlayerController.h"

#include "AbilitySystemBlueprintLibrary.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "Blueprint/UserWidget.h"
#include "Input/WitchPTInputComponent.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Item/CauldronAltar.h"
#include "Item/RitualAltar.h"
#include "Item/Ritual/RitualFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Net/UnrealNetwork.h"
#include "UI/HUD/WitchPTHUD.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/RitualWidgetController.h"
#include "UI/Widgets/CauldronUserWidget.h"
#include "UI/Widgets/Inventory/RitualUserWidget.h"
#include "WitchPT/WitchPT.h"

AWitchPTPlayerController::AWitchPTPlayerController()
{
	bReplicates = true;
	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
	InventoryManager->SetIsReplicated(true);
	
	
}

void AWitchPTPlayerController::PlayerTick(float DeltaTime)
{
	Super::PlayerTick(DeltaTime);
}

void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
{
	Super::PreProcessInput(DeltaTime, bGamePaused);
}

void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
{
	if (WitchPtAbilitySystemComponent)
	{
		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
	}
	Super::PostProcessInput(DeltaTime, bGamePaused);
}

void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
}
void AWitchPTPlayerController::LocalToggleCauldronMenu()
{
	
	if (bCauldronMenuOpen)
	{
		CloseCauldronMenu();
	}
	else
	{
		OpenCauldronMenu();
	}
}

void AWitchPTPlayerController::LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar)
{
	if (!Altar || !Altar->AltarUserWidgetClass || !IsLocalController())
	{
		UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Invalid altar or widget class!"));
		return;
	}
	
	if (Altar->IsA<ARitualAltar>())
	{
		// Cast the altar to a ritual altar
		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);

		if (!ThisRitualAltarHasWidget || ThisRitualAltarHasWidget != RitualAltar)
		{
			ThisRitualAltarHasWidget = RitualAltar;
		}
		
		URitualUserWidget* RitualUserWidget = CreateWidget<URitualUserWidget>(this, Altar->AltarUserWidgetClass);
		
		if (IsValid(RitualUserWidget))
		{
			// Get or create the ritual widget controller
			URitualWidgetController* RitualWidgetController = URitualFunctionLibrary::SetRitualWidgetController(this);
			
			if (!RitualWidgetController)
			{
				UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Failed to get or create RitualWidgetController!"));
				return;
			}
			
			RitualWidgetController->SetRitualAltar(RitualAltar);
			// Set widget controller reference for the user widget
			RitualUserWidget->SetWidgetController(RitualWidgetController);
			
			
			// Add the widget to viewport
			RitualUserWidget->AddToViewport();
		}
			
	}
	
	
}

bool AWitchPTPlayerController::HasRitualWidgetInitialized(ABaseInteractableAltar* Altar)
{
	if (Altar->IsA<ARitualAltar>())
	{
		return ThisRitualAltarHasWidget == Altar;
	}
	return false;
}

void AWitchPTPlayerController::OpenCauldronMenu()
{
	if (!IsValid(CauldronAltarMenu)) return;

	CauldronAltarMenu->SetVisibility(ESlateVisibility::Visible);
	bCauldronMenuOpen = true;
	
	FInputModeGameAndUI InputMode;
	
	SetInputMode(InputMode);
	SetShowMouseCursor(true);
}

void AWitchPTPlayerController::CloseCauldronMenu()
{
	if (!IsValid(CauldronAltarMenu)) return;

	CauldronAltarMenu->SetVisibility(ESlateVisibility::Collapsed);
	bCauldronMenuOpen = false;

	

	FInputModeGameOnly InputMode;
	SetInputMode(InputMode);
	SetShowMouseCursor(false);
}

void AWitchPTPlayerController::Client_InitializeRitualUserWidget_Implementation(ABaseInteractableAltar* Altar)
{
	if (!HasRitualWidgetInitialized(Altar))
	{
		LocalInitializeRitualUserWidget(Altar);
	}
}

void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
{
	LocalToggleCauldronMenu();
}
void AWitchPTPlayerController::BeginPlay()
{
	Super::BeginPlay();
	check(WitchPtiInputMappingContext)
	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
	if (Subsystem)
	{
		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
	}
	CreateHUDWidget();
	ConstructCauldronWidget();
}

void AWitchPTPlayerController::SetupInputComponent()
{
	Super::SetupInputComponent();
	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
	
}

void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
{
	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
	const FRotator Rotation = GetControlRotation();
	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);

	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

	if (APawn* ControlledPawn = GetPawn<APawn>())
	{
		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
	}
	
}

void AWitchPTPlayerController::Look(const FInputActionValue& Value)
{
	// input is a Vector2D
	FVector2D LookAxisVector = Value.Get<FVector2D>();

	if (APawn* ControlledPawn = GetPawn<APawn>())
	{
		// add yaw and pitch input to controller
		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
	}
}

void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagPressed(InputTag);
	}
}

void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagReleased(InputTag);
	}
}

void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
{
	if (GetASC())
	{
		GetASC()->AbilityInputTagHeld(InputTag);
	}
}

void AWitchPTPlayerController::ConstructCauldronWidget()
{
	if (!this->IsLocalController()) return;
	CauldronAltarMenu = CreateWidget<UCauldronUserWidget>(this, CauldronAltarWidgetClass);
	UCauldronWidgetController* CauldronWidgetController = URitualFunctionLibrary::SetCauldronWidgetController(this);
	CauldronAltarMenu->SetWidgetController(CauldronWidgetController);
	// Find ACauldronAltar in the level
	ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass()));
	if (CauldronAltar)
	{
		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
	}
	CauldronWidgetController->BindCallbacksToDependencies();
	CauldronAltarMenu->AddToViewport();
	CloseCauldronMenu();
}

void AWitchPTPlayerController::CreateHUDWidget()
{
	if (!IsLocalController()) return;
	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
	if (IsValid(HUDWidget))
	{
		HUDWidget->AddToViewport();
	}
}


UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
{
	if (WitchPtAbilitySystemComponent == nullptr)
	{
		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
	}
	return WitchPtAbilitySystemComponent;
}
</file>

<file path="WitchPT/Private/Player/WitchPTPlayerState.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/WitchPTPlayerState.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"
#include "Item/RitualPosition.h"

AWitchPTPlayerState::AWitchPTPlayerState()
{
	SetNetUpdateFrequency(100.f);
	
	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
	AbilitySystemComponent->SetIsReplicated(true);
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);

	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");


}

UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}
</file>

<file path="WitchPT/Private/UI/HUD/WitchPTHUD.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/HUD/WitchPTHUD.h"

#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "UI/WidgetControllers/InventoryWidgetController.h"
#include "UI/WidgetControllers/OverlayWidgetController.h"
#include "UI/WidgetControllers/RitualWidgetController.h"
#include "UI/Widgets/WitchPTUserWidget.h"

UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
{
	if (OverlayWidgetController == nullptr)
	{
		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
		OverlayWidgetController->SetWidgetControllerParams(WCParams);
		OverlayWidgetController->BindCallbacksToDependencies();
	}
	return OverlayWidgetController;
}

UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
{
	if (CauldronWidgetController == nullptr)
	{
		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
		CauldronWidgetController->SetWidgetControllerParams(WCParams);
		// CauldronWidgetController->BindCallbacksToDependencies();
	}
	return CauldronWidgetController;
}

UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
{
	if (InventoryWidgetController == nullptr)
	{
		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
		InventoryWidgetController->SetWidgetControllerParams(WCParams);
		InventoryWidgetController->BindCallbacksToDependencies();
	}
	return InventoryWidgetController;
}

URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
{
	if (RitualWidgetController == nullptr)
	{
		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
		RitualWidgetController->SetWidgetControllerParams(WCParams);
	}
	return RitualWidgetController;
}

void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
{
	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));

	
	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
	OverlayWidget = Cast<UWitchPTUserWidget>(Widget);

	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);

	OverlayWidget->SetWidgetController(WidgetController);
	WidgetController->BroadcastInitialValues();
	Widget->AddToViewport();
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/CauldronWidgetController.h"

#include "Item/CauldronAltar.h"

UCauldronWidgetController::UCauldronWidgetController()
{
}

void UCauldronWidgetController::BroadcastInitialValues()
{
	if(CauldronAltar)
	{
		OnBaseIngredientSet.Broadcast(CauldronAltar->GetBaseIngredient());
		
	}
	
}

void UCauldronWidgetController::BindCallbacksToDependencies()
{
	Super::BindCallbacksToDependencies();
	if(CauldronAltar)
	{
		CauldronAltar->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
		CauldronAltar->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
		CauldronAltar->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
		CauldronAltar->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
		CauldronAltar->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
		CauldronAltar->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
	}
}

void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
{
	if (InCauldronAltar != nullptr)
	{
		CauldronAltar = InCauldronAltar;
	}
	
}

void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnBaseIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
{
	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
}

void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
{
	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
}

void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
{
	OnModifierIngredientSet.Broadcast(IngredientInstance);
}

void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
{
	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/InventoryWidgetController.h"

#include "Inventory/WitchPTInventoryItemInstance.h"
#include "Inventory/WitchPTInventoryManagerComponent.h"
#include "Player/WitchPTPlayerController.h"

void UInventoryWidgetController::BindCallbacksToDependencies()
{
	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
	if (WitchPtPlayerController)
	{
		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
		if (InventoryManager)
		{
			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
			{
				OnItemAddedDelegate.Broadcast(ItemAdded);
			});
			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
			{
				OnItemStackChangedDelegate.Broadcast(ItemAdded);
			});
			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
			{
				OnItemRemovedDelegate.Broadcast(ItemRemoved);
			});
		}
	}
}

void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
{
	if (!ItemInstance)
	{
		return;
	}

	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
	if (!WitchPtPlayerController)
	{
		return;
	}

	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
	if (!InventoryManager)
	{
		return;
	}

	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
	
	// If we only have 1 item left and trying to remove 1 or more, remove the item completely
	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
	{
		InventoryManager->Server_RemoveItemInstance(ItemInstance);
	}
	else
	{
		// Otherwise, reduce the stack count by the requested amount
		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
	}
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/OverlayWidgetController.h"

#include "AbilitySystem/WitchPTAbilitySystemComponent.h"
#include "AbilitySystem/WitchPTAttributeSet.h"

void UOverlayWidgetController::BroadcastInitialValues()
{
	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);

	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
}

void UOverlayWidgetController::BindCallbacksToDependencies()
{
	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnHealthChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxHealthChanged.Broadcast(Data.NewValue);
	});
	
	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnStaminaChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxStaminaChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnAgeChanged.Broadcast(Data.NewValue);
	});

	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
	{
		OnMaxAgeChanged.Broadcast(Data.NewValue);
	});

	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
	
	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
	
	// Lambda for message delegates
	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
		// [this] is the capture list, in the case of this lambda, we want to capture this (OverlayWidgetController)
		[this](const FGameplayTagContainer& AssetTags)
	{
		for (const auto& Tag : AssetTags)
		{
			// Declare the tag we want to check. In our case "MessageTag"
			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
			if (Tag.MatchesTag(ParentMessageGameplayTag))
			{
				
					
				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
				OnMessageWidgetRow.Broadcast(*Row);
				
			}
			
		}
	});

	

}
void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
{

}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "UI/WidgetControllers/RitualWidgetController.h"
#include "Item/RitualAltar.h"
#include "GameFramework/Character.h"
#include "GameFramework/PlayerController.h"
#include "AbilitySystemComponent.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "FWitchPTGameplayTags.h"

URitualWidgetController::URitualWidgetController()
{
    // Constructor
}

void URitualWidgetController::BroadcastInitialValues()
{
    // If we have an altar, broadcast its initial values
    if (RitualAltar)
    {
        // Broadcast current state
        OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
        
        // Broadcast ready players data
        FRitualReadyPlayersData ReadyPlayersData;
        ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
        ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
        OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
        
        // Broadcast current turn data (processed for local player)
        FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
        FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
        OnTurnDataChanged.Broadcast(ProcessedTurnData);
        
        // Broadcast corruption
        OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
        
        // Broadcast sequence progress
        OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
    }
}

void URitualWidgetController::BindCallbacksToDependencies()
{
    // Bind to altar delegates if it exists
    if (RitualAltar)
    {
        // Bind to all the new dynamic multicast delegates
        RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
        RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
        RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
        RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
        RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
        RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
        RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
    }
}

void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
{
    // Unbind any existing callbacks first
    if (RitualAltar != nullptr)
    {
        RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
        RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
        RitualAltar->OnCountdownTickEvent.RemoveAll(this);
        RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
        RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
        RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
        RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
    }
    
    // Assign the new altar
    RitualAltar = InRitualAltar;
    
    // Rebind and broadcast if we have a valid altar
    if (RitualAltar)
    {
        BindCallbacksToDependencies();
        BroadcastInitialValues();
    }
}

bool URitualWidgetController::IsLocalPlayerActive() const
{
    if (!RitualAltar || !PlayerController)
    {
        return false;
    }
    
    // Get the local character
    ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
    if (!LocalCharacter)
    {
        return false;
    }
    
    // Check if this character is the active player
    return RitualAltar->GetCurrentActivePlayer() == LocalCharacter;
}

FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
{
    FUIRitualData ProcessedData = InTurnData;
    
    // Determine if it's the local player's turn
    ProcessedData.bIsMyTurn = IsLocalPlayerActive();
    
    // If it's not the local player's turn, clear sensitive data
    if (!ProcessedData.bIsMyTurn)
    {
        ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
        ProcessedData.CurrentInputTimeRemaining = 0.0f;
    }
    
    return ProcessedData;
}

// ----------------------------------- CALLBACK HANDLERS ---------------------------------------------- //

void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
{
    OnRitualStateChanged.Broadcast(NewState);
}

void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
{
    OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
}

void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
{
    OnRitualCountdownTick.Broadcast(CountdownValue);
}

void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
{
    // Process the turn data for the local player before broadcasting
    FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
    OnTurnDataChanged.Broadcast(ProcessedTurnData);
    
    // Also broadcast the expected input separately for backward compatibility
    if (ProcessedTurnData.bIsMyTurn)
    {
        OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
    }
    else
    {
        OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
    }
}

void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
{
    OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
}

void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
{
    OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
}

void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
{
    OnRitualCompleted.Broadcast(bWasSuccessful);
    
    // Unbind all delegates when ritual is completed to prevent memory leaks
    if (RitualAltar)
    {
        RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
        RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
        RitualAltar->OnCountdownTickEvent.RemoveAll(this);
        RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
        RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
        RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
        RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
    }
}
</file>

<file path="WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/WidgetControllers/WitchPTWidgetController.h"

void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
{
	PlayerController = WCParams.PlayerController;
	PlayerState = WCParams.PlayerState;
	AbilitySystemComponent = WCParams.AbilitySystemComponent;
	AttributeSet = WCParams.AttributeSet;
}

void UWitchPTWidgetController::BroadcastInitialValues()
{
}

void UWitchPTWidgetController::BindCallbacksToDependencies()
{
}
</file>

<file path="WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/CauldronUserWidget.h"

void UCauldronUserWidget::NativeConstruct()
{
	Super::NativeConstruct();
	FInputModeGameAndUI InputMode;
	// set the input mode to the player controller
	
	if (APlayerController* OwningController = GetOwningPlayer())
	{
		OwningController->SetInputMode(InputMode);
		OwningController->SetShowMouseCursor(true);
	}
	
}

FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	return FReply::Handled();
}
</file>

<file path="WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/Inventory/InventoryUserWidget.h"

FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	
	return FReply::Handled();
}
</file>

<file path="WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/Inventory/RitualUserWidget.h"
</file>

<file path="WitchPT/Private/UI/Widgets/PointerWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/PointerWidget.h"
</file>

<file path="WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/Widgets/WitchPTUserWidget.h"

void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
{
	WidgetController = InWidgetController;
	OnWidgetControllerSet();
}
</file>

<file path="WitchPT/Private/WitchPTAssetManager.cpp">
// Fill out your copyright notice in the Description page of Project Settings.


#include "WitchPTAssetManager.h"

#include "AbilitySystemGlobals.h"
#include "FWitchPTGameplayTags.h"

UWitchPTAssetManager& UWitchPTAssetManager::Get()
{
	check(GEngine)
	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
	return *WitchPtAssetManager;
}

void UWitchPTAssetManager::StartInitialLoading()
{
	Super::StartInitialLoading();
	FWitchPTGameplayTags::InitializeGameplayTags();
	/**
	 * 
	 */
	// TODO: What is this function for? 

	UAbilitySystemGlobals::Get().InitGlobalData();
	
}
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "AT_WaitForPlacementLocation_SLT.generated.h"

// Delegado para enviar la información de la ubicación y la normal
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);

/**
 * Task que realiza un line trace continuo para encontrar ubicaciones válidas para colocar el caldero.
 * Similar a UAT_WaitForInteractable_SLT pero devuelve información de ubicación y normal de la superficie.
 */
UCLASS()
class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
{
	GENERATED_BODY()
	
public:
	// Constructor
	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);

	// Crea y configura la tarea
	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
		UGameplayAbility* OwningAbility,
		float TraceDistance = 500.0f,
		float TraceRadius = 10.0f,
		bool TraceComplex = false,
		bool bIgnoreBlockingHits = false,
		bool bShowDebug = false);

	// Delegado llamado cuando se encuentra una ubicación válida
	UPROPERTY(BlueprintAssignable)
	FPlacementLocationFound OnLocationFound;

	// Se llama cuando se activa la tarea
	virtual void Activate() override;

	// Se llama cuando se termina la tarea
	virtual void OnDestroy(bool bInOwnerFinished) override;

private:
	// Realiza el line trace para encontrar ubicaciones
	void PerformTrace();

	// Realiza un line trace cada tick para actualizar la ubicación
	void TickTask(float DeltaTime);

	// Temporizador para realizar el trace
	FTimerHandle TraceTimerHandle;

	// Distancia del trace
	float TraceDistance;

	// Radio del trace (para spheretrace)
	float TraceRadius;

	// Si se debe considerar geometría compleja
	bool bTraceComplex;

	// Si se deben ignorar hits bloqueantes
	bool bIgnoreBlockingHits;

	// Si se debe mostrar debug visual
	bool bShowDebug;

	// Última ubicación de hit encontrada
	FVector LastHitLocation;

	// Última normal encontrada
	FVector LastHitNormal;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "GA_CauldronPlace.generated.h"

class ACauldronAltar;

/**
 * Gameplay Ability que confirma la colocación del caldero en su posición actual
 * Se activa con el botón primario durante la previsualización
 */
UCLASS()
class WITCHPT_API UGA_CauldronPlace : public UGameplayAbility
{
    GENERATED_BODY()
    
public:
    UGA_CauldronPlace();
    
    // Configuración de la habilidad
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
    
protected:
    // Encuentra el caldero que está en modo previsualización
    ACauldronAltar* FindPreviewingCauldron();
};
</file>

<file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "GA_CauldronPlacementPreview.generated.h"

class ACauldronAltar;

/**
 * Gameplay Ability que permite previsualizar la colocación del caldero
 * Realiza un line trace continuo y actualiza la posición del caldero en tiempo real.
 */
UCLASS()
class WITCHPT_API UGA_CauldronPlacementPreview : public UGameplayAbility
{
    GENERATED_BODY()
    
public:
    UGA_CauldronPlacementPreview();
    
    // Configuración de la habilidad
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
    virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;
    
    // Función de entrada para confirmar la colocación
    UFUNCTION()
    void OnConfirmPlacement();
    
    // Función de entrada para cancelar la colocación
    UFUNCTION()
    void OnCancelPlacement();
    
    // Función llamada cuando se encuentra una nueva ubicación válida
    UFUNCTION()
    void OnLocationFound(FVector HitLocation, FVector HitNormal);
    
protected:
    // Encuentra el caldero que el jugador está llevando
    ACauldronAltar* FindCarriedCauldron();
    
    // Distancia máxima del line trace
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    float TraceDistance = 500.0f;
    
    // Radio del trace (para sphere trace)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    float TraceRadius = 10.0f;
    
    // Si se debe usar trace complejo
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    bool bTraceComplex = false;
    
    // Si se deben mostrar los trazos de debug
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
    bool bShowDebug = true;
    
private:
    // Referencia al caldero que se está colocando
    UPROPERTY()
    ACauldronAltar* CauldronAltar;
};
</file>

<file path="WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "WitchPTGameplayAbility.generated.h"

/**
 * 
 */
UENUM(BlueprintType)
enum class EPrototypeAbilityActivationPolicy: uint8
{
	// Try to activate the ability when the input is triggered.
	OnInputTriggered,

	// Continually try to activate the ability while the input is active.
	WhileInputActive,

	// Try to activate the ability when an avatar is assigned.
	OnSpawn,
	
	OnTriggeredEvent
};
UCLASS()
class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
{
	GENERATED_BODY()
public:
	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
	UPROPERTY(EditDefaultsOnly, Category="Input")
	FGameplayTag StartupInputTag;
	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
protected:

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
	EPrototypeAbilityActivationPolicy ActivationPolicy;

	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "AbilityTask_GrantNearbyInteraction.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
{
	GENERATED_UCLASS_BODY()

	
	virtual void Activate() override;
	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;

	/** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */
	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);

private:
	virtual void OnDestroy(bool AbilityEnded) override;

	void QueryInteractables();
	float InteractionScanRange = 100;
	float InteractionScanRate = 0.100;
	FTimerHandle QueryTimerHandle;

	// Cache para habilidades de interacción rápida
	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
	
	// Cache para habilidades de interacción mantenida
	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;

};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "Engine/CollisionProfile.h"
#include "InteractionOption.h"
#include "AbilityTask_WaitForInteractable.generated.h"

/**
 * 
 */
class AActor;
class IInteractableTarget;
class UObject;
class UWorld;
struct FCollisionQueryParams;
struct FHitResult;
struct FInteractionQuery;
template <typename InterfaceType> class TScriptInterface;
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);

UCLASS(Abstract)
class UAbilityTask_WaitForInteractable : public UAbilityTask
{
	GENERATED_UCLASS_BODY()

public:
	UPROPERTY(BlueprintAssignable)
	FInteractableObjectsChangedEvent InteractableObjectsChanged;

protected:

	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);

	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;

	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);

	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);

	ECollisionChannel TraceProfile;

	// Does the trace affect the aiming pitch
	bool bTraceAffectsAimPitch = true;

	TArray<FInteractionOption> CurrentOptions;
	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractionQuery.h"
#include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
#include "AT_WaitForInteractable_SLT.generated.h"
struct FCollisionProfileName;

class UGameplayAbility;
class UObject;
struct FFrame;
/**
 * 
 */
UCLASS()
class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
{
	GENERATED_UCLASS_BODY()

	virtual void Activate() override;

	/** Wait until we trace new set of interactables.  This task automatically loops. */
	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);

private:

	virtual void OnDestroy(bool AbilityEnded) override;

	void PerformTrace();

	UPROPERTY()
	FInteractionQuery InteractionQuery;

	UPROPERTY()
	FGameplayAbilityTargetingLocationInfo StartLocation;

	float InteractionScanRange = 100;
	float InteractionScanRate = 0.100;
	bool bShowDebug = false;

	FTimerHandle TimerHandle;
	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "InteractionOption.h"
#include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
#include "GameplayAbility_Interact.generated.h"

class UObject;
struct FFrame;
struct FGameplayAbilityActorInfo;
struct FGameplayEventData;

// Delegado para notificar cuando se completa una interacción
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);

/**
 * 
 */
UCLASS(Abstract)
class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
{
	GENERATED_BODY()
	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	UFUNCTION(BlueprintCallable)
	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
	
	// Método para interacción de pulsación rápida
	UFUNCTION(BlueprintCallable)
	void TriggerInteraction();
	
	// Método para interacción manteniendo pulsado
	UFUNCTION(BlueprintCallable)
	void TriggerHoldInteraction();
	
	// Método llamado cuando se presiona el botón de interacción
	UFUNCTION(BlueprintCallable, Category = "Interaction")
	void OnInteractionButtonPressed();
	
	// Método llamado cuando se suelta el botón de interacción
	UFUNCTION(BlueprintCallable, Category = "Interaction")
	void OnInteractionButtonReleased();
	
	// Método llamado cuando se cumple el tiempo de interacción mantenida
	UFUNCTION()
	void OnHoldInteractionTimeElapsed();
    
    // Método que verifica si el objeto bajo el trace sigue siendo el mismo
    UFUNCTION()
    void CheckInteractionValidity();
    
    // Método que cancela una interacción en curso
    UFUNCTION(BlueprintCallable, Category = "Interaction")
    void CancelCurrentInteraction();
    
    // Método de seguridad que se activa si una interacción dura demasiado tiempo
    UFUNCTION()
    void OnMaxInteractionTimeElapsed();

	// Delegado que se dispara cuando se completa una interacción
	UPROPERTY(BlueprintAssignable, Category = "Interaction")
	FOnInteractionComplete OnInteractionComplete;

	// Delegado que se dispara cuando se completa una interacción mantenida
	UPROPERTY(BlueprintAssignable, Category = "Interaction")
	FOnInteractionComplete OnHoldInteractionComplete;
    
    // Delegado que se dispara cuando se cancela una interacción
    UPROPERTY(BlueprintAssignable, Category = "Interaction")
    FOnInteractionComplete OnInteractionCancelled;

protected:

	UPROPERTY(BlueprintReadWrite)
	TArray<FInteractionOption> CurrentOptions;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
	float InteractionScanRate = 0.1f;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
	float InteractionScanRange = 500;
	
	// Tiempo mínimo que debe mantenerse presionado el botón para considerar una interacción mantenida
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
	float HoldInteractionTime = 1.0f;
    
    // Frecuencia para verificar si el objeto interactuable sigue siendo válido durante una interacción mantenida
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
    float ValidityCheckRate = 0.1f;
    
    // Tiempo máximo que puede durar cualquier interacción antes de ser cancelada automáticamente
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
    float MaxInteractionTime = 10.0f;
	
	// Temporizador para detectar interacción mantenida
	FTimerHandle HoldInteractionTimerHandle;
    
    // Temporizador para verificar la validez del objeto interactuable
    FTimerHandle ValidityCheckTimerHandle;
    
    // Temporizador de seguridad para forzar el reinicio después de un tiempo máximo
    FTimerHandle MaxInteractionTimeTimerHandle;
	
	// Estado del botón de interacción (presionado o no)
	bool bIsInteractionButtonHeld = false;
	
	// Tiempo en que se inició la pulsación
	float InteractionStartTime = 0.0f;
	
	// Indica si ya se disparó una interacción mantenida para la pulsación actual
	bool bHoldInteractionFired = false;
    
    // Guarda el objeto con el que se inició la interacción para compararlo
    TScriptInterface<IInteractableTarget> InitialInteractableTarget;

	UPROPERTY(EditDefaultsOnly)
	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;

	
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.h"
#include "IInteractableTarget.generated.h"

struct FInteractionQuery;

/**  */
class FInteractionOptionBuilder
{
public:
	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
		: Scope(InterfaceTargetScope)
		, Options(InteractOptions)
	{
	}

	void AddInteractionOption(const FInteractionOption& Option)
	{
		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
		OptionEntry.InteractableTarget = Scope;
	}

private:
	TScriptInterface<IInteractableTarget> Scope;
	TArray<FInteractionOption>& Options;
};

/**  */
UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
class UInteractableTarget : public UInterface
{
	GENERATED_BODY()
};


class IInteractableTarget
{
	GENERATED_BODY()

public:
	/**  */
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;

	/**  */
	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
	
	/**
	 * Determina si este objeto interactuable soporta interacción mantenida
	 * @return Verdadero si el objeto soporta interacción mantenida, falso en caso contrario
	 */
	virtual bool SupportsHoldInteraction() const { return false; }
	
	/**
	 * Obtiene la habilidad que se debe activar cuando se realiza una interacción mantenida
	 * @return El handle de la habilidad para interacción mantenida
	 */
	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h">
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.generated.h"

class IInteractableTarget;
// class UUserWidget;

/**  */
USTRUCT(BlueprintType)
struct FInteractionOption
{
	GENERATED_BODY()

public:
	/** The interactable target */
	UPROPERTY(BlueprintReadWrite)
	TScriptInterface<IInteractableTarget> InteractableTarget;

	/** Simple text the interaction might return */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText Text;

	/** Simple sub-text the interaction might return */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText SubText;

	// METHODS OF INTERACTION
	//--------------------------------------------------------------

	// 1) Place an ability on the avatar that they can activate when they perform interaction.

	/** The ability to grant the avatar when they get near interactable objects. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;

	// - OR -

	// 2) Allow the object we're interacting with to have its own ability system and interaction ability, that we can activate instead.

	/** The ability system on the target that can be used for the TargetInteractionHandle and sending the event, if needed. */
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;

	/** The ability spec to activate on the object for this option. */
	UPROPERTY(BlueprintReadOnly)
	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
	
	/** Indica si esta opción de interacción soporta interacción mantenida */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	bool bSupportsHoldInteraction = false;
	
	/** La habilidad a activar cuando se mantiene presionado el botón de interacción */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
	
	/** La habilidad para interacción mantenida en el objetivo */
	UPROPERTY(BlueprintReadOnly)
	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;

	// UI
	//--------------------------------------------------------------

	/** The widget to show for this kind of interaction. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TSoftClassPtr<UUserWidget> InteractionWidgetClass;

	//--------------------------------------------------------------

public:
	FORCEINLINE bool operator==(const FInteractionOption& Other) const
	{
		return InteractableTarget == Other.InteractableTarget &&
			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
			TargetAbilitySystem == Other.TargetAbilitySystem &&
			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
			// InteractionWidgetClass == Other.InteractionWidgetClass &&
			Text.IdenticalTo(Other.Text) &&
			SubText.IdenticalTo(Other.SubText);
	}

	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
	{
		return !operator==(Other);
	}

	FORCEINLINE bool operator<(const FInteractionOption& Other) const
	{
		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
	}
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionQuery.generated.h"


/**  */
USTRUCT(BlueprintType)
struct FInteractionQuery
{
	GENERATED_BODY()

public:
	/** The requesting pawn. */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<AActor> RequestingAvatar;

	/** Allow us to specify a controller - does not need to match the owner of the requesting avatar. */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<AController> RequestingController;

	/** A generic UObject to shove in extra data required for the interaction */
	UPROPERTY(BlueprintReadWrite)
	TWeakObjectPtr<UObject> OptionalObjectData;
};
</file>

<file path="WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "InteractionStatics.generated.h"

template <typename InterfaceType> class TScriptInterface;
class AActor;
class IInteractableTarget;
class UObject;

/**
 * 
 */
UCLASS()
class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UInteractionStatics();

public:
	UFUNCTION(BlueprintCallable)
	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);

	UFUNCTION(BlueprintCallable)
	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "WitchPTAbilitySystemComponent.generated.h"

DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& /* Asset tags that the GE have*/)
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
{
	GENERATED_BODY()

public:
	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
	
	void AbilityInputTagPressed(const FGameplayTag& InputTag);
	void AbilityInputTagHeld(const FGameplayTag& InputTag);
	void AbilityInputTagReleased(const FGameplayTag& InputTag);
	void AbilityActorInfoHaveBeenSet();

	FEffectAssetTags OnEffectAssetTags;
	
	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
	
	bool bCharacterAbilitiesGiven = false;
	bool bStartupEffectsApplied = false;

	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;

	// Handles to abilities that had their input pressed this frame.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;

	// Handles to abilities that had their input released this frame.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;

	
	// Handles to abilities that have their input held.
	UPROPERTY(VisibleAnywhere, Category = "Ability System")
	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;

protected:
	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
	UFUNCTION(Client, Reliable)
	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);

};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemGlobals.h"
#include "WitchPTAbilitySystemGlobals.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTAbilitySystemLibrary.generated.h"

class IMechanicsInterface;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
};
</file>

<file path="WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "AttributeSet.h"
#include "WitchPTAttributeSet.generated.h"

/**
 * 
 */
// Macro for attribute accessors
// Functions: Getter, Setter, Initializer. The initializer set the base and current value!
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

// This syntax is a fucking nightmare, but...ok
UCLASS()
class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	UWitchPTAttributeSet();
	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;


	/**
	 * Vital Attributes
	 */
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
	FGameplayAttributeData Age;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
	FGameplayAttributeData MaxAge;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
	FGameplayAttributeData Health;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
	FGameplayAttributeData MaxHealth;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
	FGameplayAttributeData Strength;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
	FGameplayAttributeData MaxStrength;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
	FGameplayAttributeData Mana;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
	FGameplayAttributeData MaxMana;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
	FGameplayAttributeData Stamina;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
	
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
	FGameplayAttributeData MaxStamina;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
	FGameplayAttributeData SpeedMultiplier;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
	FGameplayAttributeData MaxSpeedMultiplier;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MaxMoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
	FGameplayAttributeData MinMoveSpeed;
	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);

	


	// Replication functions
	UFUNCTION()
	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
	UFUNCTION()
	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
	UFUNCTION()
	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
	UFUNCTION()
	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
	UFUNCTION()
	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
	UFUNCTION()
	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
	UFUNCTION()
	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
	UFUNCTION()
	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
	UFUNCTION()
	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
	UFUNCTION()
	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
	UFUNCTION()
	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
	UFUNCTION()
	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
	UFUNCTION()
	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
	UFUNCTION()
	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
	UFUNCTION()
	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
};
</file>

<file path="WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "WitchPTCharacterMovementComponent.generated.h"


UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
{
	GENERATED_BODY()

public:
	UWitchPTCharacterMovementComponent();
	uint8 RequestToStartSprinting : 1;
	uint8 RequestToStartADS : 1;
	virtual float GetMaxSpeed() const override;
	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
	// Sprint
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	void StartSprinting();
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	void StopSprinting();
	

	// Aim Down Sights
	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
	void StartAimDownSights();
	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
	void StopAimDownSights();
};
</file>

<file path="WitchPT/Public/Character/Components/WitchPTMechanicComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "Item/MechanicsInterface.h"
#include "WitchPTMechanicComponent.generated.h"

class ACauldronAltar;

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	UWitchPTMechanicComponent();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	
	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
	virtual void RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
	
	UFUNCTION(Server, Reliable)
	void Server_RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
	
	

	
	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
	

	

protected:

	
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
};
</file>

<file path="WitchPT/Public/Character/WitchPTCharacter.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTCharacterBase.h"
#include "Item/CauldronAltar.h"
#include "Item/MechanicsInterface.h"
#include "Blueprint/UserWidget.h"
#include "Components/WidgetComponent.h" // Necesitas un Widget Component
#include "UObject/ConstructorHelpers.h"
#include "WitchPTCharacter.generated.h"

class UWitchPTMechanicComponent;
class ACauldronAltar;
class ARitualPosition;

UCLASS()
class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
	virtual void PossessedBy(AController* NewController) override;
	virtual void OnRep_PlayerState() override;
	
	virtual void InitAbilityActorInfo() override;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
	

	




	


};
</file>

<file path="WitchPT/Public/Character/WitchPTCharacterBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemInterface.h"
#include "GameFramework/Character.h"
#include "WitchPTCharacterBase.generated.h"

class UWitchPTAbilitySystemComponent;
class UWitchPTAttributeSet;
class UGameplayAbility;
class UGameplayEffect;
class UAttributeSet;

UCLASS(Abstract)
class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);

	// Getter for ASC Main Components
	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }

protected:
	UPROPERTY()
	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
	UPROPERTY()
	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
	TSubclassOf<UGameplayEffect> DefaultAttributes;
	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;

	// These effects are only applied one time on startup
	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;

	virtual void InitializeDefaultAttributes();
	
	virtual void GrantStartupAbilities();

	virtual void AddStartupEffects();

	virtual void InitAbilityActorInfo();
private:
	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);



public:
	/**
	* Getters for attributes from GDAttributeSetBase
	**/
	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetHealth() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxHealth() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetStamina() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxStamina() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetAge() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxAge() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMana() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxMana() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetSpeedMultiplier() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMoveSpeed() const;

	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
	float GetMaxMoveSpeed() const;

	

	

	

};
</file>

<file path="WitchPT/Public/Character/WitchPTEnemy.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTCharacterBase.h"
#include "WitchPTEnemy.generated.h"

UCLASS()
class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
};
</file>

<file path="WitchPT/Public/FWitchPTGameplayTags.cpp">
#include "FWitchPTGameplayTags.h"

#include "GameplayTagsManager.h"

FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;

void FWitchPTGameplayTags::InitializeGameplayTags()
{
	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));

	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
	
	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
	// Cauldron Abilities
	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));

	/**
	 * Input Tags
	 */
	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
	// Ritual
	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));

	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));

	// --- Ritual Event Tags ---
	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));

	
	// Cauldron Tags
	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));


	// Communication Messages
	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));

	// --- Items Tags ---
	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));

	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));



	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
	
	// Base Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));

	// Principal Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));

	// Modifier Category Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
	
	// Modifier Potency Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
	
	// Modifier Duration Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
	
	// Modifier Charges Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
	
	// Modifier Target Tags
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));

}
</file>

<file path="WitchPT/Public/FWitchPTGameplayTags.h">
#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
	/**
	 * @brief Singleton accessor to all native GameplayTags.
	 *
	 * @return Reference to the singleton instance of WitchPTGameplayTags.
	 * @note To use the Singleton:
	 * const FAuraGameplayTags& AuraGameplayTags = FAuraGameplayTags::Get();
	 */
struct FWitchPTGameplayTags
{
public:
	static FWitchPTGameplayTags& Get() { return GameplayTags; }
	static void InitializeGameplayTags();


	/**
	* Attributes Primary Tags
	*/
	FGameplayTag Attributes_Primary_Health;
	FGameplayTag Attributes_Primary_Age;
	FGameplayTag Attributes_Secondary_Mana;
	FGameplayTag Attributes_Secondary_Stamina;
	// State Tags
	FGameplayTag Character_State_Movement_Sprinting;
	FGameplayTag Character_State_Movement_Crouching;
	FGameplayTag Character_State_Movement_MovingToPosition;
	FGameplayTag Character_State_Dead;
	FGameplayTag Character_State_Aim;
	FGameplayTag Character_State_Blocked;
	
	FGameplayTag Character_State_Cauldron_InPosition;
	FGameplayTag Character_State_Cauldron_Carrying;
	FGameplayTag Character_State_Cauldron_Placing;
	FGameplayTag Character_State_Cauldron_InGame;
	FGameplayTag Character_State_Cauldron_BrewingPotion;
	
	FGameplayTag Character_State_Ritual_InPosition;
	FGameplayTag Character_State_Ritual_InGame;

	// Ability Tags
	FGameplayTag Ability_Interact;
	FGameplayTag Ability_Sprint;
	FGameplayTag Ability_Jump;
	FGameplayTag Ability_Crouch;
	FGameplayTag Ability_Ritual_GoToPosition;
	FGameplayTag Ability_Ritual_ParticipatingInRitual;
	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
	FGameplayTag Ability_Ritual_Start;
	FGameplayTag Ability_Ritual_SendInput;





	
	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
	FGameplayTag Ability_Cauldron_CarryingCauldron;
	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
	FGameplayTag Ability_Cauldron_SetInPlace;
	FGameplayTag Ability_Cauldron_CancelSetInPlace;

	
	



	// Input Tags
	FGameplayTag InputTag_LMB;
	FGameplayTag InputTag_RMB;
	FGameplayTag InputTag_1;
	FGameplayTag InputTag_2;
	FGameplayTag InputTag_3;
	FGameplayTag InputTag_4;
	FGameplayTag InputTag_5;
	FGameplayTag InputTag_6;
	FGameplayTag InputTag_7;
	FGameplayTag InputTag_8;
	FGameplayTag InputTag_9;
	FGameplayTag InputTag_0;
	FGameplayTag InputTag_Ctrl;
	FGameplayTag InputTag_Alt;
	FGameplayTag InputTag_Shift;
	FGameplayTag InputTag_Tab;


	// --- Ritual Position Tags ---
	FGameplayTag Ritual_Position_1;
	FGameplayTag Ritual_Position_2;
	FGameplayTag Ritual_Position_3;
	FGameplayTag Ritual_Position_4;

	FGameplayTag Ritual_Input_Up;
	FGameplayTag Ritual_Input_Down;
	FGameplayTag Ritual_Input_Left;
	FGameplayTag Ritual_Input_Right;

	// --- Ritual Event Tags ---
	FGameplayTag Event_Ritual_InputSuccess;
	FGameplayTag Event_Ritual_InputFailure;
	FGameplayTag Event_Ritual_SequenceSuccess;
	FGameplayTag Event_Ritual_SequenceFailure;
	FGameplayTag Event_Ritual_CatastrophicFailure;
	
	

	// --- Event Tags ---
	FGameplayTag Event_Ritual_InputReceived;
	FGameplayTag Event_Ritual_TurnAdvanced;
	FGameplayTag Event_Ritual_SequenceFail;
	FGameplayTag Event_Ritual_CatastrophicFail;

	// Cauldron Tags
	FGameplayTag Cauldron_State_Empty;
	FGameplayTag Cauldron_State_Full;
	FGameplayTag Cauldron_State_PotionReady;
	FGameplayTag Event_Cauldron_CharacterPositioned;


	// Communication tags
	FGameplayTag Communication_Message;

	// --- Items Tags ---
	FGameplayTag Item;
	FGameplayTag Item_Consumable;
	FGameplayTag Item_Consumable_Potion;
	FGameplayTag Item_Consumable_Potion_Tier_0;
	FGameplayTag Item_Consumable_Potion_Tier_1;
	FGameplayTag Item_Consumable_Potion_Tier_2;
	FGameplayTag Item_Consumable_Potion_Tier_3;
	
	FGameplayTag Item_Consumable_Ingredient;
	FGameplayTag Item_Consumable_Ingredient_Tier_0;
	FGameplayTag Item_Consumable_Ingredient_Tier_1;
	FGameplayTag Item_Consumable_Ingredient_Tier_2;
	FGameplayTag Item_Consumable_Ingredient_Tier_3;


	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;

	FGameplayTag Item_Consumable_Ingredient_Category_Base;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
	
	
	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;

	




	// --------------------------- Modifier Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
	// --------------------------- Modifier Potency Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
	// --------------------------- Modifier Duration Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
	// --------------------------- Modifier Charges Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
	// --------------------------- Modifier Application Tags ---------------------------
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
	




private:
	static FWitchPTGameplayTags GameplayTags;
	
	
};
</file>

<file path="WitchPT/Public/Game/WitchPTGameModeBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "WitchPTGameModeBase.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/Input/WitchPTInputComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "EnhancedInputComponent.h"
#include "WitchPTInputConfig.h"

#include "WitchPTInputComponent.generated.h"


UCLASS()
class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
{
	GENERATED_BODY()

public:
	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);

};

template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
{
	check(InputConfig);
	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
	{
		if (Action.InputAction && Action.InputTag.IsValid())
		{
			if (PressedFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
			}
			if (ReleasedFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
			}
			if (HeldFunc)
			{
				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
			}
		}
	}
	
}
</file>

<file path="WitchPT/Public/Input/WitchPTInputConfig.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "WitchPTInputConfig.generated.h"

USTRUCT(BlueprintType)
struct FWitchPTInputAction
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly)
	const class UInputAction* InputAction = nullptr;

	UPROPERTY(EditDefaultsOnly)
	FGameplayTag InputTag = FGameplayTag();
};
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInputConfig : public UDataAsset
{
	GENERATED_BODY()
	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TArray<FWitchPTInputAction> AbilityInputActions;
	
};
</file>

<file path="WitchPT/Public/Inventory/Collectable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "Templates/SubclassOf.h"
#include "UObject/Interface.h"
#include "UObject/ObjectPtr.h"
#include "Collectable.generated.h"
template <typename InterfaceType> class TScriptInterface;
// This class does not need to be modified.

class AActor;
class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
class UObject;
struct FFrame;
// ------------------------- STRUCTS ---------------------- //
USTRUCT(BlueprintType)
struct FItemManifest
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
};


UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UCollectable : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API ICollectable
{
	GENERATED_BODY()

public:
	/**
	 * This is the functions you call from the GA_Interact_Collect
	 */
	UFUNCTION(BlueprintCallable)
	virtual FItemManifest GetPickupInventory() const = 0;
};

UCLASS()
class UCollectableStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UCollectableStatics();
	
	UFUNCTION(BlueprintPure)
	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
};
</file>

<file path="WitchPT/Public/Inventory/FastArray/FastArrayList.h">
#pragma once

#include "CoreMinimal.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "FastArrayList.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
struct FWitchPTInventoryList;

/**
 * FWitchPTInventoryEntry
 * 
 * Represents a single item entry in the inventory.
 * Uses FastArraySerializer for efficient replication.
 */
USTRUCT(BlueprintType)
struct FWitchPTInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FWitchPTInventoryEntry()
	{}

	/**
	 * Get a debug string representation of this inventory entry
	 * @return FString - A string describing the item instance and its definition
	 */
	FString GetDebugString() const;

private:
	friend FWitchPTInventoryList;
	friend UWitchPTInventoryManagerComponent;

	/** The actual item instance this entry represents */
	UPROPERTY()
	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
	
};

/**
 * FWitchPTInventoryList
 * 
 * A collection of inventory entries that supports efficient replication.
 * Uses FastArraySerializer to minimize network traffic when replicating inventory changes.
 * Handles adding, removing, and updating inventory items.
 */
USTRUCT(BlueprintType)
struct FWitchPTInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	/** Default constructor */
	FWitchPTInventoryList()
		: OwnerComponent(nullptr)
	{
	}

	/**
	 * Constructor with owner component
	 * @param InOwnerComponent - The component that owns this inventory list
	 */
	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
		: OwnerComponent(InOwnerComponent)
	{
	}

	/**
	 * Get all item instances in the inventory
	 * @return TArray<UWitchPTInventoryItemInstance*> - Array of all item instances
	 */
	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;

public:
	//~FFastArraySerializer contract
	/**
	 * Called before items are removed during replication
	 * Broadcasts the OnItemRemoved event for each removed item
	 */
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	
	/**
	 * Called after items are added during replication
	 * Broadcasts the OnItemAdded event for each added item
	 */
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	
	/**
	 * Called after items are changed during replication
	 * Broadcasts the OnItemStackChanged event for each changed item
	 */
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	/**
	 * Serializes the delta between two states of the array
	 * Required for FastArraySerializer functionality
	 */
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
	}

	/**
	 * Create a new inventory entry with the specified item definition
	 * Initializes the item instance and sets up its stack count based on the definition
	 *
	 * @param ItemClass The class of the inventory item to add
	 * @return A pointer to the newly created inventory item instance
	 */
	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
	
	/**
	 * Adds an existing item instance to the inventory list
	 *
	 * @param Instance The inventory item instance to add
	 */
	void AddEntry(UWitchPTInventoryItemInstance* Instance);

	/**
	 * Removes an item instance from the inventory list
	 * 
	 * @param Instance The inventory item instance to remove
	 */
	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);

private:
	friend UWitchPTInventoryManagerComponent;

private:
	/** Replicated list of inventory entries */
	UPROPERTY()
	TArray<FWitchPTInventoryEntry> Entries;

	/** Non-replicated reference to the owner component */
	UPROPERTY(NotReplicated)
	TObjectPtr<UActorComponent> OwnerComponent;
};

/**
 * Trait specification for FWitchPTInventoryList
 * Enables network delta serialization for efficient replication
 */
template<>
struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
{
	enum { WithNetDeltaSerializer = true };
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryFragment_Stackable.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	
	int32 GetMaxStackSize() const { return MaxStackSize; }
	int32 GetStackCount() const { return StackCount; }
	void SetStackCount(int32 Count) { StackCount = Count; }

private:

	UPROPERTY(EditAnywhere, Category = "Inventory")
	int32 MaxStackSize{1};

	UPROPERTY(EditAnywhere, Category = "Inventory")
	int32 StackCount{1};
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryFragment_UIDetails.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FText Title;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FText Description;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TSubclassOf<UUserWidget> IconWidget;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag TierTag;
	
	
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
#include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"

USTRUCT(BlueprintType)
struct FBaseIngredientData
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag BaseLiquidTypeTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	int32 DefaultChargesProvided;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float StabilityModifier;
};

USTRUCT(BlueprintType)
struct FPrincipalIngredientData 
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag PrincipalEssenceTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float BasePotency;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float BaseDuration;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	bool bIsRitualEssence;
};

USTRUCT(BlueprintType)
struct FModifierIngredientData 
{
	GENERATED_BODY()
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTagContainer ModifierEffectTags;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float PotencyModificationValue;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float DurationModificationValue;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag GrantedPropertyTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag AddedEffectTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	float StrengthOfModifier;
	
};
UCLASS()
class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
{
	GENERATED_BODY()
public:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag SlotUsageTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag TierTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag CategoryTag;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FBaseIngredientData BaseIngredientData;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FPrincipalIngredientData PrincipalIngredientData;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FModifierIngredientData ModifierIngredientData;

	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
};
</file>

<file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Templates/SubclassOf.h"
#include "WitchPTInventoryItemFragment.generated.h"

template <typename T> class TSubclassOf;

class UWitchPTInventoryItemInstance;
/**
 * 
 */
UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
{
	GENERATED_BODY()

public:
	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
	
};
</file>

<file path="WitchPT/Public/Inventory/InventoryFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "InventoryFunctionLibrary.generated.h"

class UInventoryWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, Category="Inventory")
	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTInventoryFunctionLibrary.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemFragment;
/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "WitchPTInventoryItemDefinition.generated.h"

class UWitchPTInventoryItemFragment;
struct FFrame;
/**
 * 
 */
UCLASS(Blueprintable, Const, Abstract)
class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;

	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Systems/GameplayTagStack.h"
#include "Templates/SubclassOf.h"
#include "WitchPTInventoryItemInstance.generated.h"
class UWitchPTInventoryItemFragment;
class UWitchPTInventoryItemDefinition;
struct FFrame;
struct FGameplayTag;

/**
 * 
 */
UCLASS(BlueprintType)
class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
{
	GENERATED_BODY()
public:
	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	friend struct FWitchPTInventoryList;
	
	//~UObject interface
	virtual bool IsSupportedForNetworking() const override { return true; }
	//~End of UObject interface


	UFUNCTION(BlueprintCallable)
	int32 GetTotalStackCount() const { return TotalStackCount; }
	
	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
	{
		return ItemDef;
	}

	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;

	template <typename ResultClass>
	const ResultClass* FindFragmentByClass() const
	{
		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
	}

	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);


private:
	UPROPERTY(Replicated)
	int32 TotalStackCount{0};
	
	UPROPERTY(Replicated)
	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
	
};
</file>

<file path="WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "FastArray/FastArrayList.h"
#include "Net/Serialization/FastArraySerializer.h"
#include "WitchPTInventoryManagerComponent.generated.h"

class UInventoryUserWidget;
class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class UWitchPTInventoryManagerComponent;
class UObject;
struct FFrame;
struct FNetDeltaSerializeInfo;
struct FWitchPTInventoryList;
struct FReplicationFlags;

/**
 * Delegate for inventory item events.
 * Used to broadcast when items are added, removed, or their stack counts change.
 * @param UWitchPTInventoryItemInstance* - The item instance that was affected
 */
DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);

/**
 * WitchPTInventoryManagerComponent
 * 
 * A component that manages a player's inventory of items.
 * Handles adding, removing, and stacking items, as well as replicating inventory state across the network.
 * Uses a fast array serializer for efficient replication of inventory items.
 */
UCLASS(BlueprintType)
class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
{
	GENERATED_BODY()
protected:
	virtual void BeginPlay() override;

public:
	UFUNCTION(BlueprintCallable)
	UInventoryUserWidget* GetInventoryMenuWidget() const { return InventoryMenu; }
	
	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());


	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);

	
	UFUNCTION(Server, Reliable)
	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);

	
	UFUNCTION(Server, Reliable)
	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);


	UFUNCTION(Server, Reliable)
	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);

	
	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;

	
	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;

	
	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
	
	
	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);

	// Delegates for inventory events
	
	/** Fired when a new item is added to the inventory */
	FOnItemChanged OnItemAdded;
	
	/** Fired when an item's stack count changes */
	FOnItemChanged OnItemStackChanged;
	
	/** Fired when an item is removed from the inventory */
	FOnItemChanged OnItemRemoved;

	//~UObject interface
	/**
	 * Replicates all inventory item instances as subobjects
	 * Required for proper replication of the inventory system
	 */
	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	
	/**
	 * Called when the component is ready for replication
	 * Registers all existing inventory items for replication
	 */
	virtual void ReadyForReplication() override;
	//~End of UObject interface

private:
	/**
	 * The replicated list of inventory items
	 * Uses a fast array serializer for efficient replication
	 */
	UPROPERTY(Replicated)
	FWitchPTInventoryList InventoryList;
	UPROPERTY()
	TObjectPtr<UInventoryUserWidget> InventoryMenu;


	UPROPERTY(EditAnywhere, Category = "Inventory")
	TSubclassOf<UInventoryUserWidget> InventoryMenuClass;

	TWeakObjectPtr<APlayerController> OwningController;
	UFUNCTION(BlueprintCallable, Category= "Inventory")
	void ToggleInventoryMenu();
	void ConstructInventory();
	bool bInventoryMenuOpen;
	UFUNCTION(BlueprintCallable, Category= "Inventory")
	void OpenInventoryMenu();
	UFUNCTION(BlueprintCallable, Category= "Inventory")
	void CloseInventoryMenu();
};
</file>

<file path="WitchPT/Public/Item/BaseInteractableAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "BaseInteractableAltar.generated.h"

class UWitchPTUserWidget;
class ABaseInteractionPosition;
class ACharacter;

/**
 * Base state enum for interaction state
 */
UENUM(BlueprintType)
enum class EInteractionState : uint8
{
    Inactive    UMETA(DisplayName = "Inactive"),
    WaitingForPlayers UMETA(DisplayName = "Waiting For Players"), // At least one player in position
    Preparing   UMETA(DisplayName = "Preparing"), // Players occupying positions
    Active      UMETA(DisplayName = "Active"),    // Sequence running
    Succeeded   UMETA(DisplayName = "Succeeded"),
    Failed      UMETA(DisplayName = "Failed"),
    FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);

// Estructura para mapear un jugador a su tag de posición
USTRUCT(BlueprintType)
struct FPlayerPositionTagEntry
{
    GENERATED_BODY();

    UPROPERTY(BlueprintReadWrite)
    TObjectPtr<ACharacter> Player = nullptr;

    UPROPERTY(BlueprintReadWrite)
    FGameplayTag PositionTag;
};

/**
 * Base class for interactive altars/cauldrons that players can interact with
 */
UCLASS(Abstract)
class WITCHPT_API ABaseInteractableAltar : public AActor
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ABaseInteractableAltar();
    virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
    
    // Current interaction state
    UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
    EInteractionState CurrentState = EInteractionState::Inactive;

    // Transforms defining brewing positions around the cauldron
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
    TArray<FTransform> PositionTransforms;

    // The class to spawn for brewing positions
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
    TSubclassOf<ABaseInteractionPosition> PositionClass;
    
    UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
    TArray<FGameplayTag> TagsPositions;
    
    // List of players participating in the interaction
    UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
    TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
    
    
    // Positions for interaction
    UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
    TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;

    UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
    TArray<FPlayerPositionTagEntry> PlayerPositionTags;
    
    // Basic interaction methods
  
    virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
    

    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    virtual void CreateAltarPositions();
    

    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    virtual void DestroyAltarPositions();

    
    
    // Multicast RPCs for notifications
    UFUNCTION(NetMulticast, Reliable)
    void Multicast_OnStateChanged(EInteractionState NewState);
    
    UFUNCTION(NetMulticast, Reliable)
    virtual void Multicast_OnInputSuccess(ACharacter* Character);
    
    UFUNCTION(NetMulticast, Reliable)
    virtual void Multicast_OnInputFailed(ACharacter* Character);
    
    
    // Getters for Blueprint/HUD access
    UFUNCTION(BlueprintPure, Category = "Interaction")
    EInteractionState GetCurrentState() const { return CurrentState; }

    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;
    

    
    UFUNCTION()
    virtual void OnRep_ParticipatingPlayers();
    
    
    // Helper functions
    virtual void HandleInputSuccess(ACharacter* Player);
    virtual void HandleInputFailure(ACharacter* Player);
    virtual void CheckState();
    virtual void CleanupInteraction();
    virtual void SpawnReward();
    virtual void SpawnDemon();
    virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
    
};
</file>

<file path="WitchPT/Public/Item/BaseInteractionPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/Item.h"
#include "AbilitySystem/Interaction/InteractionOption.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "MechanicsInterface.h"
#include "BaseInteractionPosition.generated.h"

class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;
class ABaseInteractableAltar;

/**
 * Base class for interaction positions (rituals, cauldrons, etc)
 */
UCLASS(Abstract)
class WITCHPT_API ABaseInteractionPosition : public AItem
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ABaseInteractionPosition();

    //~ Begin AActor Interface
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
    virtual void BeginPlay() override;
    //~ End AActor Interface

    //~ Begin IInteraction Interface (from AItem presumably)
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    //~ End IInteraction Interface

    //~ Getters

    UFUNCTION(BlueprintPure, Category = "Interaction")
    ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }

    UFUNCTION(BlueprintPure, Category = "Interaction")
    FGameplayTag GetPositionTag() const { return PositionTag; }
    //~ End Getters
    virtual bool IsOccupied() const;

    //~ Setters
    UFUNCTION()
    void SetOccupied(ACharacter* Character);

    UFUNCTION()
    void SetUnoccupied();

    UFUNCTION()
    void SetPositionTag(const FGameplayTag& NewTag);

protected:
    // Unique tag identifying this position (e.g., Ritual.Position.1). Set per instance.
    UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
    FGameplayTag PositionTag;

    // Is this position currently occupied by a player? Replicated.
    UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
    bool bIsOccupied = false;

    // Which character is currently occupying this position? Replicated.
    UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
    TObjectPtr<ACharacter> OccupyingCharacter = nullptr;

    // Variables potentially used by the base AItem interaction system
    UPROPERTY()
    TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;

    UPROPERTY()
    TWeakObjectPtr<AController> InteractingController;

    //~ Replication Notifies
    UFUNCTION()
    void OnRep_IsOccupied();

    UFUNCTION()
    void OnRep_OccupyingCharacter();
    //~ End Replication Notifies

    // Interaction Logic Helper (Called from GatherInteractionOptions or a specific interaction GA)
    virtual void HandleInteraction(ACharacter* InteractingCharacter);

private:
    void RemoveCharacterFromPosition();
};
</file>

<file path="WitchPT/Public/Item/CauldronAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractableAltar.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "MechanicsInterface.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "CauldronAltar.generated.h"

class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
class UWitchPTInventoryItemFragment;
class UCauldronUserWidget;
class ACauldronPosition;
class ACharacter;

// Estructura para contener secuencias de ingredientes
USTRUCT(BlueprintType)
struct FIngredientSequence
{
    GENERATED_BODY()
    
    UPROPERTY(BlueprintReadOnly)
    TArray<FGameplayTag> Ingredients;
};

// Enum for cauldron inputs
UENUM(BlueprintType)
enum class ECauldronInput : uint8
{
    Ingredient1 UMETA(DisplayName = "Ingredient 1"),
    Ingredient2 UMETA(DisplayName = "Ingredient 2"),
    Ingredient3 UMETA(DisplayName = "Ingredient 3"),
    Ingredient4 UMETA(DisplayName = "Ingredient 4"),
    Ingredient5 UMETA(DisplayName = "Ingredient 5"),
    None        UMETA(DisplayName = "None")
};

UENUM(BlueprintType)
enum ECauldronPhysicState
{
    Static UMETA(DisplayName = "InPlace"),
    Moving UMETA(DisplayName = "Moving"),
    Previewing UMETA(DisplayName = "Previewing")
};

// Enum para el estado de validación de la posición del caldero
UENUM(BlueprintType)
enum class ECauldronPlacementState : uint8
{
    Valid UMETA(DisplayName = "Valid"),
    Invalid UMETA(DisplayName = "Invalid"),
    None UMETA(DisplayName = "None")
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);

/**
 * Cauldron altar allows players to add ingredients in any order (unlike ritual's sequential inputs)
 */
UCLASS()
class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ACauldronAltar();
    
    // Overrides
    virtual void BeginPlay() override;
    virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
    virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
    
    // Core Properties
    UPROPERTY(EditAnywhere)
    FInteractionOption Option;
    
    UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
    TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;

    // Base ingredient
    UPROPERTY(VisibleAnywhere)
    UWitchPTInventoryItemInstance* BaseIngredient;
    UPROPERTY(VisibleAnywhere)
    UWitchPTInventoryItemInstance* PrincipalIngredient;
    UPROPERTY(VisibleAnywhere)
    UWitchPTInventoryItemInstance* ModifierIngredient;
    
    UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
    TSubclassOf<UUserWidget> BaseIngredientIcon;

    UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
    TSubclassOf<UUserWidget> PrincipalIngredientIcon;

    UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
    TSubclassOf<UUserWidget> ModifierIngredientIcon;
    
    // ----------------------------------- DELEGATES  ---------------------------------------------- //

    FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
    FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
    FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
    FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
    FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
    FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
    UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
    FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
    
    UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
    FOnCharacterPositioned OnCharacterPositioned;
    
    // UI Properties
    UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
    TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
    
    // Placement Properties
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    UMaterialInterface* ValidPlacementMaterial;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    UMaterialInterface* InvalidPlacementMaterial;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    float PlacementCollisionCheckRadius = 50.0f;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
    float MaxGroundAlignmentHeight = 20.0f;
    
    // ----------------------------------- BREWING FUNCTIONS ---------------------------------------------- //
    
    void StartBrewingPotion(ACharacter* InteractingCharacter);
   
    void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
    
    // ----------------------------------- ON REP FUNCTIONS ---------------------------------------------- //
    
    UFUNCTION()
    void OnRep_CauldronPhysicState();
    UFUNCTION()
    void OnRep_BaseIngredientIcon();
    UFUNCTION()
    void OnRep_PrincipalIngredientIcon();
    UFUNCTION()
    void OnRep_PotentiatorIngredientIcon();
    
    UFUNCTION()
    void PositionCharacterForBrewing(ACharacter* Character);
    
    UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
    ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
    
    
    // ----------------------------------- CAULDRON MOVEMENT FUNCTIONS ---------------------------------------------- //
    void StartCarryCauldron(ACharacter* InteractingCharacter);
    
    UFUNCTION()
    void AttachToCharacter(ACharacter* Character);
    
    UFUNCTION()
    void DetachFromCharacter(ACharacter* Character);
    
    // ----------------------------------- PLACEMENT FUNCTIONS ---------------------------------------------- //
    void StartPlacementPreview(ACharacter* Character);
    void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
    void FinalizePlacement();
    void CancelPlacement();
    void ApplyPlacementPreviewMaterial();
    
    UFUNCTION(Client, Unreliable)
    void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
    
    UFUNCTION(NetMulticast, Reliable)
    void Multicast_FinalizePlacement();
    
    // ----------------------------------- STATE QUERY FUNCTIONS ---------------------------------------------- //
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    bool CanBePickedUp() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    bool IsBeingCarried() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    ACharacter* GetCarryingCharacter() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
    ECauldronPlacementState GetPlacementState() const;
    
    UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
    bool IsInPlacementPreview() const;
    // ----------------------------------- GETTERS ---------------------------------------------- //
    
    UWitchPTInventoryItemInstance* GetBaseIngredient() const;
    UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
    UWitchPTInventoryItemInstance* GetModifierIngredient() const;
    
protected:
    // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
    void BroadcastBaseIngredientDropped() const;
    void BroadcastBaseIngredientIconSet() const;
    void BroadcastPrincipalIngredientDropped() const;
    void BroadcastPrincipalIngredientIconSet() const;
    void BroadcastModifierIngredientDropped() const;
    void BroadcastModifierIngredientIconSet() const;

    
private:
    UPROPERTY(Replicated)
    TObjectPtr<ACharacter> CarryingCharacter;
    
    UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
    FName BackAttachSocketName = "BackpackSocket";
    
    UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
    FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
    
    // Placement Properties
    UPROPERTY(Replicated)
    ECauldronPlacementState CurrentPlacementState;
    
    UPROPERTY()
    TArray<UMaterialInterface*> OriginalMaterials;
    
    FVector PreviewLocation;
    FRotator PreviewRotation;
    
    // Private Utility Functions
    void RestoreOriginalMaterials();
    bool IsPlacementValid() const;
};
</file>

<file path="WitchPT/Public/Item/CauldronPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractionPosition.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "CauldronPosition.generated.h"

// Forward Declarations
class ACauldronAltar;
class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;

/**
 * Position for interacting with a Cauldron altar
 */
UCLASS()
class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
{
    GENERATED_BODY()

public:
    // Sets default values for this actor's properties
    ACauldronPosition();

    //~ Begin AActor Interface
    virtual void BeginPlay() override;
    //~ End AActor Interface

    //~ Begin IInteraction Interface (from AItem)
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
    //~ End IInteraction Interface

    //~ Getters
    UFUNCTION(BlueprintPure, Category = "Cauldron")
    ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
    //~ End Getters

    //~ Setters
    UFUNCTION(BlueprintCallable)
    void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
    //~ End Setters
    //
    // /**
    //  * Posiciona un personaje en esta ubicación
    //  * @param Character El personaje a posicionar
    //  * @return True si el personaje fue posicionado correctamente
    //  */
    // UFUNCTION(BlueprintCallable, Category = "Cauldron|Interaction")
    // bool PositionCharacter(ACharacter* Character);
    //
    // /**
    //  * Comprueba si esta posición está ocupada
    //  * @return True si la posición está ocupada por un personaje
    //  */
    // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    // bool IsOccupied() const;
    //
    // /**
    //  * Establece el estado de ocupación de esta posición
    //  * @param bInOccupied Si la posición está ocupada
    //  * @param InOccupyingCharacter El personaje que ocupa la posición
    //  */
    // UFUNCTION(BlueprintCallable, Category = "Cauldron|State")
    // void SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter = nullptr);
    //
    // /**
    //  * Obtiene el personaje que ocupa esta posición
    //  * @return El personaje que ocupa la posición, o nullptr si no está ocupada
    //  */
    // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
    // ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }

protected:
    // Reference to the parent altar
    UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
    TObjectPtr<ACauldronAltar> CauldronAltar;

    // Interaction Logic Helper
    virtual void HandleInteraction(ACharacter* InteractingCharacter) override;

private:
    // Find the CauldronAltar if not set
    void FindCauldronAltar();
    //
    // // Character currently occupying this position
    // UPROPERTY()
    // TObjectPtr<ACharacter> OccupyingCharacter;
    //
    // // Whether this position is currently occupied
    // UPROPERTY()
    // bool bIsOccupied;
};
</file>

<file path="WitchPT/Public/Item/Ingredient/IngredientBase.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Inventory/Collectable.h"
#include "Item/Item.h"
#include "IngredientBase.generated.h"

UCLASS()
class WITCHPT_API AIngredientBase : public AItem, public ICollectable
{
	GENERATED_BODY()

public:

	AIngredientBase();
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
	virtual FItemManifest GetPickupInventory() const override;
	
protected:

	UPROPERTY(EditAnywhere)
	FItemManifest StaticInventory;

};
</file>

<file path="WitchPT/Public/Item/Item.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystem/Interaction/IInteractableTarget.h"
#include "GameFramework/Actor.h"
#include "Item.generated.h"

UCLASS()
class WITCHPT_API AItem : public AActor, public IInteractableTarget
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AItem();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	UPROPERTY(EditAnywhere)
	FInteractionOption Option;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
};
</file>

<file path="WitchPT/Public/Item/MechanicsInterface.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "UObject/Interface.h"
#include "MechanicsInterface.generated.h"

class UWitchPTInventoryItemDefinition;
class UWitchPTInventoryItemInstance;
class ABaseInteractionPosition;
class ACauldronAltar;
class ARitualPosition;
class ARitualAltar;
class ACharacter;

// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class UMechanicsInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API IMechanicsInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
	
public:
	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestStartRitual(ARitualAltar* TargetAltar);
	

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);


	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
	
	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);

	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
	void RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
	
	
	// General Queries that might be implemented by positions or other interactables
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
	ARitualAltar* GetRitualAltarActor() const;

	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
	bool IsOccuppied() const;
	
};
</file>

<file path="WitchPT/Public/Item/PositionInterface.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "PositionInterface.generated.h"

class ARitualAltar;
// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class UPositionInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class WITCHPT_API IPositionInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
	ARitualAltar* GetRitualAltarActor() const;
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
	bool IsOccupied();
};
</file>

<file path="WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "UI/WidgetControllers/CauldronWidgetController.h"
#include "RitualFunctionLibrary.generated.h"

class UWitchPTWidgetController;
class URitualWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(Category="Ritual")
	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
	UFUNCTION(Category="Cauldron")
	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
};
</file>

<file path="WitchPT/Public/Item/RitualAltar.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractableAltar.h"
#include "GameplayTagContainer.h" // Include for FGameplayTag
#include "RitualAltar.generated.h"

class URitualUserWidget;
class ARitualPosition;

// Enum defining the possible inputs for the ritual sequence
UENUM(BlueprintType)
enum class ERitualInput : uint8
{
	Up		UMETA(DisplayName = "Up"),
	Down	UMETA(DisplayName = "Down"),
	Left	UMETA(DisplayName = "Left"),
	Right	UMETA(DisplayName = "Right"),
	None	UMETA(DisplayName = "None") // Optional: For default/invalid state
};

USTRUCT(BlueprintType)
struct FUIRitualData
{
	GENERATED_BODY()
	UPROPERTY(BlueprintReadOnly)
	bool bIsMyTurn = false;
	UPROPERTY(BlueprintReadOnly)
	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
	UPROPERTY(BlueprintReadOnly)
	float RitualPercentageCompleted = 0.0f;
	UPROPERTY(BlueprintReadOnly)
	float CorruptionPercentage = 0.0f;
	UPROPERTY(BlueprintReadOnly)
	float CurrentInputTimeRemaining = 0.0f;
};

// Replicated struct for ready players data
USTRUCT(BlueprintType)
struct FRitualReadyPlayersData
{
	GENERATED_BODY()
	
	UPROPERTY(BlueprintReadOnly)
	int32 TotalPlayers = 0;
	
	UPROPERTY(BlueprintReadOnly)
	int32 ReadyPlayers = 0;
	
	bool operator==(const FRitualReadyPlayersData& Other) const
	{
		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
	}
	
	bool operator!=(const FRitualReadyPlayersData& Other) const
	{
		return !(*this == Other);
	}
};

// Delegates for UI updates - these will be called from OnRep functions
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);

UCLASS()
class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ARitualAltar();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
	
	// ----------------------------------- REPLICATED PROPERTIES ---------------------------------------------- //
	// Current ritual state
	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
	EInteractionState CurrentRitualState = EInteractionState::Inactive;
	
	// Current sequence of inputs required for the ritual
	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
	TArray<FGameplayTag> InputSequence;

	// Current index in the sequence
	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
	int32 CurrentSequenceIndex = -1;
	
	// Players who have confirmed they're ready to start
	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
	
	// Ready players data for UI
	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
	FRitualReadyPlayersData ReadyPlayersData;
	
	// Current countdown value (when starting ritual)
	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
	int32 StartCountdown = 3;
	
	// Current player whose turn it is to input
	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
	TObjectPtr<ACharacter> CurrentActivePlayer;
	
	// Timer for the current input
	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
	float CurrentInputTimer;
	
	// Current turn data for UI
	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
	FUIRitualData CurrentTurnData;
	
	// Current corruption level
	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
	float CorruptionAmount = 0.0f;

	// Maximum corruption allowed before catastrophic failure
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float MaxCorruption = 100.0f;
	
	// Corruption increase per failure
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float CorruptionIncreasePerFail = 10.0f;
	
	// Base time window for inputs
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float BaseInputTimeWindow = 10.0f;
	
	// Scaling multiplier for difficulty
	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
	float DifficultyScalingMultiplier = 1.0f;
	
	// Ritual completion status
	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
	bool bRitualCompleted = false;
	
	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
	bool bRitualWasSuccessful = false;
	
	// ----------------------------------- DELEGATES ---------------------------------------------- //
	FOnRitualStateChanged OnRitualStateChangedEvent;
	
	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
	
	FOnCountdownTick OnCountdownTickEvent;
	
	FOnTurnDataChanged OnTurnDataChangedEvent;
	
	FOnCorruptionChanged OnCorruptionChangedEvent;
	
	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
	UPROPERTY(BlueprintAssignable)
	FOnRitualCompleted OnRitualCompletedEvent;

	// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
	UFUNCTION()
	void OnRep_CurrentRitualState();
	
	UFUNCTION()
	void OnRep_CurrentSequenceIndex();
	
	UFUNCTION()
	void OnRep_ReadyPlayersData();
	
	UFUNCTION()
	void OnRep_StartCountdown();
	
	UFUNCTION()
	void OnRep_CurrentActivePlayer();
	
	UFUNCTION()
	void OnRep_TurnData();
	
	UFUNCTION()
	void OnRep_CorruptionAmount();
	
	UFUNCTION()
	void OnRep_RitualCompleted();

	// ----------------------------------- MAIN FUNCTIONS ---------------------------------------------- //
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
	
	void StartRitual(ACharacter* RequestingCharacter);
	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
	
	// New function to check player ready status
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool IsPlayerReady(ACharacter* Player) const;
	
	// New function to check if all players are ready
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool AreAllPlayersReady() const;
	
	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
	
	// Multicast RPCs for notifications
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnRitualSucceeded();
	
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnRitualCatastrophicFail();
	
	// New multicast RPC for countdown
	UFUNCTION(NetMulticast, Reliable)
	void Multicast_OnCountdownTick(int32 CountdownValue);
	
	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
	
	// ---------------------------- GETTERS FOR WC ---------------------------- //
	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
	float GetCorruptionPercentage() const;
	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
	float GetCurrentSequenceProgress() const;
	FGameplayTag GetCurrentExpectedInput() const;
	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }


protected:
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaTime) override;
	
	// Timer handle for the ritual start countdown
	FTimerHandle RitualStartCountdownHandle;
	
	// Timer handles
	FTimerHandle InputTimerHandle;
	
	// ----------------------------------- LOGIC FUNCTIONS ---------------------------------------------- //
	void GenerateInputSequence();
	void AdvanceToNextPlayer();
	virtual void HandleInputSuccess(ACharacter* Player) override;
	virtual void HandleInputFailure(ACharacter* Player) override;
	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
	void StartInputTimer();
	void OnInputTimerExpired();
	void CheckRitualState();
	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
	void CleanupRitual();
	void SpawnReward();
	void SpawnDemon();
	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
	void UpdateTurnData();
	void UpdateReadyPlayersData();
	
	// New helper functions for the ready system
	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
	void StartRitualCountdown();
	void ProcessCountdownTick();
	void ActivateRitual();
	
	// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
	void BroadcastRitualStateChanged();
	void BroadcastReadyPlayersChanged();
	void BroadcastCountdownTick();
	void BroadcastTurnDataChanged();
	void BroadcastCorruptionChanged();
	void BroadcastSequenceProgressChanged();
	void BroadcastRitualCompleted();

	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> FailedAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
	
	// Animation montages specifically for ritual
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
};
</file>

<file path="WitchPT/Public/Item/RitualPosition.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Item/BaseInteractionPosition.h"
#include "GameplayTagContainer.h" // Added for FGameplayTag
#include "MechanicsInterface.h" // For GetRitualAltarActor & IsOccuppied if still needed
#include "PositionInterface.h"
#include "RitualPosition.generated.h"

// Forward Declarations
class ARitualAltar;
class UAbilitySystemComponent;
struct FGameplayAbilitySpec;
class AController;
class UGameplayAbility;
class UBoxComponent;
class ACharacter;

UCLASS()
class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ARitualPosition();
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	//~ Begin AActor Interface
	virtual void BeginPlay() override;
	//~ End AActor Interface

	//~ Begin IInteraction Interface (from AItem)
	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
	//~ End IInteraction Interface
	
	// Still part of IMechanicsInterface if these are general queries
	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
   

	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
	virtual bool IsOccupied_Implementation() override;

protected:
	// Reference to the parent altar
	UPROPERTY(EditInstanceOnly, Replicated)
	TObjectPtr<ARitualAltar> RitualAltar;

	// Interaction Logic Helper
	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;

private:
	// Find the RitualAltar if not set
	
};
</file>

<file path="WitchPT/Public/Player/WitchPTPlayerController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "UI/Widgets/PointerWidget.h"
#include "WitchPTPlayerController.generated.h"

class UCauldronUserWidget;
class ABaseInteractableAltar;
class ACauldronAltar;
class ARitualAltar;
class UWitchPTInventoryManagerComponent;
struct FGameplayTag;
class UWitchPTAbilitySystemComponent;
class UWitchPTInputConfig;
struct FInputActionValue;
class UInputAction;
class UInputMappingContext;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTPlayerController : public APlayerController
{
	GENERATED_BODY()
public:
	AWitchPTPlayerController();
	virtual void PlayerTick(float DeltaTime) override;
	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;

	void LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar);
	bool HasRitualWidgetInitialized(ABaseInteractableAltar* Altar);
	void LocalToggleCauldronMenu();
	



	UFUNCTION(Client, Reliable)
	void Client_InitializeRitualUserWidget(ABaseInteractableAltar* Altar);

	UFUNCTION(Client, Reliable)
	void Client_ToggleCauldronMenu();


	UPROPERTY(Replicated, VisibleAnywhere)
	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
	UPROPERTY()
	TObjectPtr<UPointerWidget> HUDWidget;
	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
protected:
	virtual void BeginPlay() override;
	virtual void SetupInputComponent() override;

	// Actions
	UPROPERTY(EditAnywhere, Category="Input")
	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
	UPROPERTY(EditAnywhere, Category="Input")
	TObjectPtr<UInputAction> MoveAction;
	UPROPERTY(EditAnywhere, Category= "Input")
	TObjectPtr<UInputAction> LookAction;
	//InputConfig
	UPROPERTY(EditDefaultsOnly, Category= "Input")
	TObjectPtr<UWitchPTInputConfig> InputConfig;

	// Ability System Component
	UPROPERTY()
	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;

	UWitchPTAbilitySystemComponent* GetASC();
	
	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TSubclassOf<UPointerWidget> HUDWidgetClass;

	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;

	

private:

	void Move(const FInputActionValue& InputActionValue);

	void Look(const FInputActionValue& Value);

	void AbilityInputTagPressed(FGameplayTag InputTag);
	void AbilityInputTagReleased(FGameplayTag InputTag);
	void AbilityInputTagHeld(FGameplayTag InputTag);

	void ConstructCauldronWidget();

	void CreateHUDWidget();
	void OpenCauldronMenu();
	void CloseCauldronMenu();
	bool bCauldronMenuOpen = false;
	
	// Array de altares para los que ya se ha creado un widget
	UPROPERTY()
	TObjectPtr<ARitualAltar> ThisRitualAltarHasWidget;
	UPROPERTY()
	TObjectPtr<UCauldronUserWidget> CauldronAltarMenu;
	
};
</file>

<file path="WitchPT/Public/Player/WitchPTPlayerState.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AbilitySystemInterface.h"
#include "GameFramework/PlayerState.h"
#include "WitchPTPlayerState.generated.h"
class ARitualPosition;
class ARitualAltar;
class UAbilitySystemComponent;
class UAttributeSet;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
{
	GENERATED_BODY()
	AWitchPTPlayerState();
public:

	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
	UAttributeSet* GetAttributeSet() const { return AttributeSet; }

protected:
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAttributeSet> AttributeSet;
	
	
};
</file>

<file path="WitchPT/Public/Systems/GameplayTagStack.cpp">
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Systems/GameplayTagStack.h"

#include "UObject/Stack.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)

//////////////////////////////////////////////////////////////////////
// FGameplayTagStack

FString FGameplayTagStack::GetDebugString() const
{
	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
}

//////////////////////////////////////////////////////////////////////
// FGameplayTagStackContainer

void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
{
	if (!Tag.IsValid())
	{
		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
		return;
	}

	if (StackCount > 0)
	{
		for (FGameplayTagStack& Stack : Stacks)
		{
			if (Stack.Tag == Tag)
			{
				const int32 NewCount = Stack.StackCount + StackCount;
				Stack.StackCount = NewCount;
				TagToCountMap[Tag] = NewCount;
				MarkItemDirty(Stack);
				return;
			}
		}

		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
		MarkItemDirty(NewStack);
		TagToCountMap.Add(Tag, StackCount);
	}
}

void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
{
	if (!Tag.IsValid())
	{
		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
		return;
	}

	//@TODO: Should we error if you try to remove a stack that doesn't exist or has a smaller count?
	if (StackCount > 0)
	{
		for (auto It = Stacks.CreateIterator(); It; ++It)
		{
			FGameplayTagStack& Stack = *It;
			if (Stack.Tag == Tag)
			{
				if (Stack.StackCount <= StackCount)
				{
					It.RemoveCurrent();
					TagToCountMap.Remove(Tag);
					MarkArrayDirty();
				}
				else
				{
					const int32 NewCount = Stack.StackCount - StackCount;
					Stack.StackCount = NewCount;
					TagToCountMap[Tag] = NewCount;
					MarkItemDirty(Stack);
				}
				return;
			}
		}
	}
}

void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (int32 Index : RemovedIndices)
	{
		const FGameplayTag Tag = Stacks[Index].Tag;
		TagToCountMap.Remove(Tag);
	}
}

void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (int32 Index : AddedIndices)
	{
		const FGameplayTagStack& Stack = Stacks[Index];
		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
	}
}

void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (int32 Index : ChangedIndices)
	{
		const FGameplayTagStack& Stack = Stacks[Index];
		TagToCountMap[Stack.Tag] = Stack.StackCount;
	}
}
</file>

<file path="WitchPT/Public/Systems/GameplayTagStack.h">
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameplayTagContainer.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "GameplayTagStack.generated.h"

struct FGameplayTagStackContainer;
struct FNetDeltaSerializeInfo;

/**
 * Represents one stack of a gameplay tag (tag + count)
 */
USTRUCT(BlueprintType)
struct FGameplayTagStack : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FGameplayTagStack()
	{}

	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
		: Tag(InTag)
		, StackCount(InStackCount)
	{
	}

	FString GetDebugString() const;

private:
	friend FGameplayTagStackContainer;

	UPROPERTY()
	FGameplayTag Tag;

	UPROPERTY()
	int32 StackCount = 0;
};

/** Container of gameplay tag stacks */
USTRUCT(BlueprintType)
struct FGameplayTagStackContainer : public FFastArraySerializer
{
	GENERATED_BODY()

	FGameplayTagStackContainer()
	//	: Owner(nullptr)
	{
	}

public:
	// Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
	void AddStack(FGameplayTag Tag, int32 StackCount);

	// Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
	void RemoveStack(FGameplayTag Tag, int32 StackCount);

	// Returns the stack count of the specified tag (or 0 if the tag is not present)
	int32 GetStackCount(FGameplayTag Tag) const
	{
		return TagToCountMap.FindRef(Tag);
	}

	// Returns true if there is at least one stack of the specified tag
	bool ContainsTag(FGameplayTag Tag) const
	{
		return TagToCountMap.Contains(Tag);
	}

	//~FFastArraySerializer contract
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
	}

private:
	// Replicated list of gameplay tag stacks
	UPROPERTY()
	TArray<FGameplayTagStack> Stacks;
	
	// Accelerated list of tag stacks for queries
	TMap<FGameplayTag, int32> TagToCountMap;
};

template<>
struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
{
	enum
	{
		WithNetDeltaSerializer = true,
	};
};
</file>

<file path="WitchPT/Public/UI/HUD/WitchPTHUD.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "WitchPTHUD.generated.h"

class UCauldronWidgetController;
class UWitchPTWidgetController;
class URitualWidgetController;
class UAbilitySystemComponent;
class UAttributeSet;
class UWitchPTUserWidget;
class UInventoryWidgetController;
struct FWidgetControllerParams;
class UOverlayWidgetController;
/**
 * 
 */
UCLASS()
class WITCHPT_API AWitchPTHUD : public AHUD
{
	GENERATED_BODY()
public:
	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);

	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);



private:
	UPROPERTY()
	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;


	UPROPERTY()
	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<URitualWidgetController> RitualWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;

	UPROPERTY()
	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
	UPROPERTY(EditAnywhere)
	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTWidgetController.h"
#include "CauldronWidgetController.generated.h"

class ACauldronAltar;
class UWitchPTInventoryItemInstance;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
/**
 * 
 */
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
public:
	UCauldronWidgetController();
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;

	// Delegates for widgets to subscribe to
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;

	UFUNCTION(Category = "Cauldron")
	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);

	// Getter for the current ritual altar
	UFUNCTION(BlueprintPure, Category = "Cauldron")
	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }


protected:
	// Reference to the ritual altar that this widget controls
	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
	TObjectPtr<ACauldronAltar> CauldronAltar;

	UFUNCTION(Category = "Cauldron")
	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
	UFUNCTION(Category = "Cauldron")
	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
	UFUNCTION(Category = "Cauldron")
	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
	UFUNCTION(Category = "Cauldron")
	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTWidgetController.h"
#include "InventoryWidgetController.generated.h"

/**
 * 
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);

UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
	
public:
	UFUNCTION(BlueprintCallable)
	virtual void BindCallbacksToDependencies() override;
						
	/**
	 * Removes a stack or specified amount from an inventory item instance
	 * If there's only one stack left and count is 1, removes the item completely
	 * @param ItemInstance - The item instance to remove from
	 * @param AmountToRemove - The amount to remove, defaults to 1
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);

	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemAddedSignature OnItemAddedDelegate;
	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemAddedSignature OnItemStackChangedDelegate;
	UPROPERTY(BlueprintAssignable, Category="Inventory")
	FOnItemRemovedSignature OnItemRemovedDelegate;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTWidgetController.h"
#include "OverlayWidgetController.generated.h"
class UWitchPTUserWidget;

USTRUCT()
struct FUIWidgetRow: public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FGameplayTag MessageGameplayTag = FGameplayTag();

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FText Message = FText();

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSubclassOf<UWitchPTUserWidget> MessageWidget;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	UTexture2D* Image = nullptr;
	
};


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);

UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
public:
	/**
	 * Handles the reception of asset gameplay tags from a Gameplay Effect (GE).
	 *
	 * This method is triggered when a Gameplay Effect sends a set of gameplay tags
	 * as part of its asset definition. It usually processes or reacts to the tags
	 * received within the container.
	 *
	 * @param TagContainer A container of gameplay tags associated with the triggered Gameplay Effect.
	 */
	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
	virtual void BroadcastInitialValues() override;

	virtual void BindCallbacksToDependencies() override;



	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnHealthChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxHealthChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnStaminaChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxStaminaChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnAgeChanged;
	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
	FOnAttributeChangedSignature OnMaxAgeChanged;

	UPROPERTY(BlueprintAssignable, Category="Widget Data")
	FOnMessageWidgetRowSignature OnMessageWidgetRow;
protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
	TObjectPtr<UDataTable> MessageWidgetDataTable;

	template<typename T>
T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
};

template <typename T>
T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
{
	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));

}
</file>

<file path="WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "WitchPTWidgetController.h"
#include "Item/RitualAltar.h"
#include "RitualWidgetController.generated.h"

enum class ERitualInput : uint8;
class ARitualAltar;
class ACharacter;
enum class EInteractionState : uint8;

// Delegate to notify when the expected input in the ritual changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
// Delegate to notify when the ready players count changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
// Delegate to notify when the countdown ticks
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
// Delegate to notify when turn data changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
// Delegate to notify ritual state changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
// Delegate to notify corruption changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
// Delegate to notify sequence progress changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
// Delegate to notify when the ritual is completed
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);

/**
 * Widget Controller to manage the ritual UI
 */
UCLASS(BlueprintType, Blueprintable)
class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
{
	GENERATED_BODY()
	
public:
	URitualWidgetController();
	
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;
	
	// Method to set the associated ritual altar
	UFUNCTION(Category = "Ritual")
	void SetRitualAltar(ARitualAltar* InRitualAltar);
	
	// Getter for the current ritual altar
	UFUNCTION(BlueprintPure, Category = "Ritual")
	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
	
	// Checks if the current player is the active player in the ritual
	UFUNCTION(BlueprintPure, Category = "Ritual")
	bool IsLocalPlayerActive() const;
	
	// Delegates for widgets to subscribe to
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;

	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;

	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
	
	UPROPERTY(BlueprintAssignable, Category = "Ritual")
	FOnRitualCompletedSignature_WC OnRitualCompleted;

protected:
	// Reference to the ritual altar that this widget controls
	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
	TObjectPtr<ARitualAltar> RitualAltar;
	
	// Callbacks for altar changes
	UFUNCTION()
	void HandleRitualStateChanged(EInteractionState NewState);
	
	UFUNCTION()
	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
	
	UFUNCTION()
	void HandleCountdownTick(int32 CountdownValue);
	
	UFUNCTION()
	void HandleTurnDataChanged(FUIRitualData TurnData);
	
	UFUNCTION()
	void HandleCorruptionChanged(float CorruptionPercentage);
	
	UFUNCTION()
	void HandleSequenceProgressChanged(float ProgressPercentage);
	
	UFUNCTION()
	void HandleRitualCompleted(bool bWasSuccessful);
	
private:
	// Helper function to determine if local player's turn and update turn data accordingly
	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
};
</file>

<file path="WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "WitchPTWidgetController.generated.h"

class UAbilitySystemComponent;
class UAttributeSet;
/**
 * @struct FWidgetControllerParams
 * @brief A structure that encapsulates parameters required to initialize a widget controller.
 *
 * This structure is designed to pass necessary references into widget controllers for proper functionality,
 * primarily used in player-related widgets to access player-specific systems and attributes.
 *
 * It includes references to the Player Controller, Player State, Ability System Component,
 * and an Attribute Set. These references allow the widget controller to interact with the gameplay systems
 * linked to a player.
 *
 * @note Each of the parameters is a nullable pointer to account for scenarios where specific components
 * may not be initialized or required.
 */
USTRUCT(BlueprintType)
struct FWidgetControllerParams
{
	GENERATED_BODY()
	FWidgetControllerParams() {};
	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
	:
	PlayerController(PC),
	PlayerState(PS),
	AbilitySystemComponent(ASC),
	AttributeSet(AS)
	{}
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerController> PlayerController = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerState> PlayerState = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
	
};
UCLASS()
class WITCHPT_API UWitchPTWidgetController : public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);

	UFUNCTION(BlueprintCallable)
	virtual void BroadcastInitialValues();
	virtual void BindCallbacksToDependencies();
protected:
	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<APlayerController> PlayerController;
	
	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<APlayerState> PlayerState;

	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;

	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
	TObjectPtr<UAttributeSet> AttributeSet;
};
</file>

<file path="WitchPT/Public/UI/Widgets/CauldronUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "WitchPTUserWidget.h"
#include "CauldronUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
private:
	virtual void NativeConstruct() override;
	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
};
</file>

<file path="WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "InventoryUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
	
};
</file>

<file path="WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UI/Widgets/WitchPTUserWidget.h"
#include "RitualUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
{
	GENERATED_BODY()
};
</file>

<file path="WitchPT/Public/UI/Widgets/PointerWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "PointerWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UPointerWidget : public UUserWidget
{
	GENERATED_BODY()
public:
	
	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
	void ShowPickupMessage(const FString& Message);

	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
	void HidePickupMessage();
};
</file>

<file path="WitchPT/Public/UI/Widgets/WitchPTUserWidget.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "WitchPTUserWidget.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTUserWidget : public UUserWidget
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	void SetWidgetController(UObject* InWidgetController);
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UObject> WidgetController;

	UFUNCTION(BlueprintImplementableEvent)
	void OnWidgetControllerSet();
};
</file>

<file path="WitchPT/Public/WitchPTAssetManager.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/AssetManager.h"
#include "WitchPTAssetManager.generated.h"

/**
 * 
 */
UCLASS()
class WITCHPT_API UWitchPTAssetManager : public UAssetManager
{
	GENERATED_BODY()
public:
	static UWitchPTAssetManager& Get();
protected:
	virtual void StartInitialLoading() override;

	
};
</file>

<file path="WitchPT/WitchPT.Build.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;

public class WitchPT : ModuleRules
{
	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });

		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}
</file>

<file path="WitchPT/WitchPT.cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#include "WitchPT.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );
</file>

<file path="WitchPT/WitchPT.h">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
#define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
#define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)
</file>

<file path="WitchPTEditor.Target.cs">
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class WitchPTEditorTarget : TargetRules
{
	public WitchPTEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V5;

		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
	}
}
</file>

</files>
