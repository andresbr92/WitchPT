This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, line numbers have been added.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.test.ts, docs/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.gitignore
.vsconfig
AITools/repomix_output.txt
Config/DefaultEditor.ini
Config/DefaultEngine.ini
Config/DefaultGame.ini
Config/DefaultGameplayTags.ini
Config/DefaultInput.ini
repomix-output.xml
repomix.config.json5
Source/repomix-output.xml
Source/WitchPT.Target.cs
Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
Source/WitchPT/Private/Character/WitchPTCharacter.cpp
Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
Source/WitchPT/Private/Character/WitchPTEnemy.cpp
Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
Source/WitchPT/Private/Inventory/Collectable.cpp
Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
Source/WitchPT/Private/Item/CauldronAltar.cpp
Source/WitchPT/Private/Item/CauldronPosition.cpp
Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
Source/WitchPT/Private/Item/Item.cpp
Source/WitchPT/Private/Item/MechanicsInterface.cpp
Source/WitchPT/Private/Item/PositionInterface.cpp
Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
Source/WitchPT/Private/Item/RitualAltar.cpp
Source/WitchPT/Private/Item/RitualPosition.cpp
Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
Source/WitchPT/Private/WitchPTAssetManager.cpp
Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
Source/WitchPT/Public/Character/WitchPTCharacter.h
Source/WitchPT/Public/Character/WitchPTCharacterBase.h
Source/WitchPT/Public/Character/WitchPTEnemy.h
Source/WitchPT/Public/FWitchPTGameplayTags.cpp
Source/WitchPT/Public/FWitchPTGameplayTags.h
Source/WitchPT/Public/Game/WitchPTGameModeBase.h
Source/WitchPT/Public/Input/WitchPTInputComponent.h
Source/WitchPT/Public/Input/WitchPTInputConfig.h
Source/WitchPT/Public/Inventory/Collectable.h
Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
Source/WitchPT/Public/Item/BaseInteractableAltar.h
Source/WitchPT/Public/Item/BaseInteractionPosition.h
Source/WitchPT/Public/Item/CauldronAltar.h
Source/WitchPT/Public/Item/CauldronPosition.h
Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
Source/WitchPT/Public/Item/Item.h
Source/WitchPT/Public/Item/MechanicsInterface.h
Source/WitchPT/Public/Item/PositionInterface.h
Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
Source/WitchPT/Public/Item/RitualAltar.h
Source/WitchPT/Public/Item/RitualPosition.h
Source/WitchPT/Public/Player/WitchPTPlayerController.h
Source/WitchPT/Public/Player/WitchPTPlayerState.h
Source/WitchPT/Public/Systems/GameplayTagStack.cpp
Source/WitchPT/Public/Systems/GameplayTagStack.h
Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
Source/WitchPT/Public/UI/Widgets/PointerWidget.h
Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
Source/WitchPT/Public/WitchPTAssetManager.h
Source/WitchPT/WitchPT.Build.cs
Source/WitchPT/WitchPT.cpp
Source/WitchPT/WitchPT.h
Source/WitchPTEditor.Target.cs
WitchPT.uproject
WitchPT.uproject.DotSettings.user
```

# Files

## File: Source/repomix-output.xml
```xml
    1: This file is a merged representation of the entire codebase, combined into a single document by Repomix.
    2: 
    3: <file_summary>
    4: This section contains a summary of this file.
    5: 
    6: <purpose>
    7: This file contains a packed representation of the entire repository's contents.
    8: It is designed to be easily consumable by AI systems for analysis, code review,
    9: or other automated processes.
   10: </purpose>
   11: 
   12: <file_format>
   13: The content is organized as follows:
   14: 1. This summary section
   15: 2. Repository information
   16: 3. Directory structure
   17: 4. Repository files (if enabled)
   18: 5. Multiple file entries, each consisting of:
   19:   - File path as an attribute
   20:   - Full contents of the file
   21: </file_format>
   22: 
   23: <usage_guidelines>
   24: - This file should be treated as read-only. Any changes should be made to the
   25:   original repository files, not this packed version.
   26: - When processing this file, use the file path to distinguish
   27:   between different files in the repository.
   28: - Be aware that this file may contain sensitive information. Handle it with
   29:   the same level of security as you would the original repository.
   30: </usage_guidelines>
   31: 
   32: <notes>
   33: - Some files may have been excluded based on .gitignore rules and Repomix's configuration
   34: - Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
   35: - Files matching patterns in .gitignore are excluded
   36: - Files matching default ignore patterns are excluded
   37: - Files are sorted by Git change count (files with more changes are at the bottom)
   38: </notes>
   39: 
   40: </file_summary>
   41: 
   42: <directory_structure>
   43: WitchPT.Target.cs
   44: WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
   45: WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp
   46: WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp
   47: WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
   48: WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
   49: WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
   50: WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
   51: WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
   52: WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
   53: WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
   54: WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
   55: WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
   56: WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
   57: WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
   58: WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
   59: WitchPT/Private/Character/WitchPTCharacter.cpp
   60: WitchPT/Private/Character/WitchPTCharacterBase.cpp
   61: WitchPT/Private/Character/WitchPTEnemy.cpp
   62: WitchPT/Private/Game/WitchPTGameModeBase.cpp
   63: WitchPT/Private/Input/WitchPTInputComponent.cpp
   64: WitchPT/Private/Input/WitchPTInputConfig.cpp
   65: WitchPT/Private/Inventory/Collectable.cpp
   66: WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
   67: WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
   68: WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
   69: WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
   70: WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
   71: WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
   72: WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
   73: WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
   74: WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
   75: WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
   76: WitchPT/Private/Item/BaseInteractableAltar.cpp
   77: WitchPT/Private/Item/BaseInteractionPosition.cpp
   78: WitchPT/Private/Item/CauldronAltar.cpp
   79: WitchPT/Private/Item/CauldronPosition.cpp
   80: WitchPT/Private/Item/Ingredient/IngredientBase.cpp
   81: WitchPT/Private/Item/Item.cpp
   82: WitchPT/Private/Item/MechanicsInterface.cpp
   83: WitchPT/Private/Item/PositionInterface.cpp
   84: WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
   85: WitchPT/Private/Item/RitualAltar.cpp
   86: WitchPT/Private/Item/RitualPosition.cpp
   87: WitchPT/Private/Player/WitchPTPlayerController.cpp
   88: WitchPT/Private/Player/WitchPTPlayerState.cpp
   89: WitchPT/Private/UI/HUD/WitchPTHUD.cpp
   90: WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
   91: WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
   92: WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
   93: WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
   94: WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
   95: WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
   96: WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
   97: WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
   98: WitchPT/Private/UI/Widgets/PointerWidget.cpp
   99: WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
  100: WitchPT/Private/WitchPTAssetManager.cpp
  101: WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
  102: WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h
  103: WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h
  104: WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
  105: WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
  106: WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
  107: WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
  108: WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
  109: WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
  110: WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
  111: WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
  112: WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
  113: WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
  114: WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
  115: WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
  116: WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
  117: WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
  118: WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
  119: WitchPT/Public/Character/WitchPTCharacter.h
  120: WitchPT/Public/Character/WitchPTCharacterBase.h
  121: WitchPT/Public/Character/WitchPTEnemy.h
  122: WitchPT/Public/FWitchPTGameplayTags.cpp
  123: WitchPT/Public/FWitchPTGameplayTags.h
  124: WitchPT/Public/Game/WitchPTGameModeBase.h
  125: WitchPT/Public/Input/WitchPTInputComponent.h
  126: WitchPT/Public/Input/WitchPTInputConfig.h
  127: WitchPT/Public/Inventory/Collectable.h
  128: WitchPT/Public/Inventory/FastArray/FastArrayList.h
  129: WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
  130: WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
  131: WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
  132: WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
  133: WitchPT/Public/Inventory/InventoryFunctionLibrary.h
  134: WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
  135: WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
  136: WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
  137: WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
  138: WitchPT/Public/Item/BaseInteractableAltar.h
  139: WitchPT/Public/Item/BaseInteractionPosition.h
  140: WitchPT/Public/Item/CauldronAltar.h
  141: WitchPT/Public/Item/CauldronPosition.h
  142: WitchPT/Public/Item/Ingredient/IngredientBase.h
  143: WitchPT/Public/Item/Item.h
  144: WitchPT/Public/Item/MechanicsInterface.h
  145: WitchPT/Public/Item/PositionInterface.h
  146: WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
  147: WitchPT/Public/Item/RitualAltar.h
  148: WitchPT/Public/Item/RitualPosition.h
  149: WitchPT/Public/Player/WitchPTPlayerController.h
  150: WitchPT/Public/Player/WitchPTPlayerState.h
  151: WitchPT/Public/Systems/GameplayTagStack.cpp
  152: WitchPT/Public/Systems/GameplayTagStack.h
  153: WitchPT/Public/UI/HUD/WitchPTHUD.h
  154: WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
  155: WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
  156: WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
  157: WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
  158: WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
  159: WitchPT/Public/UI/Widgets/CauldronUserWidget.h
  160: WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
  161: WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
  162: WitchPT/Public/UI/Widgets/PointerWidget.h
  163: WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
  164: WitchPT/Public/WitchPTAssetManager.h
  165: WitchPT/WitchPT.Build.cs
  166: WitchPT/WitchPT.cpp
  167: WitchPT/WitchPT.h
  168: WitchPTEditor.Target.cs
  169: </directory_structure>
  170: 
  171: <files>
  172: This section contains the contents of the repository's files.
  173: 
  174: <file path="WitchPT.Target.cs">
  175: // Fill out your copyright notice in the Description page of Project Settings.
  176: 
  177: using UnrealBuildTool;
  178: using System.Collections.Generic;
  179: 
  180: public class WitchPTTarget : TargetRules
  181: {
  182: 	public WitchPTTarget(TargetInfo Target) : base(Target)
  183: 	{
  184: 		Type = TargetType.Game;
  185: 		DefaultBuildSettings = BuildSettingsVersion.V5;
  186: 
  187: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
  188: 	}
  189: }
  190: </file>
  191: 
  192: <file path="WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp">
  193: // Fill out your copyright notice in the Description page of Project Settings.
  194: 
  195: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  196: #include "AbilitySystemComponent.h"
  197: #include "GameFramework/PlayerController.h"
  198: #include "Engine/World.h"
  199: #include "DrawDebugHelpers.h"
  200: #include "TimerManager.h"
  201: #include "GameFramework/Character.h"
  202: #include "Camera/CameraComponent.h"
  203: 
  204: UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
  205: 	: Super(ObjectInitializer)
  206: {
  207: 	bTickingTask = true;
  208: 	TraceDistance = 500.0f;
  209: 	TraceRadius = 10.0f;
  210: 	bTraceComplex = false;
  211: 	bIgnoreBlockingHits = false;
  212: 	bShowDebug = false;
  213: 	LastHitLocation = FVector::ZeroVector;
  214: 	LastHitNormal = FVector::UpVector;
  215: }
  216: 
  217: UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
  218: 	UGameplayAbility* OwningAbility,
  219: 	float TraceDistance,
  220: 	float TraceRadius,
  221: 	bool TraceComplex,
  222: 	bool bIgnoreBlockingHits,
  223: 	bool bShowDebug)
  224: {
  225: 	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
  226: 
  227: 	MyObj->TraceDistance = TraceDistance;
  228: 	MyObj->TraceRadius = TraceRadius;
  229: 	MyObj->bTraceComplex = TraceComplex;
  230: 	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
  231: 	MyObj->bShowDebug = bShowDebug;
  232: 
  233: 	return MyObj;
  234: }
  235: 
  236: void UAT_WaitForPlacementLocation_SLT::Activate()
  237: {
  238: 	Super::Activate();
  239: 
  240: 	// Configurar para ejecutar el trace en cada tick
  241: 	SetWaitingOnAvatar();
  242: 
  243: 	// Realizar un primer trace inmediatamente
  244: 	PerformTrace();
  245: }
  246: 
  247: void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
  248: {
  249: 	// Limpiar el temporizador si está activo
  250: 	UWorld* World = GetWorld();
  251: 	if (World)
  252: 	{
  253: 		World->GetTimerManager().ClearTimer(TraceTimerHandle);
  254: 	}
  255: 
  256: 	Super::OnDestroy(bInOwnerFinished);
  257: }
  258: 
  259: void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
  260: {
  261: 	Super::TickTask(DeltaTime);
  262: 
  263: 	// Realizar el trace en cada tick
  264: 	PerformTrace();
  265: }
  266: 
  267: void UAT_WaitForPlacementLocation_SLT::PerformTrace()
  268: {
  269: 	if (!Ability || !Ability->GetCurrentActorInfo())
  270: 	{
  271: 		return;
  272: 	}
  273: 
  274: 	// Obtener el controlador del jugador
  275: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
  276: 	if (!PC)
  277: 	{
  278: 		return;
  279: 	}
  280: 
  281: 	// Obtener el personaje del jugador (necesario para obtener la cámara)
  282: 	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
  283: 	if (!Character)
  284: 	{
  285: 		return;
  286: 	}
  287: 
  288: 	// Definir los puntos de inicio y fin del trace
  289: 	FVector TraceStart;
  290: 	FVector TraceDirection;
  291: 
  292: 	// Buscar un componente de cámara en el personaje
  293: 	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
  294: 	if (CameraComponent)
  295: 	{
  296: 		// Usar la posición y dirección de la cámara para el trace
  297: 		TraceStart = CameraComponent->GetComponentLocation();
  298: 		TraceDirection = CameraComponent->GetForwardVector();
  299: 	}
  300: 	else
  301: 	{
  302: 		// Si no hay cámara, usar la rotación del controlador
  303: 		FRotator ControllerRotation = PC->GetControlRotation();
  304: 		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
  305: 		TraceDirection = ControllerRotation.Vector();
  306: 	}
  307: 
  308: 	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
  309: 
  310: 	// Configurar parámetros del trace
  311: 	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
  312: 	QueryParams.AddIgnoredActor(Character);
  313: 
  314: 	// Configurar qué tipos de objetos detectar
  315: 	ECollisionChannel TraceChannel = ECC_Visibility;
  316: 
  317: 	// Realizar el trace
  318: 	FHitResult HitResult;
  319: 	bool bHit = false;
  320: 
  321: 	// Realizar un sphere trace o line trace según el radio
  322: 	if (TraceRadius > 0.0f)
  323: 	{
  324: 		bHit = GetWorld()->SweepSingleByChannel(
  325: 			HitResult,
  326: 			TraceStart,
  327: 			TraceEnd,
  328: 			FQuat::Identity,
  329: 			TraceChannel,
  330: 			FCollisionShape::MakeSphere(TraceRadius),
  331: 			QueryParams
  332: 		);
  333: 	}
  334: 	else
  335: 	{
  336: 		bHit = GetWorld()->LineTraceSingleByChannel(
  337: 			HitResult,
  338: 			TraceStart,
  339: 			TraceEnd,
  340: 			TraceChannel,
  341: 			QueryParams
  342: 		);
  343: 	}
  344: 
  345: 	// Si encontramos un hit y es diferente al último que reportamos
  346: 	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
  347: 	{
  348: 		// Almacenar los nuevos valores
  349: 		LastHitLocation = HitResult.ImpactPoint;
  350: 		LastHitNormal = HitResult.ImpactNormal;
  351: 
  352: 		// Disparar el delegado con la información del hit
  353: 		if (ShouldBroadcastAbilityTaskDelegates())
  354: 		{
  355: 			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
  356: 		}
  357: 	}
  358: 
  359: 	// Mostrar debug si está habilitado
  360: 	if (bShowDebug)
  361: 	{
  362: 		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
  363: 
  364: 		if (bHit)
  365: 		{
  366: 			// Dibujar una esfera en el punto de impacto
  367: 			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
  368: 
  369: 			// Dibujar la normal
  370: 			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
  371: 		}
  372: 	}
  373: }
  374: </file>
  375: 
  376: <file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp">
  377: // Fill out your copyright notice in the Description page of Project Settings.
  378: 
  379: #include "AbilitySystem/Cauldron/GA_CauldronPlace.h"
  380: #include "Item/CauldronAltar.h"
  381: #include "GameFramework/Character.h"
  382: #include "Engine/World.h"
  383: #include "Kismet/GameplayStatics.h"
  384: 
  385: UGA_CauldronPlace::UGA_CauldronPlace()
  386: {
  387:     // Configurar entradas para esta habilidad
  388: 
  389: 
  390:     // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
  391:     InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
  392: 
  393:     // Flags de red
  394:     NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
  395: 
  396:     // No se requiere confirmación para activar
  397:     bServerRespectsRemoteAbilityCancellation = true;
  398: }
  399: 
  400: void UGA_CauldronPlace::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
  401: {
  402:     // Llamar a la implementación base
  403:     if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
  404:     {
  405:         EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
  406:         return;
  407:     }
  408: 
  409:     // Buscar el caldero que está en modo previsualización
  410:     ACauldronAltar* CauldronAltar = FindPreviewingCauldron();
  411:     if (!CauldronAltar)
  412:     {
  413:         UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlace: No se encontró un caldero en modo previsualización"));
  414:         EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
  415:         return;
  416:     }
  417: 
  418:     // Intentar finalizar la colocación
  419:     // CauldronAltar->Server_FinalizePlacement();
  420: 
  421: 
  422: 
  423:     // Terminar la habilidad independientemente del resultado
  424:     EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
  425: }
  426: 
  427: ACauldronAltar* UGA_CauldronPlace::FindPreviewingCauldron()
  428: {
  429:     // Obtener el personaje que está usando la habilidad
  430:     ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
  431:     if (!Character)
  432:     {
  433:         return nullptr;
  434:     }
  435: 
  436:     // Buscar todos los calderos en el mundo
  437:     TArray<AActor*> FoundCauldrons;
  438:     UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
  439: 
  440:     // Buscar el caldero que está en modo previsualización para este personaje
  441:     for (AActor* Actor : FoundCauldrons)
  442:     {
  443:         ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
  444:         if (Cauldron && Cauldron->IsInPlacementPreview() && Cauldron->GetCarryingCharacter() == Character)
  445:         {
  446:             return Cauldron;
  447:         }
  448:     }
  449: 
  450:     return nullptr;
  451: }
  452: </file>
  453: 
  454: <file path="WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp">
  455: // Fill out your copyright notice in the Description page of Project Settings.
  456: 
  457: #include "AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h"
  458: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  459: #include "Item/CauldronAltar.h"
  460: #include "AbilitySystemComponent.h"
  461: #include "GameFramework/Character.h"
  462: #include "Engine/World.h"
  463: #include "Kismet/GameplayStatics.h"
  464: 
  465: UGA_CauldronPlacementPreview::UGA_CauldronPlacementPreview()
  466: {
  467:     // Configurar entradas para esta habilidad
  468: 
  469:     // Definir la instanciación - esta habilidad puede ejecutarse en el servidor y cliente
  470:     InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
  471: 
  472:     // Flags de red
  473:     NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
  474: 
  475:     // No se requiere confirmación para activar
  476:     bServerRespectsRemoteAbilityCancellation = true;
  477: }
  478: 
  479: void UGA_CauldronPlacementPreview::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
  480: {
  481:     // Llamar a la implementación base
  482:     if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
  483:     {
  484:         EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
  485:         return;
  486:     }
  487: 
  488:     // Buscar el caldero que está llevando el personaje
  489:     CauldronAltar = FindCarriedCauldron();
  490:     if (!CauldronAltar)
  491:     {
  492:         UE_LOG(LogTemp, Warning, TEXT("GA_CauldronPlacementPreview: No se encontró un caldero que esté siendo llevado por el personaje"));
  493:         EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
  494:         return;
  495:     }
  496: 
  497:     // Iniciar el modo de previsualización en el caldero
  498:     // CauldronAltar->Server_StartPlacementPreview(Cast<ACharacter>(ActorInfo->AvatarActor.Get()));
  499: 
  500:     // Vincular entradas para confirmar/cancelar
  501:     FGameplayAbilityActorInfo* ActorInfoConst = const_cast<FGameplayAbilityActorInfo*>(ActorInfo);
  502: 
  503:     // Configurar vinculaciones de entrada
  504:     if (IsLocallyControlled())
  505:     {
  506:         // Vincular eventos de entrada para confirmar/cancelar
  507: 
  508:     }
  509: 
  510:     // Crear la tarea de seguimiento de ubicación
  511:     UAT_WaitForPlacementLocation_SLT* Task = UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
  512:         this,
  513:         TraceDistance,
  514:         TraceRadius,
  515:         bTraceComplex,
  516:         false,
  517:         bShowDebug
  518:     );
  519: 
  520:     if (Task)
  521:     {
  522:         // Configurar el callback para cuando encuentre una ubicación
  523:         Task->OnLocationFound.AddDynamic(this, &UGA_CauldronPlacementPreview::OnLocationFound);
  524: 
  525:         // Activar la tarea
  526:         Task->ReadyForActivation();
  527:     }
  528:     else
  529:     {
  530:         UE_LOG(LogTemp, Error, TEXT("GA_CauldronPlacementPreview: No se pudo crear la tarea de ubicación"));
  531:         EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
  532:     }
  533: 
  534:     // Llamar a la implementación base después de configurar todo
  535:     Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
  536: }
  537: 
  538: void UGA_CauldronPlacementPreview::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
  539: {
  540:     // Si la habilidad fue cancelada y tenemos un caldero, cancelar la colocación
  541:     if (bWasCancelled && CauldronAltar && CauldronAltar->IsInPlacementPreview())
  542:     {
  543:         // CauldronAltar->Server_CancelPlacement();
  544:     }
  545: 
  546:     // Desvincular entradas si es necesario
  547:     if (IsLocallyControlled())
  548:     {
  549:         // TODO: Desvincular eventos de entrada si es necesario
  550:     }
  551: 
  552:     Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
  553: }
  554: 
  555: ACauldronAltar* UGA_CauldronPlacementPreview::FindCarriedCauldron()
  556: {
  557:     // Obtener el personaje que está usando la habilidad
  558:     ACharacter* Character = Cast<ACharacter>(GetActorInfo().AvatarActor.Get());
  559:     if (!Character)
  560:     {
  561:         return nullptr;
  562:     }
  563: 
  564:     // Buscar todos los calderos en el mundo
  565:     TArray<AActor*> FoundCauldrons;
  566:     UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundCauldrons);
  567: 
  568:     // Buscar el caldero que está siendo llevado por este personaje
  569:     for (AActor* Actor : FoundCauldrons)
  570:     {
  571:         ACauldronAltar* Cauldron = Cast<ACauldronAltar>(Actor);
  572:         if (Cauldron && Cauldron->IsBeingCarried() && Cauldron->GetCarryingCharacter() == Character)
  573:         {
  574:             return Cauldron;
  575:         }
  576:     }
  577: 
  578:     return nullptr;
  579: }
  580: 
  581: void UGA_CauldronPlacementPreview::OnConfirmPlacement()
  582: {
  583:     if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
  584:     {
  585:          // CauldronAltar->Server_FinalizePlacement();
  586:         // if (bSuccess)
  587:         // {
  588:         //     // La colocación fue exitosa, terminar la habilidad
  589:         //     CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
  590:         // }
  591:         // Si no tuvo éxito, seguimos en modo de previsualización
  592:     }
  593: }
  594: 
  595: void UGA_CauldronPlacementPreview::OnCancelPlacement()
  596: {
  597:     if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
  598:     {
  599:         // Cancelar la colocación y volver a adjuntar el caldero al personaje
  600:         // CauldronAltar->Server_CancelPlacement();
  601:     }
  602: 
  603:     // Terminar la habilidad
  604:     CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
  605: }
  606: 
  607: void UGA_CauldronPlacementPreview::OnLocationFound(FVector HitLocation, FVector HitNormal)
  608: {
  609:     if (CauldronAltar && CauldronAltar->IsInPlacementPreview())
  610:     {
  611:         // Actualizar la posición de previsualización del caldero
  612:         // CauldronAltar->UpdatePlacementPreview(HitLocation, HitNormal);
  613:     }
  614: }
  615: </file>
  616: 
  617: <file path="WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp">
  618: // Fill out your copyright notice in the Description page of Project Settings.
  619: 
  620: 
  621: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  622: 
  623: #include "AbilitySystemComponent.h"
  624: 
  625: UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
  626: 	:Super(ObjectInitializer)
  627: {
  628: 	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
  629: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
  630: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
  631: 	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
  632: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
  633: }
  634: 
  635: void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
  636:                                             const FGameplayAbilitySpec& Spec)
  637: {
  638: 	Super::OnGiveAbility(ActorInfo, Spec);
  639: 	TryActivateAbilityOnSpawn(ActorInfo, Spec);
  640: }
  641: 
  642: void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
  643: 	const FGameplayAbilitySpec& Spec) const
  644: {
  645: 	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
  646: 	{
  647: 		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
  648: 		AbilitySystem->TryActivateAbility(Spec.Handle);
  649: 	}
  650: }
  651: </file>
  652: 
  653: <file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp">
  654: // Fill out your copyright notice in the Description page of Project Settings.
  655: 
  656: 
  657: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  658: 
  659: #include "AbilitySystemComponent.h"
  660: #include "Engine/OverlapResult.h"
  661: #include "Engine/World.h"
  662: #include "GameFramework/Controller.h"
  663: 
  664: #include "TimerManager.h"
  665: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  666: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  667: #include "AbilitySystem/Interaction/InteractionQuery.h"
  668: #include "AbilitySystem/Interaction/InteractionStatics.h"
  669: #include "WitchPT/WitchPT.h"
  670: 
  671: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
  672: UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
  673: 	: Super(ObjectInitializer)
  674: {
  675: }
  676: void UAbilityTask_GrantNearbyInteraction::Activate()
  677: {
  678: 
  679: 	SetWaitingOnAvatar();
  680: 	UWorld* World = GetWorld();
  681: 	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
  682: 
  683: }
  684: 
  685: void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
  686: {
  687: 	Super::OnGameplayTaskActivated(Task);
  688: 
  689: }
  690: 
  691: UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
  692:                                                                                                              float InteractionScanRange, float InteractionScanRate)
  693: {
  694: 
  695: 	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
  696: 	MyObj->InteractionScanRange = InteractionScanRange;
  697: 	MyObj->InteractionScanRate = InteractionScanRate;
  698: 	return MyObj;
  699: }
  700: 
  701: void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
  702: {
  703: 	// Limpiar el temporizador
  704: 	UWorld* World = GetWorld();
  705: 	if (World)
  706: 	{
  707: 		World->GetTimerManager().ClearTimer(QueryTimerHandle);
  708: 	}
  709: 
  710: 	// Limpiar las habilidades concedidas
  711: 	// if (AbilitySystemComponent)
  712: 	// {
  713: 	// 	// Limpiar habilidades de interacción rápida
  714: 	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : InteractionAbilityCache)
  715: 	// 	{
  716: 	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
  717: 	// 	}
  718: 	//
  719: 	// 	// Limpiar habilidades de interacción mantenida
  720: 	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : HoldInteractionAbilityCache)
  721: 	// 	{
  722: 	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
  723: 	// 	}
  724: 	// }
  725: 	//
  726: 	// InteractionAbilityCache.Empty();
  727: 	// HoldInteractionAbilityCache.Empty();
  728: 
  729: 	Super::OnDestroy(AbilityEnded);
  730: }
  731: 
  732: void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
  733: {
  734: 	UWorld* World = GetWorld();
  735: 	AActor* ActorOwner = GetAvatarActor();
  736: 
  737: 	if (World && ActorOwner)
  738: 	{
  739: 		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);
  740: 
  741: 		TArray<FOverlapResult> OverlapResults;
  742: 		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);
  743: 
  744: 		if (OverlapResults.Num() > 0)
  745: 		{
  746: 			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
  747: 			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
  748: 
  749: 			FInteractionQuery InteractionQuery;
  750: 			InteractionQuery.RequestingAvatar = ActorOwner;
  751: 			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());
  752: 
  753: 			TArray<FInteractionOption> Options;
  754: 			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
  755: 			{
  756: 				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
  757: 				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
  758: 			}
  759: 
  760: 			// Check if any of the options need to grant the ability to the user before they can be used.
  761: 			for (FInteractionOption& Option : Options)
  762: 			{
  763: 				// Otorgar la habilidad de interacción regular
  764: 				if (Option.InteractionAbilityToGrant)
  765: 				{
  766: 					// Grant the ability to the GAS, otherwise it won't be able to do whatever the interaction is.
  767: 					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
  768: 					if (!InteractionAbilityCache.Find(ObjectKey))
  769: 					{
  770: 						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
  771: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
  772: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
  773: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
  774: 						InteractionAbilityCache.Add(ObjectKey, Handle);
  775: 					}
  776: 				}
  777: 
  778: 				// Otorgar la habilidad de interacción mantenida si está disponible y soportada
  779: 				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
  780: 				{
  781: 					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
  782: 					if (!HoldInteractionAbilityCache.Find(ObjectKey))
  783: 					{
  784: 						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
  785: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
  786: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
  787: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
  788: 						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
  789: 					}
  790: 				}
  791: 			}
  792: 		}
  793: 	}
  794: }
  795: </file>
  796: 
  797: <file path="WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp">
  798: // Fill out your copyright notice in the Description page of Project Settings.
  799: 
  800: 
  801: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
  802: #include "AbilitySystemComponent.h"
  803: #include "Engine/World.h"
  804: #include "GameFramework/PlayerController.h"
  805: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  806: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
  807: struct FInteractionQuery;
  808: 
  809: UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
  810: 	: Super(ObjectInitializer)
  811: {
  812: }
  813: void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
  814: {
  815: 	check(World);
  816: 
  817: 	OutHitResult = FHitResult();
  818: 	FHitResult HitResult;
  819: 	// World->LineTraceMultiByProfile(HitResults, Start, End, CollisionChannel, Params);
  820: 	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
  821: 	OutHitResult.TraceStart = Start;
  822: 	OutHitResult.TraceEnd = End;
  823: 
  824: 	OutHitResult = HitResult;
  825: }
  826: 
  827: void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
  828: {
  829: 	if (!Ability) // Server and launching client only
  830: 	{
  831: 		return;
  832: 	}
  833: 
  834: 	//@TODO: Bots?
  835: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
  836: 	check(PC);
  837: 
  838: 	FVector ViewStart;
  839: 	FRotator ViewRot;
  840: 	PC->GetPlayerViewPoint(ViewStart, ViewRot);
  841: 
  842: 	const FVector ViewDir = ViewRot.Vector();
  843: 	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);
  844: 
  845: 	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);
  846: 
  847: 	FHitResult HitResult;
  848: 	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);
  849: 
  850: 	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));
  851: 
  852: 	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;
  853: 
  854: 	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
  855: 	if (AdjustedAimDir.IsZero())
  856: 	{
  857: 		AdjustedAimDir = ViewDir;
  858: 	}
  859: 
  860: 	if (!bTraceAffectsAimPitch && bUseTraceResult)
  861: 	{
  862: 		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();
  863: 
  864: 		if (!OriginalAimDir.IsZero())
  865: 		{
  866: 			// Convert to angles and use original pitch
  867: 			const FRotator OriginalAimRot = OriginalAimDir.Rotation();
  868: 
  869: 			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
  870: 			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;
  871: 
  872: 			AdjustedAimDir = AdjustedAimRot.Vector();
  873: 		}
  874: 	}
  875: 
  876: 	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
  877: }
  878: 
  879: bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
  880: {
  881: 	FVector CameraToCenter = AbilityCenter - CameraLocation;
  882: 	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
  883: 	if (DotToCenter >= 0)		//If this fails, we're pointed away from the center, but we might be inside the sphere and able to find a good exit point.
  884: 	{
  885: 		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
  886: 		float RadiusSquared = (AbilityRange * AbilityRange);
  887: 		if (DistanceSquared <= RadiusSquared)
  888: 		{
  889: 			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
  890: 			float DistanceAlongRay = DotToCenter + DistanceFromCamera;						//Subtracting instead of adding will get the other intersection point
  891: 			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);		//Cam aim point clipped to range sphere
  892: 			return true;
  893: 		}
  894: 	}
  895: 	return false;
  896: }
  897: 
  898: void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
  899: {
  900: 	TArray<FInteractionOption> NewOptions;
  901: 
  902: 	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
  903: 	{
  904: 		TArray<FInteractionOption> TempOptions;
  905: 		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
  906: 		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);
  907: 
  908: 		for (FInteractionOption& Option : TempOptions)
  909: 		{
  910: 			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;
  911: 
  912: 			// if there is a handle an a target ability system, we're triggering the ability on the target.
  913: 			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
  914: 			{
  915: 				// Find the spec
  916: 				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
  917: 			}
  918: 			// If there's an interaction ability then we're activating it on ourselves.
  919: 			else if (Option.InteractionAbilityToGrant)
  920: 			{
  921: 				// Find the spec
  922: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);
  923: 
  924: 				if (InteractionAbilitySpec)
  925: 				{
  926: 					// update the option
  927: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
  928: 					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
  929: 				}
  930: 			}
  931: 			if (Option.HoldInteractionAbilityToGrant)
  932: 			{
  933: 				// Find the spec
  934: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);
  935: 
  936: 				if (InteractionAbilitySpec)
  937: 				{
  938: 					// update the option
  939: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
  940: 					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
  941: 				}
  942: 			}
  943: 			if (InteractionAbilitySpec)
  944: 			{
  945: 				// Filter any options that we can't activate right now for whatever reason.
  946: 				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
  947: 				{
  948: 					NewOptions.Add(Option);
  949: 				}
  950: 			}
  951: 		}
  952: 	}
  953: 
  954: 	bool bOptionsChanged = false;
  955: 	if (NewOptions.Num() == CurrentOptions.Num())
  956: 	{
  957: 		NewOptions.Sort();
  958: 
  959: 		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
  960: 		{
  961: 			const FInteractionOption& NewOption = NewOptions[OptionIndex];
  962: 			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];
  963: 
  964: 			if (NewOption != CurrentOption)
  965: 			{
  966: 				bOptionsChanged = true;
  967: 				break;
  968: 			}
  969: 		}
  970: 	}
  971: 	else
  972: 	{
  973: 		bOptionsChanged = true;
  974: 	}
  975: 
  976: 	if (bOptionsChanged)
  977: 	{
  978: 		CurrentOptions = NewOptions;
  979: 		InteractableObjectsChanged.Broadcast(CurrentOptions);
  980: 	}
  981: }
  982: </file>
  983: 
  984: <file path="WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp">
  985: // Fill out your copyright notice in the Description page of Project Settings.
  986: 
  987: 
  988: #include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"
  989: 
  990: #include "AbilitySystem/Interaction/InteractionStatics.h"
  991: #include "Kismet/GameplayStatics.h"
  992: 
  993: UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
  994: 	: Super(ObjectInitializer)
  995: {
  996: }
  997: 
  998: UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
  999: 	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
 1000: 	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
 1001: 	bool bShowDebug)
 1002: {
 1003: 	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
 1004: 	MyObj->InteractionScanRange = InteractionScanRange;
 1005: 	MyObj->InteractionScanRate = InteractionScanRate;
 1006: 	MyObj->StartLocation = StartLocation;
 1007: 	MyObj->InteractionQuery = InteractionQuery;
 1008: 	MyObj->TraceProfile = TraceProfile;
 1009: 	MyObj->bShowDebug = bShowDebug;
 1010: 
 1011: 	return MyObj;
 1012: }
 1013: void UAT_WaitForInteractable_SLT::Activate()
 1014: {
 1015: 	SetWaitingOnAvatar();
 1016: 
 1017: 	UWorld* World = GetWorld();
 1018: 	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
 1019: }
 1020: 
 1021: void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
 1022: {
 1023: 	if (UWorld* World = GetWorld())
 1024: 	{
 1025: 		World->GetTimerManager().ClearTimer(TimerHandle);
 1026: 	}
 1027: 
 1028: 	Super::OnDestroy(AbilityEnded);
 1029: }
 1030: 
 1031: void UAT_WaitForInteractable_SLT::PerformTrace()
 1032: {
 1033: 	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
 1034: 
 1035: 	if (!AvatarActor)
 1036: 	{
 1037: 		return;
 1038: 	}
 1039: 
 1040: 	UWorld* World = GetWorld();
 1041: 
 1042: 	TArray<AActor*> ActorsToIgnore;
 1043: 	ActorsToIgnore.Add(AvatarActor);
 1044: 
 1045: 	const bool bTraceComplex = false;
 1046: 	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
 1047: 	Params.AddIgnoredActors(ActorsToIgnore);
 1048: 	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
 1049: 	FVector2D ViewportSize;
 1050: 	GEngine->GameViewport->GetViewportSize(ViewportSize);
 1051: 	const FVector2D ViewportCenter = ViewportSize / 2.f;
 1052: 	FVector TraceStart;
 1053: 	FVector Forward;
 1054: 	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;
 1055: 
 1056: 
 1057: 	FVector TraceEnd;
 1058: 	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);
 1059: 
 1060: 	FHitResult OutHitResult;
 1061: 	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);
 1062: 
 1063: 	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 1064: 	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);
 1065: 
 1066: 	UpdateInteractableOptions(InteractionQuery, InteractableTargets);
 1067: 
 1068: #if ENABLE_DRAW_DEBUG
 1069: 	if (bShowDebug)
 1070: 	{
 1071: 		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
 1072: 		if (OutHitResult.bBlockingHit)
 1073: 		{
 1074: 			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
 1075: 			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
 1076: 		}
 1077: 		else
 1078: 		{
 1079: 			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
 1080: 		}
 1081: 	}
 1082: #endif // ENABLE_DRAW_DEBUG
 1083: }
 1084: </file>
 1085: 
 1086: <file path="WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp">
 1087: // Fill out your copyright notice in the Description page of Project Settings.
 1088: 
 1089: 
 1090: #include "AbilitySystem/Interaction/GameplayAbility_Interact.h"
 1091: 
 1092: #include "AbilitySystemComponent.h"
 1093: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
 1094: #include "AbilitySystem/Interaction/InteractionStatics.h"
 1095: #include "NativeGameplayTags.h"
 1096: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 1097: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 1098: #include "Engine/World.h"
 1099: #include "Player/WitchPTPlayerController.h"
 1100: 
 1101: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
 1102: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");
 1103: 
 1104: UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
 1105: 	: Super(ObjectInitializer)
 1106: {
 1107: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
 1108: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 1109: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 1110: }
 1111: 
 1112: void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
 1113: 	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
 1114: 	const FGameplayEventData* TriggerEventData)
 1115: {
 1116: 	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
 1117: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 1118: 	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
 1119: 	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
 1120: 	{
 1121: 
 1122: 		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
 1123: 		Task->ReadyForActivation();
 1124: 
 1125: 	}
 1126: }
 1127: 
 1128: void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
 1129: {
 1130: 
 1131: 	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
 1132: 	{
 1133: 
 1134: 
 1135: 		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
 1136: 
 1137: 		CurrentOptions = InteractiveOptions;
 1138: 
 1139: 		for (const FInteractionOption& InteractionOption : InteractiveOptions)
 1140: 		{
 1141: 			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 1142: 
 1143: 			if (InteractableTargetActor)
 1144: 			{
 1145: 				FString ActorName = InteractableTargetActor->GetName();
 1146: 				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
 1147: 			}
 1148: 
 1149: 
 1150: 		}
 1151: 		if (InteractiveOptions.Num() == 0)
 1152: 		{
 1153: 			WitchPt->HUDWidget->HidePickupMessage();
 1154: 		}
 1155: 
 1156: 	}
 1157: 
 1158: 	CurrentOptions = InteractiveOptions;
 1159: }
 1160: 
 1161: void UGameplayAbility_Interact::TriggerInteraction()
 1162: {
 1163: 	if (CurrentOptions.Num() == 0)
 1164: 	{
 1165: 		return;
 1166: 	}
 1167: 
 1168: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 1169: 	if (AbilitySystem)
 1170: 	{
 1171: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 1172: 
 1173: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 1174: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 1175: 
 1176: 		// Allow the target to customize the event data we're about to pass in, in case the ability needs custom data
 1177: 		// that only the actor knows.
 1178: 		FGameplayEventData Payload;
 1179: 		Payload.EventTag = TAG_Ability_Interaction_Activate;
 1180: 		Payload.Instigator = Instigator;
 1181: 		Payload.Target = InteractableTargetActor;
 1182: 
 1183: 		// If needed we allow the interactable target to manipulate the event data so that for example, a button on the wall
 1184: 		// may want to specify a door actor to execute the ability on, so it might choose to override Target to be the
 1185: 		// door actor.
 1186: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
 1187: 
 1188: 
 1189: 		// Grab the target actor off the payload we're going to use it as the 'avatar' for the interaction, and the
 1190: 		// source InteractableTarget actor as the owner actor.
 1191: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
 1192: 
 1193: 		// The actor info needed for the interaction.
 1194: 		FGameplayAbilityActorInfo ActorInfo;
 1195: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
 1196: 
 1197: 		// Trigger the ability using event tag.
 1198: 
 1199: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
 1200: 			InteractionOption.TargetInteractionAbilityHandle,
 1201: 			&ActorInfo,
 1202: 			TAG_Ability_Interaction_Activate,
 1203: 			&Payload,
 1204: 			*InteractionOption.TargetAbilitySystem
 1205: 		);
 1206: 
 1207: 		// Notificar que se completó la interacción
 1208: 		OnInteractionComplete.Broadcast();
 1209: 	}
 1210: }
 1211: 
 1212: void UGameplayAbility_Interact::TriggerHoldInteraction()
 1213: {
 1214: 	if (CurrentOptions.Num() == 0)
 1215: 	{
 1216: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
 1217: 		OnInteractionCancelled.Broadcast();
 1218: 		return;
 1219: 	}
 1220: 
 1221: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 1222: 	if (AbilitySystem)
 1223: 	{
 1224: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 1225: 
 1226: 		// Verificar si la opción de interacción soporta interacción mantenida
 1227: 		if (!InteractionOption.bSupportsHoldInteraction)
 1228: 		{
 1229: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
 1230: 			// Si no soporta interacción mantenida, podemos usar la interacción normal en su lugar
 1231: 			TriggerInteraction();
 1232: 			return;
 1233: 		}
 1234: 
 1235: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
 1236: 
 1237: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 1238: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 1239: 
 1240: 		// Configurar los datos del evento para la interacción mantenida
 1241: 		FGameplayEventData Payload;
 1242: 		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
 1243: 		Payload.Instigator = Instigator;
 1244: 		Payload.Target = InteractableTargetActor;
 1245: 
 1246: 		// Permitir que el objetivo personalice los datos del evento
 1247: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);
 1248: 
 1249: 		// Obtener el actor objetivo
 1250: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
 1251: 
 1252: 		// La información del actor necesaria para la interacción
 1253: 		FGameplayAbilityActorInfo ActorInfo;
 1254: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
 1255: 
 1256: 		// Usar el handle de habilidad específico para interacción mantenida, si está disponible
 1257: 		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
 1258: 
 1259: 		// Si no hay un handle específico para interacción mantenida, usar el handle normal
 1260: 		if (!AbilityHandle.IsValid())
 1261: 		{
 1262: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
 1263: 			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
 1264: 		}
 1265: 		else
 1266: 		{
 1267: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
 1268: 		}
 1269: 
 1270: 		// Activar la habilidad usando la etiqueta de evento de interacción mantenida
 1271: 		// UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Intentando activar habilidad con tag %s"), *TAG_Ability_Interaction_Hold_Activate.ToString());
 1272: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
 1273: 			AbilityHandle,
 1274: 			&ActorInfo,
 1275: 			TAG_Ability_Interaction_Hold_Activate,
 1276: 			&Payload,
 1277: 			*InteractionOption.TargetAbilitySystem
 1278: 		);
 1279: 
 1280: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
 1281: 
 1282: 		// Notificar que se completó la interacción mantenida
 1283: 		OnHoldInteractionComplete.Broadcast();
 1284: 	}
 1285: }
 1286: 
 1287: void UGameplayAbility_Interact::OnInteractionButtonPressed()
 1288: {
 1289: 	if (CurrentOptions.Num() == 0)
 1290: 	{
 1291: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No hay opciones de interacción disponibles"));
 1292: 		OnInteractionCancelled.Broadcast();
 1293: 		return;
 1294: 	}
 1295: 
 1296: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción presionado"));
 1297: 	bIsInteractionButtonHeld = true;
 1298: 	bHoldInteractionFired = false; // Reiniciamos la bandera al comenzar una nueva interacción
 1299: 	InteractionStartTime = GetWorld()->GetTimeSeconds();
 1300: 
 1301: 	// Guardar el objetivo interactuable actual para validaciones posteriores
 1302: 	if (CurrentOptions.Num() > 0)
 1303: 	{
 1304: 		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
 1305: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Guardando objetivo inicial de interacción"));
 1306: 	}
 1307: 
 1308: 	// Configurar un temporizador para detectar si el botón se mantiene presionado durante el tiempo requerido
 1309: 	GetWorld()->GetTimerManager().SetTimer(
 1310: 		HoldInteractionTimerHandle,
 1311: 		this,
 1312: 		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
 1313: 		HoldInteractionTime,
 1314: 		false
 1315: 	);
 1316: 
 1317: 	// Iniciar comprobación periódica de validez
 1318: 	GetWorld()->GetTimerManager().SetTimer(
 1319: 		ValidityCheckTimerHandle,
 1320: 		this,
 1321: 		&UGameplayAbility_Interact::CheckInteractionValidity,
 1322: 		ValidityCheckRate,
 1323: 		true // Repetitivo
 1324: 	);
 1325: 
 1326: 	// Configurar el temporizador de seguridad para forzar un reinicio después de un tiempo máximo
 1327: 	GetWorld()->GetTimerManager().SetTimer(
 1328: 		MaxInteractionTimeTimerHandle,
 1329: 		this,
 1330: 		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
 1331: 		MaxInteractionTime,
 1332: 		false // No repetitivo
 1333: 	);
 1334: 
 1335: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizadores configurados. Hold: %f segundos, Max: %f segundos"),
 1336: 	// 	HoldInteractionTime, MaxInteractionTime);
 1337: }
 1338: 
 1339: void UGameplayAbility_Interact::OnInteractionButtonReleased()
 1340: {
 1341: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Botón de interacción liberado"));
 1342: 
 1343: 	if (!bIsInteractionButtonHeld)
 1344: 	{
 1345: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón no estaba siendo mantenido, ignorando liberación"));
 1346: 		return;
 1347: 	}
 1348: 
 1349: 	bIsInteractionButtonHeld = false;
 1350: 
 1351: 	// Cancelar los temporizadores
 1352: 	if (GetWorld())
 1353: 	{
 1354: 		// Temporizador de validez
 1355: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
 1356: 		{
 1357: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
 1358: 		}
 1359: 
 1360: 		// Temporizador de seguridad
 1361: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
 1362: 		{
 1363: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
 1364: 		}
 1365: 
 1366: 		// Temporizador de interacción mantenida
 1367: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
 1368: 		{
 1369: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizador de hold cancelado"));
 1370: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
 1371: 
 1372: 			// Verificamos si ya se lanzó una interacción mantenida
 1373: 			if (bHoldInteractionFired)
 1374: 			{
 1375: 				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Ya se disparó una interacción mantenida, ignorando interacción rápida"));
 1376: 				return; // Si ya se disparó una interacción mantenida, no lanzamos la rápida
 1377: 			}
 1378: 
 1379: 			// Si el botón se soltó antes del tiempo de interacción mantenida, considerarlo como una pulsación rápida
 1380: 			float CurrentTime = GetWorld()->GetTimeSeconds();
 1381: 			float HoldTime = CurrentTime - InteractionStartTime;
 1382: 
 1383: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo mantenido: %f / Requerido: %f"), HoldTime, HoldInteractionTime);
 1384: 
 1385: 			if (HoldTime < HoldInteractionTime)
 1386: 			{
 1387: 				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción rápida"));
 1388: 				// Llamar a la interacción de pulsación rápida
 1389: 				TriggerInteraction();
 1390: 
 1391: 				// Llamar a InteractPressScan después de la interacción para restaurar el estado
 1392: 				// y prepararse para la siguiente interacción
 1393: 				// Nota: Esto debe implementarse en el blueprint conectando la salida de este nodo
 1394: 				// a la entrada del nodo InteractPressScan
 1395: 			}
 1396: 		}
 1397: 		else
 1398: 		{
 1399: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No había temporizador activo al liberar el botón"));
 1400: 		}
 1401: 	}
 1402: 
 1403: 	// Limpiar la referencia al objetivo inicial
 1404: 	InitialInteractableTarget = nullptr;
 1405: }
 1406: 
 1407: void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
 1408: {
 1409: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo de interacción mantenida alcanzado"));
 1410: 
 1411: 	if (bIsInteractionButtonHeld)
 1412: 	{
 1413: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacción mantenida"));
 1414: 		// Marcamos que ya se disparó la interacción mantenida
 1415: 		bHoldInteractionFired = true;
 1416: 
 1417: 		// El botón se ha mantenido presionado durante el tiempo requerido
 1418: 		// Llamar a la interacción mantenida
 1419: 		TriggerHoldInteraction();
 1420: 
 1421: 		// Nota: Después de llamar a TriggerHoldInteraction,
 1422: 		// es necesario llamar a InteractPressScan en el blueprint
 1423: 		// para restaurar el estado y prepararse para la siguiente interacción
 1424: 		// Esto se logra escuchando al delegado OnHoldInteractionComplete
 1425: 	}
 1426: 	else
 1427: 	{
 1428: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botón ya no está presionado, no se activa interacción mantenida"));
 1429: 	}
 1430: }
 1431: 
 1432: void UGameplayAbility_Interact::CheckInteractionValidity()
 1433: {
 1434: 	// Si no estamos en un estado de interacción, no necesitamos verificar
 1435: 	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
 1436: 	{
 1437: 		return;
 1438: 	}
 1439: 
 1440: 	// Log adicional para verificar estado actual
 1441: 	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
 1442: 
 1443: 	// Verificar si aún hay opciones de interacción disponibles
 1444: 	bool bHasValidInteraction = false;
 1445: 
 1446: 	if (CurrentOptions.Num() > 0)
 1447: 	{
 1448: 		// Buscar el objetivo inicial en cualquier posición del array
 1449: 		for (const FInteractionOption& Option : CurrentOptions)
 1450: 		{
 1451: 			if (Option.InteractableTarget == InitialInteractableTarget)
 1452: 			{
 1453: 				bHasValidInteraction = true;
 1454: 				break;
 1455: 			}
 1456: 		}
 1457: 
 1458: 		// Log detallado sobre la validación
 1459: 		if (bHasValidInteraction)
 1460: 		{
 1461: 			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
 1462: 		}
 1463: 		else
 1464: 		{
 1465: 			// Intentar identificar qué cambió
 1466: 			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
 1467: 			AActor* CurrentActor = CurrentOptions.Num() > 0 ?
 1468: 				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
 1469: 
 1470: 			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"),
 1471: 				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
 1472: 				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
 1473: 		}
 1474: 	}
 1475: 	else
 1476: 	{
 1477: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
 1478: 	}
 1479: 
 1480: 	// Si no hay una interacción válida, cancelar la interacción actual
 1481: 	if (!bHasValidInteraction)
 1482: 	{
 1483: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
 1484: 		CancelCurrentInteraction();
 1485: 	}
 1486: }
 1487: 
 1488: void UGameplayAbility_Interact::CancelCurrentInteraction()
 1489: {
 1490: 	// Si no estamos en un estado de interacción, no hay nada que cancelar
 1491: 	if (!bIsInteractionButtonHeld)
 1492: 	{
 1493: 		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
 1494: 		return;
 1495: 	}
 1496: 
 1497: 	// Obtener información del objeto inicial para el log
 1498: 	FString InitialObjectName = TEXT("Desconocido");
 1499: 	if (InitialInteractableTarget.GetInterface())
 1500: 	{
 1501: 		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
 1502: 		if (InitialActor)
 1503: 		{
 1504: 			InitialObjectName = InitialActor->GetName();
 1505: 		}
 1506: 	}
 1507: 
 1508: 	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
 1509: 
 1510: 	// Detener temporizadores
 1511: 	if (GetWorld())
 1512: 	{
 1513: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
 1514: 		{
 1515: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
 1516: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
 1517: 		}
 1518: 
 1519: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
 1520: 		{
 1521: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
 1522: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
 1523: 		}
 1524: 
 1525: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
 1526: 		{
 1527: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
 1528: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
 1529: 		}
 1530: 	}
 1531: 
 1532: 	// Restablecer variables de estado
 1533: 	bIsInteractionButtonHeld = false;
 1534: 	bHoldInteractionFired = false;
 1535: 
 1536: 	// Hacer una copia de la referencia antes de limpiarla para poder notificar
 1537: 	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
 1538: 	InitialInteractableTarget = nullptr;
 1539: 
 1540: 	// Log para confirmar que el estado ha sido restablecido
 1541: 	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
 1542: 
 1543: 	// Notificar la cancelación
 1544: 	OnInteractionCancelled.Broadcast();
 1545: }
 1546: 
 1547: void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
 1548: {
 1549: 	// Si todavía estamos en un estado de interacción, forzar una cancelación
 1550: 	if (bIsInteractionButtonHeld)
 1551: 	{
 1552: 		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
 1553: 		CancelCurrentInteraction();
 1554: 
 1555: 		// Forzar un reinicio del escaneo de interacciones
 1556: 		OnInteractionCancelled.Broadcast();
 1557: 	}
 1558: }
 1559: </file>
 1560: 
 1561: <file path="WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp">
 1562: // Fill out your copyright notice in the Description page of Project Settings.
 1563: 
 1564: 
 1565: #include "AbilitySystem/Interaction/InteractionStatics.h"
 1566: 
 1567: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 1568: #include "Engine/OverlapResult.h"
 1569: 
 1570: UInteractionStatics::UInteractionStatics()
 1571: 	: Super(FObjectInitializer::Get())
 1572: {
 1573: }
 1574: 
 1575: AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
 1576: {
 1577: 	if (UObject* Object = InteractableTarget.GetObject())
 1578: 	{
 1579: 		if (AActor* Actor = Cast<AActor>(Object))
 1580: 		{
 1581: 			return Actor;
 1582: 		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
 1583: 		{
 1584: 			AActor* ActorToReturn = ActorComponent->GetOwner();
 1585: 			return ActorToReturn;
 1586: 		} else
 1587: 		{
 1588: 			unimplemented()
 1589: 		}
 1590: 	}
 1591: 	return nullptr;
 1592: }
 1593: 
 1594: void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
 1595: 	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
 1596: {
 1597: 	// If the actor is directly interactable, return that.
 1598: 	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
 1599: 	if (InteractableActor)
 1600: 	{
 1601: 		OutInteractableTargets.Add(InteractableActor);
 1602: 	}
 1603: 
 1604: 	// If the actor isn't interactable, it might have a component that has a interactable interface.
 1605: 	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
 1606: 	for (UActorComponent* InteractableComponent : InteractableComponents)
 1607: 	{
 1608: 		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
 1609: 	}
 1610: }
 1611: 
 1612: void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
 1613: {
 1614: 	for (const FOverlapResult& Overlap : OverlapResults)
 1615: 	{
 1616: 		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
 1617: 		if (InteractableActor)
 1618: 		{
 1619: 			OutInteractableTargets.AddUnique(InteractableActor);
 1620: 		}
 1621: 
 1622: 		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
 1623: 		if (InteractableComponent)
 1624: 		{
 1625: 			OutInteractableTargets.AddUnique(InteractableComponent);
 1626: 		}
 1627: 	}
 1628: }
 1629: 
 1630: void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
 1631: {
 1632: 	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
 1633: 	if (InteractableActor)
 1634: 	{
 1635: 		OutInteractableTargets.AddUnique(InteractableActor);
 1636: 	}
 1637: 
 1638: 	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
 1639: 	if (InteractableComponent)
 1640: 	{
 1641: 		OutInteractableTargets.AddUnique(InteractableComponent);
 1642: 	}
 1643: }
 1644: </file>
 1645: 
 1646: <file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp">
 1647: // Fill out your copyright notice in the Description page of Project Settings.
 1648: 
 1649: 
 1650: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 1651: 
 1652: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 1653: 
 1654: 
 1655: void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
 1656: 	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
 1657: {
 1658: 	if (!AbilitiesToGrant.IsEmpty())
 1659: 	{
 1660: 		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
 1661: 		{
 1662: 			if (!AbilityClass)
 1663: 			{
 1664: 				continue;
 1665: 			}
 1666: 
 1667: 			// Obtener la clase de habilidad para acceder a la propiedad StartupInputTag
 1668: 			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
 1669: 			if (!AbilityCDO)
 1670: 			{
 1671: 				continue;
 1672: 			}
 1673: 
 1674: 			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
 1675: 			// Source of the ability is the ASC
 1676: 			AbilitySpec.SourceObject = this;
 1677: 			// Add the startup input tag to the ability spec
 1678: 			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
 1679: 			// Give the ability to the ASC
 1680: 			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
 1681: 			// Store the handle of the ability
 1682: 			GrantedAbilities.Add(AbilitySpecHandle);
 1683: 		}
 1684: 	}
 1685: }
 1686: 
 1687: void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
 1688: {
 1689: 	if (InputTag.IsValid())
 1690: 	{
 1691: 
 1692: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 1693: 		{
 1694: 			// print each ability
 1695: 
 1696: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 1697: 			{
 1698: 				//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, AbilitySpec.Ability->GetName());
 1699: 				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
 1700: 				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
 1701: 			}
 1702: 		}
 1703: 	}
 1704: }
 1705: 
 1706: void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
 1707: {
 1708: 	if (!InputTag.IsValid()) return;
 1709: 	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
 1710: 	{
 1711: 		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
 1712: 		{
 1713: 			AbilitySpecInputPressed(AbilitySpec);
 1714: 			if (!AbilitySpec.IsActive())
 1715: 			{
 1716: 				TryActivateAbility(AbilitySpec.Handle);
 1717: 			}
 1718: 		}
 1719: 	}
 1720: }
 1721: 
 1722: void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
 1723: {
 1724: 	if (InputTag.IsValid())
 1725: 	{
 1726: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 1727: 		{
 1728: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 1729: 			{
 1730: 				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
 1731: 				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
 1732: 			}
 1733: 		}
 1734: 	}
 1735: }
 1736: 
 1737: void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
 1738: {
 1739: 	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
 1740: }
 1741: 
 1742: void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
 1743: {
 1744: 		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
 1745: 	AbilitiesToActivate.Reset();
 1746: 	//
 1747: 	// Process all abilities that activate when the input is held.
 1748: 	//
 1749: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
 1750: 	{
 1751: 
 1752: 
 1753: 		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 1754: 		{
 1755: 			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
 1756: 			{
 1757: 				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
 1758: 				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
 1759: 				{
 1760: 					// --- MODIFICACION AQUI ---
 1761: 					// Solo añadir si la política es WhileInputActive y NO es la nueva On Triggered Event
 1762: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
 1763: 					{
 1764: 						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
 1765: 					}
 1766: 				}
 1767: 			}
 1768: 		}
 1769: 	}
 1770: 	//
 1771: 	// Process all abilities that had their input pressed this frame.
 1772: 	//
 1773: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
 1774: 	{
 1775: 
 1776: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 1777: 		{
 1778: 			if (AbilitySpec->Ability)
 1779: 			{
 1780: 				AbilitySpec->InputPressed = true;
 1781: 
 1782: 				if (AbilitySpec->IsActive())
 1783: 				{
 1784: 
 1785: 
 1786: 					// Ability is active so pass along the input event.
 1787: 					AbilitySpecInputPressed(*AbilitySpec);
 1788: 				}
 1789: 				else
 1790: 				{
 1791: 					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
 1792: 
 1793: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
 1794: 					{
 1795: 						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
 1796: 						{
 1797: 							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
 1798: 						}
 1799: 					}
 1800: 				}
 1801: 			}
 1802: 		}
 1803: 	}
 1804: 	//
 1805: 	// Try to activate all the abilities that are from presses and holds.
 1806: 	// We do it all at once so that held inputs don't activate the ability
 1807: 	// and then also send a input event to the ability because of the press.
 1808: 	//
 1809: 	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
 1810: 	{
 1811: 		TryActivateAbility(AbilitySpecHandle);
 1812: 	}
 1813: 	//
 1814: 	// Process all abilities that had their input released this frame.
 1815: 	//
 1816: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
 1817: 	{
 1818: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 1819: 		{
 1820: 			if (AbilitySpec->Ability)
 1821: 			{
 1822: 				AbilitySpec->InputPressed = false;
 1823: 
 1824: 				if (AbilitySpec->IsActive())
 1825: 				{
 1826: 					// Ability is active so pass along the input event.
 1827: 					AbilitySpecInputReleased(*AbilitySpec);
 1828: 				}
 1829: 			}
 1830: 		}
 1831: 	}
 1832: 
 1833: 	//
 1834: 	// Clear the cached ability handles.
 1835: 	//
 1836: 	InputPressedSpecHandles.Reset();
 1837: 	InputReleasedSpecHandles.Reset();
 1838: 
 1839: }
 1840: 
 1841: void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
 1842: {
 1843: 	Super::AbilitySpecInputPressed(Spec);
 1844: 	// We don't support UGameplayAbility::bReplicateInputDirectly.
 1845: 	// Use replicated events instead so that the WaitInputPress ability task works.
 1846: 	if (Spec.IsActive())
 1847: 	{
 1848: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
 1849: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
 1850: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
 1851: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
 1852: 
 1853: 		// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.
 1854: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
 1855: 	}
 1856: 
 1857: }
 1858: 
 1859: void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
 1860: {
 1861: 	Super::AbilitySpecInputReleased(Spec);
 1862: 	// We don't support UGameplayAbility::bReplicateInputDirectly.
 1863: 	// Use replicated events instead so that the WaitInputRelease ability task works.
 1864: 	if (Spec.IsActive())
 1865: 	{
 1866: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
 1867: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
 1868: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
 1869: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
 1870: 
 1871: 		// Invoke the InputReleased event. This is not replicated here. If someone is listening, they may replicate the InputReleased event to the server.
 1872: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
 1873: 	}
 1874: }
 1875: 
 1876: void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
 1877: 	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
 1878: {
 1879: 	FGameplayTagContainer TagContainer;
 1880: 	EffectSpec.GetAllAssetTags(TagContainer);
 1881: 
 1882: 	OnEffectAssetTags.Broadcast(TagContainer);
 1883: }
 1884: </file>
 1885: 
 1886: <file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp">
 1887: // Fill out your copyright notice in the Description page of Project Settings.
 1888: 
 1889: 
 1890: #include "AbilitySystem/WitchPTAbilitySystemGlobals.h"
 1891: </file>
 1892: 
 1893: <file path="WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp">
 1894: // Fill out your copyright notice in the Description page of Project Settings.
 1895: 
 1896: 
 1897: #include "AbilitySystem/WitchPTAbilitySystemLibrary.h"
 1898: 
 1899: #include "Item/MechanicsInterface.h"
 1900: 
 1901: TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
 1902: {
 1903: 	if (!Actor)
 1904: 	{
 1905: 		return TScriptInterface<IMechanicsInterface>();
 1906: 
 1907: 	}
 1908: 	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
 1909: 	if (ComponentsImplementingInterface.Num() > 0)
 1910: 	{
 1911: 		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
 1912: 	}
 1913: 	return TScriptInterface<IMechanicsInterface>();
 1914: }
 1915: </file>
 1916: 
 1917: <file path="WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp">
 1918: // Fill out your copyright notice in the Description page of Project Settings.
 1919: 
 1920: 
 1921: #include "AbilitySystem/WitchPTAttributeSet.h"
 1922: 
 1923: #include "AbilitySystemBlueprintLibrary.h"
 1924: #include "GameplayEffectExtension.h"
 1925: #include "GameFramework/Character.h"
 1926: #include "Net/UnrealNetwork.h"
 1927: #include "WitchPT/WitchPT.h"
 1928: 
 1929: void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 1930: {
 1931: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 1932: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
 1933: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)
 1934: 
 1935: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
 1936: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)
 1937: 
 1938: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
 1939: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
 1940: 
 1941: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
 1942: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
 1943: 
 1944: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
 1945: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
 1946: 
 1947: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
 1948: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)
 1949: 
 1950: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
 1951: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
 1952: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)
 1953: 
 1954: 
 1955: }
 1956: 
 1957: UWitchPTAttributeSet::UWitchPTAttributeSet()
 1958: {
 1959: }
 1960: 
 1961: void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
 1962: {
 1963: 	Super::PreAttributeChange(Attribute, NewValue);
 1964: }
 1965: 
 1966: void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 1967: {
 1968: 	Super::PostGameplayEffectExecute(Data);
 1969: 	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
 1970: 	{
 1971: 		// SetMoveSpeed(FMath::Clamp(GetMoveSpeed(), 0.f, GetMaxMoveSpeed()));
 1972: 	}
 1973: 	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
 1974: 	{
 1975: 		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
 1976: 	}
 1977: }
 1978: 
 1979: void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 1980: {
 1981: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
 1982: }
 1983: 
 1984: void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
 1985: {
 1986: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
 1987: }
 1988: void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
 1989: {
 1990: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
 1991: }
 1992: 
 1993: void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
 1994: {
 1995: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
 1996: }
 1997: 
 1998: void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
 1999: {
 2000: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
 2001: }
 2002: 
 2003: void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
 2004: {
 2005: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
 2006: }
 2007: 
 2008: void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
 2009: {
 2010: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
 2011: }
 2012: 
 2013: void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
 2014: {
 2015: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
 2016: }
 2017: 
 2018: void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
 2019: {
 2020: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
 2021: }
 2022: 
 2023: void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
 2024: {
 2025: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
 2026: }
 2027: 
 2028: void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
 2029: {
 2030: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
 2031: }
 2032: 
 2033: void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
 2034: {
 2035: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
 2036: }
 2037: 
 2038: void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
 2039: {
 2040: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
 2041: }
 2042: 
 2043: void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
 2044: {
 2045: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
 2046: }
 2047: 
 2048: void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
 2049: {
 2050: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
 2051: }
 2052: </file>
 2053: 
 2054: <file path="WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp">
 2055: // Fill out your copyright notice in the Description page of Project Settings.
 2056: 
 2057: 
 2058: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2059: 
 2060: #include "AbilitySystemComponent.h"
 2061: #include "GameplayTagContainer.h"
 2062: #include "Character/WitchPTCharacterBase.h"
 2063: 
 2064: 
 2065: 
 2066: UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
 2067: {
 2068: 
 2069: 	PrimaryComponentTick.bCanEverTick = true;
 2070: 
 2071: 
 2072: }
 2073: 
 2074: float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
 2075: {
 2076: 
 2077: 	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());
 2078: 
 2079: 	if (!Owner)
 2080: 	{
 2081: 
 2082: 		return Super::GetMaxSpeed();
 2083: 	}
 2084: 
 2085: 
 2086: 
 2087: 	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
 2088: 	{
 2089: 
 2090: 		return 0.0f;
 2091: 	}
 2092: 
 2093: 	float FinalSpeed = Owner->GetMoveSpeed();
 2094: 	if (RequestToStartSprinting)
 2095: 	{
 2096: 		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
 2097: 
 2098: 	}
 2099: 	// else if (RequestToStartCrouching)
 2100: 	// {
 2101: 	// 	// FinalSpeed = Owner->GetMoveSpeed() * CrouchSpeedMultiplier;
 2102: 	// 	// UE_LOG(LogTemp, Warning, TEXT("Character %s is Crouching - Speed: %f"), *GetOwner()->GetName(), FinalSpeed);
 2103: 	// }
 2104: 
 2105: 
 2106: 	return FinalSpeed;
 2107: }
 2108: 
 2109: void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
 2110: {
 2111: 	Super::UpdateFromCompressedFlags(Flags);
 2112: }
 2113: 
 2114: class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
 2115: {
 2116: 	return Super::GetPredictionData_Client();
 2117: }
 2118: 
 2119: 
 2120: void UWitchPTCharacterMovementComponent::StartSprinting()
 2121: {
 2122: 	RequestToStartSprinting = true;
 2123: }
 2124: 
 2125: void UWitchPTCharacterMovementComponent::StopSprinting()
 2126: {
 2127: 	RequestToStartSprinting = false;
 2128: }
 2129: 
 2130: void UWitchPTCharacterMovementComponent::StartAimDownSights()
 2131: {
 2132: 	RequestToStartADS = true;
 2133: }
 2134: 
 2135: void UWitchPTCharacterMovementComponent::StopAimDownSights()
 2136: {
 2137: 	RequestToStartADS = false;
 2138: 
 2139: }
 2140: </file>
 2141: 
 2142: <file path="WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp">
 2143: // Fill out your copyright notice in the Description page of Project Settings.
 2144: 
 2145: 
 2146: #include "Character/Components/WitchPTMechanicComponent.h"
 2147: #include "Item/CauldronAltar.h"
 2148: #include "Net/UnrealNetwork.h"
 2149: #include "GameFramework/Character.h"
 2150: #include "Item/RitualAltar.h"
 2151: 
 2152: // Sets default values for this component's properties
 2153: UWitchPTMechanicComponent::UWitchPTMechanicComponent()
 2154: {
 2155: 	// Set this component to be initialized when the game starts, and to be ticked every frame.
 2156: 	PrimaryComponentTick.bCanEverTick = true;
 2157: 	SetIsReplicatedByDefault(true);
 2158: }
 2159: 
 2160: void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 2161: {
 2162: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 2163: 
 2164: 	// Agregar propiedades replicadas aquí si es necesario
 2165: }
 2166: 
 2167: // Called when the game starts
 2168: void UWitchPTMechanicComponent::BeginPlay()
 2169: {
 2170: 	Super::BeginPlay();
 2171: 
 2172: }
 2173: 
 2174: // Called every frame
 2175: void UWitchPTMechanicComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
 2176: {
 2177: 	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
 2178: }
 2179: 
 2180: // --- RITUAL IMPLEMENTATION ---
 2181: void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
 2182: {
 2183: 	if (!TargetAltar)
 2184: 	{
 2185: 		return;
 2186: 	}
 2187: 
 2188: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2189: 	if (!Character)
 2190: 	{
 2191: 		return;
 2192: 	}
 2193: 
 2194: 	if (Character->HasAuthority())
 2195: 	{
 2196: 		TargetAltar->StartBrewingPotion(Character);
 2197: 	}
 2198: }
 2199: 
 2200: void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
 2201: {
 2202: 	if (!TargetAltar)
 2203: 	{
 2204: 		return;
 2205: 	}
 2206: 
 2207: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2208: 	if (!Character)
 2209: 	{
 2210: 		return;
 2211: 	}
 2212: 
 2213: 	if (GetOwnerRole() == ROLE_Authority)
 2214: 	{
 2215: 		// Si estamos en el servidor, llamamos directamente
 2216: 		TargetAltar->StartCarryCauldron(Character);
 2217: 	}
 2218: 
 2219: }
 2220: 
 2221: void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 2222: {
 2223: 	if (!TargetAltar)
 2224: 	{
 2225: 		return;
 2226: 	}
 2227: 
 2228: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2229: 	if (!Character)
 2230: 	{
 2231: 		return;
 2232: 	}
 2233: 
 2234: 	if (GetOwnerRole() == ROLE_Authority)
 2235: 	{
 2236: 		// Si estamos en el servidor, llamamos directamente
 2237: 		TargetAltar->StartPlacementPreview(Character);
 2238: 	}
 2239: }
 2240: 
 2241: void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
 2242: {
 2243: 	if (!TargetAltar)
 2244: 	{
 2245: 		return;
 2246: 	}
 2247: 
 2248: 	if (GetOwnerRole() == ROLE_Authority)
 2249: 	{
 2250: 		// Si estamos en el servidor, llamamos directamente
 2251: 		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
 2252: 	}
 2253: }
 2254: 
 2255: void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 2256: {
 2257: 	if (!TargetAltar)
 2258: 	{
 2259: 		return;
 2260: 	}
 2261: 
 2262: 	if (GetOwnerRole() == ROLE_Authority)
 2263: 	{
 2264: 		// Si estamos en el servidor, llamamos directamente
 2265: 		TargetAltar->CancelPlacement();
 2266: 	}
 2267: 
 2268: }
 2269: 
 2270: void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
 2271: {
 2272: 	if (!TargetAltar)
 2273: 	{
 2274: 		return;
 2275: 	}
 2276: 
 2277: 	if (GetOwnerRole() == ROLE_Authority)
 2278: 	{
 2279: 		// Si estamos en el servidor, llamamos directamente
 2280: 		TargetAltar->FinalizePlacement();
 2281: 	}
 2282: 
 2283: }
 2284: 
 2285: void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
 2286: {
 2287: 	if (!TargetCauldron) return;
 2288: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2289: 	if (GetOwnerRole() == ROLE_Authority)
 2290: 	{
 2291: 		TargetCauldron->UnoccupyPosition(Character, nullptr);
 2292: 	}
 2293: }
 2294: 
 2295: void UWitchPTMechanicComponent::RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
 2296: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
 2297: {
 2298: 	if (!TargetAltar) return;
 2299: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2300: 
 2301: 
 2302: 	if(GetOwnerRole() == ROLE_Authority)
 2303: 	{
 2304: 		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
 2305: 	}
 2306: 	else
 2307: 	{
 2308: 		Server_RequestSetBaseIngredient(TargetAltar, IngredientItemDef);
 2309: 	}
 2310: 
 2311: 
 2312: 
 2313: }
 2314: 
 2315: void UWitchPTMechanicComponent::Server_RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
 2316: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
 2317: {
 2318: 	if (!TargetAltar) return;
 2319: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2320: 
 2321: 	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
 2322: 
 2323: }
 2324: 
 2325: void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
 2326: {
 2327: 
 2328: 	if (!TargetAltar) return;
 2329: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2330: 
 2331: 	if (GetOwnerRole() == ROLE_Authority)
 2332: 	{
 2333: 		TargetAltar->OccupyPosition(Character, Position);
 2334: 	}
 2335: 
 2336: }
 2337: 
 2338: void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
 2339: 	ABaseInteractionPosition* Position)
 2340: {
 2341: 	if (!TargetAltar) return;
 2342: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2343: 	if (GetOwnerRole() == ROLE_Authority)
 2344: 	{
 2345: 		TargetAltar->UnoccupyPosition(Character, Position);
 2346: 	}
 2347: 
 2348: }
 2349: 
 2350: void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
 2351: {
 2352: 	if (!TargetAltar) return;
 2353: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2354: 	if (GetOwnerRole() == ROLE_Authority)
 2355: 	{
 2356: 		TargetAltar->StartRitual(Character);
 2357: 	}
 2358: }
 2359: 
 2360: void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
 2361: {
 2362: 	if (!TargetAltar) return;
 2363: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 2364: 	if (GetOwnerRole() == ROLE_Authority)
 2365: 	{
 2366: 		TargetAltar->HandlePlayerInput(Character, InputTag);
 2367: 	}
 2368: }
 2369: </file>
 2370: 
 2371: <file path="WitchPT/Private/Character/WitchPTCharacter.cpp">
 2372: // Fill out your copyright notice in the Description page of Project Settings.
 2373: 
 2374: 
 2375: #include "Character/WitchPTCharacter.h"
 2376: 
 2377: #include "AbilitySystemComponent.h"
 2378: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 2379: #include "AbilitySystem/WitchPTAttributeSet.h"
 2380: #include "Character/Components/WitchPTMechanicComponent.h"
 2381: #include "Item/RitualAltar.h"
 2382: #include "Item/RitualPosition.h"
 2383: #include "Player/WitchPTPlayerController.h"
 2384: #include "Player/WitchPTPlayerState.h"
 2385: #include "UI/HUD/WitchPTHUD.h"
 2386: #include "WitchPT/WitchPT.h"
 2387: 
 2388: 
 2389: // Sets default values
 2390: AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 2391: {
 2392: 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 2393: 	PrimaryActorTick.bCanEverTick = true;
 2394: 	// Initialize the MechanicComponent
 2395: 	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
 2396: 
 2397: }
 2398: 
 2399: void AWitchPTCharacter::PossessedBy(AController* NewController)
 2400: {
 2401: 	Super::PossessedBy(NewController);
 2402: 
 2403: 	// Init ability actor info for the Server
 2404: 	InitAbilityActorInfo();
 2405: 
 2406: 
 2407: 	// Solo conceder habilidades si AbilitySystemComponent fue inicializado correctamente
 2408: 	if (AbilitySystemComponent)
 2409: 	{
 2410: 		GrantStartupAbilities();
 2411: 		AddStartupEffects();
 2412: 	}
 2413: }
 2414: 
 2415: void AWitchPTCharacter::OnRep_PlayerState()
 2416: {
 2417: 	Super::OnRep_PlayerState();
 2418: 	// Init ability actor info for the Client
 2419: 	InitAbilityActorInfo();
 2420: 	AddStartupEffects();
 2421: }
 2422: 
 2423: void AWitchPTCharacter::InitAbilityActorInfo()
 2424: {
 2425: 	Super::InitAbilityActorInfo();
 2426: 	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
 2427: 
 2428: 	if (!WitchPtPlayerState)
 2429: 	{
 2430: 		return;
 2431: 	}
 2432: 
 2433: 	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);
 2434: 
 2435: 	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
 2436: 	if (!AbilitySystemComponent)
 2437: 	{
 2438: 		return;
 2439: 	}
 2440: 
 2441: 	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
 2442: 	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
 2443: 
 2444: 
 2445: 
 2446: 	/*
 2447: 	* Here we initialize the Overlay because we have all the data we need: the player controller, player state, ability system component and attribute set.
 2448: 	* Also, the HUD is accessible from the player controller.
 2449: 	*/
 2450: 	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
 2451: 	{
 2452: 		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
 2453: 		{
 2454: 			WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
 2455: 		}
 2456: 	}
 2457: 	InitializeDefaultAttributes();
 2458: }
 2459: </file>
 2460: 
 2461: <file path="WitchPT/Private/Character/WitchPTCharacterBase.cpp">
 2462: // Fill out your copyright notice in the Description page of Project Settings.
 2463: 
 2464: 
 2465: #include "Character/WitchPTCharacterBase.h"
 2466: 
 2467: #include "AbilitySystemComponent.h"
 2468: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 2469: #include "AbilitySystem/WitchPTAttributeSet.h"
 2470: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2471: #include "Components/CapsuleComponent.h"
 2472: 
 2473: // Sets default values
 2474: AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
 2475: 	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
 2476: {
 2477:  	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 2478: 	PrimaryActorTick.bCanEverTick = true;
 2479: 	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 2480: 	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 2481: 
 2482: }
 2483: 
 2484: UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
 2485: {
 2486: 	return AbilitySystemComponent;
 2487: }
 2488: 
 2489: 
 2490: 
 2491: // Called to bind functionality to input
 2492: void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 2493: {
 2494: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 2495: 
 2496: }
 2497: 
 2498: void AWitchPTCharacterBase::InitializeDefaultAttributes()
 2499: {
 2500: 	ApplyGameplayEffectToSelf(DefaultAttributes);
 2501: 
 2502: 
 2503: }
 2504: 
 2505: void AWitchPTCharacterBase::GrantStartupAbilities()
 2506: {
 2507: 	if (!HasAuthority()) return;
 2508: 
 2509: 	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 2510: 
 2511: 	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
 2512: }
 2513: 
 2514: void AWitchPTCharacterBase::AddStartupEffects()
 2515: {
 2516: 	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
 2517: 	{
 2518: 		return;
 2519: 	}
 2520: 
 2521: 	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
 2522: 	EffectContext.AddSourceObject(this);
 2523: 
 2524: 	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
 2525: 	{
 2526: 		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
 2527: 		if (NewHandle.IsValid())
 2528: 		{
 2529: 			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
 2530: 		}
 2531: 	}
 2532: 
 2533: 	AbilitySystemComponent->bStartupEffectsApplied = true;
 2534: }
 2535: 
 2536: void AWitchPTCharacterBase::InitAbilityActorInfo()
 2537: {
 2538: }
 2539: 
 2540: void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
 2541: {
 2542: 	check(IsValid(GetAbilitySystemComponent()));
 2543: 	check(GameplayEffectClass);
 2544: 	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
 2545: 	EffectContextHandle.AddSourceObject(this);
 2546: 	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
 2547: 	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
 2548: 
 2549: }
 2550: 
 2551: float AWitchPTCharacterBase::GetHealth() const
 2552: {
 2553: 	if (IsValid(AttributeSet))
 2554: 	{
 2555: 		return AttributeSet->GetHealth();
 2556: 	}
 2557: 	return 0.f;
 2558: }
 2559: 
 2560: float AWitchPTCharacterBase::GetMaxHealth() const
 2561: {
 2562: 	if (IsValid(AttributeSet))
 2563: 	{
 2564: 		return AttributeSet->GetMaxHealth();
 2565: 	}
 2566: 	return 0.f;
 2567: }
 2568: 
 2569: float AWitchPTCharacterBase::GetStamina() const
 2570: {
 2571: 	if (IsValid(AttributeSet))
 2572: 	{
 2573: 		return AttributeSet->GetStamina();
 2574: 	}
 2575: 	return 0.f;
 2576: }
 2577: 
 2578: float AWitchPTCharacterBase::GetMaxStamina() const
 2579: {
 2580: 	if (IsValid(AttributeSet))
 2581: 	{
 2582: 		return AttributeSet->GetMaxStamina();
 2583: 	}
 2584: 	return 0.f;
 2585: }
 2586: 
 2587: float AWitchPTCharacterBase::GetAge() const
 2588: {
 2589: 	if (IsValid(AttributeSet))
 2590: 	{
 2591: 		return AttributeSet->GetAge();
 2592: 	}
 2593: 	return 0.f;
 2594: }
 2595: 
 2596: float AWitchPTCharacterBase::GetMaxAge() const
 2597: {
 2598: 	if (IsValid(AttributeSet))
 2599: 	{
 2600: 		return AttributeSet->GetMaxAge();
 2601: 	}
 2602: 	return 0.f;
 2603: }
 2604: 
 2605: float AWitchPTCharacterBase::GetMana() const
 2606: {
 2607: 	if (IsValid(AttributeSet))
 2608: 	{
 2609: 		return AttributeSet->GetMana();
 2610: 	}
 2611: 	return 0.f;
 2612: }
 2613: 
 2614: float AWitchPTCharacterBase::GetMaxMana() const
 2615: {
 2616: 	if (IsValid(AttributeSet))
 2617: 	{
 2618: 		return AttributeSet->GetMaxMana();
 2619: 	}
 2620: 	return 0.f;
 2621: }
 2622: 
 2623: float AWitchPTCharacterBase::GetSpeedMultiplier() const
 2624: {
 2625: 	if (IsValid(AttributeSet))
 2626: 	{
 2627: 		return AttributeSet->GetSpeedMultiplier();
 2628: 	}
 2629: 	return 0.f;
 2630: }
 2631: 
 2632: float AWitchPTCharacterBase::GetMoveSpeed() const
 2633: {
 2634: 	if (IsValid(AttributeSet))
 2635: 	{
 2636: 		return AttributeSet->GetMoveSpeed();
 2637: 	}
 2638: 	return 0.f;
 2639: }
 2640: 
 2641: float AWitchPTCharacterBase::GetMaxMoveSpeed() const
 2642: {
 2643: 	if (IsValid(AttributeSet))
 2644: 	{
 2645: 		return AttributeSet->GetMaxMoveSpeed();
 2646: 	}
 2647: 	return 0.f;
 2648: }
 2649: </file>
 2650: 
 2651: <file path="WitchPT/Private/Character/WitchPTEnemy.cpp">
 2652: // Fill out your copyright notice in the Description page of Project Settings.
 2653: 
 2654: 
 2655: #include "Character/WitchPTEnemy.h"
 2656: 
 2657: 
 2658: // Sets default values
 2659: AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 2660: {
 2661: 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 2662: 	PrimaryActorTick.bCanEverTick = true;
 2663: }
 2664: 
 2665: // Called when the game starts or when spawned
 2666: void AWitchPTEnemy::BeginPlay()
 2667: {
 2668: 	Super::BeginPlay();
 2669: 
 2670: }
 2671: 
 2672: // Called every frame
 2673: void AWitchPTEnemy::Tick(float DeltaTime)
 2674: {
 2675: 	Super::Tick(DeltaTime);
 2676: }
 2677: 
 2678: // Called to bind functionality to input
 2679: void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 2680: {
 2681: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 2682: 	// Test commit again
 2683: }
 2684: </file>
 2685: 
 2686: <file path="WitchPT/Private/Game/WitchPTGameModeBase.cpp">
 2687: // Fill out your copyright notice in the Description page of Project Settings.
 2688: 
 2689: 
 2690: #include "Game/WitchPTGameModeBase.h"
 2691: </file>
 2692: 
 2693: <file path="WitchPT/Private/Input/WitchPTInputComponent.cpp">
 2694: // Fill out your copyright notice in the Description page of Project Settings.
 2695: 
 2696: 
 2697: #include "Input/WitchPTInputComponent.h"
 2698: </file>
 2699: 
 2700: <file path="WitchPT/Private/Input/WitchPTInputConfig.cpp">
 2701: // Fill out your copyright notice in the Description page of Project Settings.
 2702: 
 2703: 
 2704: #include "Input/WitchPTInputConfig.h"
 2705: 
 2706: const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
 2707: {
 2708: 	for (const FWitchPTInputAction& Pair: AbilityInputActions)
 2709: 	{
 2710: 		if (InputTag == Pair.InputTag)
 2711: 		{
 2712: 			return Pair.InputAction;
 2713: 		}
 2714: 	}
 2715: 	if (bLogNotFound)
 2716: 	{
 2717: 		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
 2718: 	}
 2719: 	return nullptr;
 2720: 
 2721: }
 2722: </file>
 2723: 
 2724: <file path="WitchPT/Private/Inventory/Collectable.cpp">
 2725: // Fill out your copyright notice in the Description page of Project Settings.
 2726: 
 2727: 
 2728: #include "Inventory/Collectable.h"
 2729: 
 2730: #include "Inventory/WitchPTInventoryManagerComponent.h"
 2731: 
 2732: UCollectableStatics::UCollectableStatics()
 2733: : Super(FObjectInitializer::Get())
 2734: {
 2735: }
 2736: 
 2737: TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
 2738: {
 2739: 	TScriptInterface<ICollectable> PickupableActor(Actor);
 2740: 	if (PickupableActor)
 2741: 	{
 2742: 		return PickupableActor;
 2743: 	}
 2744: 
 2745: 	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
 2746: 	if (PickupableComponents.Num() > 0)
 2747: 	{
 2748: 		return TScriptInterface<ICollectable>(PickupableComponents[0]);
 2749: 	}
 2750: 
 2751: 	return TScriptInterface<ICollectable>();
 2752: }
 2753: 
 2754: 
 2755: void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
 2756: 	TScriptInterface<ICollectable> Collectable)
 2757: {
 2758: 	if (InventoryComponent && Collectable)
 2759: 	{
 2760: 		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
 2761: 		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
 2762: 	}
 2763: }
 2764: </file>
 2765: 
 2766: <file path="WitchPT/Private/Inventory/FastArray/FastArrayList.cpp">
 2767: #pragma once
 2768: 
 2769: #include "Inventory/FastArray/FastArrayList.h"
 2770: 
 2771: #include "CoreMinimal.h"
 2772: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2773: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 2774: #include "Inventory/WitchPTInventoryItemInstance.h"
 2775: #include "Inventory/WitchPTInventoryManagerComponent.h"
 2776: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 2777: 
 2778: 
 2779: class FLifetimeProperty;
 2780: struct FReplicationFlags;
 2781: //////////////////////////////////////////////////////////////////////
 2782: // FWitchPTInventoryEntry
 2783: FString FWitchPTInventoryEntry::GetDebugString() const
 2784: {
 2785: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 2786: 	if (Instance != nullptr)
 2787: 	{
 2788: 		ItemDef = Instance->GetItemDef();
 2789: 	}
 2790: 
 2791: 	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
 2792: }
 2793: 
 2794: 
 2795: 
 2796: //////////////////////////////////////////////////////////////////////
 2797: // FWitchPTInventoryList
 2798: void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 2799: {
 2800: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 2801: 	if (!IsValid(IMC)) return;
 2802: 	for (int32 Index : RemovedIndices)
 2803: 	{
 2804: 		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
 2805: 	}
 2806: }
 2807: 
 2808: void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 2809: {
 2810: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 2811: 	if (!IsValid(IMC)) return;
 2812: 	for (int32 Index : AddedIndices)
 2813: 	{
 2814: 		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
 2815: 	}
 2816: }
 2817: 
 2818: void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 2819: {
 2820: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 2821: 	if (!IsValid(IMC)) return;
 2822: 
 2823: 	for (int32 Index : ChangedIndices)
 2824: 	{
 2825: 		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
 2826: 	}
 2827: }
 2828: 
 2829: UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 2830: {
 2831: 	UWitchPTInventoryItemInstance* Result = nullptr;
 2832: 
 2833: 	check(ItemDef != nullptr);
 2834: 	check(OwnerComponent);
 2835: 
 2836: 	AActor* OwningActor = OwnerComponent->GetOwner();
 2837: 	check(OwningActor->HasAuthority());
 2838: 
 2839: 
 2840: 	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
 2841: 	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
 2842: 	NewEntry.Instance->SetItemDef(ItemDef);
 2843: 	// ------ Stack stuff
 2844: 	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 2845: 	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 2846: 	if (IsValid(StackableFragment))
 2847: 	{
 2848: 		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
 2849: 	}
 2850: 	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
 2851: 	{
 2852: 		if (Fragment != nullptr)
 2853: 		{
 2854: 			Fragment->OnInstanceCreated(NewEntry.Instance);
 2855: 		}
 2856: 	}
 2857: 
 2858: 	Result = NewEntry.Instance;
 2859: 
 2860: 
 2861: 	MarkItemDirty(NewEntry);
 2862: 
 2863: 	return Result;
 2864: }
 2865: 
 2866: void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
 2867: {
 2868: 	unimplemented();
 2869: }
 2870: 
 2871: void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
 2872: {
 2873: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
 2874: 	{
 2875: 		FWitchPTInventoryEntry& Entry = *EntryIt;
 2876: 		if (Entry.Instance == Instance)
 2877: 		{
 2878: 			EntryIt.RemoveCurrent();
 2879: 			MarkArrayDirty();
 2880: 		}
 2881: 	}
 2882: }
 2883: TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
 2884: {
 2885: 	TArray<UWitchPTInventoryItemInstance*> Results;
 2886: 	Results.Reserve(Entries.Num());
 2887: 	for (const FWitchPTInventoryEntry& Entry : Entries)
 2888: 	{
 2889: 		if (Entry.Instance != nullptr) //@TODO: Would prefer to not deal with this here and hide it further?
 2890: 		{
 2891: 			Results.Add(Entry.Instance);
 2892: 		}
 2893: 	}
 2894: 	return Results;
 2895: }
 2896: </file>
 2897: 
 2898: <file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp">
 2899: // Fill out your copyright notice in the Description page of Project Settings.
 2900: 
 2901: 
 2902: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 2903: </file>
 2904: 
 2905: <file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp">
 2906: // Fill out your copyright notice in the Description page of Project Settings.
 2907: 
 2908: 
 2909: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 2910: </file>
 2911: 
 2912: <file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp">
 2913: // Fill out your copyright notice in the Description page of Project Settings.
 2914: 
 2915: 
 2916: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 2917: 
 2918: #include "Inventory/WitchPTInventoryItemInstance.h"
 2919: 
 2920: void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
 2921: {
 2922: 
 2923: }
 2924: </file>
 2925: 
 2926: <file path="WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp">
 2927: // Fill out your copyright notice in the Description page of Project Settings.
 2928: 
 2929: 
 2930: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 2931: </file>
 2932: 
 2933: <file path="WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp">
 2934: // Fill out your copyright notice in the Description page of Project Settings.
 2935: 
 2936: 
 2937: #include "Inventory/InventoryFunctionLibrary.h"
 2938: 
 2939: #include "Kismet/GameplayStatics.h"
 2940: #include "Player/WitchPTPlayerState.h"
 2941: #include "UI/HUD/WitchPTHUD.h"
 2942: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 2943: 
 2944: UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
 2945: {
 2946: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
 2947: 	{
 2948: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
 2949: 		{
 2950: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
 2951: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
 2952: 			UAttributeSet* AS = PS->GetAttributeSet();
 2953: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
 2954: 
 2955: 			return WitchPTHUD->SetInventoryWidgetController(WCParams);
 2956: 		}
 2957: 	}
 2958: 	return nullptr;
 2959: }
 2960: </file>
 2961: 
 2962: <file path="WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp">
 2963: // Fill out your copyright notice in the Description page of Project Settings.
 2964: 
 2965: 
 2966: #include "Inventory/WitchPTInventoryFunctionLibrary.h"
 2967: 
 2968: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2969: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 2970: 
 2971: const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
 2972: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
 2973: {
 2974: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
 2975: 	{
 2976: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
 2977: 	}
 2978: 	return nullptr;
 2979: }
 2980: </file>
 2981: 
 2982: <file path="WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp">
 2983: // Fill out your copyright notice in the Description page of Project Settings.
 2984: 
 2985: 
 2986: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2987: 
 2988: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 2989: 
 2990: UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
 2991: : Super(ObjectInitializer)
 2992: 
 2993: {
 2994: }
 2995: 
 2996: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
 2997: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
 2998: {
 2999: 	if (FragmentClass != nullptr)
 3000: 	{
 3001: 		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
 3002: 		{
 3003: 			if (Fragment && Fragment->IsA(FragmentClass))
 3004: 			{
 3005: 				return Fragment;
 3006: 			}
 3007: 		}
 3008: 	}
 3009: 
 3010: 	return nullptr;
 3011: }
 3012: </file>
 3013: 
 3014: <file path="WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp">
 3015: // Fill out your copyright notice in the Description page of Project Settings.
 3016: 
 3017: 
 3018: #include "Inventory/WitchPTInventoryItemInstance.h"
 3019: 
 3020: #include "GameplayTagContainer.h"
 3021: #include "Inventory/WitchPTInventoryItemDefinition.h"
 3022: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 3023: #include "Net/UnrealNetwork.h"
 3024: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
 3025: class FLifetimeProperty;
 3026: UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
 3027: 	:Super(ObjectInitializer)
 3028: {
 3029: }
 3030: 
 3031: void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 3032: {
 3033: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3034: 
 3035: 	DOREPLIFETIME(ThisClass, ItemDef);
 3036: 	DOREPLIFETIME(ThisClass, TotalStackCount);
 3037: }
 3038: 
 3039: 
 3040: 
 3041: void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
 3042: {
 3043: 	ItemDef = InDef;
 3044: }
 3045: 
 3046: 
 3047: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
 3048: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
 3049: {
 3050: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
 3051: 	{
 3052: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
 3053: 	}
 3054: 
 3055: 	return nullptr;
 3056: }
 3057: </file>
 3058: 
 3059: <file path="WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp">
 3060: // Fill out your copyright notice in the Description page of Project Settings.
 3061: 
 3062: 
 3063: #include "Inventory/WitchPTInventoryManagerComponent.h"
 3064: 
 3065: #include "Blueprint/UserWidget.h"
 3066: #include "Engine/ActorChannel.h"
 3067: #include "Inventory/WitchPTInventoryItemDefinition.h"
 3068: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 3069: #include "Inventory/WitchPTInventoryItemInstance.h"
 3070: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 3071: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 3072: #include "Net/UnrealNetwork.h"
 3073: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 3074: 
 3075: 
 3076: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)
 3077: 
 3078: 
 3079: void UWitchPTInventoryManagerComponent::BeginPlay()
 3080: {
 3081: 	Super::BeginPlay();
 3082: 	ConstructInventory();
 3083: }
 3084: 
 3085: UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
 3086: : Super(ObjectInitializer)
 3087: 	, InventoryList(this)
 3088: {
 3089: 	PrimaryComponentTick.bCanEverTick = false;
 3090: 	SetIsReplicatedByDefault(true);
 3091: 	bReplicateUsingRegisteredSubObjectList = true;
 3092: }
 3093: void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
 3094: {
 3095: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3096: 
 3097: 	DOREPLIFETIME(ThisClass, InventoryList);
 3098: }
 3099: 
 3100: // --------------- Inventory Manager Component Functions ---------------------------
 3101: 
 3102: void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 3103: {
 3104: 	if(IsValid(ItemDef))
 3105: 	{
 3106: 		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 3107: 		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 3108: 		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 3109: 
 3110: 		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
 3111: 		Server_UpdateItemStackCount(FoundItem, NewStackCount);
 3112: 	}
 3113: }
 3114: 
 3115: void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
 3116: {
 3117: 	if (IsValid(ItemInstance))
 3118: 	{
 3119: 		ItemInstance->SetTotalStackCount(NewCount);
 3120: 
 3121: 		// Marcar la entrada como sucia para la replicación
 3122: 		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 3123: 		{
 3124: 			if (Entry.Instance == ItemInstance)
 3125: 			{
 3126: 				InventoryList.MarkItemDirty(Entry);
 3127: 				break;
 3128: 			}
 3129: 		}
 3130: 
 3131: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 3132: 		{
 3133: 			OnItemStackChanged.Broadcast(ItemInstance);
 3134: 		}
 3135: 	}
 3136: }
 3137: 
 3138: void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
 3139: {
 3140: 	if (IsValid(ItemInstance))
 3141: 	{
 3142: 		// Notificar antes de eliminar para que los listeners puedan usar la información del item
 3143: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 3144: 		{
 3145: 			OnItemRemoved.Broadcast(ItemInstance);
 3146: 		}
 3147: 
 3148: 		// Eliminar el item de la lista de inventario
 3149: 		InventoryList.RemoveEntry(ItemInstance);
 3150: 
 3151: 		// Desregistrar el subobjeto para la replicación
 3152: 		if (IsUsingRegisteredSubObjectList())
 3153: 		{
 3154: 			RemoveReplicatedSubObject(ItemInstance);
 3155: 		}
 3156: 	}
 3157: }
 3158: 
 3159: void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 3160: {
 3161: 	if (IsValid(ItemInstance))
 3162: 	{
 3163: 		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
 3164: 		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
 3165: 
 3166: 		// Si el nuevo conteo es cero, eliminar el item completamente
 3167: 		if (NewCount <= 0)
 3168: 		{
 3169: 			Server_RemoveItemInstance(ItemInstance);
 3170: 		}
 3171: 		else
 3172: 		{
 3173: 			// Actualizar el conteo de stacks
 3174: 			Server_UpdateItemStackCount(ItemInstance, NewCount);
 3175: 		}
 3176: 	}
 3177: }
 3178: 
 3179: TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
 3180: {
 3181: 	return InventoryList.GetAllItems();
 3182: }
 3183: 
 3184: bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 3185: {
 3186: 	if (!ItemDef)
 3187: 	{
 3188: 		return false;
 3189: 	}
 3190: 
 3191: 	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 3192: 	if (FoundItem)
 3193: 	{
 3194: 		Server_AddStacksToItem(ItemDef);
 3195: 		return false;
 3196: 	}
 3197: 	else
 3198: 	{
 3199: 		Server_AddItem(ItemDef);
 3200: 		return true;
 3201: 	}
 3202: }
 3203: 
 3204: 
 3205: 
 3206: void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 3207: {
 3208: 	UWitchPTInventoryItemInstance* NewItem = nullptr;
 3209: 	if (ItemDef != nullptr)
 3210: 	{
 3211: 		NewItem = InventoryList.AddEntry(ItemDef);
 3212: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 3213: 		{
 3214: 			OnItemAdded.Broadcast(NewItem);
 3215: 		}
 3216: 
 3217: 		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
 3218: 		{
 3219: 			AddReplicatedSubObject(NewItem);
 3220: 		}
 3221: 	}
 3222: 
 3223: }
 3224: 
 3225: 
 3226: 
 3227: // void UWitchPTInventoryManagerComponent::RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance)
 3228: // {
 3229: // 	InventoryList.RemoveEntry(ItemInstance);
 3230: //
 3231: // 	if (ItemInstance && IsUsingRegisteredSubObjectList())
 3232: // 	{
 3233: // 		RemoveReplicatedSubObject(ItemInstance);
 3234: // 	}
 3235: // }
 3236: 
 3237: 
 3238: UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
 3239: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
 3240: {
 3241: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 3242: 	{
 3243: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 3244: 
 3245: 		if (IsValid(Instance))
 3246: 		{
 3247: 			if (Instance->GetItemDef() == ItemDef)
 3248: 			{
 3249: 				return Instance;
 3250: 			}
 3251: 		}
 3252: 	}
 3253: 
 3254: 	return nullptr;
 3255: }
 3256: 
 3257: int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
 3258: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
 3259: {
 3260: 	int32 TotalCount = 0;
 3261: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 3262: 	{
 3263: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 3264: 
 3265: 		if (IsValid(Instance))
 3266: 		{
 3267: 			if (Instance->GetItemDef() == ItemDef)
 3268: 			{
 3269: 				++TotalCount;
 3270: 			}
 3271: 		}
 3272: 	}
 3273: 
 3274: 	return TotalCount;
 3275: }
 3276: 
 3277: bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
 3278: 	int32 NumToConsume)
 3279: {
 3280: 	AActor* OwningActor = GetOwner();
 3281: 	if (!OwningActor || !OwningActor->HasAuthority())
 3282: 	{
 3283: 		return false;
 3284: 	}
 3285: 
 3286: 	//@TODO: N squared right now as there's no acceleration structure
 3287: 	int32 TotalConsumed = 0;
 3288: 	while (TotalConsumed < NumToConsume)
 3289: 	{
 3290: 		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
 3291: 		{
 3292: 			InventoryList.RemoveEntry(Instance);
 3293: 			++TotalConsumed;
 3294: 		}
 3295: 		else
 3296: 		{
 3297: 			return false;
 3298: 		}
 3299: 	}
 3300: 
 3301: 	return TotalConsumed == NumToConsume;
 3302: }
 3303: 
 3304: 
 3305: bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
 3306:                                                             FReplicationFlags* RepFlags)
 3307: {
 3308: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
 3309: 
 3310: 	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 3311: 	{
 3312: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 3313: 
 3314: 		if (Instance && IsValid(Instance))
 3315: 		{
 3316: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
 3317: 		}
 3318: 	}
 3319: 
 3320: 	return WroteSomething;
 3321: }
 3322: 
 3323: void UWitchPTInventoryManagerComponent::ReadyForReplication()
 3324: {
 3325: 	Super::ReadyForReplication();
 3326: 
 3327: 	if (IsUsingRegisteredSubObjectList())
 3328: 	{
 3329: 		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 3330: 		{
 3331: 			UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 3332: 
 3333: 			if (IsValid(Instance))
 3334: 			{
 3335: 				AddReplicatedSubObject(Instance);
 3336: 			}
 3337: 		}
 3338: 	}
 3339: }
 3340: 
 3341: void UWitchPTInventoryManagerComponent::ToggleInventoryMenu()
 3342: {
 3343: 	if (bInventoryMenuOpen)
 3344: 	{
 3345: 		CloseInventoryMenu();
 3346: 	}
 3347: 	else
 3348: 	{
 3349: 		OpenInventoryMenu();
 3350: 	}
 3351: }
 3352: 
 3353: void UWitchPTInventoryManagerComponent::ConstructInventory()
 3354: {
 3355: 	OwningController = Cast<APlayerController>(GetOwner());
 3356: 	checkf(OwningController.IsValid(), TEXT("Inventory Component should have a Player Controller as Owner."))
 3357: 	if (!OwningController->IsLocalController()) return;
 3358: 	InventoryMenu = CreateWidget<UInventoryUserWidget>(OwningController.Get(), InventoryMenuClass);
 3359: 	InventoryMenu->AddToViewport();
 3360: 	CloseInventoryMenu();
 3361: }
 3362: 
 3363: void UWitchPTInventoryManagerComponent::OpenInventoryMenu()
 3364: {
 3365: 	if (!IsValid(InventoryMenu)) return;
 3366: 
 3367: 	InventoryMenu->SetVisibility(ESlateVisibility::Visible);
 3368: 	bInventoryMenuOpen = true;
 3369: 
 3370: 	if (!OwningController.IsValid()) return;
 3371: 
 3372: 	FInputModeGameAndUI InputMode;
 3373: 
 3374: 	OwningController->SetInputMode(InputMode);
 3375: 	OwningController->SetShowMouseCursor(true);
 3376: }
 3377: 
 3378: void UWitchPTInventoryManagerComponent::CloseInventoryMenu()
 3379: {
 3380: 	if (!IsValid(InventoryMenu)) return;
 3381: 
 3382: 	InventoryMenu->SetVisibility(ESlateVisibility::Collapsed);
 3383: 	bInventoryMenuOpen = false;
 3384: 
 3385: 	if (!OwningController.IsValid()) return;
 3386: 
 3387: 	FInputModeGameOnly InputMode;
 3388: 	OwningController->SetInputMode(InputMode);
 3389: 	OwningController->SetShowMouseCursor(false);
 3390: }
 3391: </file>
 3392: 
 3393: <file path="WitchPT/Private/Item/BaseInteractableAltar.cpp">
 3394: #include "Item/BaseInteractableAltar.h"
 3395: 
 3396: #include "FWitchPTGameplayTags.h"
 3397: #include "Item/BaseInteractionPosition.h"
 3398: #include "Net/UnrealNetwork.h"
 3399: #include "GameFramework/Character.h"
 3400: #include "Item/RitualAltar.h"
 3401: #include "Item/RitualPosition.h"
 3402: 
 3403: // Sets default values
 3404: ABaseInteractableAltar::ABaseInteractableAltar()
 3405: {
 3406:     // Set this actor to call Tick() every frame
 3407:     PrimaryActorTick.bCanEverTick = true;
 3408: 
 3409:     // Make sure it replicates
 3410:     bReplicates = true;
 3411:     bAlwaysRelevant = true;
 3412: 
 3413:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
 3414:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
 3415:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
 3416:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);
 3417: 
 3418: }
 3419: 
 3420: void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 3421: {
 3422:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3423: 
 3424:     DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
 3425:     DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
 3426:     DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
 3427:     DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
 3428: 
 3429: }
 3430: 
 3431: // Called when the game starts or when spawned
 3432: void ABaseInteractableAltar::BeginPlay()
 3433: {
 3434:     Super::BeginPlay();
 3435: 
 3436:     // Initialize interaction positions
 3437:     CreateAltarPositions();
 3438: }
 3439: 
 3440: // Called every frame
 3441: void ABaseInteractableAltar::Tick(float DeltaTime)
 3442: {
 3443:     Super::Tick(DeltaTime);
 3444: 
 3445:     // Child classes will implement specific tick behavior
 3446: }
 3447: 
 3448: 
 3449: 
 3450: void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 3451: {
 3452:     if (!Player || !Position || !HasAuthority())
 3453:     {
 3454:         return;
 3455:     }
 3456: 
 3457:     Position->SetOccupied(nullptr);
 3458: 
 3459:     // Remove from participating players if they're not in the list
 3460:     ParticipatingPlayers.Remove(Player);
 3461: 
 3462: }
 3463: void ABaseInteractableAltar::CreateAltarPositions()
 3464: {
 3465:     if (!HasAuthority() || !PositionClass)
 3466:     {
 3467:         return;
 3468:     }
 3469: 
 3470:     // Make sure we have no previous positions
 3471:     DestroyAltarPositions();
 3472: 
 3473:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
 3474:     int positionIndex = 0;
 3475:     // Spawn a CauldronPosition for each transform
 3476:     for (const FTransform& PosTransform : PositionTransforms)
 3477:     {
 3478:         // Transform relative to world space
 3479:         FTransform WorldTransform = PosTransform * GetActorTransform();
 3480: 
 3481:         // Get location and rotation from the transform
 3482:         FVector Location = WorldTransform.GetLocation();
 3483:         FRotator Rotation = WorldTransform.Rotator();
 3484: 
 3485:         // Spawn parameters
 3486:         FActorSpawnParameters SpawnParams;
 3487:         SpawnParams.Owner = this;
 3488:         SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 3489: 
 3490:         // Spawn the brewing position
 3491:         ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
 3492:             PositionClass,
 3493:             Location,
 3494:             Rotation,
 3495:             SpawnParams);
 3496: 
 3497:         if (NewPosition)
 3498:         {
 3499:             // Initialize the position
 3500:             // Note: Implement this method in CauldronPosition if needed
 3501:             // NewPosition->SetCauldronAltar(this);
 3502:             NewPosition->SetPositionTag(TagsPositions[positionIndex]);
 3503:             ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
 3504:             if (RitualPosition)
 3505:             {
 3506:                 RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
 3507:             }
 3508:             positionIndex++;
 3509: 
 3510: 
 3511:             // Add to our array
 3512:             InteractionPositions.Add(NewPosition);
 3513: 
 3514:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
 3515:         }
 3516:     }
 3517: }
 3518: 
 3519: 
 3520: 
 3521: void ABaseInteractableAltar::DestroyAltarPositions()
 3522: {
 3523:     // Only destroy positions on the server
 3524:     if (!HasAuthority())
 3525:     {
 3526:         return;
 3527:     }
 3528: 
 3529:     // Destroy all brewing positions
 3530:     for (ABaseInteractionPosition* Position : InteractionPositions)
 3531:     {
 3532:         if (Position)
 3533:         {
 3534:             Position->Destroy();
 3535:         }
 3536:     }
 3537: 
 3538:     // Clear the array
 3539:     InteractionPositions.Empty();
 3540: 
 3541:     UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
 3542: }
 3543: 
 3544: 
 3545: void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
 3546: {
 3547:     // Update visuals or play sounds based on state change
 3548:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
 3549: }
 3550: 
 3551: void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 3552: {
 3553:     // Play success feedback
 3554:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
 3555: }
 3556: 
 3557: void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 3558: {
 3559:     // Play failure feedback
 3560:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
 3561: }
 3562: 
 3563: 
 3564: 
 3565: void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
 3566: {
 3567:     // Update client-side UI or visuals for players
 3568: }
 3569: 
 3570: 
 3571: void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
 3572: {
 3573:     // Base implementation - to be overridden by child classes
 3574:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
 3575: }
 3576: 
 3577: void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
 3578: {
 3579: 
 3580: }
 3581: 
 3582: void ABaseInteractableAltar::CheckState()
 3583: {
 3584:     // Base implementation - to be overridden by child classes
 3585:     // This would check if the interaction is complete or failed
 3586: }
 3587: 
 3588: void ABaseInteractableAltar::CleanupInteraction()
 3589: {
 3590: 
 3591: }
 3592: 
 3593: void ABaseInteractableAltar::SpawnReward()
 3594: {
 3595: 
 3596: }
 3597: 
 3598: void ABaseInteractableAltar::SpawnDemon()
 3599: {
 3600: 
 3601: }
 3602: 
 3603: bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
 3604: {
 3605:     // Base implementation - to be overridden by child classes
 3606:     // Check if the player is valid and in the participating list
 3607:     return Player && ParticipatingPlayers.Contains(Player);
 3608: }
 3609: </file>
 3610: 
 3611: <file path="WitchPT/Private/Item/BaseInteractionPosition.cpp">
 3612: #include "Item/BaseInteractionPosition.h"
 3613: #include "Net/UnrealNetwork.h"
 3614: #include "Engine/ActorChannel.h"
 3615: #include "AbilitySystemComponent.h"
 3616: #include "Components/BoxComponent.h"
 3617: #include "GameFramework/Character.h"
 3618: 
 3619: ABaseInteractionPosition::ABaseInteractionPosition()
 3620: {
 3621:     // Set this actor to call Tick() every frame
 3622:     PrimaryActorTick.bCanEverTick = true;
 3623: 
 3624:     // Make sure this actor replicates
 3625:     bReplicates = true;
 3626:     bAlwaysRelevant = true;
 3627: }
 3628: 
 3629: void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 3630: {
 3631:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3632: 
 3633:     // Replicate the occupied state and occupying character
 3634:     DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
 3635:     DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
 3636:     DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
 3637: 
 3638:     // PositionTag and Altar are usually set once and don't need replication unless they can change dynamically
 3639: }
 3640: 
 3641: void ABaseInteractionPosition::BeginPlay()
 3642: {
 3643:     Super::BeginPlay();
 3644: 
 3645:     // Additional initialization could go here if needed
 3646: }
 3647: 
 3648: void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 3649: {
 3650:     // This should be overridden by derived classes
 3651:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 3652: }
 3653: 
 3654: bool ABaseInteractionPosition::IsOccupied() const
 3655: {
 3656:     return bIsOccupied;
 3657: }
 3658: 
 3659: void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
 3660: {
 3661:     if (GetLocalRole() != ROLE_Authority)
 3662:     {
 3663:         return;
 3664:     }
 3665: 
 3666:     OccupyingCharacter = Character;
 3667:     bIsOccupied = (Character != nullptr);
 3668: }
 3669: 
 3670: void ABaseInteractionPosition::SetUnoccupied()
 3671: {
 3672:     if (GetLocalRole() != ROLE_Authority)
 3673:     {
 3674:         return;
 3675:     }
 3676: 
 3677:     RemoveCharacterFromPosition();
 3678: }
 3679: 
 3680: void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
 3681: {
 3682:     PositionTag = NewTag;
 3683: }
 3684: 
 3685: void ABaseInteractionPosition::OnRep_IsOccupied()
 3686: {
 3687:     // Handle any visuals or sounds when occupation state changes
 3688: }
 3689: 
 3690: void ABaseInteractionPosition::OnRep_OccupyingCharacter()
 3691: {
 3692:     // Handle any visuals or sounds when the occupying character changes
 3693: }
 3694: 
 3695: void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
 3696: {
 3697:     // Base implementation - should be overridden by child classes
 3698:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
 3699:         *GetName(), *InteractingCharacter->GetName());
 3700: }
 3701: 
 3702: void ABaseInteractionPosition::RemoveCharacterFromPosition()
 3703: {
 3704:     OccupyingCharacter = nullptr;
 3705:     bIsOccupied = false;
 3706: }
 3707: </file>
 3708: 
 3709: <file path="WitchPT/Private/Item/CauldronAltar.cpp">
 3710: #include "Item/CauldronAltar.h"
 3711: 
 3712: #include "AbilitySystemBlueprintLibrary.h"
 3713: #include "Item/CauldronPosition.h"
 3714: #include "Net/UnrealNetwork.h"
 3715: #include "GameFramework/Character.h"
 3716: #include "Kismet/GameplayStatics.h"
 3717: #include "TimerManager.h"
 3718: #include "Components/SkeletalMeshComponent.h"
 3719: #include "Components/CapsuleComponent.h"
 3720: #include "Components/StaticMeshComponent.h"
 3721: #include "Engine/World.h"
 3722: #include "DrawDebugHelpers.h"
 3723: #include "FWitchPTGameplayTags.h"
 3724: #include "Engine/ActorChannel.h"
 3725: #include "Inventory/WitchPTInventoryItemDefinition.h"
 3726: #include "Inventory/WitchPTInventoryItemInstance.h"
 3727: #include "Inventory/WitchPTInventoryManagerComponent.h"
 3728: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 3729: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 3730: #include "Player/WitchPTPlayerController.h"
 3731: 
 3732: // Sets default values
 3733: ACauldronAltar::ACauldronAltar()
 3734: {
 3735:     // Set this actor to call Tick() every frame
 3736:     PrimaryActorTick.bCanEverTick = true;
 3737: 
 3738:     // Make sure it replicates
 3739:     bReplicates = true;
 3740:     bAlwaysRelevant = true;
 3741:     CauldronPhysicState = ECauldronPhysicState::Static;
 3742:     CarryingCharacter = nullptr;
 3743:     CurrentPlacementState = ECauldronPlacementState::None;
 3744:     bReplicateUsingRegisteredSubObjectList = true;
 3745: 
 3746: }
 3747: 
 3748: void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 3749: {
 3750:     // Set up the interaction option based on the cauldron state
 3751:     FInteractionOption InteractionOption = Option;
 3752: 
 3753:     // Configure the interaction option to support hold interaction
 3754:     InteractionOption.bSupportsHoldInteraction = true;
 3755: 
 3756:     // Add the interaction option to the builder
 3757:     OptionBuilder.AddInteractionOption(InteractionOption);
 3758: }
 3759: 
 3760: void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 3761: {
 3762:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3763: 
 3764:     DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
 3765:     DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
 3766:     DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
 3767:     DOREPLIFETIME(ACauldronAltar, BaseIngredientIcon);
 3768:     DOREPLIFETIME(ACauldronAltar, PrincipalIngredientIcon);
 3769:     DOREPLIFETIME(ACauldronAltar, ModifierIngredientIcon);
 3770: 
 3771: }
 3772: 
 3773: 
 3774: void ACauldronAltar::OnRep_CauldronPhysicState()
 3775: {
 3776:     // Update visual representation based on the new state
 3777:     if (CauldronPhysicState == ECauldronPhysicState::Moving)
 3778:     {
 3779:         // Cauldron is being carried - update visuals if needed
 3780:         SetActorEnableCollision(false);
 3781:     }
 3782:     else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
 3783:     {
 3784:         // Cauldron is in preview mode - update visuals
 3785:         SetActorEnableCollision(false);
 3786: 
 3787: 
 3788:     }
 3789: 
 3790: }
 3791: 
 3792: 
 3793: 
 3794: void ACauldronAltar::OnRep_BaseIngredientIcon()
 3795: {
 3796:     BroadcastBaseIngredientIconSet();
 3797: }
 3798: 
 3799: void ACauldronAltar::OnRep_PrincipalIngredientIcon()
 3800: {
 3801:     BroadcastPrincipalIngredientIconSet();
 3802: }
 3803: 
 3804: void ACauldronAltar::OnRep_PotentiatorIngredientIcon()
 3805: {
 3806:     BroadcastModifierIngredientIconSet();
 3807: }
 3808: 
 3809: // --- Interaction Functions ---
 3810: 
 3811: void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
 3812: {
 3813:     if (!InteractingCharacter)
 3814:     {
 3815:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
 3816:         return;
 3817:     }
 3818: 
 3819:     // Si el caldero está en modo de previsualización, finalizar la colocación
 3820:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 3821:     {
 3822:         FinalizePlacement();
 3823:         return;
 3824:     }
 3825: 
 3826:     // Otherwise, try to position the character for brewing
 3827:     PositionCharacterForBrewing(InteractingCharacter);
 3828: }
 3829: 
 3830: void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
 3831: {
 3832:     if (!HasAuthority())
 3833:     {
 3834:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Not authority"));
 3835:         return;
 3836:     }
 3837: 
 3838:     if (CauldronPhysicState != ECauldronPhysicState::Static)
 3839:     {
 3840:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
 3841:         return;
 3842:     }
 3843: 
 3844:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
 3845:     if (!PC)
 3846:     {
 3847:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
 3848:         return;
 3849:     }
 3850: 
 3851:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
 3852:     if (!InventoryManager)
 3853:     {
 3854:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
 3855:         return;
 3856:     }
 3857: 
 3858:     UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);
 3859: 
 3860:     if (!InstanceFromInventory)
 3861:     {
 3862:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
 3863:         return;
 3864:     }
 3865: 
 3866:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 3867:     if (!IngredientCraftingDetails)
 3868:     {
 3869:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
 3870:         return;
 3871:     }
 3872: 
 3873:     // Determine ingredient type based on SlotUsageTag
 3874:     const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
 3875:     bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
 3876:     bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
 3877:     bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);
 3878: 
 3879:     // Check if the appropriate slot is already occupied
 3880:     if (bIsBaseIngredient && BaseIngredient != nullptr)
 3881:     {
 3882:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
 3883:         return;
 3884:     }
 3885: 
 3886:     if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
 3887:     {
 3888:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
 3889:         return;
 3890:     }
 3891: 
 3892:     if (bIsModifierIngredient && ModifierIngredient != nullptr)
 3893:     {
 3894:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
 3895:         return;
 3896:     }
 3897: 
 3898:     // If none of the slot usage tags match, this ingredient can't be used
 3899:     if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
 3900:     {
 3901:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
 3902:         return;
 3903:     }
 3904: 
 3905:     bool bConsumedSuccessfully = false;
 3906:     int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
 3907: 
 3908:     if (CurrentStackCount > 0)
 3909:     {
 3910:         UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
 3911: 
 3912:         if (CurrentStackCount == 1)
 3913:         {
 3914:             IngredientToSet = InstanceFromInventory;
 3915:             InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
 3916:             bConsumedSuccessfully = true;
 3917:         }
 3918:         else
 3919:         {
 3920:             InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
 3921:             IngredientToSet = InstanceFromInventory;
 3922:             bConsumedSuccessfully = true;
 3923:         }
 3924: 
 3925:         // Get UI fragment for icon
 3926:         const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
 3927:         TSubclassOf<UUserWidget> IngredientIcon = nullptr;
 3928:         if (IsValid(UIFragment))
 3929:         {
 3930:             IngredientIcon = UIFragment->IconWidget;
 3931:         }
 3932: 
 3933:         // Set the ingredient in the appropriate slot
 3934:         if (bIsBaseIngredient)
 3935:         {
 3936:             BaseIngredient = IngredientToSet;
 3937:             BaseIngredientIcon = IngredientIcon;
 3938:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient set successfully"));
 3939: 
 3940:             if (HasAuthority())
 3941:             {
 3942:                 BroadcastBaseIngredientIconSet();
 3943:             }
 3944:         }
 3945:         else if (bIsPrincipalIngredient)
 3946:         {
 3947:             PrincipalIngredient = IngredientToSet;
 3948:             PrincipalIngredientIcon = IngredientIcon;
 3949:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient set successfully"));
 3950: 
 3951:             if (HasAuthority())
 3952:             {
 3953:                 BroadcastPrincipalIngredientIconSet();
 3954:             }
 3955:         }
 3956:         else if (bIsModifierIngredient)
 3957:         {
 3958:             ModifierIngredient = IngredientToSet;
 3959:             ModifierIngredientIcon = IngredientIcon;
 3960:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient set successfully"));
 3961: 
 3962:             if (HasAuthority())
 3963:             {
 3964:                 BroadcastModifierIngredientIconSet();
 3965:             }
 3966:         }
 3967:     }
 3968: }
 3969: 
 3970: 
 3971: void ACauldronAltar::BeginPlay()
 3972: {
 3973:     Super::BeginPlay();
 3974:     SetReplicateMovement(true);
 3975: }
 3976: 
 3977: bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
 3978:     FReplicationFlags* RepFlags)
 3979: {
 3980:     return Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
 3981: }
 3982: 
 3983: 
 3984: void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
 3985: {
 3986:     if (!InteractingCharacter)
 3987:     {
 3988:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
 3989:         return;
 3990:     }
 3991: 
 3992:     // Si el caldero está en modo de previsualización, cancelar y volver a adjuntar al personaje
 3993:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 3994:     {
 3995:         CancelPlacement();
 3996:         return;
 3997:     }
 3998: 
 3999:     // Check if the cauldron can be picked up
 4000:     if (!CanBePickedUp())
 4001:     {
 4002:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
 4003:         return;
 4004:     }
 4005: 
 4006:     // Attach the cauldron to the character
 4007:     AttachToCharacter(InteractingCharacter);
 4008: }
 4009: 
 4010: bool ACauldronAltar::CanBePickedUp() const
 4011: {
 4012:     // Check if the cauldron is already being carried
 4013:     if (IsBeingCarried() || IsInPlacementPreview())
 4014:     {
 4015:         return false;
 4016:     }
 4017: 
 4018:     // Add any additional conditions here (e.g., cauldron is empty, not brewing, etc.)
 4019: 
 4020:     return true;
 4021: }
 4022: 
 4023: bool ACauldronAltar::IsBeingCarried() const
 4024: {
 4025:     return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
 4026: }
 4027: 
 4028: bool ACauldronAltar::IsInPlacementPreview() const
 4029: {
 4030:     return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
 4031: }
 4032: 
 4033: 
 4034: ACharacter* ACauldronAltar::GetCarryingCharacter() const
 4035: {
 4036:     return CarryingCharacter;
 4037: }
 4038: 
 4039: void ACauldronAltar::AttachToCharacter(ACharacter* Character)
 4040: {
 4041:     if (!Character || !HasAuthority())
 4042:     {
 4043:         return;
 4044:     }
 4045: 
 4046:     // First destroy any brewing positions
 4047:     DestroyAltarPositions();
 4048: 
 4049:     // Set the cauldron state to moving
 4050:     CauldronPhysicState = ECauldronPhysicState::Moving;
 4051:     CarryingCharacter = Character;
 4052: 
 4053:     // Attach the cauldron to the character's back
 4054:     FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget,
 4055:                                           EAttachmentRule::KeepWorld, true);
 4056: 
 4057:     // Find the socket to attach to
 4058:     USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
 4059:     if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
 4060:     {
 4061:         // Attach to the socket
 4062:         AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
 4063: 
 4064:         // Disable collision
 4065:         SetActorEnableCollision(false);
 4066: 
 4067:         // Reduce de Scale of the Cauldron
 4068:         SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
 4069: 
 4070:         UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
 4071:     }
 4072: 
 4073: 
 4074: }
 4075: 
 4076: void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
 4077: {
 4078:     if (!Character || !HasAuthority() || Character != CarryingCharacter)
 4079:     {
 4080:         return;
 4081:     }
 4082: 
 4083:     // Detach from the character
 4084:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
 4085: 
 4086:     // Place the cauldron in front of the character
 4087:     FVector CharacterLocation = Character->GetActorLocation();
 4088:     FRotator CharacterRotation = Character->GetActorRotation();
 4089:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
 4090: 
 4091:     // Set the cauldron's location
 4092:     SetActorLocation(CharacterLocation + PlacementOffset);
 4093: 
 4094:     // Reset the cauldron state
 4095:     CauldronPhysicState = ECauldronPhysicState::Static;
 4096:     CarryingCharacter = nullptr;
 4097: 
 4098:     // Reset cauldron scale to normal
 4099:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 4100: 
 4101:     // Enable collision
 4102:     SetActorEnableCollision(true);
 4103: 
 4104:     // Create brewing positions around the cauldron
 4105:     CreateAltarPositions();
 4106: 
 4107:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
 4108: 
 4109:     // Play placement sound or effects
 4110:     // PlayPlacementEffects();
 4111: }
 4112: 
 4113: void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
 4114: {
 4115:     if (!Character || !HasAuthority())
 4116:     {
 4117:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
 4118:         return;
 4119:     }
 4120: 
 4121:     // Obtener una posición disponible
 4122:     ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
 4123: 
 4124:     if (BrewingPosition)
 4125:     {
 4126:         Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
 4127:         ParticipatingPlayers.Add(Character);
 4128: 
 4129:         if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
 4130:         {
 4131: 
 4132:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 4133:             {
 4134:                 PC->LocalToggleCauldronMenu();
 4135:             }
 4136:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
 4137:         {
 4138: 
 4139:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 4140:             {
 4141:                 PC->Client_ToggleCauldronMenu();
 4142:             }
 4143:         }
 4144:         FGameplayEventData Payload;
 4145:         Payload.OptionalObject = Character;
 4146:         FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
 4147:         UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
 4148:         return BrewingPosition->SetOccupied(Character);
 4149: 
 4150:         // Teleport the character to the position facing the cauldron
 4151: 
 4152: 
 4153:     }
 4154: 
 4155: 
 4156: 
 4157: 
 4158:     // Call the ritual state delegate for Listen Server
 4159: 
 4160: }
 4161: 
 4162: 
 4163: ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
 4164: {
 4165:     // Verificar que tengamos posiciones
 4166:     if (InteractionPositions.Num() == 0)
 4167:     {
 4168:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
 4169:         return nullptr;
 4170:     }
 4171: 
 4172:     // Buscar la primera posición disponible
 4173:     for (ABaseInteractionPosition* Position : InteractionPositions)
 4174:     {
 4175:         if (Position && !Position->IsOccupied())
 4176:         {
 4177:             return Position;
 4178:         }
 4179:     }
 4180: 
 4181:     // Todas las posiciones están ocupadas
 4182:     UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
 4183: 
 4184:     return nullptr;
 4185: }
 4186: 
 4187: // --- Nueva implementación para colocación del caldero ---
 4188: 
 4189: void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
 4190: {
 4191:     if (!Character || Character != CarryingCharacter || !HasAuthority())
 4192:     {
 4193:         return;
 4194:     }
 4195: 
 4196:     // Desacoplar el caldero del personaje
 4197:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
 4198: 
 4199:     // Establecer el estado de previsualización
 4200:     CauldronPhysicState = ECauldronPhysicState::Previewing;
 4201: 
 4202:     // Guardar los materiales originales para restaurarlos después
 4203:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
 4204:     if (MeshComponent)
 4205:     {
 4206:         OriginalMaterials.Empty();
 4207:         for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
 4208:         {
 4209:             OriginalMaterials.Add(MeshComponent->GetMaterial(i));
 4210:         }
 4211:     }
 4212: 
 4213:     // Aplicar material de previsualización
 4214:     CurrentPlacementState = ECauldronPlacementState::Invalid; // Por defecto, inválido hasta que se verifique
 4215:     // ApplyPlacementPreviewMaterial();
 4216: 
 4217:     // Desactivar colisiones durante la previsualización
 4218:     SetActorEnableCollision(false);
 4219: 
 4220:     // Colocar inicialmente el caldero frente al personaje
 4221:     FVector CharacterLocation = Character->GetActorLocation();
 4222:     FRotator CharacterRotation = Character->GetActorRotation();
 4223:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
 4224: 
 4225:     // Guardar la posición inicial
 4226:     PreviewLocation = CharacterLocation + PlacementOffset;
 4227:     // PreviewRotation = CharacterRotation;
 4228:     // Reset z rotation
 4229:     PreviewRotation.Pitch = 0;
 4230:     PreviewRotation.Roll = 0;
 4231:     PreviewRotation.Yaw = 0;
 4232:     // Establecer la posición del caldero
 4233:     SetActorLocation(PreviewLocation);
 4234:     SetActorRotation(PreviewRotation);
 4235: 
 4236:     // Restablecer la escala normal
 4237:     Multicast_FinalizePlacement();
 4238: 
 4239: 
 4240: }
 4241: 
 4242: void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
 4243: {
 4244: 
 4245: 
 4246:     // Actualizar el material según el estado
 4247:     // ApplyPlacementPreviewMaterial();
 4248: }
 4249: 
 4250: void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
 4251: {
 4252:     // Llamar a la implementación del cliente para actualizar la previsualización
 4253:     // Client_UpdatePlacementPreview(HitLocation, HitNormal);
 4254:     if (!IsInPlacementPreview())
 4255:     {
 4256:         return;
 4257:     }
 4258: 
 4259:     // Guardar la nueva posición de previsualización
 4260:     PreviewLocation = HitLocation;
 4261: 
 4262:     // Calcular la rotación para alinear con la superficie
 4263:     FRotator SurfaceAlignedRotation = HitNormal.Rotation();
 4264: 
 4265:     // Ajustar la rotación para que el caldero se alinee con la superficie pero mantenga su orientación "hacia arriba"
 4266:     // Necesitamos solo el componente de inclinación de la superficie
 4267:     FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
 4268: 
 4269:     // Limitar la inclinación máxima
 4270:     if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
 4271:     {
 4272:         AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
 4273:     }
 4274: 
 4275:     if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
 4276:     {
 4277:         AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
 4278:     }
 4279: 
 4280:     PreviewRotation = AdjustedRotation;
 4281:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 4282:     SetActorLocation(PreviewLocation);
 4283: 
 4284: 
 4285:     // Verificar si la posición es válida
 4286:     CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
 4287: }
 4288: 
 4289: 
 4290: 
 4291: void ACauldronAltar::FinalizePlacement()
 4292: {
 4293:     if (!IsInPlacementPreview() || !HasAuthority())
 4294:     {
 4295:         return;
 4296:     }
 4297: 
 4298:     // Establecer la posición final
 4299:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 4300:     SetActorLocation(PreviewLocation);
 4301:     SetActorRotation(PreviewRotation);
 4302: 
 4303:     // Restaurar los materiales originales
 4304:     RestoreOriginalMaterials();
 4305: 
 4306:     // Activar colisiones
 4307:     SetActorEnableCollision(true);
 4308: 
 4309:     // Cambiar el estado
 4310:     CauldronPhysicState = ECauldronPhysicState::Static;
 4311:     CarryingCharacter = nullptr;
 4312:     CurrentPlacementState = ECauldronPlacementState::None;
 4313: 
 4314:     OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
 4315: 
 4316:     // Crear posiciones de elaboración alrededor del caldero
 4317:     CreateAltarPositions();
 4318: 
 4319:     // Multicast finalizar placement
 4320:     Multicast_FinalizePlacement();
 4321: 
 4322:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
 4323: }
 4324: 
 4325: void ACauldronAltar::CancelPlacement()
 4326: {
 4327:     if (!IsInPlacementPreview() || !HasAuthority())
 4328:     {
 4329:         return;
 4330:     }
 4331: 
 4332:     // Restaurar materiales originales
 4333:     RestoreOriginalMaterials();
 4334: 
 4335:     // Recolocar el caldero en el personaje
 4336:     ACharacter* Character = CarryingCharacter;
 4337: 
 4338:     // Reiniciar estado
 4339:     CauldronPhysicState = ECauldronPhysicState::Moving;
 4340:     CarryingCharacter = nullptr;
 4341:     CurrentPlacementState = ECauldronPlacementState::None;
 4342: 
 4343:     // Volver a adjuntar el caldero al personaje
 4344:     if (Character)
 4345:     {
 4346:         AttachToCharacter(Character);
 4347:     }
 4348: 
 4349:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
 4350: }
 4351: 
 4352: void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
 4353: {
 4354:     // Find the position occupied by the player
 4355:     for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
 4356:     {
 4357:         if(PositionOccupied->GetOccupyingCharacter() == Character)
 4358:         {
 4359:             // Close the cauldron menu
 4360:              if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
 4361:         {
 4362: 
 4363:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 4364:             {
 4365:                 PC->LocalToggleCauldronMenu();
 4366: 
 4367:             }
 4368:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
 4369:         {
 4370: 
 4371:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 4372:             {
 4373:                 PC->Client_ToggleCauldronMenu();
 4374: 
 4375:             }
 4376:         }
 4377:             PositionOccupied->SetOccupied(nullptr);
 4378:             break;
 4379:         }
 4380:     }
 4381: 
 4382: }
 4383: 
 4384: 
 4385: 
 4386: 
 4387: void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
 4388: {
 4389:     // Reset de scale for all clients
 4390:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 4391:     SetActorEnableCollision(true);
 4392: }
 4393: 
 4394: ECauldronPlacementState ACauldronAltar::GetPlacementState() const
 4395: {
 4396:     return CurrentPlacementState;
 4397: }
 4398: 
 4399: void ACauldronAltar::ApplyPlacementPreviewMaterial()
 4400: {
 4401:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
 4402:     if (!MeshComponent)
 4403:     {
 4404:         return;
 4405:     }
 4406: 
 4407:     // Determinar qué material aplicar según el estado
 4408:     UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ?
 4409:         ValidPlacementMaterial : InvalidPlacementMaterial;
 4410: 
 4411:     // Si no tenemos un material específico, no hacemos nada
 4412:     if (!MaterialToApply)
 4413:     {
 4414:         return;
 4415:     }
 4416: 
 4417:     // Aplicar el material a todos los elementos del mesh
 4418:     for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
 4419:     {
 4420:         MeshComponent->SetMaterial(i, MaterialToApply);
 4421:     }
 4422: }
 4423: 
 4424: void ACauldronAltar::RestoreOriginalMaterials()
 4425: {
 4426:     // Restaurar los materiales originales si estamos fuera del modo de previsualización
 4427:     if (CauldronPhysicState != ECauldronPhysicState::Previewing)
 4428:     {
 4429:         UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
 4430:         if (MeshComponent && OriginalMaterials.Num() > 0)
 4431:         {
 4432:             for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
 4433:             {
 4434:                 if (OriginalMaterials[i])
 4435:                 {
 4436:                     MeshComponent->SetMaterial(i, OriginalMaterials[i]);
 4437:                 }
 4438:             }
 4439:         }
 4440:     }
 4441: }
 4442: 
 4443: bool ACauldronAltar::IsPlacementValid() const
 4444: {
 4445:     if (!GetWorld())
 4446:     {
 4447:         return false;
 4448:     }
 4449: 
 4450:     // 1. Comprobar si hay objetos en el radio de colisión
 4451:     TArray<FOverlapResult> Overlaps;
 4452:     FCollisionQueryParams QueryParams;
 4453:     QueryParams.AddIgnoredActor(this);
 4454: 
 4455:     if (CarryingCharacter)
 4456:     {
 4457:         QueryParams.AddIgnoredActor(CarryingCharacter);
 4458:     }
 4459: 
 4460:     bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
 4461:         Overlaps,
 4462:         PreviewLocation,
 4463:         FQuat::Identity,
 4464:         FCollisionObjectQueryParams::AllObjects,
 4465:         FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
 4466:         QueryParams
 4467:     );
 4468: 
 4469:     if (bHasOverlaps)
 4470:     {
 4471:         // Encontramos solapamientos, verificar si son relevantes
 4472:         for (const FOverlapResult& Overlap : Overlaps)
 4473:         {
 4474:             // Ignorar actores que no tienen colisión (podrían ser efectos visuales, etc.)
 4475:             if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
 4476:             {
 4477:                 // Si encontramos algún actor con colisión, la posición no es válida
 4478:                 return false;
 4479:             }
 4480:         }
 4481:     }
 4482: 
 4483:     // 2. Comprobar si el caldero está alineado con el suelo
 4484:     // Hacer un trazado hacia abajo para ver si hay suelo cerca
 4485:     FHitResult HitResult;
 4486:     FVector TraceStart = PreviewLocation;
 4487:     FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
 4488: 
 4489:     bool bHitGround = GetWorld()->LineTraceSingleByChannel(
 4490:         HitResult,
 4491:         TraceStart,
 4492:         TraceEnd,
 4493:         ECC_Visibility,
 4494:         QueryParams
 4495:     );
 4496: 
 4497:     if (!bHitGround)
 4498:     {
 4499:         // No encontramos suelo debajo del caldero
 4500:         return false;
 4501:     }
 4502: 
 4503:     // Comprobar la distancia al suelo
 4504:     float DistanceToGround = (HitResult.Location - TraceStart).Size();
 4505:     if (DistanceToGround > MaxGroundAlignmentHeight)
 4506:     {
 4507:         // El caldero está demasiado lejos del suelo
 4508:         return false;
 4509:     }
 4510: 
 4511:     // La posición es válida
 4512:     return true;
 4513: }
 4514: // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
 4515: void ACauldronAltar::BroadcastBaseIngredientDropped() const
 4516: {
 4517:     OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
 4518: }
 4519: 
 4520: void ACauldronAltar::BroadcastBaseIngredientIconSet() const
 4521: {
 4522:     OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
 4523: }
 4524: 
 4525: void ACauldronAltar::BroadcastPrincipalIngredientDropped() const
 4526: {
 4527:     OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
 4528: }
 4529: 
 4530: void ACauldronAltar::BroadcastPrincipalIngredientIconSet() const
 4531: {
 4532:     OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
 4533: }
 4534: 
 4535: void ACauldronAltar::BroadcastModifierIngredientDropped() const
 4536: {
 4537:     OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
 4538: }
 4539: 
 4540: void ACauldronAltar::BroadcastModifierIngredientIconSet() const
 4541: {
 4542:     OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
 4543: }
 4544: 
 4545: UWitchPTInventoryItemInstance* ACauldronAltar::GetBaseIngredient() const
 4546: {
 4547:     return BaseIngredient;
 4548: }
 4549: 
 4550: UWitchPTInventoryItemInstance* ACauldronAltar::GetPrincipalIngredient() const
 4551: {
 4552:     return PrincipalIngredient;
 4553: }
 4554: 
 4555: UWitchPTInventoryItemInstance* ACauldronAltar::GetModifierIngredient() const
 4556: {
 4557:     return ModifierIngredient;
 4558: }
 4559: </file>
 4560: 
 4561: <file path="WitchPT/Private/Item/CauldronPosition.cpp">
 4562: #include "Item/CauldronPosition.h"
 4563: #include "AbilitySystemComponent.h"
 4564: #include "GameFramework/Character.h"
 4565: #include "Item/CauldronAltar.h" // Include the Altar header
 4566: #include "Kismet/GameplayStatics.h"
 4567: 
 4568: ACauldronPosition::ACauldronPosition()
 4569: {
 4570:     // No need to set up replication here - it's handled by the base class
 4571:     bIsOccupied = false;
 4572:     OccupyingCharacter = nullptr;
 4573: }
 4574: 
 4575: void ACauldronPosition::BeginPlay()
 4576: {
 4577:     Super::BeginPlay();
 4578: 
 4579:     // // Try to find the CauldronAltar if it wasn't set in the editor
 4580:     // if (!CauldronAltar)
 4581:     // {
 4582:     //     FindCauldronAltar();
 4583:     // }
 4584: }
 4585: 
 4586: void ACauldronPosition::FindCauldronAltar()
 4587: {
 4588:     // First check if we are attached to an altar
 4589:     // AActor* ParentActor = GetAttachParentActor();
 4590:     // if (ParentActor)
 4591:     // {
 4592:     //     ACauldronAltar* PotentialAltar = Cast<ACauldronAltar>(ParentActor);
 4593:     //     if (PotentialAltar)
 4594:     //     {
 4595:     //         CauldronAltar = PotentialAltar;
 4596:     //         UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found attached CauldronAltar %s"),
 4597:     //             *GetName(), *CauldronAltar->GetName());
 4598:     //         return;
 4599:     //     }
 4600:     // }
 4601:     //
 4602:     // // If not attached, try to find any altar in the world
 4603:     // TArray<AActor*> FoundAltars;
 4604:     // UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundAltars);
 4605:     //
 4606:     // if (FoundAltars.Num() > 0)
 4607:     // {
 4608:     //     CauldronAltar = Cast<ACauldronAltar>(FoundAltars[0]);
 4609:     //     UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found world CauldronAltar %s"),
 4610:     //         *GetName(), *CauldronAltar->GetName());
 4611:     // }
 4612:     // else
 4613:     // {
 4614:     //     UE_LOG(LogTemp, Warning, TEXT("[CauldronPosition] %s couldn't find a CauldronAltar!"), *GetName());
 4615:     // }
 4616: }
 4617: 
 4618: void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 4619: {
 4620:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 4621: 
 4622:     // // Cauldron-specific interaction options
 4623:     //
 4624:     // ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
 4625:     //
 4626:     // // If no player is occupying the position, let a player take the position
 4627:     // if (!IsOccupied() && InteractingCharacterPtr)
 4628:     // {
 4629:     //     OptionBuilder.AddDefaultInteraction(
 4630:     //         FText::FromString("Take Position"), // Text for the interaction
 4631:     //         [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 4632:     //         {
 4633:     //             HandleInteraction(InteractingCharacterPtr);
 4634:     //         }
 4635:     //     );
 4636:     // }
 4637:     //
 4638:     // // Special case: if the character is standing at a position and we're in Inactive state, they can initiate brewing
 4639:     // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 4640:     // {
 4641:     //     // Check cauldron state
 4642:     //     if (CauldronAltar->GetCurrentState() == EInteractionState::Inactive)
 4643:     //     {
 4644:     //         OptionBuilder.AddDefaultInteraction(
 4645:     //             FText::FromString("Start Brewing"), // Text for the interaction
 4646:     //             [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 4647:     //             {
 4648:     //                 if (CauldronAltar)
 4649:     //                 {
 4650:     //                     // Cast to the appropriate start brewing function
 4651:     //                     CauldronAltar->StartBrewing(InteractingCharacterPtr);
 4652:     //                 }
 4653:     //             }
 4654:     //         );
 4655:     //     }
 4656:     // }
 4657:     //
 4658:     // // If this player is at a position and brewing is active, they can add ingredients
 4659:     // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 4660:     // {
 4661:     //     if (CauldronAltar->GetCurrentState() == EInteractionState::Active)
 4662:     //     {
 4663:     //         // Get the player's current expected input
 4664:     //         FGameplayTag ExpectedInput = CauldronAltar->GetCurrentExpectedInputForPlayer(InteractingCharacterPtr);
 4665:     //
 4666:     //         if (ExpectedInput.IsValid())
 4667:     //         {
 4668:     //             // Determine the ingredient name
 4669:     //             FString TagString = ExpectedInput.ToString();
 4670:     //             FString IngredientName = "Unknown Ingredient";
 4671:     //
 4672:     //             if (TagString.Contains("Ingredient1"))
 4673:     //             {
 4674:     //                 IngredientName = "Red Mushroom";
 4675:     //             }
 4676:     //             else if (TagString.Contains("Ingredient2"))
 4677:     //             {
 4678:     //                 IngredientName = "Frog Leg";
 4679:     //             }
 4680:     //             else if (TagString.Contains("Ingredient3"))
 4681:     //             {
 4682:     //                 IngredientName = "Bat Wing";
 4683:     //             }
 4684:     //             else if (TagString.Contains("Ingredient4"))
 4685:     //             {
 4686:     //                 IngredientName = "Snake Venom";
 4687:     //             }
 4688:     //             else if (TagString.Contains("Ingredient5"))
 4689:     //             {
 4690:     //                 IngredientName = "Dragon Scale";
 4691:     //             }
 4692:     //
 4693:     //             // Give the player the option to add the correct ingredient
 4694:     //             OptionBuilder.AddDefaultInteraction(
 4695:     //                 FText::FromString(FString::Printf(TEXT("Add %s"), *IngredientName)),
 4696:     //                 [this, InteractingCharacterPtr, ExpectedInput](const FInteractionExecuteContext& Context)
 4697:     //                 {
 4698:     //                     if (CauldronAltar)
 4699:     //                     {
 4700:     //                         CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, ExpectedInput);
 4701:     //                     }
 4702:     //                 }
 4703:     //             );
 4704:     //
 4705:     //             // Also add wrong ingredient options for fun/challenge
 4706:     //             for (int32 i = 1; i <= 5; ++i)
 4707:     //             {
 4708:     //                 FString WrongTagString = FString::Printf(TEXT("Input.Cauldron.Ingredient%d"), i);
 4709:     //                 FGameplayTag WrongTag = FGameplayTag::RequestGameplayTag(FName(*WrongTagString));
 4710:     //
 4711:     //                 // Skip if this is the correct ingredient
 4712:     //                 if (WrongTag == ExpectedInput)
 4713:     //                 {
 4714:     //                     continue;
 4715:     //                 }
 4716:     //
 4717:     //                 // Determine wrong ingredient name
 4718:     //                 FString WrongIngredientName = "Unknown Ingredient";
 4719:     //                 switch (i)
 4720:     //                 {
 4721:     //                 case 1: WrongIngredientName = "Red Mushroom"; break;
 4722:     //                 case 2: WrongIngredientName = "Frog Leg"; break;
 4723:     //                 case 3: WrongIngredientName = "Bat Wing"; break;
 4724:     //                 case 4: WrongIngredientName = "Snake Venom"; break;
 4725:     //                 case 5: WrongIngredientName = "Dragon Scale"; break;
 4726:     //                 }
 4727:     //
 4728:     //                 OptionBuilder.AddDefaultInteraction(
 4729:     //                     FText::FromString(FString::Printf(TEXT("Add %s"), *WrongIngredientName)),
 4730:     //                     [this, InteractingCharacterPtr, WrongTag](const FInteractionExecuteContext& Context)
 4731:     //                     {
 4732:     //                         if (CauldronAltar)
 4733:     //                         {
 4734:     //                             CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, WrongTag);
 4735:     //                         }
 4736:     //                     }
 4737:     //                 );
 4738:     //             }
 4739:     //         }
 4740:     //     }
 4741:     // }
 4742: }
 4743: 
 4744: void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
 4745: {
 4746:     Super::HandleInteraction(InteractingCharacter);
 4747: 
 4748:     if (!InteractingCharacter || !CauldronAltar)
 4749:     {
 4750:         return;
 4751:     }
 4752: 
 4753:     // Call the cauldron altar to handle occupation
 4754:     // CauldronAltar->OccupyPosition(InteractingCharacter, this);
 4755: }
 4756: 
 4757: // bool ACauldronPosition::PositionCharacter(ACharacter* Character)
 4758: // {
 4759: //     if (!Character)
 4760: //     {
 4761: //         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Invalid character"));
 4762: //         return false;
 4763: //     }
 4764: //
 4765: //     // No permitir posicionar si ya está ocupado
 4766: //     if (bIsOccupied && OccupyingCharacter != Character)
 4767: //     {
 4768: //         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Position already occupied"));
 4769: //         return false;
 4770: //     }
 4771: //
 4772: //     // Teleportar al personaje a la ubicación de este actor
 4773: //     FVector TargetLocation = GetActorLocation();
 4774: //     FRotator TargetRotation = GetActorRotation();
 4775: //
 4776: //     bool bSuccess = Character->SetActorLocationAndRotation(
 4777: //         TargetLocation,
 4778: //         TargetRotation,
 4779: //         false,
 4780: //         nullptr,
 4781: //         ETeleportType::TeleportPhysics);
 4782: //
 4783: //     if (bSuccess)
 4784: //     {
 4785: //         // Marcar esta posición como ocupada
 4786: //         SetOccupied(true, Character);
 4787: //
 4788: //         UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::PositionCharacter: Character positioned at %s"),
 4789: //                *GetName());
 4790: //     }
 4791: //
 4792: //     return bSuccess;
 4793: // }
 4794: //
 4795: // bool ACauldronPosition::IsOccupied() const
 4796: // {
 4797: //     return bIsOccupied && OccupyingCharacter != nullptr;
 4798: // }
 4799: //
 4800: // void ACauldronPosition::SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter)
 4801: // {
 4802: //     bIsOccupied = bInOccupied;
 4803: //
 4804: //     if (bInOccupied)
 4805: //     {
 4806: //         OccupyingCharacter = InOccupyingCharacter;
 4807: //     }
 4808: //     else
 4809: //     {
 4810: //         OccupyingCharacter = nullptr;
 4811: //     }
 4812: //
 4813: //     UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::SetOccupied: %s is now %s"),
 4814: //            *GetName(), bIsOccupied ? TEXT("occupied") : TEXT("unoccupied"));
 4815: // }
 4816: </file>
 4817: 
 4818: <file path="WitchPT/Private/Item/Ingredient/IngredientBase.cpp">
 4819: // Fill out your copyright notice in the Description page of Project Settings.
 4820: 
 4821: 
 4822: #include "Item/Ingredient/IngredientBase.h"
 4823: 
 4824: 
 4825: // Sets default values
 4826: AIngredientBase::AIngredientBase()
 4827: {
 4828: 
 4829: }
 4830: 
 4831: void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
 4832: 	FInteractionOptionBuilder& OptionBuilder)
 4833: {
 4834: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 4835: }
 4836: 
 4837: FItemManifest AIngredientBase::GetPickupInventory() const
 4838: {
 4839: 	return StaticInventory;
 4840: }
 4841: </file>
 4842: 
 4843: <file path="WitchPT/Private/Item/Item.cpp">
 4844: // Fill out your copyright notice in the Description page of Project Settings.
 4845: 
 4846: 
 4847: #include "Item/Item.h"
 4848: 
 4849: 
 4850: // Sets default values
 4851: AItem::AItem()
 4852: {
 4853: 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 4854: 	PrimaryActorTick.bCanEverTick = true;
 4855: }
 4856: 
 4857: // Called when the game starts or when spawned
 4858: void AItem::BeginPlay()
 4859: {
 4860: 	Super::BeginPlay();
 4861: 
 4862: }
 4863: 
 4864: // Called every frame
 4865: void AItem::Tick(float DeltaTime)
 4866: {
 4867: 	Super::Tick(DeltaTime);
 4868: }
 4869: 
 4870: void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 4871: {
 4872: 	OptionBuilder.AddInteractionOption(Option);
 4873: }
 4874: </file>
 4875: 
 4876: <file path="WitchPT/Private/Item/MechanicsInterface.cpp">
 4877: // Fill out your copyright notice in the Description page of Project Settings.
 4878: 
 4879: 
 4880: #include "Item/MechanicsInterface.h"
 4881: 
 4882: // Add default functionality here for any IMechanicsInterface functions that are not pure virtual.
 4883: </file>
 4884: 
 4885: <file path="WitchPT/Private/Item/PositionInterface.cpp">
 4886: // Fill out your copyright notice in the Description page of Project Settings.
 4887: 
 4888: 
 4889: #include "Item/PositionInterface.h"
 4890: 
 4891: // Add default functionality here for any IPositionInterface functions that are not pure virtual.
 4892: </file>
 4893: 
 4894: <file path="WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp">
 4895: // Fill out your copyright notice in the Description page of Project Settings.
 4896: 
 4897: 
 4898: #include "Item/Ritual/RitualFunctionLibrary.h"
 4899: 
 4900: #include "Kismet/GameplayStatics.h"
 4901: #include "Player/WitchPTPlayerState.h"
 4902: #include "UI/HUD/WitchPTHUD.h"
 4903: #include "UI/WidgetControllers/CauldronWidgetController.h"
 4904: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 4905: 
 4906: URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
 4907: {
 4908: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
 4909: 	{
 4910: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
 4911: 		{
 4912: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
 4913: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
 4914: 			UAttributeSet* AS = PS->GetAttributeSet();
 4915: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
 4916: 
 4917: 			return WitchPTHUD->SetRitualWidgetController(WCParams);
 4918: 		}
 4919: 	}
 4920: 	return nullptr;
 4921: }
 4922: 
 4923: UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
 4924: {
 4925: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
 4926: 	{
 4927: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
 4928: 		{
 4929: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
 4930: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
 4931: 			UAttributeSet* AS = PS->GetAttributeSet();
 4932: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
 4933: 			return WitchPTHUD->SetCauldronWidgetController(WCParams);
 4934: 		}
 4935: 	}
 4936: 	return nullptr;
 4937: }
 4938: </file>
 4939: 
 4940: <file path="WitchPT/Private/Item/RitualAltar.cpp">
 4941: // Fill out your copyright notice in the Description page of Project Settings.
 4942: 
 4943: #include "Item/RitualAltar.h"
 4944: #include "Net/UnrealNetwork.h"
 4945: #include "Item/RitualPosition.h"
 4946: #include "GameFramework/Character.h"
 4947: #include "AbilitySystemComponent.h"
 4948: #include "AbilitySystemBlueprintLibrary.h"
 4949: #include "FWitchPTGameplayTags.h"
 4950: #include "Player/WitchPTPlayerController.h"
 4951: 
 4952: // Sets default values
 4953: ARitualAltar::ARitualAltar()
 4954: {
 4955: 	// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
 4956: 	PrimaryActorTick.bCanEverTick = true;
 4957: 
 4958: 	bReplicates = true;
 4959: 
 4960: 	// Default values
 4961: 	CurrentRitualState = EInteractionState::Inactive;
 4962: 	CurrentSequenceIndex = -1;
 4963: 	CurrentInputTimer = 0.0f;
 4964: 	CorruptionAmount = 0.0f;
 4965: 	MaxCorruption = 100.0f;
 4966: 	StartCountdown = 3;
 4967: 	bRitualCompleted = false;
 4968: 	bRitualWasSuccessful = false;
 4969: }
 4970: 
 4971: void ARitualAltar::BeginPlay()
 4972: {
 4973: 	Super::BeginPlay();
 4974: 
 4975: 	// // Auto-discover RitualPositions if not set in editor
 4976: 	// if (RitualPositions.Num() == 0 && HasAuthority())
 4977: 	// {
 4978: 	// 	TArray<AActor*> FoundActors;
 4979: 	// 	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ARitualPosition::StaticClass(), FoundActors);
 4980: 	//
 4981: 	// 	for (AActor* Actor : FoundActors)
 4982: 	// 	{
 4983: 	// 		ARitualPosition* Position = Cast<ARitualPosition>(Actor);
 4984: 	// 		if (Position)
 4985: 	// 		{
 4986: 	// 			RitualPositions.Add(Position);
 4987: 	// 			Position->SetRitualAltar(this);
 4988: 	// 		}
 4989: 	// 	}
 4990: 	// }
 4991: }
 4992: 
 4993: void ARitualAltar::Tick(float DeltaTime)
 4994: {
 4995: 	Super::Tick(DeltaTime);
 4996: }
 4997: 
 4998: void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 4999: {
 5000: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 5001: 
 5002: 	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
 5003: 	DOREPLIFETIME(ARitualAltar, InputSequence);
 5004: 	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
 5005: 	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
 5006: 	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
 5007: 	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
 5008: 	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
 5009: 	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
 5010: 	DOREPLIFETIME(ARitualAltar, MaxCorruption);
 5011: 	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
 5012: 	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
 5013: 	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
 5014: 	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
 5015: 	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
 5016: 	DOREPLIFETIME(ARitualAltar, StartCountdown);
 5017: 	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
 5018: 	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
 5019: }
 5020: 
 5021: // ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
 5022: 
 5023: void ARitualAltar::OnRep_CurrentRitualState()
 5024: {
 5025: 	BroadcastRitualStateChanged();
 5026: }
 5027: 
 5028: void ARitualAltar::OnRep_CurrentSequenceIndex()
 5029: {
 5030: 	// Just broadcast sequence progress change - turn data updates are handled by OnRep_TurnData
 5031: 	BroadcastSequenceProgressChanged();
 5032: }
 5033: 
 5034: void ARitualAltar::OnRep_ReadyPlayersData()
 5035: {
 5036: 	BroadcastReadyPlayersChanged();
 5037: }
 5038: 
 5039: void ARitualAltar::OnRep_StartCountdown()
 5040: {
 5041: 	BroadcastCountdownTick();
 5042: }
 5043: 
 5044: void ARitualAltar::OnRep_CurrentActivePlayer()
 5045: {
 5046: 	// Turn data updates are handled by OnRep_TurnData
 5047: 	// This OnRep function is kept for potential future use
 5048: }
 5049: 
 5050: void ARitualAltar::OnRep_TurnData()
 5051: {
 5052: 	BroadcastTurnDataChanged();
 5053: }
 5054: 
 5055: void ARitualAltar::OnRep_CorruptionAmount()
 5056: {
 5057: 	BroadcastCorruptionChanged();
 5058: }
 5059: 
 5060: void ARitualAltar::OnRep_RitualCompleted()
 5061: {
 5062: 	if (bRitualCompleted)
 5063: 	{
 5064: 		BroadcastRitualCompleted();
 5065: 	}
 5066: }
 5067: 
 5068: // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
 5069: 
 5070: void ARitualAltar::BroadcastRitualStateChanged()
 5071: {
 5072: 	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
 5073: }
 5074: 
 5075: void ARitualAltar::BroadcastReadyPlayersChanged()
 5076: {
 5077: 	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
 5078: }
 5079: 
 5080: void ARitualAltar::BroadcastCountdownTick()
 5081: {
 5082: 	OnCountdownTickEvent.Broadcast(StartCountdown);
 5083: }
 5084: 
 5085: void ARitualAltar::BroadcastTurnDataChanged()
 5086: {
 5087: 	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
 5088: }
 5089: 
 5090: void ARitualAltar::BroadcastCorruptionChanged()
 5091: {
 5092: 	float CorruptionPercentage = GetCorruptionPercentage();
 5093: 	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
 5094: }
 5095: 
 5096: void ARitualAltar::BroadcastSequenceProgressChanged()
 5097: {
 5098: 	float Progress = GetCurrentSequenceProgress();
 5099: 	OnSequenceProgressChangedEvent.Broadcast(Progress);
 5100: }
 5101: 
 5102: void ARitualAltar::BroadcastRitualCompleted()
 5103: {
 5104: 	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
 5105: }
 5106: 
 5107: // ----------------------------------- HELPER FUNCTIONS ---------------------------------------------- //
 5108: 
 5109: void ARitualAltar::UpdateTurnData()
 5110: {
 5111: 	// This function can be called on both server and clients
 5112: 	// On server: updates the replicated CurrentTurnData
 5113: 	// On clients: called from OnRep functions to update local UI data
 5114: 
 5115: 	FUIRitualData NewTurnData;
 5116: 	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
 5117: 	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
 5118: 	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
 5119: 
 5120: 	// Set expected input if we have valid data
 5121: 	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
 5122: 	{
 5123: 		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
 5124: 	}
 5125: 	else
 5126: 	{
 5127: 		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
 5128: 	}
 5129: 
 5130: 	// Always set bIsMyTurn to false here - the widget controller will determine the correct value
 5131: 	NewTurnData.bIsMyTurn = false;
 5132: 
 5133: 	// On server, update the replicated data if it has changed
 5134: 	if (HasAuthority())
 5135: 	{
 5136: 		// Only update if data has changed to avoid unnecessary replication
 5137: 		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
 5138: 			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
 5139: 			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
 5140: 			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
 5141: 			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
 5142: 		{
 5143: 			CurrentTurnData = NewTurnData;
 5144: 			// Broadcast on server for local UI updates (OnRep will handle clients)
 5145: 			BroadcastTurnDataChanged();
 5146: 		}
 5147: 	}
 5148: 	else
 5149: 	{
 5150: 		// On clients, just update the local data and broadcast
 5151: 		CurrentTurnData = NewTurnData;
 5152: 		BroadcastTurnDataChanged();
 5153: 	}
 5154: }
 5155: 
 5156: void ARitualAltar::UpdateReadyPlayersData()
 5157: {
 5158: 	if (!HasAuthority())
 5159: 	{
 5160: 		return;
 5161: 	}
 5162: 
 5163: 	FRitualReadyPlayersData NewData;
 5164: 	NewData.TotalPlayers = ParticipatingPlayers.Num();
 5165: 	NewData.ReadyPlayers = ReadyPlayers.Num();
 5166: 
 5167: 	if (ReadyPlayersData != NewData)
 5168: 	{
 5169: 		ReadyPlayersData = NewData;
 5170: 		// Broadcast on server for local UI updates (OnRep will handle clients)
 5171: 		BroadcastReadyPlayersChanged();
 5172: 	}
 5173: }
 5174: 
 5175: // ----------------------------------- EXISTING FUNCTIONS (UPDATED) ---------------------------------------------- //
 5176: 
 5177: void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
 5178: {
 5179: 	// This is now handled by OnRep_ReadyPlayersData, but keeping for backward compatibility
 5180: 	UpdateReadyPlayersData();
 5181: }
 5182: 
 5183: void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
 5184: {
 5185: 	if (!HasAuthority() || !RequestingCharacter)
 5186: 	{
 5187: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
 5188: 		return;
 5189: 	}
 5190: 
 5191: 	// Check if the ritual is in a valid state
 5192: 	if (CurrentRitualState != EInteractionState::Inactive &&
 5193: 	    CurrentRitualState != EInteractionState::WaitingForPlayers)
 5194: 	{
 5195: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
 5196: 		return;
 5197: 	}
 5198: 
 5199: 	// Process the ready request
 5200: 	ProcessRitualReadyRequest(RequestingCharacter);
 5201: }
 5202: 
 5203: void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
 5204: {
 5205: 	if (!HasAuthority() || !RequestingCharacter)
 5206: 	{
 5207: 		return;
 5208: 	}
 5209: 
 5210: 	// Check if player is already in the ready list
 5211: 	if (ReadyPlayers.Contains(RequestingCharacter))
 5212: 	{
 5213: 		// Player is already ready, could allow them to un-ready if desired
 5214: 		ReadyPlayers.Remove(RequestingCharacter);
 5215: 		UpdateReadyPlayersData();
 5216: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
 5217: 		return;
 5218: 	}
 5219: 
 5220: 	// Add player to ready list
 5221: 	ReadyPlayers.Add(RequestingCharacter);
 5222: 	UpdateReadyPlayersData();
 5223: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
 5224: 
 5225: 	// Check if all players are ready
 5226: 	if (AreAllPlayersReady())
 5227: 	{
 5228: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
 5229: 		StartRitualCountdown();
 5230: 	}
 5231: }
 5232: 
 5233: bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
 5234: {
 5235: 	return ReadyPlayers.Contains(Player);
 5236: }
 5237: 
 5238: bool ARitualAltar::AreAllPlayersReady() const
 5239: {
 5240: 	// Check if all participating players are in the ready list
 5241: 	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
 5242: 	{
 5243: 		return false;
 5244: 	}
 5245: 
 5246: 	for (ACharacter* Player : ParticipatingPlayers)
 5247: 	{
 5248: 		if (!ReadyPlayers.Contains(Player))
 5249: 		{
 5250: 			return false;
 5251: 		}
 5252: 	}
 5253: 
 5254: 	return true;
 5255: }
 5256: 
 5257: void ARitualAltar::StartRitualCountdown()
 5258: {
 5259: 	if (!HasAuthority())
 5260: 	{
 5261: 		return;
 5262: 	}
 5263: 
 5264: 	// Set the state to preparing
 5265: 	CurrentRitualState = EInteractionState::Preparing;
 5266: 	// Broadcast on server for local UI updates (OnRep will handle clients)
 5267: 	BroadcastRitualStateChanged();
 5268: 
 5269: 	// Generate the ritual input sequence
 5270: 	GenerateInputSequence();
 5271: 
 5272: 	// Reset countdown value
 5273: 	StartCountdown = 3;
 5274: 	// Broadcast on server for local UI updates (OnRep will handle clients)
 5275: 	BroadcastCountdownTick();
 5276: 
 5277: 	// Start countdown timer
 5278: 	GetWorldTimerManager().SetTimer(
 5279: 		RitualStartCountdownHandle,
 5280: 		this,
 5281: 		&ARitualAltar::ProcessCountdownTick,
 5282: 		1.0f,  // Fire every second
 5283: 		true   // Looping
 5284: 	);
 5285: }
 5286: 
 5287: void ARitualAltar::ProcessCountdownTick()
 5288: {
 5289: 	if (!HasAuthority())
 5290: 	{
 5291: 		return;
 5292: 	}
 5293: 
 5294: 	// Decrease countdown
 5295: 	StartCountdown--;
 5296: 	// Broadcast on server for local UI updates (OnRep will handle clients)
 5297: 	BroadcastCountdownTick();
 5298: 
 5299: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
 5300: 
 5301: 	if (StartCountdown <= 0)
 5302: 	{
 5303: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 5304: 		ActivateRitual();
 5305: 	}
 5306: }
 5307: 
 5308: void ARitualAltar::ActivateRitual()
 5309: {
 5310: 	if (!HasAuthority())
 5311: 	{
 5312: 		return;
 5313: 	}
 5314: 
 5315: 	// Set initial active player (from ready list)
 5316: 	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
 5317: 
 5318: 	// Fallback
 5319: 	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
 5320: 	CurrentSequenceIndex = 0;
 5321: 	CurrentRitualState = EInteractionState::Active;
 5322: 
 5323: 	// Start the input timer (this updates CurrentInputTimer)
 5324: 	StartInputTimer();
 5325: 
 5326: 	// Now update turn data with all the new values
 5327: 	UpdateTurnData();
 5328: 
 5329: 	// Broadcast state change on server for local UI updates (OnRep will handle clients)
 5330: 	BroadcastRitualStateChanged();
 5331: }
 5332: 
 5333: void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
 5334: {
 5335: 	// This is now handled by OnRep_StartCountdown, but keeping for backward compatibility
 5336: 	StartCountdown = CountdownValue;
 5337: }
 5338: 
 5339: void ARitualAltar::GenerateInputSequence()
 5340: {
 5341: 	if (!HasAuthority())
 5342: 	{
 5343: 		return;
 5344: 	}
 5345: 
 5346: 	InputSequence.Empty();
 5347: 
 5348: 	// Number of inputs scales with the number of players and difficulty
 5349: 	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
 5350: 
 5351: 	// Get gameplay tags from the native tag manager
 5352: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5353: 
 5354: 	TArray<FGameplayTag> PossibleInputs;
 5355: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
 5356: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
 5357: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
 5358: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
 5359: 
 5360: 	// Generate random sequence
 5361: 	for (int32 i = 0; i < SequenceLength; ++i)
 5362: 	{
 5363: 		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
 5364: 		InputSequence.Add(PossibleInputs[RandomIndex]);
 5365: 	}
 5366: 
 5367: 	// Reset sequence index
 5368: 
 5369: 
 5370: }
 5371: 
 5372: void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
 5373: {
 5374: 	if (!Character || !HasAuthority())
 5375: 	{
 5376: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
 5377: 		return;
 5378: 	}
 5379: 
 5380: 	// Check if the ritual is active
 5381: 	if (CurrentRitualState != EInteractionState::Active)
 5382: 	{
 5383: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"),
 5384: 			*Character->GetName(), static_cast<int32>(CurrentRitualState));
 5385: 		return;
 5386: 	}
 5387: 
 5388: 	// Check if it's this player's turn
 5389: 	if (Character != CurrentActivePlayer)
 5390: 	{
 5391: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"),
 5392: 			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
 5393: 		return;
 5394: 	}
 5395: 
 5396: 	// Check if we have a valid input to match against
 5397: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 5398: 	{
 5399: 		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"),
 5400: 			CurrentSequenceIndex, InputSequence.Num());
 5401: 		return;
 5402: 	}
 5403: 
 5404: 	// Get the expected input for the current step
 5405: 	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
 5406: 
 5407: 
 5408: 	// Check if the input matches
 5409: 	if (InputTag == ExpectedInput)
 5410: 	{
 5411: 		HandleInputSuccess(Character);
 5412: 	}
 5413: 	else
 5414: 	{
 5415: 		HandleInputFailure(Character);
 5416: 	}
 5417: }
 5418: 
 5419: void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 5420: {
 5421: 
 5422: 	if (Character)
 5423: 	{
 5424: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 5425: 		if (ASC)
 5426: 		{
 5427: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5428: 			FGameplayEventData EventData;
 5429: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 5430: 			EventData.Instigator = this;
 5431: 			EventData.Target = Character;
 5432: 
 5433: 			// Buscar el tag de posición del jugador en el array
 5434: 			FGameplayTag* PositionTag = nullptr;
 5435: 			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 5436: 			{
 5437: 				if (Entry.Player == Character)
 5438: 				{
 5439: 					PositionTag = &Entry.PositionTag;
 5440: 					break;
 5441: 				}
 5442: 			}
 5443: 			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
 5444: 			{
 5445: 				EventData.OptionalObject = PrimaryAnimMontage;
 5446: 			} else
 5447: 			{
 5448: 				EventData.OptionalObject = SecondaryAnimMontage;
 5449: 			}
 5450: 
 5451: 
 5452: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
 5453: 		}
 5454: 
 5455: 
 5456: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 5457: 	}
 5458: }
 5459: 
 5460: void ARitualAltar::HandleInputSuccess(ACharacter* Player)
 5461: {
 5462: 	if (!HasAuthority() || !Player)
 5463: 	{
 5464: 		return;
 5465: 	}
 5466: 
 5467: 	// Cancel the input timer
 5468: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 5469: 
 5470: 	// Advance to the next input
 5471: 	CurrentSequenceIndex++;
 5472: 
 5473: 	// Send success feedback
 5474: 	Multicast_OnInputSuccess(Player);
 5475: 
 5476: 	// Check if the sequence is complete
 5477: 	if (CurrentSequenceIndex >= InputSequence.Num())
 5478: 	{
 5479: 		// Ritual succeeded
 5480: 		CurrentRitualState = EInteractionState::Succeeded;
 5481: 		bRitualCompleted = true;
 5482: 		bRitualWasSuccessful = true;
 5483: 
 5484: 		// Update turn data with final state
 5485: 		UpdateTurnData();
 5486: 
 5487: 		// Broadcast state and completion on server for local UI updates
 5488: 		BroadcastRitualStateChanged();
 5489: 		BroadcastRitualCompleted();
 5490: 
 5491: 		// Spawn reward and notify
 5492: 		SpawnReward();
 5493: 		Multicast_OnRitualSucceeded();
 5494: 
 5495: 		// Clean up
 5496: 		CleanupRitual();
 5497: 	}
 5498: 	else
 5499: 	{
 5500: 		// Move to the next player's turn (this updates CurrentActivePlayer)
 5501: 		AdvanceToNextPlayer();
 5502: 
 5503: 		// Start the input timer (this updates CurrentInputTimer)
 5504: 		StartInputTimer();
 5505: 
 5506: 		// Now update turn data with all the new values
 5507: 		UpdateTurnData();
 5508: 	}
 5509: }
 5510: 
 5511: void ARitualAltar::HandleInputFailure(ACharacter* Player)
 5512: {
 5513: 	if (!HasAuthority() || !Player)
 5514: 	{
 5515: 		return;
 5516: 	}
 5517: 
 5518: 	// Cancel the input timer
 5519: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 5520: 
 5521: 	// Increase corruption
 5522: 	CorruptionAmount += CorruptionIncreasePerFail;
 5523: 	// Broadcast corruption change on server for local UI updates
 5524: 	BroadcastCorruptionChanged();
 5525: 
 5526: 	// DO NOT advance to the next input on failure - only on success
 5527: 	// CurrentSequenceIndex++; // REMOVED: Failed inputs should not advance the sequence
 5528: 
 5529: 	// Apply age penalty to the player
 5530: 	ApplyAgePenalty(Player);
 5531: 
 5532: 	// Send failure feedback
 5533: 	Multicast_OnInputFailed(Player);
 5534: 
 5535: 	// Check if corruption has reached the maximum
 5536: 	if (CorruptionAmount >= MaxCorruption)
 5537: 	{
 5538: 		// Ritual failed catastrophically
 5539: 		CurrentRitualState = EInteractionState::FailedCatastrophically;
 5540: 		bRitualCompleted = true;
 5541: 		bRitualWasSuccessful = false;
 5542: 
 5543: 		// Update turn data with final state
 5544: 		UpdateTurnData();
 5545: 
 5546: 		// Broadcast state and completion on server for local UI updates
 5547: 		BroadcastRitualStateChanged();
 5548: 		BroadcastRitualCompleted();
 5549: 
 5550: 		// Apply catastrophic penalties to all players
 5551: 		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
 5552: 		{
 5553: 			if (ParticipatingPlayer)
 5554: 			{
 5555: 				ApplyAgePenalty(ParticipatingPlayer, true);
 5556: 			}
 5557: 		}
 5558: 
 5559: 		// Spawn demon and notify
 5560: 		SpawnDemon();
 5561: 		Multicast_OnRitualCatastrophicFail();
 5562: 
 5563: 		// Clean up
 5564: 		CleanupRitual();
 5565: 	}
 5566: 	else
 5567: 	{
 5568: 		// Move to the next player's turn (this updates CurrentActivePlayer)
 5569: 		AdvanceToNextPlayer();
 5570: 
 5571: 		// Start the input timer (this updates CurrentInputTimer)
 5572: 		StartInputTimer();
 5573: 
 5574: 		// Now update turn data with all the new values
 5575: 		UpdateTurnData();
 5576: 	}
 5577: }
 5578: 
 5579: void ARitualAltar::StartInputTimer()
 5580: {
 5581: 	if (!HasAuthority())
 5582: 	{
 5583: 		return;
 5584: 	}
 5585: 
 5586: 	// Calculate the time window for this input, possibly scaling down as the sequence progresses
 5587: 	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
 5588: 	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f)); // Up to 50% shorter at the end
 5589: 
 5590: 	// Set the timer value for client display
 5591: 	CurrentInputTimer = ScaledTimeWindow;
 5592: 
 5593: 
 5594: 	// Start the timer
 5595: 	GetWorldTimerManager().SetTimer(
 5596: 		InputTimerHandle,
 5597: 		this,
 5598: 		&ARitualAltar::OnInputTimerExpired,
 5599: 		ScaledTimeWindow,
 5600: 		false
 5601: 	);
 5602: 
 5603: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"),
 5604: 		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"),
 5605: 		CurrentSequenceIndex, InputSequence.Num()-1);
 5606: 
 5607: 	// Log the expected input
 5608: 	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
 5609: 	{
 5610: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"),
 5611: 			*InputSequence[CurrentSequenceIndex].ToString());
 5612: 	}
 5613: }
 5614: 
 5615: void ARitualAltar::OnInputTimerExpired()
 5616: {
 5617: 	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
 5618: 	{
 5619: 		return;
 5620: 	}
 5621: 
 5622: 	// If we get here, the player failed to input in time
 5623: 	if (CurrentActivePlayer)
 5624: 	{
 5625: 		HandleInputFailure(CurrentActivePlayer);
 5626: 	}
 5627: 	else
 5628: 	{
 5629: 		// Fallback in case CurrentActivePlayer is null
 5630: 		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
 5631: 		AdvanceToNextPlayer();
 5632: 		StartInputTimer();
 5633: 	}
 5634: }
 5635: 
 5636: void ARitualAltar::AdvanceToNextPlayer()
 5637: {
 5638: 	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
 5639: 	{
 5640: 		return;
 5641: 	}
 5642: 
 5643: 
 5644: 	// Find the index of the current active player
 5645: 	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
 5646: 
 5647: 	// If not found or at the end, wrap around to the first player
 5648: 	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
 5649: 	{
 5650: 		CurrentPlayerIndex = 0;
 5651: 	}
 5652: 	else
 5653: 	{
 5654: 		CurrentPlayerIndex++;
 5655: 	}
 5656: 
 5657: 	// Safety check for eligible players
 5658: 	int32 StartIndex = CurrentPlayerIndex;
 5659: 	bool bFoundEligiblePlayer = false;
 5660: 
 5661: 	// Loop through players starting from CurrentPlayerIndex until we find an eligible one
 5662: 	do
 5663: 	{
 5664: 		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
 5665: 		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
 5666: 		{
 5667: 			CurrentActivePlayer = NextPlayer;
 5668: 			bFoundEligiblePlayer = true;
 5669: 			break;
 5670: 		}
 5671: 
 5672: 		// Move to next player
 5673: 		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
 5674: 	}
 5675: 	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
 5676: 
 5677: 	// If we couldn't find an eligible player, just use the first one as fallback
 5678: 	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
 5679: 	{
 5680: 		CurrentActivePlayer = ParticipatingPlayers[0];
 5681: 	}
 5682: }
 5683: 
 5684: bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
 5685: {
 5686: 	if (!Player)
 5687: 	{
 5688: 		return false;
 5689: 	}
 5690: 
 5691: 	// Check if the player is still in a ritual position
 5692: 	bool bIsInPosition = false;
 5693: 	for (const ABaseInteractionPosition* Position : InteractionPositions)
 5694: 	{
 5695: 		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
 5696: 		{
 5697: 			bIsInPosition = true;
 5698: 			break;
 5699: 		}
 5700: 	}
 5701: 
 5702: 	// Check if the player has the OccupyingPosition tag
 5703: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5704: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 5705: 	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
 5706: 
 5707: 	return bIsInPosition && bHasPositionTag;
 5708: }
 5709: 
 5710: 
 5711: void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
 5712: {
 5713: 	if (!HasAuthority() || !Player)
 5714: 	{
 5715: 		return;
 5716: 	}
 5717: 
 5718: 	// Get the player's ASC
 5719: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 5720: 	if (!ASC)
 5721: 	{
 5722: 		return;
 5723: 	}
 5724: 
 5725: 	// TODO: Apply aging GameplayEffect
 5726: 	// This would typically be implemented using a GameplayEffect that increases age
 5727: 	// The effect class would be defined elsewhere and referenced here
 5728: 
 5729: 	// Pseudo-code:
 5730: 	// TSubclassOf<UGameplayEffect> AgeEffect = bCatastrophic ? CatastrophicAgeEffectClass : StandardAgeEffectClass;
 5731: 	// if (AgeEffect)
 5732: 	// {
 5733: 	//     FGameplayEffectContextHandle ContextHandle = ASC->MakeEffectContext();
 5734: 	//     ContextHandle.AddSourceObject(this);
 5735: 	//     FGameplayEffectSpecHandle SpecHandle = ASC->MakeOutgoingSpec(AgeEffect, 1.0f, ContextHandle);
 5736: 	//     ASC->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
 5737: 	// }
 5738: 
 5739: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"),
 5740: 		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
 5741: }
 5742: 
 5743: void ARitualAltar::SpawnReward()
 5744: {
 5745: 	if (!HasAuthority())
 5746: 	{
 5747: 		return;
 5748: 	}
 5749: 
 5750: 	// TODO: Implement reward spawning logic
 5751: 	// This would typically create a special item and add it to inventory
 5752: 
 5753: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
 5754: }
 5755: 
 5756: void ARitualAltar::SpawnDemon()
 5757: {
 5758: 	if (!HasAuthority())
 5759: 	{
 5760: 		return;
 5761: 	}
 5762: 
 5763: 	// TODO: Implement demon spawning logic
 5764: 	// This would typically spawn an enemy character
 5765: 
 5766: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
 5767: }
 5768: 
 5769: void ARitualAltar::CleanupRitual()
 5770: {
 5771: 	if (!HasAuthority())
 5772: 	{
 5773: 		return;
 5774: 	}
 5775: 
 5776: 	// Clear timers
 5777: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 5778: 
 5779: 	// Reset ritual-specific variables
 5780: 	CurrentSequenceIndex = 0;
 5781: 	InputSequence.Empty();
 5782: 	CurrentActivePlayer = nullptr;
 5783: 
 5784: 	// Don't reset corruption or state - these should persist for UI feedback
 5785: 
 5786: 	// Reset positions? This depends on design - maybe players stay in position
 5787: 
 5788: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up"));
 5789: }
 5790: 
 5791: float ARitualAltar::GetCurrentSequenceProgress() const
 5792: {
 5793: 	if (InputSequence.Num() == 0)
 5794: 	{
 5795: 		return 0.0f;
 5796: 	}
 5797: 
 5798: 	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
 5799: }
 5800: 
 5801: FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
 5802: {
 5803: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 5804: 	{
 5805: 
 5806: 		return FGameplayTag();
 5807: 	}
 5808: 
 5809: 	return InputSequence[CurrentSequenceIndex];
 5810: }
 5811: 
 5812: 
 5813: 
 5814: FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
 5815: {
 5816: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5817: 
 5818: 	switch (Input)
 5819: 	{
 5820: 	case ERitualInput::Up:
 5821: 		return WitchPtGameplayTags.Ritual_Input_Up;
 5822: 	case ERitualInput::Down:
 5823: 		return WitchPtGameplayTags.Ritual_Input_Down;
 5824: 	case ERitualInput::Left:
 5825: 		return WitchPtGameplayTags.Ritual_Input_Left;
 5826: 	case ERitualInput::Right:
 5827: 		return WitchPtGameplayTags.Ritual_Input_Right;
 5828: 	default:
 5829: 		return FGameplayTag();
 5830: 	}
 5831: }
 5832: 
 5833: ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
 5834: {
 5835: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5836: 
 5837: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
 5838: 		return ERitualInput::Up;
 5839: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
 5840: 		return ERitualInput::Down;
 5841: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
 5842: 		return ERitualInput::Left;
 5843: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
 5844: 		return ERitualInput::Right;
 5845: 
 5846: 	return ERitualInput::None;
 5847: }
 5848: 
 5849: void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 5850: {
 5851: 	if (Character)
 5852: 	{
 5853: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 5854: 		if (ASC)
 5855: 		{
 5856: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 5857: 			FGameplayEventData EventData;
 5858: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 5859: 			EventData.Instigator = this;
 5860: 			EventData.Target = Character;
 5861: 
 5862: 			EventData.OptionalObject = FailedAnimMontage;
 5863: 
 5864: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
 5865: 
 5866: 		}
 5867: 
 5868: 
 5869: 
 5870: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 5871: 	}
 5872: 
 5873: 
 5874: }
 5875: 
 5876: 
 5877: 
 5878: void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 5879: {
 5880: 	// Print the local role por the RitualAltar and the Player
 5881: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
 5882: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
 5883: 	if (Player->IsLocallyControlled())
 5884: 	{
 5885: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
 5886: 	}
 5887: 	else
 5888: 	{
 5889: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
 5890: 	}
 5891: 
 5892: 	if (!Player || !Position || !HasAuthority())
 5893: 	{
 5894: 		return;
 5895: 	}
 5896: 
 5897: 
 5898: 	if (Position->IsOccupied())
 5899: 	{
 5900: 		//broadcast
 5901: 		return;
 5902: 	}
 5903: 	Position->SetOccupied(Player);
 5904: 
 5905: 	bool bFound = false;
 5906: 	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 5907: 	{
 5908: 		if (Entry.Player == Player)
 5909: 		{
 5910: 			Entry.PositionTag = Position->GetPositionTag();
 5911: 			bFound = true;
 5912: 			break;
 5913: 		}
 5914: 	}
 5915: 	if (!bFound)
 5916: 	{
 5917: 		FPlayerPositionTagEntry NewEntry;
 5918: 		NewEntry.Player = Player;
 5919: 		NewEntry.PositionTag = Position->GetPositionTag();
 5920: 		PlayerPositionTags.Add(NewEntry);
 5921: 	}
 5922: 
 5923: 	// Add to participating players if not already there
 5924: 	if (!ParticipatingPlayers.Contains(Player))
 5925: 	{
 5926: 		ParticipatingPlayers.Add(Player);
 5927: 	}
 5928: 	CurrentRitualState = EInteractionState::WaitingForPlayers;
 5929: 
 5930: 	// Broadcast state change on server for local UI updates (OnRep will handle clients)
 5931: 	if (HasAuthority())
 5932: 	{
 5933: 		BroadcastRitualStateChanged();
 5934: 	}
 5935: 
 5936: 	// Update ready players data
 5937: 	UpdateReadyPlayersData();
 5938: 
 5939: 	// Call the ritual state delegate for Listen Server
 5940: 	if (Player->GetLocalRole() == ROLE_Authority && Player->IsLocallyControlled()) // Im the listen server
 5941: 	{
 5942: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
 5943: 		if (!PC->HasRitualWidgetInitialized(this))
 5944: 		{
 5945: 			PC->LocalInitializeRitualUserWidget(this);
 5946: 		}
 5947: 	} else if (Player->HasAuthority() && !Player->IsLocallyControlled()) // The call is from the client
 5948: 	{
 5949: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
 5950: 		if (!PC->HasRitualWidgetInitialized(this))
 5951: 		{
 5952: 			PC->Client_InitializeRitualUserWidget(this);
 5953: 		}
 5954: 	}
 5955: }
 5956: 
 5957: void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
 5958: {
 5959: 	// Client-side feedback for ritual success
 5960: 	// This would typically play sounds, particle effects, etc.
 5961: 
 5962: 	// Example: Play celebratory effects at altar location
 5963: 	// UGameplayStatics::PlaySoundAtLocation(this, SuccessSound, GetActorLocation());
 5964: 	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SuccessParticles, GetActorTransform());
 5965: 
 5966: 	// Set completion status for replication
 5967: 	bRitualCompleted = true;
 5968: 	bRitualWasSuccessful = true;
 5969: 
 5970: 	DestroyAltarPositions();
 5971: 
 5972: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback"));
 5973: }
 5974: 
 5975: void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
 5976: {
 5977: 	// Client-side feedback for catastrophic failure
 5978: 	// This would typically play sounds, particle effects, etc.
 5979: 
 5980: 	// Example: Play ominous effects at altar location
 5981: 	// UGameplayStatics::PlaySoundAtLocation(this, CatastrophicFailSound, GetActorLocation());
 5982: 	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), CatastrophicFailParticles, GetActorTransform());
 5983: 
 5984: 	// Set completion status for replication
 5985: 	bRitualCompleted = true;
 5986: 	bRitualWasSuccessful = false;
 5987: 
 5988: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback"));
 5989: }
 5990: 
 5991: float ARitualAltar::GetCorruptionPercentage() const
 5992: {
 5993: 	if (MaxCorruption == 0.0f)
 5994: 	{
 5995: 		return 0.0f;
 5996: 	}
 5997: 
 5998: 	return CorruptionAmount / MaxCorruption;
 5999: }
 6000: </file>
 6001: 
 6002: <file path="WitchPT/Private/Item/RitualPosition.cpp">
 6003: // Fill out your copyright notice in the Description page of Project Settings.
 6004: 
 6005: #include "Item/RitualPosition.h"
 6006: #include "Net/UnrealNetwork.h"
 6007: #include "GameFramework/Character.h"
 6008: #include "Item/RitualAltar.h" // Include the Altar header
 6009: #include "GameplayTagContainer.h" // For tags
 6010: #include "AbilitySystemComponent.h"
 6011: #include "AbilitySystemBlueprintLibrary.h"
 6012: #include "FWitchPTGameplayTags.h"
 6013: #include "GameplayEffect.h"
 6014: #include "GameFramework/CharacterMovementComponent.h"
 6015: #include "Components/CapsuleComponent.h"
 6016: #include "Kismet/GameplayStatics.h"
 6017: #include "Character/Components/WitchPTMechanicComponent.h" // Required for new RPC calls
 6018: 
 6019: // Sets default values
 6020: ARitualPosition::ARitualPosition()
 6021: {
 6022: 	// No need to set up replication here - it's handled by the base class
 6023: }
 6024: 
 6025: void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 6026: {
 6027: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6028: 
 6029: 	DOREPLIFETIME(ARitualPosition, RitualAltar);
 6030: }
 6031: 
 6032: // void ARitualPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 6033: // {
 6034: // 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6035: //
 6036: // 	DOREPLIFETIME(ARitualPosition, bIsOccupied);
 6037: // 	DOREPLIFETIME(ARitualPosition, OccupyingCharacter);
 6038: // 	// RitualAltar and PositionTag are usually set once and don't need replication unless they can change dynamically
 6039: // }
 6040: 
 6041: void ARitualPosition::BeginPlay()
 6042: {
 6043: 	Super::BeginPlay();
 6044: 
 6045: 	// Try to find the RitualAltar if it wasn't set in the editor
 6046: 
 6047: }
 6048: 
 6049: 
 6050: void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 6051: {
 6052: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 6053: 
 6054: 	// Ritual-specific interaction options
 6055: 
 6056: 	// ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
 6057: 	//
 6058: 	// // If no player is occupying the position, let a player take the position
 6059: 	// if (!IsOccupied() && InteractingCharacterPtr)
 6060: 	// {
 6061: 	// 	OptionBuilder.AddDefaultInteraction(
 6062: 	// 		FText::FromString("Take Position"), // Text for the interaction
 6063: 	// 		[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 6064: 	// 		{
 6065: 	// 			HandleInteraction(InteractingCharacterPtr);
 6066: 	// 		}
 6067: 	// 	);
 6068: 	// }
 6069: 	//
 6070: 	// // Special case: if the character is standing at a position and we're in Inactive state, they can initiate the ritual
 6071: 	// if (IsOccupied() && RitualAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 6072: 	// {
 6073: 	// 	// Check ritual state
 6074: 	// 	if (RitualAltar->GetCurrentState() == EInteractionState::Inactive)
 6075: 	// 	{
 6076: 	// 		OptionBuilder.AddDefaultInteraction(
 6077: 	// 			FText::FromString("Start Ritual"), // Text for the interaction
 6078: 	// 			[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 6079: 	// 			{
 6080: 	// 				if (RitualAltar)
 6081: 	// 				{
 6082: 	// 					// Cast to the appropriate start ritual function
 6083: 	// 					RitualAltar->StartRitual(InteractingCharacterPtr);
 6084: 	// 				}
 6085: 	// 			}
 6086: 	// 		);
 6087: 	// 	}
 6088: 	// }
 6089: }
 6090: 
 6091: ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
 6092: {
 6093: 	if (RitualAltar)
 6094: 	{
 6095: 		return RitualAltar;
 6096: 	}
 6097: 	return nullptr;
 6098: }
 6099: 
 6100: bool ARitualPosition::IsOccupied_Implementation()
 6101: {
 6102: 	return bIsOccupied;
 6103: }
 6104: 
 6105: 
 6106: void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
 6107: {
 6108: 	Super::HandleInteraction(InteractingCharacter);
 6109: 
 6110: 	if (!InteractingCharacter || !RitualAltar)
 6111: 	{
 6112: 		return;
 6113: 	}
 6114: 
 6115: }
 6116: 
 6117: 
 6118: 
 6119: 
 6120: 
 6121: // void ARitualPosition::SetOccupied(ACharacter* Character)
 6122: // {
 6123: // 	if (!HasAuthority())
 6124: // 	{
 6125: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: no authority"));
 6126: // 		return;
 6127: // 	}
 6128: //
 6129: // 	if (!Character)
 6130: // 	{
 6131: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: invalid character"));
 6132: // 		return;
 6133: // 	}
 6134: //
 6135: // 	if (bIsOccupied)
 6136: // 	{
 6137: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: position %s already occupied by %s"),
 6138: // 			*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
 6139: // 		return;
 6140: // 	}
 6141: //
 6142: // 	// Set as occupied
 6143: // 	bIsOccupied = true;
 6144: // 	OccupyingCharacter = Character;
 6145: //
 6146: // 	// Force OnReps if needed immediately on server
 6147: // 	OnRep_IsOccupied();
 6148: // 	OnRep_OccupyingCharacter();
 6149: //
 6150: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Occupied by %s"), *GetName(), *Character->GetName());
 6151: // }
 6152: 
 6153: // Called on the Server by the Altar (or potentially a GA)
 6154: // void ARitualPosition::RemoveCharacterFromPosition()
 6155: // {
 6156: // 	if (!HasAuthority())
 6157: // 	{
 6158: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: no authority"));
 6159: // 		return;
 6160: // 	}
 6161: //
 6162: // 	if (!bIsOccupied || !OccupyingCharacter)
 6163: // 	{
 6164: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: position %s is not occupied"), *GetName());
 6165: // 		return;
 6166: // 	}
 6167: //
 6168: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removing %s from position %s"),
 6169: // 		*OccupyingCharacter->GetName(), *GetName());
 6170: //
 6171: // 	// Remove the occupying position tag from the character
 6172: // 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OccupyingCharacter);
 6173: // 	if (ASC)
 6174: // 	{
 6175: // 		const FWitchPTGameplayTags& gameplayTags = FWitchPTGameplayTags::Get();
 6176: //
 6177: // 		// Remove the State.Ritual.OccupyingPosition tag
 6178: // 		// This would typically be done by removing the GE that applied it
 6179: //
 6180: // 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removed State.Ritual.OccupyingPosition tag from %s"), *OccupyingCharacter->GetName());
 6181: // 	}
 6182: //
 6183: // 	// Clear state
 6184: // 	bIsOccupied = false;
 6185: // 	ACharacter* OldCharacter = OccupyingCharacter;
 6186: // 	OccupyingCharacter = nullptr;
 6187: //
 6188: // 	// Force OnReps if needed immediately on server
 6189: // 	OnRep_IsOccupied();
 6190: // 	OnRep_OccupyingCharacter();
 6191: //
 6192: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Unoccupied (was %s)"),
 6193: // 		*GetName(), OldCharacter ? *OldCharacter->GetName() : TEXT("nullptr"));
 6194: // }
 6195: //
 6196: // void ARitualPosition::OnRep_IsOccupied()
 6197: // {
 6198: // 	// Client-side reaction to occupancy change
 6199: // 	// Example: Change material, play sound, update UI attached to this position
 6200: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupancy changed to: %s"),
 6201: // 		*GetName(), bIsOccupied ? TEXT("OCCUPIED") : TEXT("VACANT"));
 6202: // }
 6203: //
 6204: // void ARitualPosition::OnRep_OccupyingCharacter()
 6205: // {
 6206: // 	// Client-side reaction to character change
 6207: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupying character changed to: %s"),
 6208: // 		*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
 6209: // }
 6210: </file>
 6211: 
 6212: <file path="WitchPT/Private/Player/WitchPTPlayerController.cpp">
 6213: // Fill out your copyright notice in the Description page of Project Settings.
 6214: 
 6215: 
 6216: #include "Player/WitchPTPlayerController.h"
 6217: 
 6218: #include "AbilitySystemBlueprintLibrary.h"
 6219: #include "EnhancedInputSubsystems.h"
 6220: #include "InputActionValue.h"
 6221: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 6222: #include "Blueprint/UserWidget.h"
 6223: #include "Input/WitchPTInputComponent.h"
 6224: #include "Inventory/WitchPTInventoryManagerComponent.h"
 6225: #include "Item/CauldronAltar.h"
 6226: #include "Item/RitualAltar.h"
 6227: #include "Item/Ritual/RitualFunctionLibrary.h"
 6228: #include "Kismet/GameplayStatics.h"
 6229: #include "Net/UnrealNetwork.h"
 6230: #include "UI/HUD/WitchPTHUD.h"
 6231: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6232: #include "UI/WidgetControllers/RitualWidgetController.h"
 6233: #include "UI/Widgets/CauldronUserWidget.h"
 6234: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 6235: #include "WitchPT/WitchPT.h"
 6236: 
 6237: AWitchPTPlayerController::AWitchPTPlayerController()
 6238: {
 6239: 	bReplicates = true;
 6240: 	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
 6241: 	InventoryManager->SetIsReplicated(true);
 6242: 
 6243: 
 6244: }
 6245: 
 6246: void AWitchPTPlayerController::PlayerTick(float DeltaTime)
 6247: {
 6248: 	Super::PlayerTick(DeltaTime);
 6249: }
 6250: 
 6251: void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
 6252: {
 6253: 	Super::PreProcessInput(DeltaTime, bGamePaused);
 6254: }
 6255: 
 6256: void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
 6257: {
 6258: 	if (WitchPtAbilitySystemComponent)
 6259: 	{
 6260: 		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
 6261: 	}
 6262: 	Super::PostProcessInput(DeltaTime, bGamePaused);
 6263: }
 6264: 
 6265: void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 6266: {
 6267: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6268: 	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
 6269: }
 6270: void AWitchPTPlayerController::LocalToggleCauldronMenu()
 6271: {
 6272: 
 6273: 	if (bCauldronMenuOpen)
 6274: 	{
 6275: 		CloseCauldronMenu();
 6276: 	}
 6277: 	else
 6278: 	{
 6279: 		OpenCauldronMenu();
 6280: 	}
 6281: }
 6282: 
 6283: void AWitchPTPlayerController::LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar)
 6284: {
 6285: 	if (!Altar || !Altar->AltarUserWidgetClass || !IsLocalController())
 6286: 	{
 6287: 		UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Invalid altar or widget class!"));
 6288: 		return;
 6289: 	}
 6290: 
 6291: 	if (Altar->IsA<ARitualAltar>())
 6292: 	{
 6293: 		// Cast the altar to a ritual altar
 6294: 		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
 6295: 
 6296: 		if (!ThisRitualAltarHasWidget || ThisRitualAltarHasWidget != RitualAltar)
 6297: 		{
 6298: 			ThisRitualAltarHasWidget = RitualAltar;
 6299: 		}
 6300: 
 6301: 		URitualUserWidget* RitualUserWidget = CreateWidget<URitualUserWidget>(this, Altar->AltarUserWidgetClass);
 6302: 
 6303: 		if (IsValid(RitualUserWidget))
 6304: 		{
 6305: 			// Get or create the ritual widget controller
 6306: 			URitualWidgetController* RitualWidgetController = URitualFunctionLibrary::SetRitualWidgetController(this);
 6307: 
 6308: 			if (!RitualWidgetController)
 6309: 			{
 6310: 				UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Failed to get or create RitualWidgetController!"));
 6311: 				return;
 6312: 			}
 6313: 
 6314: 			RitualWidgetController->SetRitualAltar(RitualAltar);
 6315: 			// Set widget controller reference for the user widget
 6316: 			RitualUserWidget->SetWidgetController(RitualWidgetController);
 6317: 
 6318: 
 6319: 			// Add the widget to viewport
 6320: 			RitualUserWidget->AddToViewport();
 6321: 		}
 6322: 
 6323: 	}
 6324: 
 6325: 
 6326: }
 6327: 
 6328: bool AWitchPTPlayerController::HasRitualWidgetInitialized(ABaseInteractableAltar* Altar)
 6329: {
 6330: 	if (Altar->IsA<ARitualAltar>())
 6331: 	{
 6332: 		return ThisRitualAltarHasWidget == Altar;
 6333: 	}
 6334: 	return false;
 6335: }
 6336: 
 6337: void AWitchPTPlayerController::OpenCauldronMenu()
 6338: {
 6339: 	if (!IsValid(CauldronAltarMenu)) return;
 6340: 
 6341: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Visible);
 6342: 	bCauldronMenuOpen = true;
 6343: 
 6344: 	FInputModeGameAndUI InputMode;
 6345: 
 6346: 	SetInputMode(InputMode);
 6347: 	SetShowMouseCursor(true);
 6348: }
 6349: 
 6350: void AWitchPTPlayerController::CloseCauldronMenu()
 6351: {
 6352: 	if (!IsValid(CauldronAltarMenu)) return;
 6353: 
 6354: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Collapsed);
 6355: 	bCauldronMenuOpen = false;
 6356: 
 6357: 
 6358: 
 6359: 	FInputModeGameOnly InputMode;
 6360: 	SetInputMode(InputMode);
 6361: 	SetShowMouseCursor(false);
 6362: }
 6363: 
 6364: void AWitchPTPlayerController::Client_InitializeRitualUserWidget_Implementation(ABaseInteractableAltar* Altar)
 6365: {
 6366: 	if (!HasRitualWidgetInitialized(Altar))
 6367: 	{
 6368: 		LocalInitializeRitualUserWidget(Altar);
 6369: 	}
 6370: }
 6371: 
 6372: void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
 6373: {
 6374: 	LocalToggleCauldronMenu();
 6375: }
 6376: void AWitchPTPlayerController::BeginPlay()
 6377: {
 6378: 	Super::BeginPlay();
 6379: 	check(WitchPtiInputMappingContext)
 6380: 	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
 6381: 	if (Subsystem)
 6382: 	{
 6383: 		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
 6384: 	}
 6385: 	CreateHUDWidget();
 6386: 	ConstructCauldronWidget();
 6387: }
 6388: 
 6389: void AWitchPTPlayerController::SetupInputComponent()
 6390: {
 6391: 	Super::SetupInputComponent();
 6392: 	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
 6393: 	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
 6394: 	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
 6395: 	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
 6396: 
 6397: }
 6398: 
 6399: void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
 6400: {
 6401: 	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
 6402: 	const FRotator Rotation = GetControlRotation();
 6403: 	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);
 6404: 
 6405: 	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
 6406: 	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
 6407: 
 6408: 	if (APawn* ControlledPawn = GetPawn<APawn>())
 6409: 	{
 6410: 		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
 6411: 		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
 6412: 	}
 6413: 
 6414: }
 6415: 
 6416: void AWitchPTPlayerController::Look(const FInputActionValue& Value)
 6417: {
 6418: 	// input is a Vector2D
 6419: 	FVector2D LookAxisVector = Value.Get<FVector2D>();
 6420: 
 6421: 	if (APawn* ControlledPawn = GetPawn<APawn>())
 6422: 	{
 6423: 		// add yaw and pitch input to controller
 6424: 		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
 6425: 		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
 6426: 	}
 6427: }
 6428: 
 6429: void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
 6430: {
 6431: 	if (GetASC())
 6432: 	{
 6433: 		GetASC()->AbilityInputTagPressed(InputTag);
 6434: 	}
 6435: }
 6436: 
 6437: void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
 6438: {
 6439: 	if (GetASC())
 6440: 	{
 6441: 		GetASC()->AbilityInputTagReleased(InputTag);
 6442: 	}
 6443: }
 6444: 
 6445: void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
 6446: {
 6447: 	if (GetASC())
 6448: 	{
 6449: 		GetASC()->AbilityInputTagHeld(InputTag);
 6450: 	}
 6451: }
 6452: 
 6453: void AWitchPTPlayerController::ConstructCauldronWidget()
 6454: {
 6455: 	if (!this->IsLocalController()) return;
 6456: 	CauldronAltarMenu = CreateWidget<UCauldronUserWidget>(this, CauldronAltarWidgetClass);
 6457: 	UCauldronWidgetController* CauldronWidgetController = URitualFunctionLibrary::SetCauldronWidgetController(this);
 6458: 	CauldronAltarMenu->SetWidgetController(CauldronWidgetController);
 6459: 	// Find ACauldronAltar in the level
 6460: 	ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass()));
 6461: 	if (CauldronAltar)
 6462: 	{
 6463: 		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
 6464: 	}
 6465: 	CauldronWidgetController->BindCallbacksToDependencies();
 6466: 	CauldronAltarMenu->AddToViewport();
 6467: 	CloseCauldronMenu();
 6468: }
 6469: 
 6470: void AWitchPTPlayerController::CreateHUDWidget()
 6471: {
 6472: 	if (!IsLocalController()) return;
 6473: 	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
 6474: 	if (IsValid(HUDWidget))
 6475: 	{
 6476: 		HUDWidget->AddToViewport();
 6477: 	}
 6478: }
 6479: 
 6480: 
 6481: UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
 6482: {
 6483: 	if (WitchPtAbilitySystemComponent == nullptr)
 6484: 	{
 6485: 		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
 6486: 	}
 6487: 	return WitchPtAbilitySystemComponent;
 6488: }
 6489: </file>
 6490: 
 6491: <file path="WitchPT/Private/Player/WitchPTPlayerState.cpp">
 6492: // Fill out your copyright notice in the Description page of Project Settings.
 6493: 
 6494: 
 6495: #include "Player/WitchPTPlayerState.h"
 6496: 
 6497: #include "AbilitySystemComponent.h"
 6498: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 6499: #include "AbilitySystem/WitchPTAttributeSet.h"
 6500: #include "Item/RitualPosition.h"
 6501: 
 6502: AWitchPTPlayerState::AWitchPTPlayerState()
 6503: {
 6504: 	SetNetUpdateFrequency(100.f);
 6505: 
 6506: 	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
 6507: 	AbilitySystemComponent->SetIsReplicated(true);
 6508: 	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
 6509: 
 6510: 	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");
 6511: 
 6512: 
 6513: }
 6514: 
 6515: UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
 6516: {
 6517: 	return AbilitySystemComponent;
 6518: }
 6519: </file>
 6520: 
 6521: <file path="WitchPT/Private/UI/HUD/WitchPTHUD.cpp">
 6522: // Fill out your copyright notice in the Description page of Project Settings.
 6523: 
 6524: 
 6525: #include "UI/HUD/WitchPTHUD.h"
 6526: 
 6527: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6528: #include "UI/WidgetControllers/InventoryWidgetController.h"
 6529: #include "UI/WidgetControllers/OverlayWidgetController.h"
 6530: #include "UI/WidgetControllers/RitualWidgetController.h"
 6531: #include "UI/Widgets/WitchPTUserWidget.h"
 6532: 
 6533: UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
 6534: {
 6535: 	if (OverlayWidgetController == nullptr)
 6536: 	{
 6537: 		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
 6538: 		OverlayWidgetController->SetWidgetControllerParams(WCParams);
 6539: 		OverlayWidgetController->BindCallbacksToDependencies();
 6540: 	}
 6541: 	return OverlayWidgetController;
 6542: }
 6543: 
 6544: UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
 6545: {
 6546: 	if (CauldronWidgetController == nullptr)
 6547: 	{
 6548: 		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
 6549: 		CauldronWidgetController->SetWidgetControllerParams(WCParams);
 6550: 		// CauldronWidgetController->BindCallbacksToDependencies();
 6551: 	}
 6552: 	return CauldronWidgetController;
 6553: }
 6554: 
 6555: UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
 6556: {
 6557: 	if (InventoryWidgetController == nullptr)
 6558: 	{
 6559: 		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
 6560: 		InventoryWidgetController->SetWidgetControllerParams(WCParams);
 6561: 		InventoryWidgetController->BindCallbacksToDependencies();
 6562: 	}
 6563: 	return InventoryWidgetController;
 6564: }
 6565: 
 6566: URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
 6567: {
 6568: 	if (RitualWidgetController == nullptr)
 6569: 	{
 6570: 		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
 6571: 		RitualWidgetController->SetWidgetControllerParams(WCParams);
 6572: 	}
 6573: 	return RitualWidgetController;
 6574: }
 6575: 
 6576: void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
 6577: {
 6578: 	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
 6579: 	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));
 6580: 
 6581: 
 6582: 	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
 6583: 	OverlayWidget = Cast<UWitchPTUserWidget>(Widget);
 6584: 
 6585: 	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
 6586: 	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);
 6587: 
 6588: 	OverlayWidget->SetWidgetController(WidgetController);
 6589: 	WidgetController->BroadcastInitialValues();
 6590: 	Widget->AddToViewport();
 6591: }
 6592: </file>
 6593: 
 6594: <file path="WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp">
 6595: // Fill out your copyright notice in the Description page of Project Settings.
 6596: 
 6597: 
 6598: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6599: 
 6600: #include "Item/CauldronAltar.h"
 6601: 
 6602: UCauldronWidgetController::UCauldronWidgetController()
 6603: {
 6604: }
 6605: 
 6606: void UCauldronWidgetController::BroadcastInitialValues()
 6607: {
 6608: 	if(CauldronAltar)
 6609: 	{
 6610: 		OnBaseIngredientSet.Broadcast(CauldronAltar->GetBaseIngredient());
 6611: 
 6612: 	}
 6613: 
 6614: }
 6615: 
 6616: void UCauldronWidgetController::BindCallbacksToDependencies()
 6617: {
 6618: 	Super::BindCallbacksToDependencies();
 6619: 	if(CauldronAltar)
 6620: 	{
 6621: 		CauldronAltar->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
 6622: 		CauldronAltar->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
 6623: 		CauldronAltar->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
 6624: 		CauldronAltar->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
 6625: 		CauldronAltar->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
 6626: 		CauldronAltar->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
 6627: 	}
 6628: }
 6629: 
 6630: void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
 6631: {
 6632: 	if (InCauldronAltar != nullptr)
 6633: 	{
 6634: 		CauldronAltar = InCauldronAltar;
 6635: 	}
 6636: 
 6637: }
 6638: 
 6639: void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 6640: {
 6641: 	OnBaseIngredientSet.Broadcast(IngredientInstance);
 6642: }
 6643: 
 6644: void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
 6645: {
 6646: 	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
 6647: }
 6648: 
 6649: void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 6650: {
 6651: 	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
 6652: }
 6653: 
 6654: void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
 6655: {
 6656: 	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
 6657: }
 6658: 
 6659: void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 6660: {
 6661: 	OnModifierIngredientSet.Broadcast(IngredientInstance);
 6662: }
 6663: 
 6664: void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
 6665: {
 6666: 	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
 6667: }
 6668: </file>
 6669: 
 6670: <file path="WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp">
 6671: // Fill out your copyright notice in the Description page of Project Settings.
 6672: 
 6673: 
 6674: #include "UI/WidgetControllers/InventoryWidgetController.h"
 6675: 
 6676: #include "Inventory/WitchPTInventoryItemInstance.h"
 6677: #include "Inventory/WitchPTInventoryManagerComponent.h"
 6678: #include "Player/WitchPTPlayerController.h"
 6679: 
 6680: void UInventoryWidgetController::BindCallbacksToDependencies()
 6681: {
 6682: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 6683: 	if (WitchPtPlayerController)
 6684: 	{
 6685: 		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 6686: 		if (InventoryManager)
 6687: 		{
 6688: 			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 6689: 			{
 6690: 				OnItemAddedDelegate.Broadcast(ItemAdded);
 6691: 			});
 6692: 			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 6693: 			{
 6694: 				OnItemStackChangedDelegate.Broadcast(ItemAdded);
 6695: 			});
 6696: 			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
 6697: 			{
 6698: 				OnItemRemovedDelegate.Broadcast(ItemRemoved);
 6699: 			});
 6700: 		}
 6701: 	}
 6702: }
 6703: 
 6704: void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 6705: {
 6706: 	if (!ItemInstance)
 6707: 	{
 6708: 		return;
 6709: 	}
 6710: 
 6711: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 6712: 	if (!WitchPtPlayerController)
 6713: 	{
 6714: 		return;
 6715: 	}
 6716: 
 6717: 	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 6718: 	if (!InventoryManager)
 6719: 	{
 6720: 		return;
 6721: 	}
 6722: 
 6723: 	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
 6724: 
 6725: 	// If we only have 1 item left and trying to remove 1 or more, remove the item completely
 6726: 	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
 6727: 	{
 6728: 		InventoryManager->Server_RemoveItemInstance(ItemInstance);
 6729: 	}
 6730: 	else
 6731: 	{
 6732: 		// Otherwise, reduce the stack count by the requested amount
 6733: 		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
 6734: 	}
 6735: }
 6736: </file>
 6737: 
 6738: <file path="WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp">
 6739: // Fill out your copyright notice in the Description page of Project Settings.
 6740: 
 6741: 
 6742: #include "UI/WidgetControllers/OverlayWidgetController.h"
 6743: 
 6744: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 6745: #include "AbilitySystem/WitchPTAttributeSet.h"
 6746: 
 6747: void UOverlayWidgetController::BroadcastInitialValues()
 6748: {
 6749: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
 6750: 
 6751: 	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
 6752: 	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
 6753: 	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
 6754: 	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
 6755: 	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
 6756: 	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
 6757: }
 6758: 
 6759: void UOverlayWidgetController::BindCallbacksToDependencies()
 6760: {
 6761: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
 6762: 
 6763: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6764: 	{
 6765: 		OnHealthChanged.Broadcast(Data.NewValue);
 6766: 	});
 6767: 
 6768: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6769: 	{
 6770: 		OnMaxHealthChanged.Broadcast(Data.NewValue);
 6771: 	});
 6772: 
 6773: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6774: 	{
 6775: 		OnStaminaChanged.Broadcast(Data.NewValue);
 6776: 	});
 6777: 
 6778: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6779: 	{
 6780: 		OnMaxStaminaChanged.Broadcast(Data.NewValue);
 6781: 	});
 6782: 
 6783: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6784: 	{
 6785: 		OnAgeChanged.Broadcast(Data.NewValue);
 6786: 	});
 6787: 
 6788: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
 6789: 	{
 6790: 		OnMaxAgeChanged.Broadcast(Data.NewValue);
 6791: 	});
 6792: 
 6793: 	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 6794: 
 6795: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
 6796: 
 6797: 	// Lambda for message delegates
 6798: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
 6799: 		// [this] is the capture list, in the case of this lambda, we want to capture this (OverlayWidgetController)
 6800: 		[this](const FGameplayTagContainer& AssetTags)
 6801: 	{
 6802: 		for (const auto& Tag : AssetTags)
 6803: 		{
 6804: 			// Declare the tag we want to check. In our case "MessageTag"
 6805: 			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
 6806: 			if (Tag.MatchesTag(ParentMessageGameplayTag))
 6807: 			{
 6808: 
 6809: 
 6810: 				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
 6811: 				OnMessageWidgetRow.Broadcast(*Row);
 6812: 
 6813: 			}
 6814: 
 6815: 		}
 6816: 	});
 6817: 
 6818: 
 6819: 
 6820: }
 6821: void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
 6822: {
 6823: 
 6824: }
 6825: </file>
 6826: 
 6827: <file path="WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp">
 6828: // Fill out your copyright notice in the Description page of Project Settings.
 6829: 
 6830: #include "UI/WidgetControllers/RitualWidgetController.h"
 6831: #include "Item/RitualAltar.h"
 6832: #include "GameFramework/Character.h"
 6833: #include "GameFramework/PlayerController.h"
 6834: #include "AbilitySystemComponent.h"
 6835: #include "AbilitySystemBlueprintLibrary.h"
 6836: #include "FWitchPTGameplayTags.h"
 6837: 
 6838: URitualWidgetController::URitualWidgetController()
 6839: {
 6840:     // Constructor
 6841: }
 6842: 
 6843: void URitualWidgetController::BroadcastInitialValues()
 6844: {
 6845:     // If we have an altar, broadcast its initial values
 6846:     if (RitualAltar)
 6847:     {
 6848:         // Broadcast current state
 6849:         OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
 6850: 
 6851:         // Broadcast ready players data
 6852:         FRitualReadyPlayersData ReadyPlayersData;
 6853:         ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
 6854:         ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
 6855:         OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 6856: 
 6857:         // Broadcast current turn data (processed for local player)
 6858:         FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
 6859:         FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
 6860:         OnTurnDataChanged.Broadcast(ProcessedTurnData);
 6861: 
 6862:         // Broadcast corruption
 6863:         OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
 6864: 
 6865:         // Broadcast sequence progress
 6866:         OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
 6867:     }
 6868: }
 6869: 
 6870: void URitualWidgetController::BindCallbacksToDependencies()
 6871: {
 6872:     // Bind to altar delegates if it exists
 6873:     if (RitualAltar)
 6874:     {
 6875:         // Bind to all the new dynamic multicast delegates
 6876:         RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
 6877:         RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
 6878:         RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
 6879:         RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
 6880:         RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
 6881:         RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
 6882:         RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
 6883:     }
 6884: }
 6885: 
 6886: void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
 6887: {
 6888:     // Unbind any existing callbacks first
 6889:     if (RitualAltar != nullptr)
 6890:     {
 6891:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 6892:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 6893:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 6894:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 6895:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 6896:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 6897:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 6898:     }
 6899: 
 6900:     // Assign the new altar
 6901:     RitualAltar = InRitualAltar;
 6902: 
 6903:     // Rebind and broadcast if we have a valid altar
 6904:     if (RitualAltar)
 6905:     {
 6906:         BindCallbacksToDependencies();
 6907:         BroadcastInitialValues();
 6908:     }
 6909: }
 6910: 
 6911: bool URitualWidgetController::IsLocalPlayerActive() const
 6912: {
 6913:     if (!RitualAltar || !PlayerController)
 6914:     {
 6915:         return false;
 6916:     }
 6917: 
 6918:     // Get the local character
 6919:     ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
 6920:     if (!LocalCharacter)
 6921:     {
 6922:         return false;
 6923:     }
 6924: 
 6925:     // Check if this character is the active player
 6926:     return RitualAltar->GetCurrentActivePlayer() == LocalCharacter;
 6927: }
 6928: 
 6929: FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
 6930: {
 6931:     FUIRitualData ProcessedData = InTurnData;
 6932: 
 6933:     // Determine if it's the local player's turn
 6934:     ProcessedData.bIsMyTurn = IsLocalPlayerActive();
 6935: 
 6936:     // If it's not the local player's turn, clear sensitive data
 6937:     if (!ProcessedData.bIsMyTurn)
 6938:     {
 6939:         ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
 6940:         ProcessedData.CurrentInputTimeRemaining = 0.0f;
 6941:     }
 6942: 
 6943:     return ProcessedData;
 6944: }
 6945: 
 6946: // ----------------------------------- CALLBACK HANDLERS ---------------------------------------------- //
 6947: 
 6948: void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
 6949: {
 6950:     OnRitualStateChanged.Broadcast(NewState);
 6951: }
 6952: 
 6953: void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
 6954: {
 6955:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 6956: }
 6957: 
 6958: void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
 6959: {
 6960:     OnRitualCountdownTick.Broadcast(CountdownValue);
 6961: }
 6962: 
 6963: void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
 6964: {
 6965:     // Process the turn data for the local player before broadcasting
 6966:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
 6967:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
 6968: 
 6969:     // Also broadcast the expected input separately for backward compatibility
 6970:     if (ProcessedTurnData.bIsMyTurn)
 6971:     {
 6972:         OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
 6973:     }
 6974:     else
 6975:     {
 6976:         OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
 6977:     }
 6978: }
 6979: 
 6980: void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
 6981: {
 6982:     OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
 6983: }
 6984: 
 6985: void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
 6986: {
 6987:     OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
 6988: }
 6989: 
 6990: void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
 6991: {
 6992:     OnRitualCompleted.Broadcast(bWasSuccessful);
 6993: 
 6994:     // Unbind all delegates when ritual is completed to prevent memory leaks
 6995:     if (RitualAltar)
 6996:     {
 6997:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 6998:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 6999:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 7000:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 7001:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 7002:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 7003:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 7004:     }
 7005: }
 7006: </file>
 7007: 
 7008: <file path="WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp">
 7009: // Fill out your copyright notice in the Description page of Project Settings.
 7010: 
 7011: 
 7012: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 7013: 
 7014: void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
 7015: {
 7016: 	PlayerController = WCParams.PlayerController;
 7017: 	PlayerState = WCParams.PlayerState;
 7018: 	AbilitySystemComponent = WCParams.AbilitySystemComponent;
 7019: 	AttributeSet = WCParams.AttributeSet;
 7020: }
 7021: 
 7022: void UWitchPTWidgetController::BroadcastInitialValues()
 7023: {
 7024: }
 7025: 
 7026: void UWitchPTWidgetController::BindCallbacksToDependencies()
 7027: {
 7028: }
 7029: </file>
 7030: 
 7031: <file path="WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp">
 7032: // Fill out your copyright notice in the Description page of Project Settings.
 7033: 
 7034: 
 7035: #include "UI/Widgets/CauldronUserWidget.h"
 7036: 
 7037: void UCauldronUserWidget::NativeConstruct()
 7038: {
 7039: 	Super::NativeConstruct();
 7040: 	FInputModeGameAndUI InputMode;
 7041: 	// set the input mode to the player controller
 7042: 
 7043: 	if (APlayerController* OwningController = GetOwningPlayer())
 7044: 	{
 7045: 		OwningController->SetInputMode(InputMode);
 7046: 		OwningController->SetShowMouseCursor(true);
 7047: 	}
 7048: 
 7049: }
 7050: 
 7051: FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
 7052: {
 7053: 	return FReply::Handled();
 7054: }
 7055: </file>
 7056: 
 7057: <file path="WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp">
 7058: // Fill out your copyright notice in the Description page of Project Settings.
 7059: 
 7060: 
 7061: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 7062: 
 7063: FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
 7064: {
 7065: 
 7066: 	return FReply::Handled();
 7067: }
 7068: </file>
 7069: 
 7070: <file path="WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp">
 7071: // Fill out your copyright notice in the Description page of Project Settings.
 7072: 
 7073: 
 7074: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 7075: </file>
 7076: 
 7077: <file path="WitchPT/Private/UI/Widgets/PointerWidget.cpp">
 7078: // Fill out your copyright notice in the Description page of Project Settings.
 7079: 
 7080: 
 7081: #include "UI/Widgets/PointerWidget.h"
 7082: </file>
 7083: 
 7084: <file path="WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp">
 7085: // Fill out your copyright notice in the Description page of Project Settings.
 7086: 
 7087: 
 7088: #include "UI/Widgets/WitchPTUserWidget.h"
 7089: 
 7090: void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
 7091: {
 7092: 	WidgetController = InWidgetController;
 7093: 	OnWidgetControllerSet();
 7094: }
 7095: </file>
 7096: 
 7097: <file path="WitchPT/Private/WitchPTAssetManager.cpp">
 7098: // Fill out your copyright notice in the Description page of Project Settings.
 7099: 
 7100: 
 7101: #include "WitchPTAssetManager.h"
 7102: 
 7103: #include "AbilitySystemGlobals.h"
 7104: #include "FWitchPTGameplayTags.h"
 7105: 
 7106: UWitchPTAssetManager& UWitchPTAssetManager::Get()
 7107: {
 7108: 	check(GEngine)
 7109: 	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
 7110: 	return *WitchPtAssetManager;
 7111: }
 7112: 
 7113: void UWitchPTAssetManager::StartInitialLoading()
 7114: {
 7115: 	Super::StartInitialLoading();
 7116: 	FWitchPTGameplayTags::InitializeGameplayTags();
 7117: 	/**
 7118: 	 *
 7119: 	 */
 7120: 	// TODO: What is this function for?
 7121: 
 7122: 	UAbilitySystemGlobals::Get().InitGlobalData();
 7123: 
 7124: }
 7125: </file>
 7126: 
 7127: <file path="WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h">
 7128: // Fill out your copyright notice in the Description page of Project Settings.
 7129: 
 7130: #pragma once
 7131: 
 7132: #include "CoreMinimal.h"
 7133: #include "Abilities/Tasks/AbilityTask.h"
 7134: #include "AT_WaitForPlacementLocation_SLT.generated.h"
 7135: 
 7136: // Delegado para enviar la información de la ubicación y la normal
 7137: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);
 7138: 
 7139: /**
 7140:  * Task que realiza un line trace continuo para encontrar ubicaciones válidas para colocar el caldero.
 7141:  * Similar a UAT_WaitForInteractable_SLT pero devuelve información de ubicación y normal de la superficie.
 7142:  */
 7143: UCLASS()
 7144: class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
 7145: {
 7146: 	GENERATED_BODY()
 7147: 
 7148: public:
 7149: 	// Constructor
 7150: 	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);
 7151: 
 7152: 	// Crea y configura la tarea
 7153: 	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
 7154: 	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
 7155: 		UGameplayAbility* OwningAbility,
 7156: 		float TraceDistance = 500.0f,
 7157: 		float TraceRadius = 10.0f,
 7158: 		bool TraceComplex = false,
 7159: 		bool bIgnoreBlockingHits = false,
 7160: 		bool bShowDebug = false);
 7161: 
 7162: 	// Delegado llamado cuando se encuentra una ubicación válida
 7163: 	UPROPERTY(BlueprintAssignable)
 7164: 	FPlacementLocationFound OnLocationFound;
 7165: 
 7166: 	// Se llama cuando se activa la tarea
 7167: 	virtual void Activate() override;
 7168: 
 7169: 	// Se llama cuando se termina la tarea
 7170: 	virtual void OnDestroy(bool bInOwnerFinished) override;
 7171: 
 7172: private:
 7173: 	// Realiza el line trace para encontrar ubicaciones
 7174: 	void PerformTrace();
 7175: 
 7176: 	// Realiza un line trace cada tick para actualizar la ubicación
 7177: 	void TickTask(float DeltaTime);
 7178: 
 7179: 	// Temporizador para realizar el trace
 7180: 	FTimerHandle TraceTimerHandle;
 7181: 
 7182: 	// Distancia del trace
 7183: 	float TraceDistance;
 7184: 
 7185: 	// Radio del trace (para spheretrace)
 7186: 	float TraceRadius;
 7187: 
 7188: 	// Si se debe considerar geometría compleja
 7189: 	bool bTraceComplex;
 7190: 
 7191: 	// Si se deben ignorar hits bloqueantes
 7192: 	bool bIgnoreBlockingHits;
 7193: 
 7194: 	// Si se debe mostrar debug visual
 7195: 	bool bShowDebug;
 7196: 
 7197: 	// Última ubicación de hit encontrada
 7198: 	FVector LastHitLocation;
 7199: 
 7200: 	// Última normal encontrada
 7201: 	FVector LastHitNormal;
 7202: };
 7203: </file>
 7204: 
 7205: <file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h">
 7206: // Fill out your copyright notice in the Description page of Project Settings.
 7207: 
 7208: #pragma once
 7209: 
 7210: #include "CoreMinimal.h"
 7211: #include "Abilities/GameplayAbility.h"
 7212: #include "GA_CauldronPlace.generated.h"
 7213: 
 7214: class ACauldronAltar;
 7215: 
 7216: /**
 7217:  * Gameplay Ability que confirma la colocación del caldero en su posición actual
 7218:  * Se activa con el botón primario durante la previsualización
 7219:  */
 7220: UCLASS()
 7221: class WITCHPT_API UGA_CauldronPlace : public UGameplayAbility
 7222: {
 7223:     GENERATED_BODY()
 7224: 
 7225: public:
 7226:     UGA_CauldronPlace();
 7227: 
 7228:     // Configuración de la habilidad
 7229:     virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 7230: 
 7231: protected:
 7232:     // Encuentra el caldero que está en modo previsualización
 7233:     ACauldronAltar* FindPreviewingCauldron();
 7234: };
 7235: </file>
 7236: 
 7237: <file path="WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h">
 7238: // Fill out your copyright notice in the Description page of Project Settings.
 7239: 
 7240: #pragma once
 7241: 
 7242: #include "CoreMinimal.h"
 7243: #include "Abilities/GameplayAbility.h"
 7244: #include "GA_CauldronPlacementPreview.generated.h"
 7245: 
 7246: class ACauldronAltar;
 7247: 
 7248: /**
 7249:  * Gameplay Ability que permite previsualizar la colocación del caldero
 7250:  * Realiza un line trace continuo y actualiza la posición del caldero en tiempo real.
 7251:  */
 7252: UCLASS()
 7253: class WITCHPT_API UGA_CauldronPlacementPreview : public UGameplayAbility
 7254: {
 7255:     GENERATED_BODY()
 7256: 
 7257: public:
 7258:     UGA_CauldronPlacementPreview();
 7259: 
 7260:     // Configuración de la habilidad
 7261:     virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 7262:     virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;
 7263: 
 7264:     // Función de entrada para confirmar la colocación
 7265:     UFUNCTION()
 7266:     void OnConfirmPlacement();
 7267: 
 7268:     // Función de entrada para cancelar la colocación
 7269:     UFUNCTION()
 7270:     void OnCancelPlacement();
 7271: 
 7272:     // Función llamada cuando se encuentra una nueva ubicación válida
 7273:     UFUNCTION()
 7274:     void OnLocationFound(FVector HitLocation, FVector HitNormal);
 7275: 
 7276: protected:
 7277:     // Encuentra el caldero que el jugador está llevando
 7278:     ACauldronAltar* FindCarriedCauldron();
 7279: 
 7280:     // Distancia máxima del line trace
 7281:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
 7282:     float TraceDistance = 500.0f;
 7283: 
 7284:     // Radio del trace (para sphere trace)
 7285:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
 7286:     float TraceRadius = 10.0f;
 7287: 
 7288:     // Si se debe usar trace complejo
 7289:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
 7290:     bool bTraceComplex = false;
 7291: 
 7292:     // Si se deben mostrar los trazos de debug
 7293:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Placement")
 7294:     bool bShowDebug = true;
 7295: 
 7296: private:
 7297:     // Referencia al caldero que se está colocando
 7298:     UPROPERTY()
 7299:     ACauldronAltar* CauldronAltar;
 7300: };
 7301: </file>
 7302: 
 7303: <file path="WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h">
 7304: // Fill out your copyright notice in the Description page of Project Settings.
 7305: 
 7306: #pragma once
 7307: 
 7308: #include "CoreMinimal.h"
 7309: #include "Abilities/GameplayAbility.h"
 7310: #include "WitchPTGameplayAbility.generated.h"
 7311: 
 7312: /**
 7313:  *
 7314:  */
 7315: UENUM(BlueprintType)
 7316: enum class EPrototypeAbilityActivationPolicy: uint8
 7317: {
 7318: 	// Try to activate the ability when the input is triggered.
 7319: 	OnInputTriggered,
 7320: 
 7321: 	// Continually try to activate the ability while the input is active.
 7322: 	WhileInputActive,
 7323: 
 7324: 	// Try to activate the ability when an avatar is assigned.
 7325: 	OnSpawn,
 7326: 
 7327: 	OnTriggeredEvent
 7328: };
 7329: UCLASS()
 7330: class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
 7331: {
 7332: 	GENERATED_BODY()
 7333: public:
 7334: 	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 7335: 	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
 7336: 	UPROPERTY(EditDefaultsOnly, Category="Input")
 7337: 	FGameplayTag StartupInputTag;
 7338: 	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
 7339: protected:
 7340: 
 7341: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
 7342: 	EPrototypeAbilityActivationPolicy ActivationPolicy;
 7343: 
 7344: 	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
 7345: };
 7346: </file>
 7347: 
 7348: <file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h">
 7349: // Fill out your copyright notice in the Description page of Project Settings.
 7350: 
 7351: #pragma once
 7352: 
 7353: #include "CoreMinimal.h"
 7354: #include "Abilities/Tasks/AbilityTask.h"
 7355: #include "AbilityTask_GrantNearbyInteraction.generated.h"
 7356: 
 7357: /**
 7358:  *
 7359:  */
 7360: UCLASS()
 7361: class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
 7362: {
 7363: 	GENERATED_UCLASS_BODY()
 7364: 
 7365: 
 7366: 	virtual void Activate() override;
 7367: 	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;
 7368: 
 7369: 	/** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */
 7370: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
 7371: 	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);
 7372: 
 7373: private:
 7374: 	virtual void OnDestroy(bool AbilityEnded) override;
 7375: 
 7376: 	void QueryInteractables();
 7377: 	float InteractionScanRange = 100;
 7378: 	float InteractionScanRate = 0.100;
 7379: 	FTimerHandle QueryTimerHandle;
 7380: 
 7381: 	// Cache para habilidades de interacción rápida
 7382: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
 7383: 
 7384: 	// Cache para habilidades de interacción mantenida
 7385: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;
 7386: 
 7387: };
 7388: </file>
 7389: 
 7390: <file path="WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h">
 7391: // Fill out your copyright notice in the Description page of Project Settings.
 7392: 
 7393: #pragma once
 7394: 
 7395: #include "CoreMinimal.h"
 7396: #include "Abilities/Tasks/AbilityTask.h"
 7397: #include "Engine/CollisionProfile.h"
 7398: #include "InteractionOption.h"
 7399: #include "AbilityTask_WaitForInteractable.generated.h"
 7400: 
 7401: /**
 7402:  *
 7403:  */
 7404: class AActor;
 7405: class IInteractableTarget;
 7406: class UObject;
 7407: class UWorld;
 7408: struct FCollisionQueryParams;
 7409: struct FHitResult;
 7410: struct FInteractionQuery;
 7411: template <typename InterfaceType> class TScriptInterface;
 7412: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);
 7413: 
 7414: UCLASS(Abstract)
 7415: class UAbilityTask_WaitForInteractable : public UAbilityTask
 7416: {
 7417: 	GENERATED_UCLASS_BODY()
 7418: 
 7419: public:
 7420: 	UPROPERTY(BlueprintAssignable)
 7421: 	FInteractableObjectsChangedEvent InteractableObjectsChanged;
 7422: 
 7423: protected:
 7424: 
 7425: 	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);
 7426: 
 7427: 	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;
 7428: 
 7429: 	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);
 7430: 
 7431: 	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);
 7432: 
 7433: 	ECollisionChannel TraceProfile;
 7434: 
 7435: 	// Does the trace affect the aiming pitch
 7436: 	bool bTraceAffectsAimPitch = true;
 7437: 
 7438: 	TArray<FInteractionOption> CurrentOptions;
 7439: 
 7440: };
 7441: </file>
 7442: 
 7443: <file path="WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h">
 7444: // Fill out your copyright notice in the Description page of Project Settings.
 7445: 
 7446: #pragma once
 7447: 
 7448: #include "CoreMinimal.h"
 7449: #include "InteractionQuery.h"
 7450: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 7451: #include "AT_WaitForInteractable_SLT.generated.h"
 7452: struct FCollisionProfileName;
 7453: 
 7454: class UGameplayAbility;
 7455: class UObject;
 7456: struct FFrame;
 7457: /**
 7458:  *
 7459:  */
 7460: UCLASS()
 7461: class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
 7462: {
 7463: 	GENERATED_UCLASS_BODY()
 7464: 
 7465: 	virtual void Activate() override;
 7466: 
 7467: 	/** Wait until we trace new set of interactables.  This task automatically loops. */
 7468: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
 7469: 	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);
 7470: 
 7471: private:
 7472: 
 7473: 	virtual void OnDestroy(bool AbilityEnded) override;
 7474: 
 7475: 	void PerformTrace();
 7476: 
 7477: 	UPROPERTY()
 7478: 	FInteractionQuery InteractionQuery;
 7479: 
 7480: 	UPROPERTY()
 7481: 	FGameplayAbilityTargetingLocationInfo StartLocation;
 7482: 
 7483: 	float InteractionScanRange = 100;
 7484: 	float InteractionScanRate = 0.100;
 7485: 	bool bShowDebug = false;
 7486: 
 7487: 	FTimerHandle TimerHandle;
 7488: 
 7489: };
 7490: </file>
 7491: 
 7492: <file path="WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h">
 7493: // Fill out your copyright notice in the Description page of Project Settings.
 7494: 
 7495: #pragma once
 7496: 
 7497: #include "CoreMinimal.h"
 7498: #include "InteractionOption.h"
 7499: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 7500: #include "GameplayAbility_Interact.generated.h"
 7501: 
 7502: class UObject;
 7503: struct FFrame;
 7504: struct FGameplayAbilityActorInfo;
 7505: struct FGameplayEventData;
 7506: 
 7507: // Delegado para notificar cuando se completa una interacción
 7508: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);
 7509: 
 7510: /**
 7511:  *
 7512:  */
 7513: UCLASS(Abstract)
 7514: class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
 7515: {
 7516: 	GENERATED_BODY()
 7517: 	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 7518: 	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 7519: 
 7520: 	UFUNCTION(BlueprintCallable)
 7521: 	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
 7522: 
 7523: 	// Método para interacción de pulsación rápida
 7524: 	UFUNCTION(BlueprintCallable)
 7525: 	void TriggerInteraction();
 7526: 
 7527: 	// Método para interacción manteniendo pulsado
 7528: 	UFUNCTION(BlueprintCallable)
 7529: 	void TriggerHoldInteraction();
 7530: 
 7531: 	// Método llamado cuando se presiona el botón de interacción
 7532: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 7533: 	void OnInteractionButtonPressed();
 7534: 
 7535: 	// Método llamado cuando se suelta el botón de interacción
 7536: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 7537: 	void OnInteractionButtonReleased();
 7538: 
 7539: 	// Método llamado cuando se cumple el tiempo de interacción mantenida
 7540: 	UFUNCTION()
 7541: 	void OnHoldInteractionTimeElapsed();
 7542: 
 7543:     // Método que verifica si el objeto bajo el trace sigue siendo el mismo
 7544:     UFUNCTION()
 7545:     void CheckInteractionValidity();
 7546: 
 7547:     // Método que cancela una interacción en curso
 7548:     UFUNCTION(BlueprintCallable, Category = "Interaction")
 7549:     void CancelCurrentInteraction();
 7550: 
 7551:     // Método de seguridad que se activa si una interacción dura demasiado tiempo
 7552:     UFUNCTION()
 7553:     void OnMaxInteractionTimeElapsed();
 7554: 
 7555: 	// Delegado que se dispara cuando se completa una interacción
 7556: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 7557: 	FOnInteractionComplete OnInteractionComplete;
 7558: 
 7559: 	// Delegado que se dispara cuando se completa una interacción mantenida
 7560: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 7561: 	FOnInteractionComplete OnHoldInteractionComplete;
 7562: 
 7563:     // Delegado que se dispara cuando se cancela una interacción
 7564:     UPROPERTY(BlueprintAssignable, Category = "Interaction")
 7565:     FOnInteractionComplete OnInteractionCancelled;
 7566: 
 7567: protected:
 7568: 
 7569: 	UPROPERTY(BlueprintReadWrite)
 7570: 	TArray<FInteractionOption> CurrentOptions;
 7571: 
 7572: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
 7573: 	float InteractionScanRate = 0.1f;
 7574: 
 7575: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
 7576: 	float InteractionScanRange = 500;
 7577: 
 7578: 	// Tiempo mínimo que debe mantenerse presionado el botón para considerar una interacción mantenida
 7579: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
 7580: 	float HoldInteractionTime = 1.0f;
 7581: 
 7582:     // Frecuencia para verificar si el objeto interactuable sigue siendo válido durante una interacción mantenida
 7583:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
 7584:     float ValidityCheckRate = 0.1f;
 7585: 
 7586:     // Tiempo máximo que puede durar cualquier interacción antes de ser cancelada automáticamente
 7587:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
 7588:     float MaxInteractionTime = 10.0f;
 7589: 
 7590: 	// Temporizador para detectar interacción mantenida
 7591: 	FTimerHandle HoldInteractionTimerHandle;
 7592: 
 7593:     // Temporizador para verificar la validez del objeto interactuable
 7594:     FTimerHandle ValidityCheckTimerHandle;
 7595: 
 7596:     // Temporizador de seguridad para forzar el reinicio después de un tiempo máximo
 7597:     FTimerHandle MaxInteractionTimeTimerHandle;
 7598: 
 7599: 	// Estado del botón de interacción (presionado o no)
 7600: 	bool bIsInteractionButtonHeld = false;
 7601: 
 7602: 	// Tiempo en que se inició la pulsación
 7603: 	float InteractionStartTime = 0.0f;
 7604: 
 7605: 	// Indica si ya se disparó una interacción mantenida para la pulsación actual
 7606: 	bool bHoldInteractionFired = false;
 7607: 
 7608:     // Guarda el objeto con el que se inició la interacción para compararlo
 7609:     TScriptInterface<IInteractableTarget> InitialInteractableTarget;
 7610: 
 7611: 	UPROPERTY(EditDefaultsOnly)
 7612: 	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
 7613: 
 7614: 
 7615: };
 7616: </file>
 7617: 
 7618: <file path="WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h">
 7619: // Copyright Epic Games, Inc. All Rights Reserved.
 7620: 
 7621: #pragma once
 7622: 
 7623: #include "CoreMinimal.h"
 7624: #include "Abilities/GameplayAbility.h"
 7625: #include "InteractionOption.h"
 7626: #include "IInteractableTarget.generated.h"
 7627: 
 7628: struct FInteractionQuery;
 7629: 
 7630: /**  */
 7631: class FInteractionOptionBuilder
 7632: {
 7633: public:
 7634: 	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
 7635: 		: Scope(InterfaceTargetScope)
 7636: 		, Options(InteractOptions)
 7637: 	{
 7638: 	}
 7639: 
 7640: 	void AddInteractionOption(const FInteractionOption& Option)
 7641: 	{
 7642: 		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
 7643: 		OptionEntry.InteractableTarget = Scope;
 7644: 	}
 7645: 
 7646: private:
 7647: 	TScriptInterface<IInteractableTarget> Scope;
 7648: 	TArray<FInteractionOption>& Options;
 7649: };
 7650: 
 7651: /**  */
 7652: UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
 7653: class UInteractableTarget : public UInterface
 7654: {
 7655: 	GENERATED_BODY()
 7656: };
 7657: 
 7658: 
 7659: class IInteractableTarget
 7660: {
 7661: 	GENERATED_BODY()
 7662: 
 7663: public:
 7664: 	/**  */
 7665: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;
 7666: 
 7667: 	/**  */
 7668: 	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
 7669: 
 7670: 	/**
 7671: 	 * Determina si este objeto interactuable soporta interacción mantenida
 7672: 	 * @return Verdadero si el objeto soporta interacción mantenida, falso en caso contrario
 7673: 	 */
 7674: 	virtual bool SupportsHoldInteraction() const { return false; }
 7675: 
 7676: 	/**
 7677: 	 * Obtiene la habilidad que se debe activar cuando se realiza una interacción mantenida
 7678: 	 * @return El handle de la habilidad para interacción mantenida
 7679: 	 */
 7680: 	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
 7681: };
 7682: </file>
 7683: 
 7684: <file path="WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h">
 7685: #pragma once
 7686: 
 7687: #include "CoreMinimal.h"
 7688: #include "Abilities/GameplayAbility.h"
 7689: #include "InteractionOption.generated.h"
 7690: 
 7691: class IInteractableTarget;
 7692: // class UUserWidget;
 7693: 
 7694: /**  */
 7695: USTRUCT(BlueprintType)
 7696: struct FInteractionOption
 7697: {
 7698: 	GENERATED_BODY()
 7699: 
 7700: public:
 7701: 	/** The interactable target */
 7702: 	UPROPERTY(BlueprintReadWrite)
 7703: 	TScriptInterface<IInteractableTarget> InteractableTarget;
 7704: 
 7705: 	/** Simple text the interaction might return */
 7706: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 7707: 	FText Text;
 7708: 
 7709: 	/** Simple sub-text the interaction might return */
 7710: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 7711: 	FText SubText;
 7712: 
 7713: 	// METHODS OF INTERACTION
 7714: 	//--------------------------------------------------------------
 7715: 
 7716: 	// 1) Place an ability on the avatar that they can activate when they perform interaction.
 7717: 
 7718: 	/** The ability to grant the avatar when they get near interactable objects. */
 7719: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 7720: 	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;
 7721: 
 7722: 	// - OR -
 7723: 
 7724: 	// 2) Allow the object we're interacting with to have its own ability system and interaction ability, that we can activate instead.
 7725: 
 7726: 	/** The ability system on the target that can be used for the TargetInteractionHandle and sending the event, if needed. */
 7727: 	UPROPERTY(BlueprintReadOnly)
 7728: 	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;
 7729: 
 7730: 	/** The ability spec to activate on the object for this option. */
 7731: 	UPROPERTY(BlueprintReadOnly)
 7732: 	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
 7733: 
 7734: 	/** Indica si esta opción de interacción soporta interacción mantenida */
 7735: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 7736: 	bool bSupportsHoldInteraction = false;
 7737: 
 7738: 	/** La habilidad a activar cuando se mantiene presionado el botón de interacción */
 7739: 	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
 7740: 	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
 7741: 
 7742: 	/** La habilidad para interacción mantenida en el objetivo */
 7743: 	UPROPERTY(BlueprintReadOnly)
 7744: 	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;
 7745: 
 7746: 	// UI
 7747: 	//--------------------------------------------------------------
 7748: 
 7749: 	/** The widget to show for this kind of interaction. */
 7750: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 7751: 	TSoftClassPtr<UUserWidget> InteractionWidgetClass;
 7752: 
 7753: 	//--------------------------------------------------------------
 7754: 
 7755: public:
 7756: 	FORCEINLINE bool operator==(const FInteractionOption& Other) const
 7757: 	{
 7758: 		return InteractableTarget == Other.InteractableTarget &&
 7759: 			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
 7760: 			TargetAbilitySystem == Other.TargetAbilitySystem &&
 7761: 			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
 7762: 			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
 7763: 			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
 7764: 			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
 7765: 			// InteractionWidgetClass == Other.InteractionWidgetClass &&
 7766: 			Text.IdenticalTo(Other.Text) &&
 7767: 			SubText.IdenticalTo(Other.SubText);
 7768: 	}
 7769: 
 7770: 	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
 7771: 	{
 7772: 		return !operator==(Other);
 7773: 	}
 7774: 
 7775: 	FORCEINLINE bool operator<(const FInteractionOption& Other) const
 7776: 	{
 7777: 		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
 7778: 	}
 7779: };
 7780: </file>
 7781: 
 7782: <file path="WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h">
 7783: // Copyright Epic Games, Inc. All Rights Reserved.
 7784: 
 7785: #pragma once
 7786: 
 7787: #include "CoreMinimal.h"
 7788: #include "Abilities/GameplayAbility.h"
 7789: #include "InteractionQuery.generated.h"
 7790: 
 7791: 
 7792: /**  */
 7793: USTRUCT(BlueprintType)
 7794: struct FInteractionQuery
 7795: {
 7796: 	GENERATED_BODY()
 7797: 
 7798: public:
 7799: 	/** The requesting pawn. */
 7800: 	UPROPERTY(BlueprintReadWrite)
 7801: 	TWeakObjectPtr<AActor> RequestingAvatar;
 7802: 
 7803: 	/** Allow us to specify a controller - does not need to match the owner of the requesting avatar. */
 7804: 	UPROPERTY(BlueprintReadWrite)
 7805: 	TWeakObjectPtr<AController> RequestingController;
 7806: 
 7807: 	/** A generic UObject to shove in extra data required for the interaction */
 7808: 	UPROPERTY(BlueprintReadWrite)
 7809: 	TWeakObjectPtr<UObject> OptionalObjectData;
 7810: };
 7811: </file>
 7812: 
 7813: <file path="WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h">
 7814: // Fill out your copyright notice in the Description page of Project Settings.
 7815: 
 7816: #pragma once
 7817: 
 7818: #include "CoreMinimal.h"
 7819: #include "Kismet/BlueprintFunctionLibrary.h"
 7820: #include "InteractionStatics.generated.h"
 7821: 
 7822: template <typename InterfaceType> class TScriptInterface;
 7823: class AActor;
 7824: class IInteractableTarget;
 7825: class UObject;
 7826: 
 7827: /**
 7828:  *
 7829:  */
 7830: UCLASS()
 7831: class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
 7832: {
 7833: 	GENERATED_BODY()
 7834: public:
 7835: 	UInteractionStatics();
 7836: 
 7837: public:
 7838: 	UFUNCTION(BlueprintCallable)
 7839: 	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);
 7840: 
 7841: 	UFUNCTION(BlueprintCallable)
 7842: 	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
 7843: 	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
 7844: 	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
 7845: };
 7846: </file>
 7847: 
 7848: <file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h">
 7849: // Fill out your copyright notice in the Description page of Project Settings.
 7850: 
 7851: #pragma once
 7852: 
 7853: #include "CoreMinimal.h"
 7854: #include "AbilitySystemComponent.h"
 7855: #include "WitchPTAbilitySystemComponent.generated.h"
 7856: 
 7857: DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& /* Asset tags that the GE have*/)
 7858: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 7859: class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
 7860: {
 7861: 	GENERATED_BODY()
 7862: 
 7863: public:
 7864: 	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
 7865: 
 7866: 	void AbilityInputTagPressed(const FGameplayTag& InputTag);
 7867: 	void AbilityInputTagHeld(const FGameplayTag& InputTag);
 7868: 	void AbilityInputTagReleased(const FGameplayTag& InputTag);
 7869: 	void AbilityActorInfoHaveBeenSet();
 7870: 
 7871: 	FEffectAssetTags OnEffectAssetTags;
 7872: 
 7873: 	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
 7874: 
 7875: 	bool bCharacterAbilitiesGiven = false;
 7876: 	bool bStartupEffectsApplied = false;
 7877: 
 7878: 	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;
 7879: 
 7880: 	// Handles to abilities that had their input pressed this frame.
 7881: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 7882: 	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;
 7883: 
 7884: 	// Handles to abilities that had their input released this frame.
 7885: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 7886: 	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;
 7887: 
 7888: 
 7889: 	// Handles to abilities that have their input held.
 7890: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 7891: 	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
 7892: 
 7893: protected:
 7894: 	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
 7895: 	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
 7896: 	UFUNCTION(Client, Reliable)
 7897: 	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
 7898: 
 7899: };
 7900: </file>
 7901: 
 7902: <file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h">
 7903: // Fill out your copyright notice in the Description page of Project Settings.
 7904: 
 7905: #pragma once
 7906: 
 7907: #include "CoreMinimal.h"
 7908: #include "AbilitySystemGlobals.h"
 7909: #include "WitchPTAbilitySystemGlobals.generated.h"
 7910: 
 7911: /**
 7912:  *
 7913:  */
 7914: UCLASS()
 7915: class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
 7916: {
 7917: 	GENERATED_BODY()
 7918: };
 7919: </file>
 7920: 
 7921: <file path="WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h">
 7922: // Fill out your copyright notice in the Description page of Project Settings.
 7923: 
 7924: #pragma once
 7925: 
 7926: #include "CoreMinimal.h"
 7927: #include "Kismet/BlueprintFunctionLibrary.h"
 7928: #include "WitchPTAbilitySystemLibrary.generated.h"
 7929: 
 7930: class IMechanicsInterface;
 7931: /**
 7932:  *
 7933:  */
 7934: UCLASS()
 7935: class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
 7936: {
 7937: 	GENERATED_BODY()
 7938: 	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
 7939: 	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
 7940: };
 7941: </file>
 7942: 
 7943: <file path="WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h">
 7944: // Fill out your copyright notice in the Description page of Project Settings.
 7945: 
 7946: #pragma once
 7947: 
 7948: #include "CoreMinimal.h"
 7949: #include "AbilitySystemComponent.h"
 7950: #include "AttributeSet.h"
 7951: #include "WitchPTAttributeSet.generated.h"
 7952: 
 7953: /**
 7954:  *
 7955:  */
 7956: // Macro for attribute accessors
 7957: // Functions: Getter, Setter, Initializer. The initializer set the base and current value!
 7958: #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 7959: GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 7960: GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 7961: GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 7962: GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 7963: 
 7964: // This syntax is a fucking nightmare, but...ok
 7965: UCLASS()
 7966: class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
 7967: {
 7968: 	GENERATED_BODY()
 7969: public:
 7970: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 7971: 	UWitchPTAttributeSet();
 7972: 	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
 7973: 	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 7974: 
 7975: 
 7976: 	/**
 7977: 	 * Vital Attributes
 7978: 	 */
 7979: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
 7980: 	FGameplayAttributeData Age;
 7981: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
 7982: 
 7983: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
 7984: 	FGameplayAttributeData MaxAge;
 7985: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
 7986: 
 7987: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
 7988: 	FGameplayAttributeData Health;
 7989: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
 7990: 
 7991: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
 7992: 	FGameplayAttributeData MaxHealth;
 7993: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
 7994: 
 7995: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
 7996: 	FGameplayAttributeData Strength;
 7997: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
 7998: 
 7999: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
 8000: 	FGameplayAttributeData MaxStrength;
 8001: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
 8002: 
 8003: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
 8004: 	FGameplayAttributeData Mana;
 8005: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
 8006: 
 8007: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
 8008: 	FGameplayAttributeData MaxMana;
 8009: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
 8010: 
 8011: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
 8012: 	FGameplayAttributeData Stamina;
 8013: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
 8014: 
 8015: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
 8016: 	FGameplayAttributeData MaxStamina;
 8017: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);
 8018: 
 8019: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
 8020: 	FGameplayAttributeData SpeedMultiplier;
 8021: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);
 8022: 
 8023: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
 8024: 	FGameplayAttributeData MaxSpeedMultiplier;
 8025: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);
 8026: 
 8027: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
 8028: 	FGameplayAttributeData MoveSpeed;
 8029: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);
 8030: 
 8031: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
 8032: 	FGameplayAttributeData MaxMoveSpeed;
 8033: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);
 8034: 
 8035: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
 8036: 	FGameplayAttributeData MinMoveSpeed;
 8037: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);
 8038: 
 8039: 
 8040: 
 8041: 
 8042: 	// Replication functions
 8043: 	UFUNCTION()
 8044: 	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
 8045: 	UFUNCTION()
 8046: 	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
 8047: 	UFUNCTION()
 8048: 	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
 8049: 	UFUNCTION()
 8050: 	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
 8051: 	UFUNCTION()
 8052: 	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
 8053: 	UFUNCTION()
 8054: 	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
 8055: 	UFUNCTION()
 8056: 	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
 8057: 	UFUNCTION()
 8058: 	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
 8059: 	UFUNCTION()
 8060: 	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
 8061: 	UFUNCTION()
 8062: 	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
 8063: 	UFUNCTION()
 8064: 	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
 8065: 	UFUNCTION()
 8066: 	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
 8067: 	UFUNCTION()
 8068: 	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
 8069: 	UFUNCTION()
 8070: 	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
 8071: 	UFUNCTION()
 8072: 	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
 8073: };
 8074: </file>
 8075: 
 8076: <file path="WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h">
 8077: // Fill out your copyright notice in the Description page of Project Settings.
 8078: 
 8079: #pragma once
 8080: 
 8081: #include "CoreMinimal.h"
 8082: #include "GameFramework/CharacterMovementComponent.h"
 8083: #include "WitchPTCharacterMovementComponent.generated.h"
 8084: 
 8085: 
 8086: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 8087: class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
 8088: {
 8089: 	GENERATED_BODY()
 8090: 
 8091: public:
 8092: 	UWitchPTCharacterMovementComponent();
 8093: 	uint8 RequestToStartSprinting : 1;
 8094: 	uint8 RequestToStartADS : 1;
 8095: 	virtual float GetMaxSpeed() const override;
 8096: 	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
 8097: 	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
 8098: 	// Sprint
 8099: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
 8100: 	void StartSprinting();
 8101: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
 8102: 	void StopSprinting();
 8103: 
 8104: 
 8105: 	// Aim Down Sights
 8106: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
 8107: 	void StartAimDownSights();
 8108: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
 8109: 	void StopAimDownSights();
 8110: };
 8111: </file>
 8112: 
 8113: <file path="WitchPT/Public/Character/Components/WitchPTMechanicComponent.h">
 8114: // Fill out your copyright notice in the Description page of Project Settings.
 8115: 
 8116: #pragma once
 8117: 
 8118: #include "CoreMinimal.h"
 8119: #include "Components/ActorComponent.h"
 8120: #include "Item/MechanicsInterface.h"
 8121: #include "WitchPTMechanicComponent.generated.h"
 8122: 
 8123: class ACauldronAltar;
 8124: 
 8125: UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
 8126: class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
 8127: {
 8128: 	GENERATED_BODY()
 8129: 
 8130: public:
 8131: 	// Sets default values for this component's properties
 8132: 	UWitchPTMechanicComponent();
 8133: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 8134: 
 8135: 	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
 8136: 	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
 8137: 	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
 8138: 	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
 8139: 	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
 8140: 	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
 8141: 	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
 8142: 	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
 8143: 	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
 8144: 	virtual void RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
 8145: 
 8146: 	UFUNCTION(Server, Reliable)
 8147: 	void Server_RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
 8148: 
 8149: 
 8150: 
 8151: 
 8152: 	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
 8153: 	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
 8154: 	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
 8155: 	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
 8156: 	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
 8157: 
 8158: 
 8159: 
 8160: 
 8161: protected:
 8162: 
 8163: 
 8164: 	virtual void BeginPlay() override;
 8165: 
 8166: public:
 8167: 	// Called every frame
 8168: 	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
 8169: };
 8170: </file>
 8171: 
 8172: <file path="WitchPT/Public/Character/WitchPTCharacter.h">
 8173: // Fill out your copyright notice in the Description page of Project Settings.
 8174: 
 8175: #pragma once
 8176: 
 8177: #include "CoreMinimal.h"
 8178: #include "WitchPTCharacterBase.h"
 8179: #include "Item/CauldronAltar.h"
 8180: #include "Item/MechanicsInterface.h"
 8181: #include "Blueprint/UserWidget.h"
 8182: #include "Components/WidgetComponent.h" // Necesitas un Widget Component
 8183: #include "UObject/ConstructorHelpers.h"
 8184: #include "WitchPTCharacter.generated.h"
 8185: 
 8186: class UWitchPTMechanicComponent;
 8187: class ACauldronAltar;
 8188: class ARitualPosition;
 8189: 
 8190: UCLASS()
 8191: class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
 8192: {
 8193: 	GENERATED_BODY()
 8194: 
 8195: public:
 8196: 	// Sets default values for this character's properties
 8197: 	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
 8198: 	virtual void PossessedBy(AController* NewController) override;
 8199: 	virtual void OnRep_PlayerState() override;
 8200: 
 8201: 	virtual void InitAbilityActorInfo() override;
 8202: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
 8203: 	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
 8204: 
 8205: 
 8206: 
 8207: 
 8208: 
 8209: 
 8210: 
 8211: 
 8212: 
 8213: 
 8214: };
 8215: </file>
 8216: 
 8217: <file path="WitchPT/Public/Character/WitchPTCharacterBase.h">
 8218: // Fill out your copyright notice in the Description page of Project Settings.
 8219: 
 8220: #pragma once
 8221: 
 8222: #include "CoreMinimal.h"
 8223: #include "AbilitySystemInterface.h"
 8224: #include "GameFramework/Character.h"
 8225: #include "WitchPTCharacterBase.generated.h"
 8226: 
 8227: class UWitchPTAbilitySystemComponent;
 8228: class UWitchPTAttributeSet;
 8229: class UGameplayAbility;
 8230: class UGameplayEffect;
 8231: class UAttributeSet;
 8232: 
 8233: UCLASS(Abstract)
 8234: class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
 8235: {
 8236: 	GENERATED_BODY()
 8237: 
 8238: public:
 8239: 	// Sets default values for this character's properties
 8240: 	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);
 8241: 
 8242: 	// Getter for ASC Main Components
 8243: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
 8244: 	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }
 8245: 
 8246: protected:
 8247: 	UPROPERTY()
 8248: 	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
 8249: 	UPROPERTY()
 8250: 	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
 8251: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
 8252: 
 8253: 	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
 8254: 	TSubclassOf<UGameplayEffect> DefaultAttributes;
 8255: 	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
 8256: 	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
 8257: 
 8258: 	// These effects are only applied one time on startup
 8259: 	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
 8260: 	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;
 8261: 
 8262: 	virtual void InitializeDefaultAttributes();
 8263: 
 8264: 	virtual void GrantStartupAbilities();
 8265: 
 8266: 	virtual void AddStartupEffects();
 8267: 
 8268: 	virtual void InitAbilityActorInfo();
 8269: private:
 8270: 	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);
 8271: 
 8272: 
 8273: 
 8274: public:
 8275: 	/**
 8276: 	* Getters for attributes from GDAttributeSetBase
 8277: 	**/
 8278: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8279: 	float GetHealth() const;
 8280: 
 8281: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8282: 	float GetMaxHealth() const;
 8283: 
 8284: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8285: 	float GetStamina() const;
 8286: 
 8287: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8288: 	float GetMaxStamina() const;
 8289: 
 8290: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8291: 	float GetAge() const;
 8292: 
 8293: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8294: 	float GetMaxAge() const;
 8295: 
 8296: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8297: 	float GetMana() const;
 8298: 
 8299: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8300: 	float GetMaxMana() const;
 8301: 
 8302: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8303: 	float GetSpeedMultiplier() const;
 8304: 
 8305: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8306: 	float GetMoveSpeed() const;
 8307: 
 8308: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 8309: 	float GetMaxMoveSpeed() const;
 8310: 
 8311: 
 8312: 
 8313: 
 8314: 
 8315: 
 8316: 
 8317: };
 8318: </file>
 8319: 
 8320: <file path="WitchPT/Public/Character/WitchPTEnemy.h">
 8321: // Fill out your copyright notice in the Description page of Project Settings.
 8322: 
 8323: #pragma once
 8324: 
 8325: #include "CoreMinimal.h"
 8326: #include "WitchPTCharacterBase.h"
 8327: #include "WitchPTEnemy.generated.h"
 8328: 
 8329: UCLASS()
 8330: class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
 8331: {
 8332: 	GENERATED_BODY()
 8333: 
 8334: public:
 8335: 	// Sets default values for this character's properties
 8336: 	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);
 8337: 
 8338: protected:
 8339: 	// Called when the game starts or when spawned
 8340: 	virtual void BeginPlay() override;
 8341: 
 8342: public:
 8343: 	// Called every frame
 8344: 	virtual void Tick(float DeltaTime) override;
 8345: 
 8346: 	// Called to bind functionality to input
 8347: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
 8348: };
 8349: </file>
 8350: 
 8351: <file path="WitchPT/Public/FWitchPTGameplayTags.cpp">
 8352: #include "FWitchPTGameplayTags.h"
 8353: 
 8354: #include "GameplayTagsManager.h"
 8355: 
 8356: FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;
 8357: 
 8358: void FWitchPTGameplayTags::InitializeGameplayTags()
 8359: {
 8360: 	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
 8361: 	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
 8362: 	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
 8363: 	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
 8364: 	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
 8365: 	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
 8366: 	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
 8367: 	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
 8368: 	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
 8369: 	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
 8370: 	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
 8371: 	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
 8372: 	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
 8373: 	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
 8374: 	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
 8375: 	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
 8376: 	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));
 8377: 
 8378: 	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
 8379: 	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
 8380: 	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
 8381: 	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
 8382: 
 8383: 	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
 8384: 	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
 8385: 	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
 8386: 	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
 8387: 	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
 8388: 	// Cauldron Abilities
 8389: 	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
 8390: 	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
 8391: 	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
 8392: 	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
 8393: 	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
 8394: 	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
 8395: 	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));
 8396: 
 8397: 	/**
 8398: 	 * Input Tags
 8399: 	 */
 8400: 	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
 8401: 	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
 8402: 	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
 8403: 	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
 8404: 	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
 8405: 	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
 8406: 	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
 8407: 	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
 8408: 	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
 8409: 	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
 8410: 	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
 8411: 	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
 8412: 	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
 8413: 	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
 8414: 	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
 8415: 	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
 8416: 	// Ritual
 8417: 	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
 8418: 	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
 8419: 	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
 8420: 	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));
 8421: 
 8422: 	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
 8423: 	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
 8424: 	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
 8425: 	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));
 8426: 
 8427: 	// --- Ritual Event Tags ---
 8428: 	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
 8429: 	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
 8430: 	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
 8431: 	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
 8432: 	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
 8433: 	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
 8434: 	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));
 8435: 
 8436: 
 8437: 	// Cauldron Tags
 8438: 	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
 8439: 	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
 8440: 	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
 8441: 
 8442: 
 8443: 	// Communication Messages
 8444: 	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));
 8445: 
 8446: 	// --- Items Tags ---
 8447: 	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
 8448: 	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
 8449: 	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
 8450: 	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
 8451: 	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
 8452: 	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
 8453: 	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));
 8454: 
 8455: 	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
 8456: 	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
 8457: 	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
 8458: 	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
 8459: 	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));
 8460: 
 8461: 
 8462: 
 8463: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
 8464: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
 8465: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
 8466: 
 8467: 	// Base Category Tags
 8468: 	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
 8469: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
 8470: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
 8471: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));
 8472: 
 8473: 	// Principal Category Tags
 8474: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
 8475: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
 8476: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
 8477: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));
 8478: 
 8479: 	// Modifier Category Tags
 8480: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
 8481: 
 8482: 	// Modifier Potency Tags
 8483: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
 8484: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
 8485: 
 8486: 	// Modifier Duration Tags
 8487: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
 8488: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
 8489: 
 8490: 	// Modifier Charges Tags
 8491: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
 8492: 
 8493: 	// Modifier Target Tags
 8494: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
 8495: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
 8496: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));
 8497: 
 8498: }
 8499: </file>
 8500: 
 8501: <file path="WitchPT/Public/FWitchPTGameplayTags.h">
 8502: #pragma once
 8503: 
 8504: #include "CoreMinimal.h"
 8505: #include "GameplayTagContainer.h"
 8506: 	/**
 8507: 	 * @brief Singleton accessor to all native GameplayTags.
 8508: 	 *
 8509: 	 * @return Reference to the singleton instance of WitchPTGameplayTags.
 8510: 	 * @note To use the Singleton:
 8511: 	 * const FAuraGameplayTags& AuraGameplayTags = FAuraGameplayTags::Get();
 8512: 	 */
 8513: struct FWitchPTGameplayTags
 8514: {
 8515: public:
 8516: 	static FWitchPTGameplayTags& Get() { return GameplayTags; }
 8517: 	static void InitializeGameplayTags();
 8518: 
 8519: 
 8520: 	/**
 8521: 	* Attributes Primary Tags
 8522: 	*/
 8523: 	FGameplayTag Attributes_Primary_Health;
 8524: 	FGameplayTag Attributes_Primary_Age;
 8525: 	FGameplayTag Attributes_Secondary_Mana;
 8526: 	FGameplayTag Attributes_Secondary_Stamina;
 8527: 	// State Tags
 8528: 	FGameplayTag Character_State_Movement_Sprinting;
 8529: 	FGameplayTag Character_State_Movement_Crouching;
 8530: 	FGameplayTag Character_State_Movement_MovingToPosition;
 8531: 	FGameplayTag Character_State_Dead;
 8532: 	FGameplayTag Character_State_Aim;
 8533: 	FGameplayTag Character_State_Blocked;
 8534: 
 8535: 	FGameplayTag Character_State_Cauldron_InPosition;
 8536: 	FGameplayTag Character_State_Cauldron_Carrying;
 8537: 	FGameplayTag Character_State_Cauldron_Placing;
 8538: 	FGameplayTag Character_State_Cauldron_InGame;
 8539: 	FGameplayTag Character_State_Cauldron_BrewingPotion;
 8540: 
 8541: 	FGameplayTag Character_State_Ritual_InPosition;
 8542: 	FGameplayTag Character_State_Ritual_InGame;
 8543: 
 8544: 	// Ability Tags
 8545: 	FGameplayTag Ability_Interact;
 8546: 	FGameplayTag Ability_Sprint;
 8547: 	FGameplayTag Ability_Jump;
 8548: 	FGameplayTag Ability_Crouch;
 8549: 	FGameplayTag Ability_Ritual_GoToPosition;
 8550: 	FGameplayTag Ability_Ritual_ParticipatingInRitual;
 8551: 	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
 8552: 	FGameplayTag Ability_Ritual_Start;
 8553: 	FGameplayTag Ability_Ritual_SendInput;
 8554: 
 8555: 
 8556: 
 8557: 
 8558: 
 8559: 
 8560: 	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
 8561: 	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
 8562: 	FGameplayTag Ability_Cauldron_CarryingCauldron;
 8563: 	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
 8564: 	FGameplayTag Ability_Cauldron_SetInPlace;
 8565: 	FGameplayTag Ability_Cauldron_CancelSetInPlace;
 8566: 
 8567: 
 8568: 
 8569: 
 8570: 
 8571: 
 8572: 	// Input Tags
 8573: 	FGameplayTag InputTag_LMB;
 8574: 	FGameplayTag InputTag_RMB;
 8575: 	FGameplayTag InputTag_1;
 8576: 	FGameplayTag InputTag_2;
 8577: 	FGameplayTag InputTag_3;
 8578: 	FGameplayTag InputTag_4;
 8579: 	FGameplayTag InputTag_5;
 8580: 	FGameplayTag InputTag_6;
 8581: 	FGameplayTag InputTag_7;
 8582: 	FGameplayTag InputTag_8;
 8583: 	FGameplayTag InputTag_9;
 8584: 	FGameplayTag InputTag_0;
 8585: 	FGameplayTag InputTag_Ctrl;
 8586: 	FGameplayTag InputTag_Alt;
 8587: 	FGameplayTag InputTag_Shift;
 8588: 	FGameplayTag InputTag_Tab;
 8589: 
 8590: 
 8591: 	// --- Ritual Position Tags ---
 8592: 	FGameplayTag Ritual_Position_1;
 8593: 	FGameplayTag Ritual_Position_2;
 8594: 	FGameplayTag Ritual_Position_3;
 8595: 	FGameplayTag Ritual_Position_4;
 8596: 
 8597: 	FGameplayTag Ritual_Input_Up;
 8598: 	FGameplayTag Ritual_Input_Down;
 8599: 	FGameplayTag Ritual_Input_Left;
 8600: 	FGameplayTag Ritual_Input_Right;
 8601: 
 8602: 	// --- Ritual Event Tags ---
 8603: 	FGameplayTag Event_Ritual_InputSuccess;
 8604: 	FGameplayTag Event_Ritual_InputFailure;
 8605: 	FGameplayTag Event_Ritual_SequenceSuccess;
 8606: 	FGameplayTag Event_Ritual_SequenceFailure;
 8607: 	FGameplayTag Event_Ritual_CatastrophicFailure;
 8608: 
 8609: 
 8610: 
 8611: 	// --- Event Tags ---
 8612: 	FGameplayTag Event_Ritual_InputReceived;
 8613: 	FGameplayTag Event_Ritual_TurnAdvanced;
 8614: 	FGameplayTag Event_Ritual_SequenceFail;
 8615: 	FGameplayTag Event_Ritual_CatastrophicFail;
 8616: 
 8617: 	// Cauldron Tags
 8618: 	FGameplayTag Cauldron_State_Empty;
 8619: 	FGameplayTag Cauldron_State_Full;
 8620: 	FGameplayTag Cauldron_State_PotionReady;
 8621: 	FGameplayTag Event_Cauldron_CharacterPositioned;
 8622: 
 8623: 
 8624: 	// Communication tags
 8625: 	FGameplayTag Communication_Message;
 8626: 
 8627: 	// --- Items Tags ---
 8628: 	FGameplayTag Item;
 8629: 	FGameplayTag Item_Consumable;
 8630: 	FGameplayTag Item_Consumable_Potion;
 8631: 	FGameplayTag Item_Consumable_Potion_Tier_0;
 8632: 	FGameplayTag Item_Consumable_Potion_Tier_1;
 8633: 	FGameplayTag Item_Consumable_Potion_Tier_2;
 8634: 	FGameplayTag Item_Consumable_Potion_Tier_3;
 8635: 
 8636: 	FGameplayTag Item_Consumable_Ingredient;
 8637: 	FGameplayTag Item_Consumable_Ingredient_Tier_0;
 8638: 	FGameplayTag Item_Consumable_Ingredient_Tier_1;
 8639: 	FGameplayTag Item_Consumable_Ingredient_Tier_2;
 8640: 	FGameplayTag Item_Consumable_Ingredient_Tier_3;
 8641: 
 8642: 
 8643: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
 8644: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
 8645: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;
 8646: 
 8647: 	FGameplayTag Item_Consumable_Ingredient_Category_Base;
 8648: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
 8649: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
 8650: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
 8651: 
 8652: 
 8653: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
 8654: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
 8655: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
 8656: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;
 8657: 
 8658: 
 8659: 
 8660: 
 8661: 
 8662: 
 8663: 	// --------------------------- Modifier Tags ---------------------------
 8664: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
 8665: 	// --------------------------- Modifier Potency Tags ---------------------------
 8666: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
 8667: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
 8668: 	// --------------------------- Modifier Duration Tags ---------------------------
 8669: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
 8670: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
 8671: 	// --------------------------- Modifier Charges Tags ---------------------------
 8672: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
 8673: 	// --------------------------- Modifier Application Tags ---------------------------
 8674: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
 8675: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
 8676: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
 8677: 
 8678: 
 8679: 
 8680: 
 8681: 
 8682: private:
 8683: 	static FWitchPTGameplayTags GameplayTags;
 8684: 
 8685: 
 8686: };
 8687: </file>
 8688: 
 8689: <file path="WitchPT/Public/Game/WitchPTGameModeBase.h">
 8690: // Fill out your copyright notice in the Description page of Project Settings.
 8691: 
 8692: #pragma once
 8693: 
 8694: #include "CoreMinimal.h"
 8695: #include "GameFramework/GameModeBase.h"
 8696: #include "WitchPTGameModeBase.generated.h"
 8697: 
 8698: /**
 8699:  *
 8700:  */
 8701: UCLASS()
 8702: class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
 8703: {
 8704: 	GENERATED_BODY()
 8705: };
 8706: </file>
 8707: 
 8708: <file path="WitchPT/Public/Input/WitchPTInputComponent.h">
 8709: // Fill out your copyright notice in the Description page of Project Settings.
 8710: 
 8711: #pragma once
 8712: 
 8713: #include "CoreMinimal.h"
 8714: #include "EnhancedInputComponent.h"
 8715: #include "WitchPTInputConfig.h"
 8716: 
 8717: #include "WitchPTInputComponent.generated.h"
 8718: 
 8719: 
 8720: UCLASS()
 8721: class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
 8722: {
 8723: 	GENERATED_BODY()
 8724: 
 8725: public:
 8726: 	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
 8727: 	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);
 8728: 
 8729: };
 8730: 
 8731: template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
 8732: void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
 8733: 	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
 8734: {
 8735: 	check(InputConfig);
 8736: 	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
 8737: 	{
 8738: 		if (Action.InputAction && Action.InputTag.IsValid())
 8739: 		{
 8740: 			if (PressedFunc)
 8741: 			{
 8742: 				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
 8743: 			}
 8744: 			if (ReleasedFunc)
 8745: 			{
 8746: 				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
 8747: 			}
 8748: 			if (HeldFunc)
 8749: 			{
 8750: 				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
 8751: 			}
 8752: 		}
 8753: 	}
 8754: 
 8755: }
 8756: </file>
 8757: 
 8758: <file path="WitchPT/Public/Input/WitchPTInputConfig.h">
 8759: // Fill out your copyright notice in the Description page of Project Settings.
 8760: 
 8761: #pragma once
 8762: 
 8763: #include "CoreMinimal.h"
 8764: #include "GameplayTagContainer.h"
 8765: #include "Engine/DataAsset.h"
 8766: #include "WitchPTInputConfig.generated.h"
 8767: 
 8768: USTRUCT(BlueprintType)
 8769: struct FWitchPTInputAction
 8770: {
 8771: 	GENERATED_BODY()
 8772: 	UPROPERTY(EditDefaultsOnly)
 8773: 	const class UInputAction* InputAction = nullptr;
 8774: 
 8775: 	UPROPERTY(EditDefaultsOnly)
 8776: 	FGameplayTag InputTag = FGameplayTag();
 8777: };
 8778: /**
 8779:  *
 8780:  */
 8781: UCLASS()
 8782: class WITCHPT_API UWitchPTInputConfig : public UDataAsset
 8783: {
 8784: 	GENERATED_BODY()
 8785: 	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
 8786: public:
 8787: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 8788: 	TArray<FWitchPTInputAction> AbilityInputActions;
 8789: 
 8790: };
 8791: </file>
 8792: 
 8793: <file path="WitchPT/Public/Inventory/Collectable.h">
 8794: // Fill out your copyright notice in the Description page of Project Settings.
 8795: 
 8796: #pragma once
 8797: 
 8798: #include "CoreMinimal.h"
 8799: #include "Kismet/BlueprintFunctionLibrary.h"
 8800: #include "Templates/SubclassOf.h"
 8801: #include "UObject/Interface.h"
 8802: #include "UObject/ObjectPtr.h"
 8803: #include "Collectable.generated.h"
 8804: template <typename InterfaceType> class TScriptInterface;
 8805: // This class does not need to be modified.
 8806: 
 8807: class AActor;
 8808: class UWitchPTInventoryItemDefinition;
 8809: class UWitchPTInventoryItemInstance;
 8810: class UWitchPTInventoryManagerComponent;
 8811: class UObject;
 8812: struct FFrame;
 8813: // ------------------------- STRUCTS ---------------------- //
 8814: USTRUCT(BlueprintType)
 8815: struct FItemManifest
 8816: {
 8817: 	GENERATED_BODY()
 8818: 
 8819: public:
 8820: 	UPROPERTY(EditAnywhere)
 8821: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 8822: };
 8823: 
 8824: 
 8825: UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
 8826: class UCollectable : public UInterface
 8827: {
 8828: 	GENERATED_BODY()
 8829: };
 8830: 
 8831: /**
 8832:  *
 8833:  */
 8834: class WITCHPT_API ICollectable
 8835: {
 8836: 	GENERATED_BODY()
 8837: 
 8838: public:
 8839: 	/**
 8840: 	 * This is the functions you call from the GA_Interact_Collect
 8841: 	 */
 8842: 	UFUNCTION(BlueprintCallable)
 8843: 	virtual FItemManifest GetPickupInventory() const = 0;
 8844: };
 8845: 
 8846: UCLASS()
 8847: class UCollectableStatics : public UBlueprintFunctionLibrary
 8848: {
 8849: 	GENERATED_BODY()
 8850: 
 8851: public:
 8852: 	UCollectableStatics();
 8853: 
 8854: 	UFUNCTION(BlueprintPure)
 8855: 	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);
 8856: 
 8857: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
 8858: 	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
 8859: };
 8860: </file>
 8861: 
 8862: <file path="WitchPT/Public/Inventory/FastArray/FastArrayList.h">
 8863: #pragma once
 8864: 
 8865: #include "CoreMinimal.h"
 8866: #include "Net/Serialization/FastArraySerializer.h"
 8867: 
 8868: #include "FastArrayList.generated.h"
 8869: 
 8870: class UWitchPTInventoryItemDefinition;
 8871: class UWitchPTInventoryItemInstance;
 8872: class UWitchPTInventoryManagerComponent;
 8873: struct FWitchPTInventoryList;
 8874: 
 8875: /**
 8876:  * FWitchPTInventoryEntry
 8877:  *
 8878:  * Represents a single item entry in the inventory.
 8879:  * Uses FastArraySerializer for efficient replication.
 8880:  */
 8881: USTRUCT(BlueprintType)
 8882: struct FWitchPTInventoryEntry : public FFastArraySerializerItem
 8883: {
 8884: 	GENERATED_BODY()
 8885: 
 8886: 	FWitchPTInventoryEntry()
 8887: 	{}
 8888: 
 8889: 	/**
 8890: 	 * Get a debug string representation of this inventory entry
 8891: 	 * @return FString - A string describing the item instance and its definition
 8892: 	 */
 8893: 	FString GetDebugString() const;
 8894: 
 8895: private:
 8896: 	friend FWitchPTInventoryList;
 8897: 	friend UWitchPTInventoryManagerComponent;
 8898: 
 8899: 	/** The actual item instance this entry represents */
 8900: 	UPROPERTY()
 8901: 	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
 8902: 
 8903: };
 8904: 
 8905: /**
 8906:  * FWitchPTInventoryList
 8907:  *
 8908:  * A collection of inventory entries that supports efficient replication.
 8909:  * Uses FastArraySerializer to minimize network traffic when replicating inventory changes.
 8910:  * Handles adding, removing, and updating inventory items.
 8911:  */
 8912: USTRUCT(BlueprintType)
 8913: struct FWitchPTInventoryList : public FFastArraySerializer
 8914: {
 8915: 	GENERATED_BODY()
 8916: 
 8917: 	/** Default constructor */
 8918: 	FWitchPTInventoryList()
 8919: 		: OwnerComponent(nullptr)
 8920: 	{
 8921: 	}
 8922: 
 8923: 	/**
 8924: 	 * Constructor with owner component
 8925: 	 * @param InOwnerComponent - The component that owns this inventory list
 8926: 	 */
 8927: 	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
 8928: 		: OwnerComponent(InOwnerComponent)
 8929: 	{
 8930: 	}
 8931: 
 8932: 	/**
 8933: 	 * Get all item instances in the inventory
 8934: 	 * @return TArray<UWitchPTInventoryItemInstance*> - Array of all item instances
 8935: 	 */
 8936: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 8937: 
 8938: public:
 8939: 	//~FFastArraySerializer contract
 8940: 	/**
 8941: 	 * Called before items are removed during replication
 8942: 	 * Broadcasts the OnItemRemoved event for each removed item
 8943: 	 */
 8944: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 8945: 
 8946: 	/**
 8947: 	 * Called after items are added during replication
 8948: 	 * Broadcasts the OnItemAdded event for each added item
 8949: 	 */
 8950: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 8951: 
 8952: 	/**
 8953: 	 * Called after items are changed during replication
 8954: 	 * Broadcasts the OnItemStackChanged event for each changed item
 8955: 	 */
 8956: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 8957: 	//~End of FFastArraySerializer contract
 8958: 
 8959: 	/**
 8960: 	 * Serializes the delta between two states of the array
 8961: 	 * Required for FastArraySerializer functionality
 8962: 	 */
 8963: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
 8964: 	{
 8965: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
 8966: 	}
 8967: 
 8968: 	/**
 8969: 	 * Create a new inventory entry with the specified item definition
 8970: 	 * Initializes the item instance and sets up its stack count based on the definition
 8971: 	 *
 8972: 	 * @param ItemClass The class of the inventory item to add
 8973: 	 * @return A pointer to the newly created inventory item instance
 8974: 	 */
 8975: 	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
 8976: 
 8977: 	/**
 8978: 	 * Adds an existing item instance to the inventory list
 8979: 	 *
 8980: 	 * @param Instance The inventory item instance to add
 8981: 	 */
 8982: 	void AddEntry(UWitchPTInventoryItemInstance* Instance);
 8983: 
 8984: 	/**
 8985: 	 * Removes an item instance from the inventory list
 8986: 	 *
 8987: 	 * @param Instance The inventory item instance to remove
 8988: 	 */
 8989: 	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);
 8990: 
 8991: private:
 8992: 	friend UWitchPTInventoryManagerComponent;
 8993: 
 8994: private:
 8995: 	/** Replicated list of inventory entries */
 8996: 	UPROPERTY()
 8997: 	TArray<FWitchPTInventoryEntry> Entries;
 8998: 
 8999: 	/** Non-replicated reference to the owner component */
 9000: 	UPROPERTY(NotReplicated)
 9001: 	TObjectPtr<UActorComponent> OwnerComponent;
 9002: };
 9003: 
 9004: /**
 9005:  * Trait specification for FWitchPTInventoryList
 9006:  * Enables network delta serialization for efficient replication
 9007:  */
 9008: template<>
 9009: struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
 9010: {
 9011: 	enum { WithNetDeltaSerializer = true };
 9012: };
 9013: </file>
 9014: 
 9015: <file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h">
 9016: // Fill out your copyright notice in the Description page of Project Settings.
 9017: 
 9018: #pragma once
 9019: 
 9020: #include "CoreMinimal.h"
 9021: #include "WitchPTInventoryItemFragment.h"
 9022: #include "WitchPTInventoryFragment_Stackable.generated.h"
 9023: 
 9024: /**
 9025:  *
 9026:  */
 9027: UCLASS()
 9028: class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
 9029: {
 9030: 	GENERATED_BODY()
 9031: public:
 9032: 
 9033: 	int32 GetMaxStackSize() const { return MaxStackSize; }
 9034: 	int32 GetStackCount() const { return StackCount; }
 9035: 	void SetStackCount(int32 Count) { StackCount = Count; }
 9036: 
 9037: private:
 9038: 
 9039: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 9040: 	int32 MaxStackSize{1};
 9041: 
 9042: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 9043: 	int32 StackCount{1};
 9044: };
 9045: </file>
 9046: 
 9047: <file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h">
 9048: // Fill out your copyright notice in the Description page of Project Settings.
 9049: 
 9050: #pragma once
 9051: 
 9052: #include "CoreMinimal.h"
 9053: #include "GameplayTagContainer.h"
 9054: #include "WitchPTInventoryItemFragment.h"
 9055: #include "WitchPTInventoryFragment_UIDetails.generated.h"
 9056: 
 9057: /**
 9058:  *
 9059:  */
 9060: UCLASS()
 9061: class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
 9062: {
 9063: 	GENERATED_BODY()
 9064: public:
 9065: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9066: 	FText Title;
 9067: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9068: 	FText Description;
 9069: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9070: 	TSubclassOf<UUserWidget> IconWidget;
 9071: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9072: 	FGameplayTag TierTag;
 9073: 
 9074: 
 9075: };
 9076: </file>
 9077: 
 9078: <file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h">
 9079: // Fill out your copyright notice in the Description page of Project Settings.
 9080: 
 9081: #pragma once
 9082: 
 9083: #include "CoreMinimal.h"
 9084: #include "GameplayTagContainer.h"
 9085: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 9086: #include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"
 9087: 
 9088: USTRUCT(BlueprintType)
 9089: struct FBaseIngredientData
 9090: {
 9091: 	GENERATED_BODY()
 9092: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9093: 	FGameplayTag BaseLiquidTypeTag;
 9094: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9095: 	int32 DefaultChargesProvided;
 9096: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9097: 	float StabilityModifier;
 9098: };
 9099: 
 9100: USTRUCT(BlueprintType)
 9101: struct FPrincipalIngredientData
 9102: {
 9103: 	GENERATED_BODY()
 9104: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9105: 	FGameplayTag PrincipalEssenceTag;
 9106: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9107: 	float BasePotency;
 9108: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9109: 	float BaseDuration;
 9110: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9111: 	bool bIsRitualEssence;
 9112: };
 9113: 
 9114: USTRUCT(BlueprintType)
 9115: struct FModifierIngredientData
 9116: {
 9117: 	GENERATED_BODY()
 9118: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9119: 	FGameplayTagContainer ModifierEffectTags;
 9120: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9121: 	float PotencyModificationValue;
 9122: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9123: 	float DurationModificationValue;
 9124: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9125: 	FGameplayTag GrantedPropertyTag;
 9126: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9127: 	FGameplayTag AddedEffectTag;
 9128: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9129: 	float StrengthOfModifier;
 9130: 
 9131: };
 9132: UCLASS()
 9133: class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
 9134: {
 9135: 	GENERATED_BODY()
 9136: public:
 9137: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9138: 	FGameplayTag SlotUsageTag;
 9139: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9140: 	FGameplayTag TierTag;
 9141: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9142: 	FGameplayTag CategoryTag;
 9143: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9144: 	FBaseIngredientData BaseIngredientData;
 9145: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9146: 	FPrincipalIngredientData PrincipalIngredientData;
 9147: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 9148: 	FModifierIngredientData ModifierIngredientData;
 9149: 
 9150: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
 9151: };
 9152: </file>
 9153: 
 9154: <file path="WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h">
 9155: // Fill out your copyright notice in the Description page of Project Settings.
 9156: 
 9157: #pragma once
 9158: 
 9159: #include "CoreMinimal.h"
 9160: #include "Templates/SubclassOf.h"
 9161: #include "WitchPTInventoryItemFragment.generated.h"
 9162: 
 9163: template <typename T> class TSubclassOf;
 9164: 
 9165: class UWitchPTInventoryItemInstance;
 9166: /**
 9167:  *
 9168:  */
 9169: UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
 9170: class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
 9171: {
 9172: 	GENERATED_BODY()
 9173: 
 9174: public:
 9175: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
 9176: 
 9177: };
 9178: </file>
 9179: 
 9180: <file path="WitchPT/Public/Inventory/InventoryFunctionLibrary.h">
 9181: // Fill out your copyright notice in the Description page of Project Settings.
 9182: 
 9183: #pragma once
 9184: 
 9185: #include "CoreMinimal.h"
 9186: #include "Kismet/BlueprintFunctionLibrary.h"
 9187: #include "InventoryFunctionLibrary.generated.h"
 9188: 
 9189: class UInventoryWidgetController;
 9190: /**
 9191:  *
 9192:  */
 9193: UCLASS()
 9194: class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
 9195: {
 9196: 	GENERATED_BODY()
 9197: public:
 9198: 	UFUNCTION(BlueprintPure, Category="Inventory")
 9199: 	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
 9200: };
 9201: </file>
 9202: 
 9203: <file path="WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h">
 9204: // Fill out your copyright notice in the Description page of Project Settings.
 9205: 
 9206: #pragma once
 9207: 
 9208: #include "CoreMinimal.h"
 9209: #include "Kismet/BlueprintFunctionLibrary.h"
 9210: #include "WitchPTInventoryFunctionLibrary.generated.h"
 9211: 
 9212: class UWitchPTInventoryItemDefinition;
 9213: class UWitchPTInventoryItemFragment;
 9214: /**
 9215:  *
 9216:  */
 9217: UCLASS()
 9218: class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
 9219: {
 9220: 	GENERATED_BODY()
 9221: 	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
 9222: 	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
 9223: };
 9224: </file>
 9225: 
 9226: <file path="WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h">
 9227: // Fill out your copyright notice in the Description page of Project Settings.
 9228: 
 9229: #pragma once
 9230: 
 9231: #include "CoreMinimal.h"
 9232: #include "UObject/NoExportTypes.h"
 9233: #include "Kismet/BlueprintFunctionLibrary.h"
 9234: #include "WitchPTInventoryItemDefinition.generated.h"
 9235: 
 9236: class UWitchPTInventoryItemFragment;
 9237: struct FFrame;
 9238: /**
 9239:  *
 9240:  */
 9241: UCLASS(Blueprintable, Const, Abstract)
 9242: class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
 9243: {
 9244: 	GENERATED_BODY()
 9245: public:
 9246: 	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 9247: 
 9248: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
 9249: 	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;
 9250: 
 9251: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
 9252: };
 9253: </file>
 9254: 
 9255: <file path="WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h">
 9256: // Fill out your copyright notice in the Description page of Project Settings.
 9257: 
 9258: #pragma once
 9259: 
 9260: #include "CoreMinimal.h"
 9261: #include "Systems/GameplayTagStack.h"
 9262: #include "Templates/SubclassOf.h"
 9263: #include "WitchPTInventoryItemInstance.generated.h"
 9264: class UWitchPTInventoryItemFragment;
 9265: class UWitchPTInventoryItemDefinition;
 9266: struct FFrame;
 9267: struct FGameplayTag;
 9268: 
 9269: /**
 9270:  *
 9271:  */
 9272: UCLASS(BlueprintType)
 9273: class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
 9274: {
 9275: 	GENERATED_BODY()
 9276: public:
 9277: 	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 9278: 	friend struct FWitchPTInventoryList;
 9279: 
 9280: 	//~UObject interface
 9281: 	virtual bool IsSupportedForNetworking() const override { return true; }
 9282: 	//~End of UObject interface
 9283: 
 9284: 
 9285: 	UFUNCTION(BlueprintCallable)
 9286: 	int32 GetTotalStackCount() const { return TotalStackCount; }
 9287: 
 9288: 	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
 9289: 	UFUNCTION(BlueprintCallable)
 9290: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
 9291: 	{
 9292: 		return ItemDef;
 9293: 	}
 9294: 
 9295: 	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
 9296: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
 9297: 
 9298: 	template <typename ResultClass>
 9299: 	const ResultClass* FindFragmentByClass() const
 9300: 	{
 9301: 		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
 9302: 	}
 9303: 
 9304: 	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);
 9305: 
 9306: 
 9307: private:
 9308: 	UPROPERTY(Replicated)
 9309: 	int32 TotalStackCount{0};
 9310: 
 9311: 	UPROPERTY(Replicated)
 9312: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 9313: 
 9314: };
 9315: </file>
 9316: 
 9317: <file path="WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h">
 9318: // Fill out your copyright notice in the Description page of Project Settings.
 9319: 
 9320: #pragma once
 9321: 
 9322: #include "CoreMinimal.h"
 9323: #include "Components/ActorComponent.h"
 9324: #include "FastArray/FastArrayList.h"
 9325: #include "Net/Serialization/FastArraySerializer.h"
 9326: #include "WitchPTInventoryManagerComponent.generated.h"
 9327: 
 9328: class UInventoryUserWidget;
 9329: class UWitchPTInventoryItemDefinition;
 9330: class UWitchPTInventoryItemInstance;
 9331: class UWitchPTInventoryManagerComponent;
 9332: class UObject;
 9333: struct FFrame;
 9334: struct FNetDeltaSerializeInfo;
 9335: struct FWitchPTInventoryList;
 9336: struct FReplicationFlags;
 9337: 
 9338: /**
 9339:  * Delegate for inventory item events.
 9340:  * Used to broadcast when items are added, removed, or their stack counts change.
 9341:  * @param UWitchPTInventoryItemInstance* - The item instance that was affected
 9342:  */
 9343: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);
 9344: 
 9345: /**
 9346:  * WitchPTInventoryManagerComponent
 9347:  *
 9348:  * A component that manages a player's inventory of items.
 9349:  * Handles adding, removing, and stacking items, as well as replicating inventory state across the network.
 9350:  * Uses a fast array serializer for efficient replication of inventory items.
 9351:  */
 9352: UCLASS(BlueprintType)
 9353: class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
 9354: {
 9355: 	GENERATED_BODY()
 9356: protected:
 9357: 	virtual void BeginPlay() override;
 9358: 
 9359: public:
 9360: 	UFUNCTION(BlueprintCallable)
 9361: 	UInventoryUserWidget* GetInventoryMenuWidget() const { return InventoryMenu; }
 9362: 
 9363: 	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 9364: 
 9365: 
 9366: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
 9367: 	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 9368: 
 9369: 
 9370: 	UFUNCTION(Server, Reliable)
 9371: 	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 9372: 
 9373: 
 9374: 	UFUNCTION(Server, Reliable)
 9375: 	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 9376: 
 9377: 
 9378: 	UFUNCTION(Server, Reliable)
 9379: 	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);
 9380: 
 9381: 
 9382: 	UFUNCTION(Server, Reliable)
 9383: 	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);
 9384: 
 9385: 
 9386: 	UFUNCTION(Server, Reliable)
 9387: 	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);
 9388: 
 9389: 
 9390: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
 9391: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 9392: 
 9393: 
 9394: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
 9395: 	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 9396: 
 9397: 
 9398: 	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 9399: 
 9400: 
 9401: 	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);
 9402: 
 9403: 	// Delegates for inventory events
 9404: 
 9405: 	/** Fired when a new item is added to the inventory */
 9406: 	FOnItemChanged OnItemAdded;
 9407: 
 9408: 	/** Fired when an item's stack count changes */
 9409: 	FOnItemChanged OnItemStackChanged;
 9410: 
 9411: 	/** Fired when an item is removed from the inventory */
 9412: 	FOnItemChanged OnItemRemoved;
 9413: 
 9414: 	//~UObject interface
 9415: 	/**
 9416: 	 * Replicates all inventory item instances as subobjects
 9417: 	 * Required for proper replication of the inventory system
 9418: 	 */
 9419: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 9420: 
 9421: 	/**
 9422: 	 * Called when the component is ready for replication
 9423: 	 * Registers all existing inventory items for replication
 9424: 	 */
 9425: 	virtual void ReadyForReplication() override;
 9426: 	//~End of UObject interface
 9427: 
 9428: private:
 9429: 	/**
 9430: 	 * The replicated list of inventory items
 9431: 	 * Uses a fast array serializer for efficient replication
 9432: 	 */
 9433: 	UPROPERTY(Replicated)
 9434: 	FWitchPTInventoryList InventoryList;
 9435: 	UPROPERTY()
 9436: 	TObjectPtr<UInventoryUserWidget> InventoryMenu;
 9437: 
 9438: 
 9439: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 9440: 	TSubclassOf<UInventoryUserWidget> InventoryMenuClass;
 9441: 
 9442: 	TWeakObjectPtr<APlayerController> OwningController;
 9443: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 9444: 	void ToggleInventoryMenu();
 9445: 	void ConstructInventory();
 9446: 	bool bInventoryMenuOpen;
 9447: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 9448: 	void OpenInventoryMenu();
 9449: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 9450: 	void CloseInventoryMenu();
 9451: };
 9452: </file>
 9453: 
 9454: <file path="WitchPT/Public/Item/BaseInteractableAltar.h">
 9455: // Fill out your copyright notice in the Description page of Project Settings.
 9456: 
 9457: #pragma once
 9458: 
 9459: #include "CoreMinimal.h"
 9460: #include "GameFramework/Actor.h"
 9461: #include "GameplayTagContainer.h" // Include for FGameplayTag
 9462: #include "BaseInteractableAltar.generated.h"
 9463: 
 9464: class UWitchPTUserWidget;
 9465: class ABaseInteractionPosition;
 9466: class ACharacter;
 9467: 
 9468: /**
 9469:  * Base state enum for interaction state
 9470:  */
 9471: UENUM(BlueprintType)
 9472: enum class EInteractionState : uint8
 9473: {
 9474:     Inactive    UMETA(DisplayName = "Inactive"),
 9475:     WaitingForPlayers UMETA(DisplayName = "Waiting For Players"), // At least one player in position
 9476:     Preparing   UMETA(DisplayName = "Preparing"), // Players occupying positions
 9477:     Active      UMETA(DisplayName = "Active"),    // Sequence running
 9478:     Succeeded   UMETA(DisplayName = "Succeeded"),
 9479:     Failed      UMETA(DisplayName = "Failed"),
 9480:     FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
 9481: };
 9482: 
 9483: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
 9484: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);
 9485: 
 9486: // Estructura para mapear un jugador a su tag de posición
 9487: USTRUCT(BlueprintType)
 9488: struct FPlayerPositionTagEntry
 9489: {
 9490:     GENERATED_BODY();
 9491: 
 9492:     UPROPERTY(BlueprintReadWrite)
 9493:     TObjectPtr<ACharacter> Player = nullptr;
 9494: 
 9495:     UPROPERTY(BlueprintReadWrite)
 9496:     FGameplayTag PositionTag;
 9497: };
 9498: 
 9499: /**
 9500:  * Base class for interactive altars/cauldrons that players can interact with
 9501:  */
 9502: UCLASS(Abstract)
 9503: class WITCHPT_API ABaseInteractableAltar : public AActor
 9504: {
 9505:     GENERATED_BODY()
 9506: 
 9507: public:
 9508:     // Sets default values for this actor's properties
 9509:     ABaseInteractableAltar();
 9510:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 9511: 
 9512:     // Current interaction state
 9513:     UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
 9514:     EInteractionState CurrentState = EInteractionState::Inactive;
 9515: 
 9516:     // Transforms defining brewing positions around the cauldron
 9517:     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
 9518:     TArray<FTransform> PositionTransforms;
 9519: 
 9520:     // The class to spawn for brewing positions
 9521:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
 9522:     TSubclassOf<ABaseInteractionPosition> PositionClass;
 9523: 
 9524:     UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
 9525:     TArray<FGameplayTag> TagsPositions;
 9526: 
 9527:     // List of players participating in the interaction
 9528:     UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
 9529:     TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
 9530: 
 9531: 
 9532:     // Positions for interaction
 9533:     UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 9534:     TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;
 9535: 
 9536:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 9537:     TArray<FPlayerPositionTagEntry> PlayerPositionTags;
 9538: 
 9539:     // Basic interaction methods
 9540: 
 9541:     virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
 9542: 
 9543: 
 9544:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 9545:     virtual void CreateAltarPositions();
 9546: 
 9547: 
 9548:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 9549:     virtual void DestroyAltarPositions();
 9550: 
 9551: 
 9552: 
 9553:     // Multicast RPCs for notifications
 9554:     UFUNCTION(NetMulticast, Reliable)
 9555:     void Multicast_OnStateChanged(EInteractionState NewState);
 9556: 
 9557:     UFUNCTION(NetMulticast, Reliable)
 9558:     virtual void Multicast_OnInputSuccess(ACharacter* Character);
 9559: 
 9560:     UFUNCTION(NetMulticast, Reliable)
 9561:     virtual void Multicast_OnInputFailed(ACharacter* Character);
 9562: 
 9563: 
 9564:     // Getters for Blueprint/HUD access
 9565:     UFUNCTION(BlueprintPure, Category = "Interaction")
 9566:     EInteractionState GetCurrentState() const { return CurrentState; }
 9567: 
 9568:     UPROPERTY(EditDefaultsOnly)
 9569:     TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;
 9570: 
 9571: protected:
 9572:     virtual void BeginPlay() override;
 9573:     virtual void Tick(float DeltaTime) override;
 9574: 
 9575: 
 9576: 
 9577:     UFUNCTION()
 9578:     virtual void OnRep_ParticipatingPlayers();
 9579: 
 9580: 
 9581:     // Helper functions
 9582:     virtual void HandleInputSuccess(ACharacter* Player);
 9583:     virtual void HandleInputFailure(ACharacter* Player);
 9584:     virtual void CheckState();
 9585:     virtual void CleanupInteraction();
 9586:     virtual void SpawnReward();
 9587:     virtual void SpawnDemon();
 9588:     virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
 9589: 
 9590: };
 9591: </file>
 9592: 
 9593: <file path="WitchPT/Public/Item/BaseInteractionPosition.h">
 9594: // Fill out your copyright notice in the Description page of Project Settings.
 9595: 
 9596: #pragma once
 9597: 
 9598: #include "CoreMinimal.h"
 9599: #include "Item/Item.h"
 9600: #include "AbilitySystem/Interaction/InteractionOption.h"
 9601: #include "GameplayTagContainer.h" // Added for FGameplayTag
 9602: #include "MechanicsInterface.h"
 9603: #include "BaseInteractionPosition.generated.h"
 9604: 
 9605: class UAbilitySystemComponent;
 9606: struct FGameplayAbilitySpec;
 9607: class AController;
 9608: class UGameplayAbility;
 9609: class UBoxComponent;
 9610: class ACharacter;
 9611: class ABaseInteractableAltar;
 9612: 
 9613: /**
 9614:  * Base class for interaction positions (rituals, cauldrons, etc)
 9615:  */
 9616: UCLASS(Abstract)
 9617: class WITCHPT_API ABaseInteractionPosition : public AItem
 9618: {
 9619:     GENERATED_BODY()
 9620: 
 9621: public:
 9622:     // Sets default values for this actor's properties
 9623:     ABaseInteractionPosition();
 9624: 
 9625:     //~ Begin AActor Interface
 9626:     virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
 9627:     virtual void BeginPlay() override;
 9628:     //~ End AActor Interface
 9629: 
 9630:     //~ Begin IInteraction Interface (from AItem presumably)
 9631:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 9632:     //~ End IInteraction Interface
 9633: 
 9634:     //~ Getters
 9635: 
 9636:     UFUNCTION(BlueprintPure, Category = "Interaction")
 9637:     ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
 9638: 
 9639:     UFUNCTION(BlueprintPure, Category = "Interaction")
 9640:     FGameplayTag GetPositionTag() const { return PositionTag; }
 9641:     //~ End Getters
 9642:     virtual bool IsOccupied() const;
 9643: 
 9644:     //~ Setters
 9645:     UFUNCTION()
 9646:     void SetOccupied(ACharacter* Character);
 9647: 
 9648:     UFUNCTION()
 9649:     void SetUnoccupied();
 9650: 
 9651:     UFUNCTION()
 9652:     void SetPositionTag(const FGameplayTag& NewTag);
 9653: 
 9654: protected:
 9655:     // Unique tag identifying this position (e.g., Ritual.Position.1). Set per instance.
 9656:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
 9657:     FGameplayTag PositionTag;
 9658: 
 9659:     // Is this position currently occupied by a player? Replicated.
 9660:     UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
 9661:     bool bIsOccupied = false;
 9662: 
 9663:     // Which character is currently occupying this position? Replicated.
 9664:     UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
 9665:     TObjectPtr<ACharacter> OccupyingCharacter = nullptr;
 9666: 
 9667:     // Variables potentially used by the base AItem interaction system
 9668:     UPROPERTY()
 9669:     TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;
 9670: 
 9671:     UPROPERTY()
 9672:     TWeakObjectPtr<AController> InteractingController;
 9673: 
 9674:     //~ Replication Notifies
 9675:     UFUNCTION()
 9676:     void OnRep_IsOccupied();
 9677: 
 9678:     UFUNCTION()
 9679:     void OnRep_OccupyingCharacter();
 9680:     //~ End Replication Notifies
 9681: 
 9682:     // Interaction Logic Helper (Called from GatherInteractionOptions or a specific interaction GA)
 9683:     virtual void HandleInteraction(ACharacter* InteractingCharacter);
 9684: 
 9685: private:
 9686:     void RemoveCharacterFromPosition();
 9687: };
 9688: </file>
 9689: 
 9690: <file path="WitchPT/Public/Item/CauldronAltar.h">
 9691: // Fill out your copyright notice in the Description page of Project Settings.
 9692: 
 9693: #pragma once
 9694: 
 9695: #include "CoreMinimal.h"
 9696: #include "Item/BaseInteractableAltar.h"
 9697: #include "GameplayTagContainer.h" // Include for FGameplayTag
 9698: #include "MechanicsInterface.h"
 9699: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 9700: #include "CauldronAltar.generated.h"
 9701: 
 9702: class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
 9703: class UWitchPTInventoryItemFragment;
 9704: class UCauldronUserWidget;
 9705: class ACauldronPosition;
 9706: class ACharacter;
 9707: 
 9708: // Estructura para contener secuencias de ingredientes
 9709: USTRUCT(BlueprintType)
 9710: struct FIngredientSequence
 9711: {
 9712:     GENERATED_BODY()
 9713: 
 9714:     UPROPERTY(BlueprintReadOnly)
 9715:     TArray<FGameplayTag> Ingredients;
 9716: };
 9717: 
 9718: // Enum for cauldron inputs
 9719: UENUM(BlueprintType)
 9720: enum class ECauldronInput : uint8
 9721: {
 9722:     Ingredient1 UMETA(DisplayName = "Ingredient 1"),
 9723:     Ingredient2 UMETA(DisplayName = "Ingredient 2"),
 9724:     Ingredient3 UMETA(DisplayName = "Ingredient 3"),
 9725:     Ingredient4 UMETA(DisplayName = "Ingredient 4"),
 9726:     Ingredient5 UMETA(DisplayName = "Ingredient 5"),
 9727:     None        UMETA(DisplayName = "None")
 9728: };
 9729: 
 9730: UENUM(BlueprintType)
 9731: enum ECauldronPhysicState
 9732: {
 9733:     Static UMETA(DisplayName = "InPlace"),
 9734:     Moving UMETA(DisplayName = "Moving"),
 9735:     Previewing UMETA(DisplayName = "Previewing")
 9736: };
 9737: 
 9738: // Enum para el estado de validación de la posición del caldero
 9739: UENUM(BlueprintType)
 9740: enum class ECauldronPlacementState : uint8
 9741: {
 9742:     Valid UMETA(DisplayName = "Valid"),
 9743:     Invalid UMETA(DisplayName = "Invalid"),
 9744:     None UMETA(DisplayName = "None")
 9745: };
 9746: 
 9747: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
 9748: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
 9749: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 9750: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
 9751: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 9752: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
 9753: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 9754: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
 9755: 
 9756: /**
 9757:  * Cauldron altar allows players to add ingredients in any order (unlike ritual's sequential inputs)
 9758:  */
 9759: UCLASS()
 9760: class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
 9761: {
 9762:     GENERATED_BODY()
 9763: 
 9764: public:
 9765:     // Sets default values for this actor's properties
 9766:     ACauldronAltar();
 9767: 
 9768:     // Overrides
 9769:     virtual void BeginPlay() override;
 9770:     virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 9771:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 9772:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 9773:     virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
 9774: 
 9775:     // Core Properties
 9776:     UPROPERTY(EditAnywhere)
 9777:     FInteractionOption Option;
 9778: 
 9779:     UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
 9780:     TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;
 9781: 
 9782:     // Base ingredient
 9783:     UPROPERTY(VisibleAnywhere)
 9784:     UWitchPTInventoryItemInstance* BaseIngredient;
 9785:     UPROPERTY(VisibleAnywhere)
 9786:     UWitchPTInventoryItemInstance* PrincipalIngredient;
 9787:     UPROPERTY(VisibleAnywhere)
 9788:     UWitchPTInventoryItemInstance* ModifierIngredient;
 9789: 
 9790:     UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
 9791:     TSubclassOf<UUserWidget> BaseIngredientIcon;
 9792: 
 9793:     UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
 9794:     TSubclassOf<UUserWidget> PrincipalIngredientIcon;
 9795: 
 9796:     UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
 9797:     TSubclassOf<UUserWidget> ModifierIngredientIcon;
 9798: 
 9799:     // ----------------------------------- DELEGATES  ---------------------------------------------- //
 9800: 
 9801:     FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
 9802:     FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
 9803:     FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
 9804:     FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
 9805:     FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
 9806:     FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
 9807:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 9808:     FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
 9809: 
 9810:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 9811:     FOnCharacterPositioned OnCharacterPositioned;
 9812: 
 9813:     // UI Properties
 9814:     UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
 9815:     TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
 9816: 
 9817:     // Placement Properties
 9818:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
 9819:     UMaterialInterface* ValidPlacementMaterial;
 9820: 
 9821:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
 9822:     UMaterialInterface* InvalidPlacementMaterial;
 9823: 
 9824:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
 9825:     float PlacementCollisionCheckRadius = 50.0f;
 9826: 
 9827:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
 9828:     float MaxGroundAlignmentHeight = 20.0f;
 9829: 
 9830:     // ----------------------------------- BREWING FUNCTIONS ---------------------------------------------- //
 9831: 
 9832:     void StartBrewingPotion(ACharacter* InteractingCharacter);
 9833: 
 9834:     void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
 9835: 
 9836:     // ----------------------------------- ON REP FUNCTIONS ---------------------------------------------- //
 9837: 
 9838:     UFUNCTION()
 9839:     void OnRep_CauldronPhysicState();
 9840:     UFUNCTION()
 9841:     void OnRep_BaseIngredientIcon();
 9842:     UFUNCTION()
 9843:     void OnRep_PrincipalIngredientIcon();
 9844:     UFUNCTION()
 9845:     void OnRep_PotentiatorIngredientIcon();
 9846: 
 9847:     UFUNCTION()
 9848:     void PositionCharacterForBrewing(ACharacter* Character);
 9849: 
 9850:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 9851:     ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
 9852: 
 9853: 
 9854:     // ----------------------------------- CAULDRON MOVEMENT FUNCTIONS ---------------------------------------------- //
 9855:     void StartCarryCauldron(ACharacter* InteractingCharacter);
 9856: 
 9857:     UFUNCTION()
 9858:     void AttachToCharacter(ACharacter* Character);
 9859: 
 9860:     UFUNCTION()
 9861:     void DetachFromCharacter(ACharacter* Character);
 9862: 
 9863:     // ----------------------------------- PLACEMENT FUNCTIONS ---------------------------------------------- //
 9864:     void StartPlacementPreview(ACharacter* Character);
 9865:     void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
 9866:     void FinalizePlacement();
 9867:     void CancelPlacement();
 9868:     void ApplyPlacementPreviewMaterial();
 9869: 
 9870:     UFUNCTION(Client, Unreliable)
 9871:     void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
 9872: 
 9873:     UFUNCTION(NetMulticast, Reliable)
 9874:     void Multicast_FinalizePlacement();
 9875: 
 9876:     // ----------------------------------- STATE QUERY FUNCTIONS ---------------------------------------------- //
 9877:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 9878:     bool CanBePickedUp() const;
 9879: 
 9880:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 9881:     bool IsBeingCarried() const;
 9882: 
 9883:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 9884:     ACharacter* GetCarryingCharacter() const;
 9885: 
 9886:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
 9887:     ECauldronPlacementState GetPlacementState() const;
 9888: 
 9889:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
 9890:     bool IsInPlacementPreview() const;
 9891:     // ----------------------------------- GETTERS ---------------------------------------------- //
 9892: 
 9893:     UWitchPTInventoryItemInstance* GetBaseIngredient() const;
 9894:     UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
 9895:     UWitchPTInventoryItemInstance* GetModifierIngredient() const;
 9896: 
 9897: protected:
 9898:     // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
 9899: 	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
 9900:     void BroadcastBaseIngredientDropped() const;
 9901:     void BroadcastBaseIngredientIconSet() const;
 9902:     void BroadcastPrincipalIngredientDropped() const;
 9903:     void BroadcastPrincipalIngredientIconSet() const;
 9904:     void BroadcastModifierIngredientDropped() const;
 9905:     void BroadcastModifierIngredientIconSet() const;
 9906: 
 9907: 
 9908: private:
 9909:     UPROPERTY(Replicated)
 9910:     TObjectPtr<ACharacter> CarryingCharacter;
 9911: 
 9912:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
 9913:     FName BackAttachSocketName = "BackpackSocket";
 9914: 
 9915:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
 9916:     FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
 9917: 
 9918:     // Placement Properties
 9919:     UPROPERTY(Replicated)
 9920:     ECauldronPlacementState CurrentPlacementState;
 9921: 
 9922:     UPROPERTY()
 9923:     TArray<UMaterialInterface*> OriginalMaterials;
 9924: 
 9925:     FVector PreviewLocation;
 9926:     FRotator PreviewRotation;
 9927: 
 9928:     // Private Utility Functions
 9929:     void RestoreOriginalMaterials();
 9930:     bool IsPlacementValid() const;
 9931: };
 9932: </file>
 9933: 
 9934: <file path="WitchPT/Public/Item/CauldronPosition.h">
 9935: // Fill out your copyright notice in the Description page of Project Settings.
 9936: 
 9937: #pragma once
 9938: 
 9939: #include "CoreMinimal.h"
 9940: #include "Item/BaseInteractionPosition.h"
 9941: #include "GameplayTagContainer.h" // Added for FGameplayTag
 9942: #include "CauldronPosition.generated.h"
 9943: 
 9944: // Forward Declarations
 9945: class ACauldronAltar;
 9946: class UAbilitySystemComponent;
 9947: struct FGameplayAbilitySpec;
 9948: class AController;
 9949: class UGameplayAbility;
 9950: class UBoxComponent;
 9951: class ACharacter;
 9952: 
 9953: /**
 9954:  * Position for interacting with a Cauldron altar
 9955:  */
 9956: UCLASS()
 9957: class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
 9958: {
 9959:     GENERATED_BODY()
 9960: 
 9961: public:
 9962:     // Sets default values for this actor's properties
 9963:     ACauldronPosition();
 9964: 
 9965:     //~ Begin AActor Interface
 9966:     virtual void BeginPlay() override;
 9967:     //~ End AActor Interface
 9968: 
 9969:     //~ Begin IInteraction Interface (from AItem)
 9970:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 9971:     //~ End IInteraction Interface
 9972: 
 9973:     //~ Getters
 9974:     UFUNCTION(BlueprintPure, Category = "Cauldron")
 9975:     ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
 9976:     //~ End Getters
 9977: 
 9978:     //~ Setters
 9979:     UFUNCTION(BlueprintCallable)
 9980:     void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
 9981:     //~ End Setters
 9982:     //
 9983:     // /**
 9984:     //  * Posiciona un personaje en esta ubicación
 9985:     //  * @param Character El personaje a posicionar
 9986:     //  * @return True si el personaje fue posicionado correctamente
 9987:     //  */
 9988:     // UFUNCTION(BlueprintCallable, Category = "Cauldron|Interaction")
 9989:     // bool PositionCharacter(ACharacter* Character);
 9990:     //
 9991:     // /**
 9992:     //  * Comprueba si esta posición está ocupada
 9993:     //  * @return True si la posición está ocupada por un personaje
 9994:     //  */
 9995:     // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 9996:     // bool IsOccupied() const;
 9997:     //
 9998:     // /**
 9999:     //  * Establece el estado de ocupación de esta posición
10000:     //  * @param bInOccupied Si la posición está ocupada
10001:     //  * @param InOccupyingCharacter El personaje que ocupa la posición
10002:     //  */
10003:     // UFUNCTION(BlueprintCallable, Category = "Cauldron|State")
10004:     // void SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter = nullptr);
10005:     //
10006:     // /**
10007:     //  * Obtiene el personaje que ocupa esta posición
10008:     //  * @return El personaje que ocupa la posición, o nullptr si no está ocupada
10009:     //  */
10010:     // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
10011:     // ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
10012: 
10013: protected:
10014:     // Reference to the parent altar
10015:     UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
10016:     TObjectPtr<ACauldronAltar> CauldronAltar;
10017: 
10018:     // Interaction Logic Helper
10019:     virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
10020: 
10021: private:
10022:     // Find the CauldronAltar if not set
10023:     void FindCauldronAltar();
10024:     //
10025:     // // Character currently occupying this position
10026:     // UPROPERTY()
10027:     // TObjectPtr<ACharacter> OccupyingCharacter;
10028:     //
10029:     // // Whether this position is currently occupied
10030:     // UPROPERTY()
10031:     // bool bIsOccupied;
10032: };
10033: </file>
10034: 
10035: <file path="WitchPT/Public/Item/Ingredient/IngredientBase.h">
10036: // Fill out your copyright notice in the Description page of Project Settings.
10037: 
10038: #pragma once
10039: 
10040: #include "CoreMinimal.h"
10041: #include "Inventory/Collectable.h"
10042: #include "Item/Item.h"
10043: #include "IngredientBase.generated.h"
10044: 
10045: UCLASS()
10046: class WITCHPT_API AIngredientBase : public AItem, public ICollectable
10047: {
10048: 	GENERATED_BODY()
10049: 
10050: public:
10051: 
10052: 	AIngredientBase();
10053: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
10054: 	virtual FItemManifest GetPickupInventory() const override;
10055: 
10056: protected:
10057: 
10058: 	UPROPERTY(EditAnywhere)
10059: 	FItemManifest StaticInventory;
10060: 
10061: };
10062: </file>
10063: 
10064: <file path="WitchPT/Public/Item/Item.h">
10065: // Fill out your copyright notice in the Description page of Project Settings.
10066: 
10067: #pragma once
10068: 
10069: #include "CoreMinimal.h"
10070: #include "AbilitySystem/Interaction/IInteractableTarget.h"
10071: #include "GameFramework/Actor.h"
10072: #include "Item.generated.h"
10073: 
10074: UCLASS()
10075: class WITCHPT_API AItem : public AActor, public IInteractableTarget
10076: {
10077: 	GENERATED_BODY()
10078: 
10079: public:
10080: 	// Sets default values for this actor's properties
10081: 	AItem();
10082: 
10083: protected:
10084: 	// Called when the game starts or when spawned
10085: 	virtual void BeginPlay() override;
10086: 	UPROPERTY(EditAnywhere)
10087: 	FInteractionOption Option;
10088: 
10089: public:
10090: 	// Called every frame
10091: 	virtual void Tick(float DeltaTime) override;
10092: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
10093: };
10094: </file>
10095: 
10096: <file path="WitchPT/Public/Item/MechanicsInterface.h">
10097: // Fill out your copyright notice in the Description page of Project Settings.
10098: 
10099: #pragma once
10100: 
10101: #include "CoreMinimal.h"
10102: #include "GameplayTagContainer.h"
10103: #include "UObject/Interface.h"
10104: #include "MechanicsInterface.generated.h"
10105: 
10106: class UWitchPTInventoryItemDefinition;
10107: class UWitchPTInventoryItemInstance;
10108: class ABaseInteractionPosition;
10109: class ACauldronAltar;
10110: class ARitualPosition;
10111: class ARitualAltar;
10112: class ACharacter;
10113: 
10114: // This class does not need to be modified.
10115: UINTERFACE(MinimalAPI)
10116: class UMechanicsInterface : public UInterface
10117: {
10118: 	GENERATED_BODY()
10119: };
10120: 
10121: /**
10122:  *
10123:  */
10124: class WITCHPT_API IMechanicsInterface
10125: {
10126: 	GENERATED_BODY()
10127: 
10128: 	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
10129: 
10130: public:
10131: 	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
10132: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
10133: 	void RequestStartRitual(ARitualAltar* TargetAltar);
10134: 
10135: 
10136: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
10137: 	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);
10138: 
10139: 
10140: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
10141: 	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
10142: 
10143: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
10144: 	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
10145: 
10146: 	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
10147: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10148: 	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);
10149: 
10150: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10151: 	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);
10152: 
10153: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10154: 	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);
10155: 
10156: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10157: 	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);
10158: 
10159: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10160: 	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);
10161: 
10162: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10163: 	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);
10164: 
10165: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10166: 	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);
10167: 
10168: 	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
10169: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
10170: 	void RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
10171: 
10172: 
10173: 	// General Queries that might be implemented by positions or other interactables
10174: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
10175: 	ARitualAltar* GetRitualAltarActor() const;
10176: 
10177: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
10178: 	bool IsOccuppied() const;
10179: 
10180: };
10181: </file>
10182: 
10183: <file path="WitchPT/Public/Item/PositionInterface.h">
10184: // Fill out your copyright notice in the Description page of Project Settings.
10185: 
10186: #pragma once
10187: 
10188: #include "CoreMinimal.h"
10189: #include "UObject/Interface.h"
10190: #include "PositionInterface.generated.h"
10191: 
10192: class ARitualAltar;
10193: // This class does not need to be modified.
10194: UINTERFACE(MinimalAPI)
10195: class UPositionInterface : public UInterface
10196: {
10197: 	GENERATED_BODY()
10198: };
10199: 
10200: /**
10201:  *
10202:  */
10203: class WITCHPT_API IPositionInterface
10204: {
10205: 	GENERATED_BODY()
10206: 
10207: 	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
10208: public:
10209: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
10210: 	ARitualAltar* GetRitualAltarActor() const;
10211: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
10212: 	bool IsOccupied();
10213: };
10214: </file>
10215: 
10216: <file path="WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h">
10217: // Fill out your copyright notice in the Description page of Project Settings.
10218: 
10219: #pragma once
10220: 
10221: #include "CoreMinimal.h"
10222: #include "Kismet/BlueprintFunctionLibrary.h"
10223: #include "UI/WidgetControllers/CauldronWidgetController.h"
10224: #include "RitualFunctionLibrary.generated.h"
10225: 
10226: class UWitchPTWidgetController;
10227: class URitualWidgetController;
10228: /**
10229:  *
10230:  */
10231: UCLASS()
10232: class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
10233: {
10234: 	GENERATED_BODY()
10235: public:
10236: 	UFUNCTION(Category="Ritual")
10237: 	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
10238: 	UFUNCTION(Category="Cauldron")
10239: 	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
10240: };
10241: </file>
10242: 
10243: <file path="WitchPT/Public/Item/RitualAltar.h">
10244: // Fill out your copyright notice in the Description page of Project Settings.
10245: 
10246: #pragma once
10247: 
10248: #include "CoreMinimal.h"
10249: #include "Item/BaseInteractableAltar.h"
10250: #include "GameplayTagContainer.h" // Include for FGameplayTag
10251: #include "RitualAltar.generated.h"
10252: 
10253: class URitualUserWidget;
10254: class ARitualPosition;
10255: 
10256: // Enum defining the possible inputs for the ritual sequence
10257: UENUM(BlueprintType)
10258: enum class ERitualInput : uint8
10259: {
10260: 	Up		UMETA(DisplayName = "Up"),
10261: 	Down	UMETA(DisplayName = "Down"),
10262: 	Left	UMETA(DisplayName = "Left"),
10263: 	Right	UMETA(DisplayName = "Right"),
10264: 	None	UMETA(DisplayName = "None") // Optional: For default/invalid state
10265: };
10266: 
10267: USTRUCT(BlueprintType)
10268: struct FUIRitualData
10269: {
10270: 	GENERATED_BODY()
10271: 	UPROPERTY(BlueprintReadOnly)
10272: 	bool bIsMyTurn = false;
10273: 	UPROPERTY(BlueprintReadOnly)
10274: 	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
10275: 	UPROPERTY(BlueprintReadOnly)
10276: 	float RitualPercentageCompleted = 0.0f;
10277: 	UPROPERTY(BlueprintReadOnly)
10278: 	float CorruptionPercentage = 0.0f;
10279: 	UPROPERTY(BlueprintReadOnly)
10280: 	float CurrentInputTimeRemaining = 0.0f;
10281: };
10282: 
10283: // Replicated struct for ready players data
10284: USTRUCT(BlueprintType)
10285: struct FRitualReadyPlayersData
10286: {
10287: 	GENERATED_BODY()
10288: 
10289: 	UPROPERTY(BlueprintReadOnly)
10290: 	int32 TotalPlayers = 0;
10291: 
10292: 	UPROPERTY(BlueprintReadOnly)
10293: 	int32 ReadyPlayers = 0;
10294: 
10295: 	bool operator==(const FRitualReadyPlayersData& Other) const
10296: 	{
10297: 		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
10298: 	}
10299: 
10300: 	bool operator!=(const FRitualReadyPlayersData& Other) const
10301: 	{
10302: 		return !(*this == Other);
10303: 	}
10304: };
10305: 
10306: // Delegates for UI updates - these will be called from OnRep functions
10307: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
10308: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
10309: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
10310: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
10311: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
10312: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
10313: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);
10314: 
10315: UCLASS()
10316: class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
10317: {
10318: 	GENERATED_BODY()
10319: 
10320: public:
10321: 	// Sets default values for this actor's properties
10322: 	ARitualAltar();
10323: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
10324: 
10325: 	// ----------------------------------- REPLICATED PROPERTIES ---------------------------------------------- //
10326: 	// Current ritual state
10327: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
10328: 	EInteractionState CurrentRitualState = EInteractionState::Inactive;
10329: 
10330: 	// Current sequence of inputs required for the ritual
10331: 	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
10332: 	TArray<FGameplayTag> InputSequence;
10333: 
10334: 	// Current index in the sequence
10335: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
10336: 	int32 CurrentSequenceIndex = -1;
10337: 
10338: 	// Players who have confirmed they're ready to start
10339: 	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
10340: 	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
10341: 
10342: 	// Ready players data for UI
10343: 	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
10344: 	FRitualReadyPlayersData ReadyPlayersData;
10345: 
10346: 	// Current countdown value (when starting ritual)
10347: 	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
10348: 	int32 StartCountdown = 3;
10349: 
10350: 	// Current player whose turn it is to input
10351: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
10352: 	TObjectPtr<ACharacter> CurrentActivePlayer;
10353: 
10354: 	// Timer for the current input
10355: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
10356: 	float CurrentInputTimer;
10357: 
10358: 	// Current turn data for UI
10359: 	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
10360: 	FUIRitualData CurrentTurnData;
10361: 
10362: 	// Current corruption level
10363: 	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
10364: 	float CorruptionAmount = 0.0f;
10365: 
10366: 	// Maximum corruption allowed before catastrophic failure
10367: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10368: 	float MaxCorruption = 100.0f;
10369: 
10370: 	// Corruption increase per failure
10371: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10372: 	float CorruptionIncreasePerFail = 10.0f;
10373: 
10374: 	// Base time window for inputs
10375: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10376: 	float BaseInputTimeWindow = 10.0f;
10377: 
10378: 	// Scaling multiplier for difficulty
10379: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10380: 	float DifficultyScalingMultiplier = 1.0f;
10381: 
10382: 	// Ritual completion status
10383: 	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
10384: 	bool bRitualCompleted = false;
10385: 
10386: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
10387: 	bool bRitualWasSuccessful = false;
10388: 
10389: 	// ----------------------------------- DELEGATES ---------------------------------------------- //
10390: 	FOnRitualStateChanged OnRitualStateChangedEvent;
10391: 
10392: 	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
10393: 
10394: 	FOnCountdownTick OnCountdownTickEvent;
10395: 
10396: 	FOnTurnDataChanged OnTurnDataChangedEvent;
10397: 
10398: 	FOnCorruptionChanged OnCorruptionChangedEvent;
10399: 
10400: 	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
10401: 	UPROPERTY(BlueprintAssignable)
10402: 	FOnRitualCompleted OnRitualCompletedEvent;
10403: 
10404: 	// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
10405: 	UFUNCTION()
10406: 	void OnRep_CurrentRitualState();
10407: 
10408: 	UFUNCTION()
10409: 	void OnRep_CurrentSequenceIndex();
10410: 
10411: 	UFUNCTION()
10412: 	void OnRep_ReadyPlayersData();
10413: 
10414: 	UFUNCTION()
10415: 	void OnRep_StartCountdown();
10416: 
10417: 	UFUNCTION()
10418: 	void OnRep_CurrentActivePlayer();
10419: 
10420: 	UFUNCTION()
10421: 	void OnRep_TurnData();
10422: 
10423: 	UFUNCTION()
10424: 	void OnRep_CorruptionAmount();
10425: 
10426: 	UFUNCTION()
10427: 	void OnRep_RitualCompleted();
10428: 
10429: 	// ----------------------------------- MAIN FUNCTIONS ---------------------------------------------- //
10430: 	UFUNCTION(NetMulticast, Reliable)
10431: 	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
10432: 
10433: 	void StartRitual(ACharacter* RequestingCharacter);
10434: 	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
10435: 
10436: 	// New function to check player ready status
10437: 	UFUNCTION(BlueprintPure, Category = "Ritual")
10438: 	bool IsPlayerReady(ACharacter* Player) const;
10439: 
10440: 	// New function to check if all players are ready
10441: 	UFUNCTION(BlueprintPure, Category = "Ritual")
10442: 	bool AreAllPlayersReady() const;
10443: 
10444: 	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
10445: 	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
10446: 
10447: 	// Multicast RPCs for notifications
10448: 	UFUNCTION(NetMulticast, Reliable)
10449: 	void Multicast_OnRitualSucceeded();
10450: 
10451: 	UFUNCTION(NetMulticast, Reliable)
10452: 	void Multicast_OnRitualCatastrophicFail();
10453: 
10454: 	// New multicast RPC for countdown
10455: 	UFUNCTION(NetMulticast, Reliable)
10456: 	void Multicast_OnCountdownTick(int32 CountdownValue);
10457: 
10458: 	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
10459: 
10460: 	// ---------------------------- GETTERS FOR WC ---------------------------- //
10461: 	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
10462: 	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
10463: 	float GetCorruptionPercentage() const;
10464: 	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
10465: 	float GetCurrentSequenceProgress() const;
10466: 	FGameplayTag GetCurrentExpectedInput() const;
10467: 	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
10468: 	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
10469: 	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }
10470: 
10471: 
10472: protected:
10473: 	virtual void BeginPlay() override;
10474: 	virtual void Tick(float DeltaTime) override;
10475: 
10476: 	// Timer handle for the ritual start countdown
10477: 	FTimerHandle RitualStartCountdownHandle;
10478: 
10479: 	// Timer handles
10480: 	FTimerHandle InputTimerHandle;
10481: 
10482: 	// ----------------------------------- LOGIC FUNCTIONS ---------------------------------------------- //
10483: 	void GenerateInputSequence();
10484: 	void AdvanceToNextPlayer();
10485: 	virtual void HandleInputSuccess(ACharacter* Player) override;
10486: 	virtual void HandleInputFailure(ACharacter* Player) override;
10487: 	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
10488: 	void StartInputTimer();
10489: 	void OnInputTimerExpired();
10490: 	void CheckRitualState();
10491: 	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
10492: 	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
10493: 	void CleanupRitual();
10494: 	void SpawnReward();
10495: 	void SpawnDemon();
10496: 	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
10497: 	void UpdateTurnData();
10498: 	void UpdateReadyPlayersData();
10499: 
10500: 	// New helper functions for the ready system
10501: 	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
10502: 	void StartRitualCountdown();
10503: 	void ProcessCountdownTick();
10504: 	void ActivateRitual();
10505: 
10506: 	// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
10507: 	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
10508: 	void BroadcastRitualStateChanged();
10509: 	void BroadcastReadyPlayersChanged();
10510: 	void BroadcastCountdownTick();
10511: 	void BroadcastTurnDataChanged();
10512: 	void BroadcastCorruptionChanged();
10513: 	void BroadcastSequenceProgressChanged();
10514: 	void BroadcastRitualCompleted();
10515: 
10516: 	UPROPERTY(EditDefaultsOnly)
10517: 	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
10518: 	UPROPERTY(EditDefaultsOnly)
10519: 	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
10520: 	UPROPERTY(EditDefaultsOnly)
10521: 	TObjectPtr<UAnimMontage> FailedAnimMontage;
10522: 	UPROPERTY(EditDefaultsOnly)
10523: 	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
10524: 
10525: 	// Animation montages specifically for ritual
10526: 	UPROPERTY(EditDefaultsOnly)
10527: 	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
10528: 	UPROPERTY(EditDefaultsOnly)
10529: 	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
10530: };
10531: </file>
10532: 
10533: <file path="WitchPT/Public/Item/RitualPosition.h">
10534: // Fill out your copyright notice in the Description page of Project Settings.
10535: 
10536: #pragma once
10537: 
10538: #include "CoreMinimal.h"
10539: #include "Item/BaseInteractionPosition.h"
10540: #include "GameplayTagContainer.h" // Added for FGameplayTag
10541: #include "MechanicsInterface.h" // For GetRitualAltarActor & IsOccuppied if still needed
10542: #include "PositionInterface.h"
10543: #include "RitualPosition.generated.h"
10544: 
10545: // Forward Declarations
10546: class ARitualAltar;
10547: class UAbilitySystemComponent;
10548: struct FGameplayAbilitySpec;
10549: class AController;
10550: class UGameplayAbility;
10551: class UBoxComponent;
10552: class ACharacter;
10553: 
10554: UCLASS()
10555: class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
10556: {
10557: 	GENERATED_BODY()
10558: 
10559: public:
10560: 	// Sets default values for this actor's properties
10561: 	ARitualPosition();
10562: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
10563: 
10564: 	//~ Begin AActor Interface
10565: 	virtual void BeginPlay() override;
10566: 	//~ End AActor Interface
10567: 
10568: 	//~ Begin IInteraction Interface (from AItem)
10569: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
10570: 	//~ End IInteraction Interface
10571: 
10572: 	// Still part of IMechanicsInterface if these are general queries
10573: 	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
10574: 
10575: 
10576: 	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
10577: 	virtual bool IsOccupied_Implementation() override;
10578: 
10579: protected:
10580: 	// Reference to the parent altar
10581: 	UPROPERTY(EditInstanceOnly, Replicated)
10582: 	TObjectPtr<ARitualAltar> RitualAltar;
10583: 
10584: 	// Interaction Logic Helper
10585: 	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
10586: 
10587: private:
10588: 	// Find the RitualAltar if not set
10589: 
10590: };
10591: </file>
10592: 
10593: <file path="WitchPT/Public/Player/WitchPTPlayerController.h">
10594: // Fill out your copyright notice in the Description page of Project Settings.
10595: 
10596: #pragma once
10597: 
10598: #include "CoreMinimal.h"
10599: #include "GameFramework/PlayerController.h"
10600: #include "UI/Widgets/PointerWidget.h"
10601: #include "WitchPTPlayerController.generated.h"
10602: 
10603: class UCauldronUserWidget;
10604: class ABaseInteractableAltar;
10605: class ACauldronAltar;
10606: class ARitualAltar;
10607: class UWitchPTInventoryManagerComponent;
10608: struct FGameplayTag;
10609: class UWitchPTAbilitySystemComponent;
10610: class UWitchPTInputConfig;
10611: struct FInputActionValue;
10612: class UInputAction;
10613: class UInputMappingContext;
10614: /**
10615:  *
10616:  */
10617: UCLASS()
10618: class WITCHPT_API AWitchPTPlayerController : public APlayerController
10619: {
10620: 	GENERATED_BODY()
10621: public:
10622: 	AWitchPTPlayerController();
10623: 	virtual void PlayerTick(float DeltaTime) override;
10624: 	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
10625: 	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
10626: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
10627: 
10628: 	void LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar);
10629: 	bool HasRitualWidgetInitialized(ABaseInteractableAltar* Altar);
10630: 	void LocalToggleCauldronMenu();
10631: 
10632: 
10633: 
10634: 
10635: 	UFUNCTION(Client, Reliable)
10636: 	void Client_InitializeRitualUserWidget(ABaseInteractableAltar* Altar);
10637: 
10638: 	UFUNCTION(Client, Reliable)
10639: 	void Client_ToggleCauldronMenu();
10640: 
10641: 
10642: 	UPROPERTY(Replicated, VisibleAnywhere)
10643: 	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
10644: 	UPROPERTY()
10645: 	TObjectPtr<UPointerWidget> HUDWidget;
10646: 	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
10647: protected:
10648: 	virtual void BeginPlay() override;
10649: 	virtual void SetupInputComponent() override;
10650: 
10651: 	// Actions
10652: 	UPROPERTY(EditAnywhere, Category="Input")
10653: 	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
10654: 	UPROPERTY(EditAnywhere, Category="Input")
10655: 	TObjectPtr<UInputAction> MoveAction;
10656: 	UPROPERTY(EditAnywhere, Category= "Input")
10657: 	TObjectPtr<UInputAction> LookAction;
10658: 	//InputConfig
10659: 	UPROPERTY(EditDefaultsOnly, Category= "Input")
10660: 	TObjectPtr<UWitchPTInputConfig> InputConfig;
10661: 
10662: 	// Ability System Component
10663: 	UPROPERTY()
10664: 	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;
10665: 
10666: 	UWitchPTAbilitySystemComponent* GetASC();
10667: 
10668: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
10669: 	TSubclassOf<UPointerWidget> HUDWidgetClass;
10670: 
10671: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
10672: 	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;
10673: 
10674: 
10675: 
10676: private:
10677: 
10678: 	void Move(const FInputActionValue& InputActionValue);
10679: 
10680: 	void Look(const FInputActionValue& Value);
10681: 
10682: 	void AbilityInputTagPressed(FGameplayTag InputTag);
10683: 	void AbilityInputTagReleased(FGameplayTag InputTag);
10684: 	void AbilityInputTagHeld(FGameplayTag InputTag);
10685: 
10686: 	void ConstructCauldronWidget();
10687: 
10688: 	void CreateHUDWidget();
10689: 	void OpenCauldronMenu();
10690: 	void CloseCauldronMenu();
10691: 	bool bCauldronMenuOpen = false;
10692: 
10693: 	// Array de altares para los que ya se ha creado un widget
10694: 	UPROPERTY()
10695: 	TObjectPtr<ARitualAltar> ThisRitualAltarHasWidget;
10696: 	UPROPERTY()
10697: 	TObjectPtr<UCauldronUserWidget> CauldronAltarMenu;
10698: 
10699: };
10700: </file>
10701: 
10702: <file path="WitchPT/Public/Player/WitchPTPlayerState.h">
10703: // Fill out your copyright notice in the Description page of Project Settings.
10704: 
10705: #pragma once
10706: 
10707: #include "CoreMinimal.h"
10708: #include "AbilitySystemInterface.h"
10709: #include "GameFramework/PlayerState.h"
10710: #include "WitchPTPlayerState.generated.h"
10711: class ARitualPosition;
10712: class ARitualAltar;
10713: class UAbilitySystemComponent;
10714: class UAttributeSet;
10715: /**
10716:  *
10717:  */
10718: UCLASS()
10719: class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
10720: {
10721: 	GENERATED_BODY()
10722: 	AWitchPTPlayerState();
10723: public:
10724: 
10725: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
10726: 	UAttributeSet* GetAttributeSet() const { return AttributeSet; }
10727: 
10728: protected:
10729: 	UPROPERTY(VisibleAnywhere)
10730: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
10731: 	UPROPERTY(VisibleAnywhere)
10732: 	TObjectPtr<UAttributeSet> AttributeSet;
10733: 
10734: 
10735: };
10736: </file>
10737: 
10738: <file path="WitchPT/Public/Systems/GameplayTagStack.cpp">
10739: // Copyright Epic Games, Inc. All Rights Reserved.
10740: 
10741: #include "Systems/GameplayTagStack.h"
10742: 
10743: #include "UObject/Stack.h"
10744: 
10745: #include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)
10746: 
10747: //////////////////////////////////////////////////////////////////////
10748: // FGameplayTagStack
10749: 
10750: FString FGameplayTagStack::GetDebugString() const
10751: {
10752: 	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
10753: }
10754: 
10755: //////////////////////////////////////////////////////////////////////
10756: // FGameplayTagStackContainer
10757: 
10758: void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
10759: {
10760: 	if (!Tag.IsValid())
10761: 	{
10762: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
10763: 		return;
10764: 	}
10765: 
10766: 	if (StackCount > 0)
10767: 	{
10768: 		for (FGameplayTagStack& Stack : Stacks)
10769: 		{
10770: 			if (Stack.Tag == Tag)
10771: 			{
10772: 				const int32 NewCount = Stack.StackCount + StackCount;
10773: 				Stack.StackCount = NewCount;
10774: 				TagToCountMap[Tag] = NewCount;
10775: 				MarkItemDirty(Stack);
10776: 				return;
10777: 			}
10778: 		}
10779: 
10780: 		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
10781: 		MarkItemDirty(NewStack);
10782: 		TagToCountMap.Add(Tag, StackCount);
10783: 	}
10784: }
10785: 
10786: void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
10787: {
10788: 	if (!Tag.IsValid())
10789: 	{
10790: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
10791: 		return;
10792: 	}
10793: 
10794: 	//@TODO: Should we error if you try to remove a stack that doesn't exist or has a smaller count?
10795: 	if (StackCount > 0)
10796: 	{
10797: 		for (auto It = Stacks.CreateIterator(); It; ++It)
10798: 		{
10799: 			FGameplayTagStack& Stack = *It;
10800: 			if (Stack.Tag == Tag)
10801: 			{
10802: 				if (Stack.StackCount <= StackCount)
10803: 				{
10804: 					It.RemoveCurrent();
10805: 					TagToCountMap.Remove(Tag);
10806: 					MarkArrayDirty();
10807: 				}
10808: 				else
10809: 				{
10810: 					const int32 NewCount = Stack.StackCount - StackCount;
10811: 					Stack.StackCount = NewCount;
10812: 					TagToCountMap[Tag] = NewCount;
10813: 					MarkItemDirty(Stack);
10814: 				}
10815: 				return;
10816: 			}
10817: 		}
10818: 	}
10819: }
10820: 
10821: void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
10822: {
10823: 	for (int32 Index : RemovedIndices)
10824: 	{
10825: 		const FGameplayTag Tag = Stacks[Index].Tag;
10826: 		TagToCountMap.Remove(Tag);
10827: 	}
10828: }
10829: 
10830: void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
10831: {
10832: 	for (int32 Index : AddedIndices)
10833: 	{
10834: 		const FGameplayTagStack& Stack = Stacks[Index];
10835: 		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
10836: 	}
10837: }
10838: 
10839: void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
10840: {
10841: 	for (int32 Index : ChangedIndices)
10842: 	{
10843: 		const FGameplayTagStack& Stack = Stacks[Index];
10844: 		TagToCountMap[Stack.Tag] = Stack.StackCount;
10845: 	}
10846: }
10847: </file>
10848: 
10849: <file path="WitchPT/Public/Systems/GameplayTagStack.h">
10850: // Copyright Epic Games, Inc. All Rights Reserved.
10851: 
10852: #pragma once
10853: 
10854: #include "GameplayTagContainer.h"
10855: #include "Net/Serialization/FastArraySerializer.h"
10856: 
10857: #include "GameplayTagStack.generated.h"
10858: 
10859: struct FGameplayTagStackContainer;
10860: struct FNetDeltaSerializeInfo;
10861: 
10862: /**
10863:  * Represents one stack of a gameplay tag (tag + count)
10864:  */
10865: USTRUCT(BlueprintType)
10866: struct FGameplayTagStack : public FFastArraySerializerItem
10867: {
10868: 	GENERATED_BODY()
10869: 
10870: 	FGameplayTagStack()
10871: 	{}
10872: 
10873: 	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
10874: 		: Tag(InTag)
10875: 		, StackCount(InStackCount)
10876: 	{
10877: 	}
10878: 
10879: 	FString GetDebugString() const;
10880: 
10881: private:
10882: 	friend FGameplayTagStackContainer;
10883: 
10884: 	UPROPERTY()
10885: 	FGameplayTag Tag;
10886: 
10887: 	UPROPERTY()
10888: 	int32 StackCount = 0;
10889: };
10890: 
10891: /** Container of gameplay tag stacks */
10892: USTRUCT(BlueprintType)
10893: struct FGameplayTagStackContainer : public FFastArraySerializer
10894: {
10895: 	GENERATED_BODY()
10896: 
10897: 	FGameplayTagStackContainer()
10898: 	//	: Owner(nullptr)
10899: 	{
10900: 	}
10901: 
10902: public:
10903: 	// Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
10904: 	void AddStack(FGameplayTag Tag, int32 StackCount);
10905: 
10906: 	// Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
10907: 	void RemoveStack(FGameplayTag Tag, int32 StackCount);
10908: 
10909: 	// Returns the stack count of the specified tag (or 0 if the tag is not present)
10910: 	int32 GetStackCount(FGameplayTag Tag) const
10911: 	{
10912: 		return TagToCountMap.FindRef(Tag);
10913: 	}
10914: 
10915: 	// Returns true if there is at least one stack of the specified tag
10916: 	bool ContainsTag(FGameplayTag Tag) const
10917: 	{
10918: 		return TagToCountMap.Contains(Tag);
10919: 	}
10920: 
10921: 	//~FFastArraySerializer contract
10922: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
10923: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
10924: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
10925: 	//~End of FFastArraySerializer contract
10926: 
10927: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
10928: 	{
10929: 		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
10930: 	}
10931: 
10932: private:
10933: 	// Replicated list of gameplay tag stacks
10934: 	UPROPERTY()
10935: 	TArray<FGameplayTagStack> Stacks;
10936: 
10937: 	// Accelerated list of tag stacks for queries
10938: 	TMap<FGameplayTag, int32> TagToCountMap;
10939: };
10940: 
10941: template<>
10942: struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
10943: {
10944: 	enum
10945: 	{
10946: 		WithNetDeltaSerializer = true,
10947: 	};
10948: };
10949: </file>
10950: 
10951: <file path="WitchPT/Public/UI/HUD/WitchPTHUD.h">
10952: // Fill out your copyright notice in the Description page of Project Settings.
10953: 
10954: #pragma once
10955: 
10956: #include "CoreMinimal.h"
10957: #include "GameFramework/HUD.h"
10958: #include "WitchPTHUD.generated.h"
10959: 
10960: class UCauldronWidgetController;
10961: class UWitchPTWidgetController;
10962: class URitualWidgetController;
10963: class UAbilitySystemComponent;
10964: class UAttributeSet;
10965: class UWitchPTUserWidget;
10966: class UInventoryWidgetController;
10967: struct FWidgetControllerParams;
10968: class UOverlayWidgetController;
10969: /**
10970:  *
10971:  */
10972: UCLASS()
10973: class WITCHPT_API AWitchPTHUD : public AHUD
10974: {
10975: 	GENERATED_BODY()
10976: public:
10977: 	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
10978: 	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
10979: 	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
10980: 	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
10981: 
10982: 	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
10983: 
10984: 
10985: 
10986: private:
10987: 	UPROPERTY()
10988: 	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
10989: 	UPROPERTY(EditAnywhere)
10990: 	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;
10991: 
10992: 
10993: 	UPROPERTY()
10994: 	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
10995: 	UPROPERTY(EditAnywhere)
10996: 	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;
10997: 
10998: 	UPROPERTY()
10999: 	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
11000: 	UPROPERTY(EditAnywhere)
11001: 	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;
11002: 
11003: 	UPROPERTY()
11004: 	TObjectPtr<URitualWidgetController> RitualWidgetController;
11005: 	UPROPERTY(EditAnywhere)
11006: 	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;
11007: 
11008: 	UPROPERTY()
11009: 	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
11010: 	UPROPERTY(EditAnywhere)
11011: 	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
11012: };
11013: </file>
11014: 
11015: <file path="WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h">
11016: // Fill out your copyright notice in the Description page of Project Settings.
11017: 
11018: #pragma once
11019: 
11020: #include "CoreMinimal.h"
11021: #include "WitchPTWidgetController.h"
11022: #include "CauldronWidgetController.generated.h"
11023: 
11024: class ACauldronAltar;
11025: class UWitchPTInventoryItemInstance;
11026: 
11027: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11028: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
11029: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11030: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
11031: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11032: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
11033: /**
11034:  *
11035:  */
11036: UCLASS(BlueprintType, Blueprintable)
11037: class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
11038: {
11039: 	GENERATED_BODY()
11040: public:
11041: 	UCauldronWidgetController();
11042: 	virtual void BroadcastInitialValues() override;
11043: 	virtual void BindCallbacksToDependencies() override;
11044: 
11045: 	// Delegates for widgets to subscribe to
11046: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11047: 	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
11048: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11049: 	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
11050: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11051: 	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
11052: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11053: 	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
11054: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11055: 	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
11056: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
11057: 	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;
11058: 
11059: 	UFUNCTION(Category = "Cauldron")
11060: 	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);
11061: 
11062: 	// Getter for the current ritual altar
11063: 	UFUNCTION(BlueprintPure, Category = "Cauldron")
11064: 	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
11065: 
11066: 
11067: protected:
11068: 	// Reference to the ritual altar that this widget controls
11069: 	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
11070: 	TObjectPtr<ACauldronAltar> CauldronAltar;
11071: 
11072: 	UFUNCTION(Category = "Cauldron")
11073: 	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
11074: 	UFUNCTION(Category = "Cauldron")
11075: 	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
11076: 	UFUNCTION(Category = "Cauldron")
11077: 	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
11078: 	UFUNCTION(Category = "Cauldron")
11079: 	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
11080: 	UFUNCTION(Category = "Cauldron")
11081: 	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
11082: 	UFUNCTION(Category = "Cauldron")
11083: 	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
11084: };
11085: </file>
11086: 
11087: <file path="WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h">
11088: // Fill out your copyright notice in the Description page of Project Settings.
11089: 
11090: #pragma once
11091: 
11092: #include "CoreMinimal.h"
11093: #include "WitchPTWidgetController.h"
11094: #include "InventoryWidgetController.generated.h"
11095: 
11096: /**
11097:  *
11098:  */
11099: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
11100: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);
11101: 
11102: UCLASS(BlueprintType, Blueprintable)
11103: class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
11104: {
11105: 	GENERATED_BODY()
11106: 
11107: public:
11108: 	UFUNCTION(BlueprintCallable)
11109: 	virtual void BindCallbacksToDependencies() override;
11110: 
11111: 	/**
11112: 	 * Removes a stack or specified amount from an inventory item instance
11113: 	 * If there's only one stack left and count is 1, removes the item completely
11114: 	 * @param ItemInstance - The item instance to remove from
11115: 	 * @param AmountToRemove - The amount to remove, defaults to 1
11116: 	 */
11117: 	UFUNCTION(BlueprintCallable, Category = "Inventory")
11118: 	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);
11119: 
11120: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
11121: 	FOnItemAddedSignature OnItemAddedDelegate;
11122: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
11123: 	FOnItemAddedSignature OnItemStackChangedDelegate;
11124: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
11125: 	FOnItemRemovedSignature OnItemRemovedDelegate;
11126: };
11127: </file>
11128: 
11129: <file path="WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h">
11130: // Fill out your copyright notice in the Description page of Project Settings.
11131: 
11132: #pragma once
11133: 
11134: #include "CoreMinimal.h"
11135: #include "GameplayTagContainer.h"
11136: #include "WitchPTWidgetController.h"
11137: #include "OverlayWidgetController.generated.h"
11138: class UWitchPTUserWidget;
11139: 
11140: USTRUCT()
11141: struct FUIWidgetRow: public FTableRowBase
11142: {
11143: 	GENERATED_BODY()
11144: 
11145: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
11146: 	FGameplayTag MessageGameplayTag = FGameplayTag();
11147: 
11148: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
11149: 	FText Message = FText();
11150: 
11151: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
11152: 	TSubclassOf<UWitchPTUserWidget> MessageWidget;
11153: 
11154: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
11155: 	UTexture2D* Image = nullptr;
11156: 
11157: };
11158: 
11159: 
11160: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);
11161: 
11162: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);
11163: 
11164: UCLASS(BlueprintType, Blueprintable)
11165: class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
11166: {
11167: 	GENERATED_BODY()
11168: public:
11169: 	/**
11170: 	 * Handles the reception of asset gameplay tags from a Gameplay Effect (GE).
11171: 	 *
11172: 	 * This method is triggered when a Gameplay Effect sends a set of gameplay tags
11173: 	 * as part of its asset definition. It usually processes or reacts to the tags
11174: 	 * received within the container.
11175: 	 *
11176: 	 * @param TagContainer A container of gameplay tags associated with the triggered Gameplay Effect.
11177: 	 */
11178: 	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
11179: 	virtual void BroadcastInitialValues() override;
11180: 
11181: 	virtual void BindCallbacksToDependencies() override;
11182: 
11183: 
11184: 
11185: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11186: 	FOnAttributeChangedSignature OnHealthChanged;
11187: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11188: 	FOnAttributeChangedSignature OnMaxHealthChanged;
11189: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11190: 	FOnAttributeChangedSignature OnStaminaChanged;
11191: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11192: 	FOnAttributeChangedSignature OnMaxStaminaChanged;
11193: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11194: 	FOnAttributeChangedSignature OnAgeChanged;
11195: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
11196: 	FOnAttributeChangedSignature OnMaxAgeChanged;
11197: 
11198: 	UPROPERTY(BlueprintAssignable, Category="Widget Data")
11199: 	FOnMessageWidgetRowSignature OnMessageWidgetRow;
11200: protected:
11201: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
11202: 	TObjectPtr<UDataTable> MessageWidgetDataTable;
11203: 
11204: 	template<typename T>
11205: T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
11206: };
11207: 
11208: template <typename T>
11209: T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
11210: {
11211: 	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));
11212: 
11213: }
11214: </file>
11215: 
11216: <file path="WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h">
11217: // Fill out your copyright notice in the Description page of Project Settings.
11218: 
11219: #pragma once
11220: 
11221: #include "CoreMinimal.h"
11222: #include "GameplayTagContainer.h"
11223: #include "WitchPTWidgetController.h"
11224: #include "Item/RitualAltar.h"
11225: #include "RitualWidgetController.generated.h"
11226: 
11227: enum class ERitualInput : uint8;
11228: class ARitualAltar;
11229: class ACharacter;
11230: enum class EInteractionState : uint8;
11231: 
11232: // Delegate to notify when the expected input in the ritual changes
11233: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
11234: // Delegate to notify when the ready players count changes
11235: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
11236: // Delegate to notify when the countdown ticks
11237: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
11238: // Delegate to notify when turn data changes
11239: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
11240: // Delegate to notify ritual state changes
11241: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
11242: // Delegate to notify corruption changes
11243: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
11244: // Delegate to notify sequence progress changes
11245: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
11246: // Delegate to notify when the ritual is completed
11247: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);
11248: 
11249: /**
11250:  * Widget Controller to manage the ritual UI
11251:  */
11252: UCLASS(BlueprintType, Blueprintable)
11253: class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
11254: {
11255: 	GENERATED_BODY()
11256: 
11257: public:
11258: 	URitualWidgetController();
11259: 
11260: 	virtual void BroadcastInitialValues() override;
11261: 	virtual void BindCallbacksToDependencies() override;
11262: 
11263: 	// Method to set the associated ritual altar
11264: 	UFUNCTION(Category = "Ritual")
11265: 	void SetRitualAltar(ARitualAltar* InRitualAltar);
11266: 
11267: 	// Getter for the current ritual altar
11268: 	UFUNCTION(BlueprintPure, Category = "Ritual")
11269: 	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
11270: 
11271: 	// Checks if the current player is the active player in the ritual
11272: 	UFUNCTION(BlueprintPure, Category = "Ritual")
11273: 	bool IsLocalPlayerActive() const;
11274: 
11275: 	// Delegates for widgets to subscribe to
11276: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11277: 	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;
11278: 
11279: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11280: 	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;
11281: 
11282: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11283: 	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
11284: 
11285: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11286: 	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
11287: 
11288: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11289: 	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
11290: 
11291: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11292: 	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
11293: 
11294: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11295: 	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
11296: 
11297: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
11298: 	FOnRitualCompletedSignature_WC OnRitualCompleted;
11299: 
11300: protected:
11301: 	// Reference to the ritual altar that this widget controls
11302: 	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
11303: 	TObjectPtr<ARitualAltar> RitualAltar;
11304: 
11305: 	// Callbacks for altar changes
11306: 	UFUNCTION()
11307: 	void HandleRitualStateChanged(EInteractionState NewState);
11308: 
11309: 	UFUNCTION()
11310: 	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
11311: 
11312: 	UFUNCTION()
11313: 	void HandleCountdownTick(int32 CountdownValue);
11314: 
11315: 	UFUNCTION()
11316: 	void HandleTurnDataChanged(FUIRitualData TurnData);
11317: 
11318: 	UFUNCTION()
11319: 	void HandleCorruptionChanged(float CorruptionPercentage);
11320: 
11321: 	UFUNCTION()
11322: 	void HandleSequenceProgressChanged(float ProgressPercentage);
11323: 
11324: 	UFUNCTION()
11325: 	void HandleRitualCompleted(bool bWasSuccessful);
11326: 
11327: private:
11328: 	// Helper function to determine if local player's turn and update turn data accordingly
11329: 	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
11330: };
11331: </file>
11332: 
11333: <file path="WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h">
11334: // Fill out your copyright notice in the Description page of Project Settings.
11335: 
11336: #pragma once
11337: 
11338: #include "CoreMinimal.h"
11339: #include "UObject/Object.h"
11340: #include "WitchPTWidgetController.generated.h"
11341: 
11342: class UAbilitySystemComponent;
11343: class UAttributeSet;
11344: /**
11345:  * @struct FWidgetControllerParams
11346:  * @brief A structure that encapsulates parameters required to initialize a widget controller.
11347:  *
11348:  * This structure is designed to pass necessary references into widget controllers for proper functionality,
11349:  * primarily used in player-related widgets to access player-specific systems and attributes.
11350:  *
11351:  * It includes references to the Player Controller, Player State, Ability System Component,
11352:  * and an Attribute Set. These references allow the widget controller to interact with the gameplay systems
11353:  * linked to a player.
11354:  *
11355:  * @note Each of the parameters is a nullable pointer to account for scenarios where specific components
11356:  * may not be initialized or required.
11357:  */
11358: USTRUCT(BlueprintType)
11359: struct FWidgetControllerParams
11360: {
11361: 	GENERATED_BODY()
11362: 	FWidgetControllerParams() {};
11363: 	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
11364: 	:
11365: 	PlayerController(PC),
11366: 	PlayerState(PS),
11367: 	AbilitySystemComponent(ASC),
11368: 	AttributeSet(AS)
11369: 	{}
11370: 
11371: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
11372: 	TObjectPtr<APlayerController> PlayerController = nullptr;
11373: 
11374: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
11375: 	TObjectPtr<APlayerState> PlayerState = nullptr;
11376: 
11377: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
11378: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
11379: 
11380: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
11381: 	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
11382: 
11383: };
11384: UCLASS()
11385: class WITCHPT_API UWitchPTWidgetController : public UObject
11386: {
11387: 	GENERATED_BODY()
11388: public:
11389: 	UFUNCTION(BlueprintCallable)
11390: 	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
11391: 
11392: 	UFUNCTION(BlueprintCallable)
11393: 	virtual void BroadcastInitialValues();
11394: 	virtual void BindCallbacksToDependencies();
11395: protected:
11396: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
11397: 	TObjectPtr<APlayerController> PlayerController;
11398: 
11399: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
11400: 	TObjectPtr<APlayerState> PlayerState;
11401: 
11402: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
11403: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
11404: 
11405: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
11406: 	TObjectPtr<UAttributeSet> AttributeSet;
11407: };
11408: </file>
11409: 
11410: <file path="WitchPT/Public/UI/Widgets/CauldronUserWidget.h">
11411: // Fill out your copyright notice in the Description page of Project Settings.
11412: 
11413: #pragma once
11414: 
11415: #include "CoreMinimal.h"
11416: #include "WitchPTUserWidget.h"
11417: #include "CauldronUserWidget.generated.h"
11418: 
11419: /**
11420:  *
11421:  */
11422: UCLASS()
11423: class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
11424: {
11425: 	GENERATED_BODY()
11426: private:
11427: 	virtual void NativeConstruct() override;
11428: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
11429: };
11430: </file>
11431: 
11432: <file path="WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h">
11433: // Fill out your copyright notice in the Description page of Project Settings.
11434: 
11435: #pragma once
11436: 
11437: #include "CoreMinimal.h"
11438: #include "UI/Widgets/WitchPTUserWidget.h"
11439: #include "InventoryUserWidget.generated.h"
11440: 
11441: /**
11442:  *
11443:  */
11444: UCLASS()
11445: class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
11446: {
11447: 	GENERATED_BODY()
11448: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
11449: 
11450: };
11451: </file>
11452: 
11453: <file path="WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h">
11454: // Fill out your copyright notice in the Description page of Project Settings.
11455: 
11456: #pragma once
11457: 
11458: #include "CoreMinimal.h"
11459: #include "UI/Widgets/WitchPTUserWidget.h"
11460: #include "RitualUserWidget.generated.h"
11461: 
11462: /**
11463:  *
11464:  */
11465: UCLASS()
11466: class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
11467: {
11468: 	GENERATED_BODY()
11469: };
11470: </file>
11471: 
11472: <file path="WitchPT/Public/UI/Widgets/PointerWidget.h">
11473: // Fill out your copyright notice in the Description page of Project Settings.
11474: 
11475: #pragma once
11476: 
11477: #include "CoreMinimal.h"
11478: #include "Blueprint/UserWidget.h"
11479: #include "PointerWidget.generated.h"
11480: 
11481: /**
11482:  *
11483:  */
11484: UCLASS()
11485: class WITCHPT_API UPointerWidget : public UUserWidget
11486: {
11487: 	GENERATED_BODY()
11488: public:
11489: 
11490: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
11491: 	void ShowPickupMessage(const FString& Message);
11492: 
11493: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
11494: 	void HidePickupMessage();
11495: };
11496: </file>
11497: 
11498: <file path="WitchPT/Public/UI/Widgets/WitchPTUserWidget.h">
11499: // Fill out your copyright notice in the Description page of Project Settings.
11500: 
11501: #pragma once
11502: 
11503: #include "CoreMinimal.h"
11504: #include "Blueprint/UserWidget.h"
11505: #include "WitchPTUserWidget.generated.h"
11506: 
11507: /**
11508:  *
11509:  */
11510: UCLASS()
11511: class WITCHPT_API UWitchPTUserWidget : public UUserWidget
11512: {
11513: 	GENERATED_BODY()
11514: public:
11515: 	UFUNCTION(BlueprintCallable)
11516: 	void SetWidgetController(UObject* InWidgetController);
11517: 	UPROPERTY(BlueprintReadOnly)
11518: 	TObjectPtr<UObject> WidgetController;
11519: 
11520: 	UFUNCTION(BlueprintImplementableEvent)
11521: 	void OnWidgetControllerSet();
11522: };
11523: </file>
11524: 
11525: <file path="WitchPT/Public/WitchPTAssetManager.h">
11526: // Fill out your copyright notice in the Description page of Project Settings.
11527: 
11528: #pragma once
11529: 
11530: #include "CoreMinimal.h"
11531: #include "Engine/AssetManager.h"
11532: #include "WitchPTAssetManager.generated.h"
11533: 
11534: /**
11535:  *
11536:  */
11537: UCLASS()
11538: class WITCHPT_API UWitchPTAssetManager : public UAssetManager
11539: {
11540: 	GENERATED_BODY()
11541: public:
11542: 	static UWitchPTAssetManager& Get();
11543: protected:
11544: 	virtual void StartInitialLoading() override;
11545: 
11546: 
11547: };
11548: </file>
11549: 
11550: <file path="WitchPT/WitchPT.Build.cs">
11551: // Fill out your copyright notice in the Description page of Project Settings.
11552: 
11553: using UnrealBuildTool;
11554: 
11555: public class WitchPT : ModuleRules
11556: {
11557: 	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
11558: 	{
11559: 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
11560: 
11561: 		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });
11562: 
11563: 		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });
11564: 
11565: 		// Uncomment if you are using Slate UI
11566: 		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
11567: 
11568: 		// Uncomment if you are using online features
11569: 		// PrivateDependencyModuleNames.Add("OnlineSubsystem");
11570: 
11571: 		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
11572: 	}
11573: }
11574: </file>
11575: 
11576: <file path="WitchPT/WitchPT.cpp">
11577: // Fill out your copyright notice in the Description page of Project Settings.
11578: 
11579: #include "WitchPT.h"
11580: #include "Modules/ModuleManager.h"
11581: 
11582: IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );
11583: </file>
11584: 
11585: <file path="WitchPT/WitchPT.h">
11586: // Fill out your copyright notice in the Description page of Project Settings.
11587: 
11588: #pragma once
11589: 
11590: #include "CoreMinimal.h"
11591: #define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
11592: #define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
11593: #define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)
11594: </file>
11595: 
11596: <file path="WitchPTEditor.Target.cs">
11597: // Fill out your copyright notice in the Description page of Project Settings.
11598: 
11599: using UnrealBuildTool;
11600: using System.Collections.Generic;
11601: 
11602: public class WitchPTEditorTarget : TargetRules
11603: {
11604: 	public WitchPTEditorTarget(TargetInfo Target) : base(Target)
11605: 	{
11606: 		Type = TargetType.Editor;
11607: 		DefaultBuildSettings = BuildSettingsVersion.V5;
11608: 
11609: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
11610: 	}
11611: }
11612: </file>
11613: 
11614: </files>
```

## File: .vsconfig
```
 1: {
 2:   "version": "1.0",
 3:   "components": [
 4:     "Microsoft.Net.Component.4.6.2.TargetingPack",
 5:     "Microsoft.VisualStudio.Component.Unreal.Workspace",
 6:     "Microsoft.VisualStudio.Component.VC.14.38.17.8.ATL",
 7:     "Microsoft.VisualStudio.Component.VC.14.38.17.8.x86.x64",
 8:     "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
 9:     "Microsoft.VisualStudio.Component.Windows11SDK.22621",
10:     "Microsoft.VisualStudio.Workload.CoreEditor",
11:     "Microsoft.VisualStudio.Workload.ManagedDesktop",
12:     "Microsoft.VisualStudio.Workload.NativeDesktop",
13:     "Microsoft.VisualStudio.Workload.NativeGame"
14:   ]
15: }
```

## File: AITools/repomix_output.txt
```
 1: [2m
 2: đŚ Repomix v0.3.8
 3: [22m
 4: [2mNo custom config found at repomix.config.json5, repomix.config.jsonc, repomix.config.json or global config at C:\Users\andre\AppData\Local\Repomix\repomix.config.json5, C:\Users\andre\AppData\Local\Repomix\repomix.config.jsonc, C:\Users\andre\AppData\Local\Repomix\repomix.config.json.
 5: You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.[22m
 6: [36mâ [39m Searching for files...
 7: [2K[1A[2K[G[36mâ š[39m Searching for files...
 8: [2K[1A[2K[G[36mâ ¸[39m Collecting files...
 9: [2K[1A[2K[G[36mâ ź[39m Collecting files...
10: [2K[1A[2K[G[36mâ ´[39m Collect file... (280/746) [2mContent/Characters/Mannequins/Textures/Manny/T_Manny[22m
11: [2m_01_ASAOPMASK_MSK.uasset[22m
12: [2K[1A[2K[1A[2K[G[36mâ Ś[39m Collect file... (511/746) [2mContent/StarterContent/Textures/T_Brick_Clay_New_D.u[22m
13: [2masset[22m
14: [2K[1A[2K[1A[2K[G[36mâ §[39m Collect file... (574/746) [2mContent/StarterContent/Textures/T_Metal_Rust_N.uasse[22m
15: [2mt[22m
16: [2K[1A[2K[1A[2K[G[36mâ [39m Running security check...
17: [2K[1A[2K[G[36mâ [39m Running security check... (106/132) [2mSource/WitchPT/Public/Item/MechanicsInterf[22m
18: [2mace.h[22m
19: [2K[1A[2K[1A[2K[G[36mâ [39m Processing files...
20: [2K[1A[2K[G[36mâ [39m Generating output...
21: [2K[1A[2K[G[36mâ š[39m Generating output...
22: [2K[1A[2K[G[36mâ ¸[39m Generating output...
23: [2K[1A[2K[G[36mâ ź[39m Generating output...
24: [2K[1A[2K[G[36mâ ´[39m Generating output...
25: [2K[1A[2K[G[36mâ Ś[39m Calculating metrics...
26: [2K[1A[2K[G[36mâ §[39m Calculating metrics...
27: [2K[1A[2K[G[36mâ [39m Calculating metrics...
28: [2K[1A[2K[G[36mâ [39m Calculating metrics... (132/132) [2mWitchPT.uproject.DotSettings.user[22m
29: [2K[1A[2K[G[32mâ[39m Packing completed successfully!
30: 
31: [37mđ Top 5 Files by Character Count and Token Count:[39m
32: [2mââââââââââââââââââââââââââââââââââââââââââââââââââ[22m
33: [37m1. [39m [37mConfig/DefaultEditor.ini[39m [2m(33.719 chars, 9610 tokens, 9.1%)[22m
34: [37m2. [39m [37mSource/WitchPT/Private/Item/RitualAltar.cpp[39m [2m(29.992 chars, 7632 tokens, 7.3%)[22m
35: [37m3. [39m [37mSource/WitchPT/Private/Item/CauldronAltar.cpp[39m [2m(27.794 chars, 6461 tokens, 6.1%)[22m
36: [37m4. [39m [37mConfig/DefaultEngine.ini[39m [2m(24.717 chars, 6093 tokens, 5.8%)[22m
37: [37m5. [39m [37mSource/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp[39m [2m(18.267 chars, 4236 tokens, 4%)[22m
38: 
39: [37mđ Security Check:[39m
40: [2mââââââââââââââââââ[22m
41: [32mâ[39m [37mNo suspicious files detected.[39m
42: 
43: [37mđ Pack Summary:[39m
44: [2mââââââââââââââââ[22m
45: [37m  Total Files:[39m [37m132[39m files
46: [37m  Total Chars:[39m [37m456.842[39m chars
47: [37m Total Tokens:[39m [37m110.206[39m tokens
48: [37m       Output:[39m [37mrepomix-output.xml[39m
49: [37m     Security:[39m [37m[37mâ No suspicious files detected[37m[39m
50: 
51: [32mđ All Done![39m
52: [37mYour repository has been successfully packed.[39m
53: 
54: đĄ Repomix is now available in your browser! Try it at [4mhttps://repomix.com[24m
```

## File: Config/DefaultGame.ini
```
1: [/Script/EngineSettings.GeneralProjectSettings]
2: ProjectID=D0E961A148F1B0C442F689A8AAA6585F
3: 
4: [StartupActions]
5: bAddPacks=True
6: InsertPack=(PackSource="StarterContent.upack",PackName="StarterContent")
7: 
8: [SectionsToSave]
9: +Section=StartupActions
```

## File: repomix-output.xml
```xml
    1: This file is a merged representation of the entire codebase, combined into a single document by Repomix.
    2: 
    3: <file_summary>
    4: This section contains a summary of this file.
    5: 
    6: <purpose>
    7: This file contains a packed representation of the entire repository's contents.
    8: It is designed to be easily consumable by AI systems for analysis, code review,
    9: or other automated processes.
   10: </purpose>
   11: 
   12: <file_format>
   13: The content is organized as follows:
   14: 1. This summary section
   15: 2. Repository information
   16: 3. Directory structure
   17: 4. Repository files (if enabled)
   18: 5. Multiple file entries, each consisting of:
   19:   - File path as an attribute
   20:   - Full contents of the file
   21: </file_format>
   22: 
   23: <usage_guidelines>
   24: - This file should be treated as read-only. Any changes should be made to the
   25:   original repository files, not this packed version.
   26: - When processing this file, use the file path to distinguish
   27:   between different files in the repository.
   28: - Be aware that this file may contain sensitive information. Handle it with
   29:   the same level of security as you would the original repository.
   30: </usage_guidelines>
   31: 
   32: <notes>
   33: - Some files may have been excluded based on .gitignore rules and Repomix's configuration
   34: - Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
   35: - Files matching patterns in .gitignore are excluded
   36: - Files matching default ignore patterns are excluded
   37: - Files are sorted by Git change count (files with more changes are at the bottom)
   38: </notes>
   39: 
   40: </file_summary>
   41: 
   42: <directory_structure>
   43: .gitignore
   44: .vsconfig
   45: AITools/repomix_output.txt
   46: Config/DefaultEditor.ini
   47: Config/DefaultEngine.ini
   48: Config/DefaultGame.ini
   49: Config/DefaultGameplayTags.ini
   50: Config/DefaultInput.ini
   51: Source/WitchPT.Target.cs
   52: Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
   53: Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
   54: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
   55: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
   56: Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
   57: Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
   58: Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
   59: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
   60: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
   61: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
   62: Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
   63: Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
   64: Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
   65: Source/WitchPT/Private/Character/WitchPTCharacter.cpp
   66: Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
   67: Source/WitchPT/Private/Character/WitchPTEnemy.cpp
   68: Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
   69: Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
   70: Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
   71: Source/WitchPT/Private/Inventory/Collectable.cpp
   72: Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
   73: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
   74: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
   75: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
   76: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
   77: Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
   78: Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
   79: Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
   80: Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
   81: Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
   82: Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
   83: Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
   84: Source/WitchPT/Private/Item/CauldronAltar.cpp
   85: Source/WitchPT/Private/Item/CauldronPosition.cpp
   86: Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
   87: Source/WitchPT/Private/Item/Item.cpp
   88: Source/WitchPT/Private/Item/MechanicsInterface.cpp
   89: Source/WitchPT/Private/Item/PositionInterface.cpp
   90: Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
   91: Source/WitchPT/Private/Item/RitualAltar.cpp
   92: Source/WitchPT/Private/Item/RitualPosition.cpp
   93: Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
   94: Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
   95: Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
   96: Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
   97: Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
   98: Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
   99: Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
  100: Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
  101: Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
  102: Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
  103: Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
  104: Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
  105: Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
  106: Source/WitchPT/Private/WitchPTAssetManager.cpp
  107: Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
  108: Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
  109: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
  110: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
  111: Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
  112: Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
  113: Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
  114: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
  115: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
  116: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
  117: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
  118: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
  119: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
  120: Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
  121: Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
  122: Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
  123: Source/WitchPT/Public/Character/WitchPTCharacter.h
  124: Source/WitchPT/Public/Character/WitchPTCharacterBase.h
  125: Source/WitchPT/Public/Character/WitchPTEnemy.h
  126: Source/WitchPT/Public/FWitchPTGameplayTags.cpp
  127: Source/WitchPT/Public/FWitchPTGameplayTags.h
  128: Source/WitchPT/Public/Game/WitchPTGameModeBase.h
  129: Source/WitchPT/Public/Input/WitchPTInputComponent.h
  130: Source/WitchPT/Public/Input/WitchPTInputConfig.h
  131: Source/WitchPT/Public/Inventory/Collectable.h
  132: Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
  133: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
  134: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
  135: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
  136: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
  137: Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
  138: Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
  139: Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
  140: Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
  141: Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
  142: Source/WitchPT/Public/Item/BaseInteractableAltar.h
  143: Source/WitchPT/Public/Item/BaseInteractionPosition.h
  144: Source/WitchPT/Public/Item/CauldronAltar.h
  145: Source/WitchPT/Public/Item/CauldronPosition.h
  146: Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
  147: Source/WitchPT/Public/Item/Item.h
  148: Source/WitchPT/Public/Item/MechanicsInterface.h
  149: Source/WitchPT/Public/Item/PositionInterface.h
  150: Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
  151: Source/WitchPT/Public/Item/RitualAltar.h
  152: Source/WitchPT/Public/Item/RitualPosition.h
  153: Source/WitchPT/Public/Player/WitchPTPlayerController.h
  154: Source/WitchPT/Public/Player/WitchPTPlayerState.h
  155: Source/WitchPT/Public/Systems/GameplayTagStack.cpp
  156: Source/WitchPT/Public/Systems/GameplayTagStack.h
  157: Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
  158: Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
  159: Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
  160: Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
  161: Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
  162: Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
  163: Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
  164: Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
  165: Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
  166: Source/WitchPT/Public/UI/Widgets/PointerWidget.h
  167: Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
  168: Source/WitchPT/Public/WitchPTAssetManager.h
  169: Source/WitchPT/WitchPT.Build.cs
  170: Source/WitchPT/WitchPT.cpp
  171: Source/WitchPT/WitchPT.h
  172: Source/WitchPTEditor.Target.cs
  173: WitchPT.uproject
  174: WitchPT.uproject.DotSettings.user
  175: </directory_structure>
  176: 
  177: <files>
  178: This section contains the contents of the repository's files.
  179: 
  180: <file path="AITools/repomix_output.txt">
  181: [2m
  182: Ã°Å¸â€œÂ¦ Repomix v0.3.8
  183: [22m
  184: [2mNo custom config found at repomix.config.json5, repomix.config.jsonc, repomix.config.json or global config at C:\Users\andre\AppData\Local\Repomix\repomix.config.json5, C:\Users\andre\AppData\Local\Repomix\repomix.config.jsonc, C:\Users\andre\AppData\Local\Repomix\repomix.config.json.
  185: You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.[22m
  186: [36mÃ¢Â â„¢[39m Searching for files...
  187: [2K[1A[2K[G[36mÃ¢Â Â¹[39m Searching for files...
  188: [2K[1A[2K[G[36mÃ¢Â Â¸[39m Collecting files...
  189: [2K[1A[2K[G[36mÃ¢Â Â¼[39m Collecting files...
  190: </file>
  191: 
  192: <file path=".vsconfig">
  193: {
  194:   "version": "1.0",
  195:   "components": [
  196:     "Microsoft.Net.Component.4.6.2.TargetingPack",
  197:     "Microsoft.VisualStudio.Component.Unreal.Workspace",
  198:     "Microsoft.VisualStudio.Component.VC.14.38.17.8.ATL",
  199:     "Microsoft.VisualStudio.Component.VC.14.38.17.8.x86.x64",
  200:     "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
  201:     "Microsoft.VisualStudio.Component.Windows11SDK.22621",
  202:     "Microsoft.VisualStudio.Workload.CoreEditor",
  203:     "Microsoft.VisualStudio.Workload.ManagedDesktop",
  204:     "Microsoft.VisualStudio.Workload.NativeDesktop",
  205:     "Microsoft.VisualStudio.Workload.NativeGame"
  206:   ]
  207: }
  208: </file>
  209: 
  210: <file path="Config/DefaultGame.ini">
  211: [/Script/EngineSettings.GeneralProjectSettings]
  212: ProjectID=D0E961A148F1B0C442F689A8AAA6585F
  213: 
  214: [StartupActions]
  215: bAddPacks=True
  216: InsertPack=(PackSource="StarterContent.upack",PackName="StarterContent")
  217: 
  218: [SectionsToSave]
  219: +Section=StartupActions
  220: </file>
  221: 
  222: <file path="Source/WitchPT.Target.cs">
  223: // Fill out your copyright notice in the Description page of Project Settings.
  224: 
  225: using UnrealBuildTool;
  226: using System.Collections.Generic;
  227: 
  228: public class WitchPTTarget : TargetRules
  229: {
  230: 	public WitchPTTarget(TargetInfo Target) : base(Target)
  231: 	{
  232: 		Type = TargetType.Game;
  233: 		DefaultBuildSettings = BuildSettingsVersion.V5;
  234: 
  235: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
  236: 	}
  237: }
  238: </file>
  239: 
  240: <file path="Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp">
  241: // Fill out your copyright notice in the Description page of Project Settings.
  242: 
  243: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  244: #include "AbilitySystemComponent.h"
  245: #include "GameFramework/PlayerController.h"
  246: #include "Engine/World.h"
  247: #include "DrawDebugHelpers.h"
  248: #include "TimerManager.h"
  249: #include "GameFramework/Character.h"
  250: #include "Camera/CameraComponent.h"
  251: 
  252: UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
  253: 	: Super(ObjectInitializer)
  254: {
  255: 	bTickingTask = true;
  256: 	TraceDistance = 500.0f;
  257: 	TraceRadius = 10.0f;
  258: 	bTraceComplex = false;
  259: 	bIgnoreBlockingHits = false;
  260: 	bShowDebug = false;
  261: 	LastHitLocation = FVector::ZeroVector;
  262: 	LastHitNormal = FVector::UpVector;
  263: }
  264: 
  265: UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
  266: 	UGameplayAbility* OwningAbility,
  267: 	float TraceDistance,
  268: 	float TraceRadius,
  269: 	bool TraceComplex,
  270: 	bool bIgnoreBlockingHits,
  271: 	bool bShowDebug)
  272: {
  273: 	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
  274: 
  275: 	MyObj->TraceDistance = TraceDistance;
  276: 	MyObj->TraceRadius = TraceRadius;
  277: 	MyObj->bTraceComplex = TraceComplex;
  278: 	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
  279: 	MyObj->bShowDebug = bShowDebug;
  280: 
  281: 	return MyObj;
  282: }
  283: 
  284: void UAT_WaitForPlacementLocation_SLT::Activate()
  285: {
  286: 	Super::Activate();
  287: 
  288: 	// Configurar para ejecutar el trace en cada tick
  289: 	SetWaitingOnAvatar();
  290: 
  291: 	// Realizar un primer trace inmediatamente
  292: 	PerformTrace();
  293: }
  294: 
  295: void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
  296: {
  297: 	// Limpiar el temporizador si estÃ¡ activo
  298: 	UWorld* World = GetWorld();
  299: 	if (World)
  300: 	{
  301: 		World->GetTimerManager().ClearTimer(TraceTimerHandle);
  302: 	}
  303: 
  304: 	Super::OnDestroy(bInOwnerFinished);
  305: }
  306: 
  307: void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
  308: {
  309: 	Super::TickTask(DeltaTime);
  310: 
  311: 	// Realizar el trace en cada tick
  312: 	PerformTrace();
  313: }
  314: 
  315: void UAT_WaitForPlacementLocation_SLT::PerformTrace()
  316: {
  317: 	if (!Ability || !Ability->GetCurrentActorInfo())
  318: 	{
  319: 		return;
  320: 	}
  321: 
  322: 	// Obtener el controlador del jugador
  323: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
  324: 	if (!PC)
  325: 	{
  326: 		return;
  327: 	}
  328: 
  329: 	// Obtener el personaje del jugador (necesario para obtener la cÃ¡mara)
  330: 	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
  331: 	if (!Character)
  332: 	{
  333: 		return;
  334: 	}
  335: 
  336: 	// Definir los puntos de inicio y fin del trace
  337: 	FVector TraceStart;
  338: 	FVector TraceDirection;
  339: 
  340: 	// Buscar un componente de cÃ¡mara en el personaje
  341: 	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
  342: 	if (CameraComponent)
  343: 	{
  344: 		// Usar la posiciÃ³n y direcciÃ³n de la cÃ¡mara para el trace
  345: 		TraceStart = CameraComponent->GetComponentLocation();
  346: 		TraceDirection = CameraComponent->GetForwardVector();
  347: 	}
  348: 	else
  349: 	{
  350: 		// Si no hay cÃ¡mara, usar la rotaciÃ³n del controlador
  351: 		FRotator ControllerRotation = PC->GetControlRotation();
  352: 		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
  353: 		TraceDirection = ControllerRotation.Vector();
  354: 	}
  355: 
  356: 	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
  357: 
  358: 	// Configurar parÃ¡metros del trace
  359: 	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
  360: 	QueryParams.AddIgnoredActor(Character);
  361: 
  362: 	// Configurar quÃ© tipos de objetos detectar
  363: 	ECollisionChannel TraceChannel = ECC_Visibility;
  364: 
  365: 	// Realizar el trace
  366: 	FHitResult HitResult;
  367: 	bool bHit = false;
  368: 
  369: 	// Realizar un sphere trace o line trace segÃºn el radio
  370: 	if (TraceRadius > 0.0f)
  371: 	{
  372: 		bHit = GetWorld()->SweepSingleByChannel(
  373: 			HitResult,
  374: 			TraceStart,
  375: 			TraceEnd,
  376: 			FQuat::Identity,
  377: 			TraceChannel,
  378: 			FCollisionShape::MakeSphere(TraceRadius),
  379: 			QueryParams
  380: 		);
  381: 	}
  382: 	else
  383: 	{
  384: 		bHit = GetWorld()->LineTraceSingleByChannel(
  385: 			HitResult,
  386: 			TraceStart,
  387: 			TraceEnd,
  388: 			TraceChannel,
  389: 			QueryParams
  390: 		);
  391: 	}
  392: 
  393: 	// Si encontramos un hit y es diferente al Ãºltimo que reportamos
  394: 	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
  395: 	{
  396: 		// Almacenar los nuevos valores
  397: 		LastHitLocation = HitResult.ImpactPoint;
  398: 		LastHitNormal = HitResult.ImpactNormal;
  399: 
  400: 		// Disparar el delegado con la informaciÃ³n del hit
  401: 		if (ShouldBroadcastAbilityTaskDelegates())
  402: 		{
  403: 			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
  404: 		}
  405: 	}
  406: 
  407: 	// Mostrar debug si estÃ¡ habilitado
  408: 	if (bShowDebug)
  409: 	{
  410: 		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
  411: 
  412: 		if (bHit)
  413: 		{
  414: 			// Dibujar una esfera en el punto de impacto
  415: 			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
  416: 
  417: 			// Dibujar la normal
  418: 			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
  419: 		}
  420: 	}
  421: }
  422: </file>
  423: 
  424: <file path="Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp">
  425: // Fill out your copyright notice in the Description page of Project Settings.
  426: 
  427: 
  428: #include "AbilitySystem/Interaction/InteractionStatics.h"
  429: 
  430: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  431: #include "Engine/OverlapResult.h"
  432: 
  433: UInteractionStatics::UInteractionStatics()
  434: 	: Super(FObjectInitializer::Get())
  435: {
  436: }
  437: 
  438: AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
  439: {
  440: 	if (UObject* Object = InteractableTarget.GetObject())
  441: 	{
  442: 		if (AActor* Actor = Cast<AActor>(Object))
  443: 		{
  444: 			return Actor;
  445: 		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
  446: 		{
  447: 			AActor* ActorToReturn = ActorComponent->GetOwner();
  448: 			return ActorToReturn;
  449: 		} else
  450: 		{
  451: 			unimplemented()
  452: 		}
  453: 	}
  454: 	return nullptr;
  455: }
  456: 
  457: void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
  458: 	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
  459: {
  460: 	// If the actor is directly interactable, return that.
  461: 	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
  462: 	if (InteractableActor)
  463: 	{
  464: 		OutInteractableTargets.Add(InteractableActor);
  465: 	}
  466: 
  467: 	// If the actor isn't interactable, it might have a component that has a interactable interface.
  468: 	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
  469: 	for (UActorComponent* InteractableComponent : InteractableComponents)
  470: 	{
  471: 		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
  472: 	}
  473: }
  474: 
  475: void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
  476: {
  477: 	for (const FOverlapResult& Overlap : OverlapResults)
  478: 	{
  479: 		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
  480: 		if (InteractableActor)
  481: 		{
  482: 			OutInteractableTargets.AddUnique(InteractableActor);
  483: 		}
  484: 
  485: 		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
  486: 		if (InteractableComponent)
  487: 		{
  488: 			OutInteractableTargets.AddUnique(InteractableComponent);
  489: 		}
  490: 	}
  491: }
  492: 
  493: void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
  494: {
  495: 	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
  496: 	if (InteractableActor)
  497: 	{
  498: 		OutInteractableTargets.AddUnique(InteractableActor);
  499: 	}
  500: 
  501: 	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
  502: 	if (InteractableComponent)
  503: 	{
  504: 		OutInteractableTargets.AddUnique(InteractableComponent);
  505: 	}
  506: }
  507: </file>
  508: 
  509: <file path="Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp">
  510: // Fill out your copyright notice in the Description page of Project Settings.
  511: 
  512: 
  513: #include "AbilitySystem/WitchPTAbilitySystemGlobals.h"
  514: </file>
  515: 
  516: <file path="Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp">
  517: // Fill out your copyright notice in the Description page of Project Settings.
  518: 
  519: 
  520: #include "Game/WitchPTGameModeBase.h"
  521: </file>
  522: 
  523: <file path="Source/WitchPT/Private/Input/WitchPTInputComponent.cpp">
  524: // Fill out your copyright notice in the Description page of Project Settings.
  525: 
  526: 
  527: #include "Input/WitchPTInputComponent.h"
  528: </file>
  529: 
  530: <file path="Source/WitchPT/Private/Input/WitchPTInputConfig.cpp">
  531: // Fill out your copyright notice in the Description page of Project Settings.
  532: 
  533: 
  534: #include "Input/WitchPTInputConfig.h"
  535: 
  536: const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
  537: {
  538: 	for (const FWitchPTInputAction& Pair: AbilityInputActions)
  539: 	{
  540: 		if (InputTag == Pair.InputTag)
  541: 		{
  542: 			return Pair.InputAction;
  543: 		}
  544: 	}
  545: 	if (bLogNotFound)
  546: 	{
  547: 		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
  548: 	}
  549: 	return nullptr;
  550: 
  551: }
  552: </file>
  553: 
  554: <file path="Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp">
  555: // Fill out your copyright notice in the Description page of Project Settings.
  556: 
  557: 
  558: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
  559: </file>
  560: 
  561: <file path="Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp">
  562: // Fill out your copyright notice in the Description page of Project Settings.
  563: 
  564: 
  565: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
  566: </file>
  567: 
  568: <file path="Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp">
  569: // Fill out your copyright notice in the Description page of Project Settings.
  570: 
  571: 
  572: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
  573: 
  574: #include "Inventory/WitchPTInventoryItemInstance.h"
  575: 
  576: void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
  577: {
  578: 
  579: }
  580: </file>
  581: 
  582: <file path="Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp">
  583: // Fill out your copyright notice in the Description page of Project Settings.
  584: 
  585: 
  586: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  587: </file>
  588: 
  589: <file path="Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp">
  590: // Fill out your copyright notice in the Description page of Project Settings.
  591: 
  592: 
  593: #include "Inventory/InventoryFunctionLibrary.h"
  594: 
  595: #include "Kismet/GameplayStatics.h"
  596: #include "Player/WitchPTPlayerState.h"
  597: #include "UI/HUD/WitchPTHUD.h"
  598: #include "UI/WidgetControllers/WitchPTWidgetController.h"
  599: 
  600: UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
  601: {
  602: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
  603: 	{
  604: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
  605: 		{
  606: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
  607: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
  608: 			UAttributeSet* AS = PS->GetAttributeSet();
  609: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
  610: 
  611: 			return WitchPTHUD->SetInventoryWidgetController(WCParams);
  612: 		}
  613: 	}
  614: 	return nullptr;
  615: }
  616: </file>
  617: 
  618: <file path="Source/WitchPT/Private/Item/Item.cpp">
  619: // Fill out your copyright notice in the Description page of Project Settings.
  620: 
  621: 
  622: #include "Item/Item.h"
  623: 
  624: 
  625: // Sets default values
  626: AItem::AItem()
  627: {
  628: 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
  629: 	PrimaryActorTick.bCanEverTick = true;
  630: }
  631: 
  632: // Called when the game starts or when spawned
  633: void AItem::BeginPlay()
  634: {
  635: 	Super::BeginPlay();
  636: 
  637: }
  638: 
  639: // Called every frame
  640: void AItem::Tick(float DeltaTime)
  641: {
  642: 	Super::Tick(DeltaTime);
  643: }
  644: 
  645: void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
  646: {
  647: 	OptionBuilder.AddInteractionOption(Option);
  648: }
  649: </file>
  650: 
  651: <file path="Source/WitchPT/Private/Item/MechanicsInterface.cpp">
  652: // Fill out your copyright notice in the Description page of Project Settings.
  653: 
  654: 
  655: #include "Item/MechanicsInterface.h"
  656: 
  657: // Add default functionality here for any IMechanicsInterface functions that are not pure virtual.
  658: </file>
  659: 
  660: <file path="Source/WitchPT/Private/Item/PositionInterface.cpp">
  661: // Fill out your copyright notice in the Description page of Project Settings.
  662: 
  663: 
  664: #include "Item/PositionInterface.h"
  665: 
  666: // Add default functionality here for any IPositionInterface functions that are not pure virtual.
  667: </file>
  668: 
  669: <file path="Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp">
  670: // Fill out your copyright notice in the Description page of Project Settings.
  671: 
  672: 
  673: #include "UI/WidgetControllers/OverlayWidgetController.h"
  674: 
  675: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  676: #include "AbilitySystem/WitchPTAttributeSet.h"
  677: 
  678: void UOverlayWidgetController::BroadcastInitialValues()
  679: {
  680: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
  681: 
  682: 	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
  683: 	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
  684: 	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
  685: 	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
  686: 	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
  687: 	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
  688: }
  689: 
  690: void UOverlayWidgetController::BindCallbacksToDependencies()
  691: {
  692: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
  693: 
  694: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  695: 	{
  696: 		OnHealthChanged.Broadcast(Data.NewValue);
  697: 	});
  698: 
  699: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  700: 	{
  701: 		OnMaxHealthChanged.Broadcast(Data.NewValue);
  702: 	});
  703: 
  704: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  705: 	{
  706: 		OnStaminaChanged.Broadcast(Data.NewValue);
  707: 	});
  708: 
  709: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  710: 	{
  711: 		OnMaxStaminaChanged.Broadcast(Data.NewValue);
  712: 	});
  713: 
  714: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  715: 	{
  716: 		OnAgeChanged.Broadcast(Data.NewValue);
  717: 	});
  718: 
  719: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
  720: 	{
  721: 		OnMaxAgeChanged.Broadcast(Data.NewValue);
  722: 	});
  723: 
  724: 	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
  725: 
  726: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
  727: 
  728: 	// Lambda for message delegates
  729: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
  730: 		// [this] is the capture list, in the case of this lambda, we want to capture this (OverlayWidgetController)
  731: 		[this](const FGameplayTagContainer& AssetTags)
  732: 	{
  733: 		for (const auto& Tag : AssetTags)
  734: 		{
  735: 			// Declare the tag we want to check. In our case "MessageTag"
  736: 			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
  737: 			if (Tag.MatchesTag(ParentMessageGameplayTag))
  738: 			{
  739: 
  740: 
  741: 				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
  742: 				OnMessageWidgetRow.Broadcast(*Row);
  743: 
  744: 			}
  745: 
  746: 		}
  747: 	});
  748: 
  749: 
  750: 
  751: }
  752: void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
  753: {
  754: 
  755: }
  756: </file>
  757: 
  758: <file path="Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp">
  759: // Fill out your copyright notice in the Description page of Project Settings.
  760: 
  761: 
  762: #include "UI/WidgetControllers/WitchPTWidgetController.h"
  763: 
  764: void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
  765: {
  766: 	PlayerController = WCParams.PlayerController;
  767: 	PlayerState = WCParams.PlayerState;
  768: 	AbilitySystemComponent = WCParams.AbilitySystemComponent;
  769: 	AttributeSet = WCParams.AttributeSet;
  770: }
  771: 
  772: void UWitchPTWidgetController::BroadcastInitialValues()
  773: {
  774: }
  775: 
  776: void UWitchPTWidgetController::BindCallbacksToDependencies()
  777: {
  778: }
  779: </file>
  780: 
  781: <file path="Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp">
  782: // Fill out your copyright notice in the Description page of Project Settings.
  783: 
  784: 
  785: #include "UI/Widgets/Inventory/RitualUserWidget.h"
  786: </file>
  787: 
  788: <file path="Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp">
  789: // Fill out your copyright notice in the Description page of Project Settings.
  790: 
  791: 
  792: #include "UI/Widgets/PointerWidget.h"
  793: </file>
  794: 
  795: <file path="Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp">
  796: // Fill out your copyright notice in the Description page of Project Settings.
  797: 
  798: 
  799: #include "UI/Widgets/WitchPTUserWidget.h"
  800: 
  801: void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
  802: {
  803: 	WidgetController = InWidgetController;
  804: 	OnWidgetControllerSet();
  805: }
  806: </file>
  807: 
  808: <file path="Source/WitchPT/Private/WitchPTAssetManager.cpp">
  809: // Fill out your copyright notice in the Description page of Project Settings.
  810: 
  811: 
  812: #include "WitchPTAssetManager.h"
  813: 
  814: #include "AbilitySystemGlobals.h"
  815: #include "FWitchPTGameplayTags.h"
  816: 
  817: UWitchPTAssetManager& UWitchPTAssetManager::Get()
  818: {
  819: 	check(GEngine)
  820: 	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
  821: 	return *WitchPtAssetManager;
  822: }
  823: 
  824: void UWitchPTAssetManager::StartInitialLoading()
  825: {
  826: 	Super::StartInitialLoading();
  827: 	FWitchPTGameplayTags::InitializeGameplayTags();
  828: 	/**
  829: 	 *
  830: 	 */
  831: 	// TODO: What is this function for?
  832: 
  833: 	UAbilitySystemGlobals::Get().InitGlobalData();
  834: 
  835: }
  836: </file>
  837: 
  838: <file path="Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h">
  839: // Fill out your copyright notice in the Description page of Project Settings.
  840: 
  841: #pragma once
  842: 
  843: #include "CoreMinimal.h"
  844: #include "Abilities/Tasks/AbilityTask.h"
  845: #include "AT_WaitForPlacementLocation_SLT.generated.h"
  846: 
  847: // Delegado para enviar la informaciÃ³n de la ubicaciÃ³n y la normal
  848: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);
  849: 
  850: /**
  851:  * Task que realiza un line trace continuo para encontrar ubicaciones vÃ¡lidas para colocar el caldero.
  852:  * Similar a UAT_WaitForInteractable_SLT pero devuelve informaciÃ³n de ubicaciÃ³n y normal de la superficie.
  853:  */
  854: UCLASS()
  855: class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
  856: {
  857: 	GENERATED_BODY()
  858: 
  859: public:
  860: 	// Constructor
  861: 	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);
  862: 
  863: 	// Crea y configura la tarea
  864: 	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
  865: 	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
  866: 		UGameplayAbility* OwningAbility,
  867: 		float TraceDistance = 500.0f,
  868: 		float TraceRadius = 10.0f,
  869: 		bool TraceComplex = false,
  870: 		bool bIgnoreBlockingHits = false,
  871: 		bool bShowDebug = false);
  872: 
  873: 	// Delegado llamado cuando se encuentra una ubicaciÃ³n vÃ¡lida
  874: 	UPROPERTY(BlueprintAssignable)
  875: 	FPlacementLocationFound OnLocationFound;
  876: 
  877: 	// Se llama cuando se activa la tarea
  878: 	virtual void Activate() override;
  879: 
  880: 	// Se llama cuando se termina la tarea
  881: 	virtual void OnDestroy(bool bInOwnerFinished) override;
  882: 
  883: private:
  884: 	// Realiza el line trace para encontrar ubicaciones
  885: 	void PerformTrace();
  886: 
  887: 	// Realiza un line trace cada tick para actualizar la ubicaciÃ³n
  888: 	void TickTask(float DeltaTime);
  889: 
  890: 	// Temporizador para realizar el trace
  891: 	FTimerHandle TraceTimerHandle;
  892: 
  893: 	// Distancia del trace
  894: 	float TraceDistance;
  895: 
  896: 	// Radio del trace (para spheretrace)
  897: 	float TraceRadius;
  898: 
  899: 	// Si se debe considerar geometrÃ­a compleja
  900: 	bool bTraceComplex;
  901: 
  902: 	// Si se deben ignorar hits bloqueantes
  903: 	bool bIgnoreBlockingHits;
  904: 
  905: 	// Si se debe mostrar debug visual
  906: 	bool bShowDebug;
  907: 
  908: 	// Ãšltima ubicaciÃ³n de hit encontrada
  909: 	FVector LastHitLocation;
  910: 
  911: 	// Ãšltima normal encontrada
  912: 	FVector LastHitNormal;
  913: };
  914: </file>
  915: 
  916: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h">
  917: // Copyright Epic Games, Inc. All Rights Reserved.
  918: 
  919: #pragma once
  920: 
  921: #include "CoreMinimal.h"
  922: #include "Abilities/GameplayAbility.h"
  923: #include "InteractionQuery.generated.h"
  924: 
  925: 
  926: /**  */
  927: USTRUCT(BlueprintType)
  928: struct FInteractionQuery
  929: {
  930: 	GENERATED_BODY()
  931: 
  932: public:
  933: 	/** The requesting pawn. */
  934: 	UPROPERTY(BlueprintReadWrite)
  935: 	TWeakObjectPtr<AActor> RequestingAvatar;
  936: 
  937: 	/** Allow us to specify a controller - does not need to match the owner of the requesting avatar. */
  938: 	UPROPERTY(BlueprintReadWrite)
  939: 	TWeakObjectPtr<AController> RequestingController;
  940: 
  941: 	/** A generic UObject to shove in extra data required for the interaction */
  942: 	UPROPERTY(BlueprintReadWrite)
  943: 	TWeakObjectPtr<UObject> OptionalObjectData;
  944: };
  945: </file>
  946: 
  947: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h">
  948: // Fill out your copyright notice in the Description page of Project Settings.
  949: 
  950: #pragma once
  951: 
  952: #include "CoreMinimal.h"
  953: #include "Kismet/BlueprintFunctionLibrary.h"
  954: #include "InteractionStatics.generated.h"
  955: 
  956: template <typename InterfaceType> class TScriptInterface;
  957: class AActor;
  958: class IInteractableTarget;
  959: class UObject;
  960: 
  961: /**
  962:  *
  963:  */
  964: UCLASS()
  965: class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
  966: {
  967: 	GENERATED_BODY()
  968: public:
  969: 	UInteractionStatics();
  970: 
  971: public:
  972: 	UFUNCTION(BlueprintCallable)
  973: 	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);
  974: 
  975: 	UFUNCTION(BlueprintCallable)
  976: 	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
  977: 	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
  978: 	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
  979: };
  980: </file>
  981: 
  982: <file path="Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h">
  983: // Fill out your copyright notice in the Description page of Project Settings.
  984: 
  985: #pragma once
  986: 
  987: #include "CoreMinimal.h"
  988: #include "AbilitySystemGlobals.h"
  989: #include "WitchPTAbilitySystemGlobals.generated.h"
  990: 
  991: /**
  992:  *
  993:  */
  994: UCLASS()
  995: class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
  996: {
  997: 	GENERATED_BODY()
  998: };
  999: </file>
 1000: 
 1001: <file path="Source/WitchPT/Public/Character/WitchPTEnemy.h">
 1002: // Fill out your copyright notice in the Description page of Project Settings.
 1003: 
 1004: #pragma once
 1005: 
 1006: #include "CoreMinimal.h"
 1007: #include "WitchPTCharacterBase.h"
 1008: #include "WitchPTEnemy.generated.h"
 1009: 
 1010: UCLASS()
 1011: class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
 1012: {
 1013: 	GENERATED_BODY()
 1014: 
 1015: public:
 1016: 	// Sets default values for this character's properties
 1017: 	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);
 1018: 
 1019: protected:
 1020: 	// Called when the game starts or when spawned
 1021: 	virtual void BeginPlay() override;
 1022: 
 1023: public:
 1024: 	// Called every frame
 1025: 	virtual void Tick(float DeltaTime) override;
 1026: 
 1027: 	// Called to bind functionality to input
 1028: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
 1029: };
 1030: </file>
 1031: 
 1032: <file path="Source/WitchPT/Public/Game/WitchPTGameModeBase.h">
 1033: // Fill out your copyright notice in the Description page of Project Settings.
 1034: 
 1035: #pragma once
 1036: 
 1037: #include "CoreMinimal.h"
 1038: #include "GameFramework/GameModeBase.h"
 1039: #include "WitchPTGameModeBase.generated.h"
 1040: 
 1041: /**
 1042:  *
 1043:  */
 1044: UCLASS()
 1045: class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
 1046: {
 1047: 	GENERATED_BODY()
 1048: };
 1049: </file>
 1050: 
 1051: <file path="Source/WitchPT/Public/Input/WitchPTInputComponent.h">
 1052: // Fill out your copyright notice in the Description page of Project Settings.
 1053: 
 1054: #pragma once
 1055: 
 1056: #include "CoreMinimal.h"
 1057: #include "EnhancedInputComponent.h"
 1058: #include "WitchPTInputConfig.h"
 1059: 
 1060: #include "WitchPTInputComponent.generated.h"
 1061: 
 1062: 
 1063: UCLASS()
 1064: class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
 1065: {
 1066: 	GENERATED_BODY()
 1067: 
 1068: public:
 1069: 	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
 1070: 	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);
 1071: 
 1072: };
 1073: 
 1074: template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
 1075: void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
 1076: 	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
 1077: {
 1078: 	check(InputConfig);
 1079: 	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
 1080: 	{
 1081: 		if (Action.InputAction && Action.InputTag.IsValid())
 1082: 		{
 1083: 			if (PressedFunc)
 1084: 			{
 1085: 				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
 1086: 			}
 1087: 			if (ReleasedFunc)
 1088: 			{
 1089: 				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
 1090: 			}
 1091: 			if (HeldFunc)
 1092: 			{
 1093: 				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
 1094: 			}
 1095: 		}
 1096: 	}
 1097: 
 1098: }
 1099: </file>
 1100: 
 1101: <file path="Source/WitchPT/Public/Input/WitchPTInputConfig.h">
 1102: // Fill out your copyright notice in the Description page of Project Settings.
 1103: 
 1104: #pragma once
 1105: 
 1106: #include "CoreMinimal.h"
 1107: #include "GameplayTagContainer.h"
 1108: #include "Engine/DataAsset.h"
 1109: #include "WitchPTInputConfig.generated.h"
 1110: 
 1111: USTRUCT(BlueprintType)
 1112: struct FWitchPTInputAction
 1113: {
 1114: 	GENERATED_BODY()
 1115: 	UPROPERTY(EditDefaultsOnly)
 1116: 	const class UInputAction* InputAction = nullptr;
 1117: 
 1118: 	UPROPERTY(EditDefaultsOnly)
 1119: 	FGameplayTag InputTag = FGameplayTag();
 1120: };
 1121: /**
 1122:  *
 1123:  */
 1124: UCLASS()
 1125: class WITCHPT_API UWitchPTInputConfig : public UDataAsset
 1126: {
 1127: 	GENERATED_BODY()
 1128: 	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
 1129: public:
 1130: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1131: 	TArray<FWitchPTInputAction> AbilityInputActions;
 1132: 
 1133: };
 1134: </file>
 1135: 
 1136: <file path="Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h">
 1137: // Fill out your copyright notice in the Description page of Project Settings.
 1138: 
 1139: #pragma once
 1140: 
 1141: #include "CoreMinimal.h"
 1142: #include "WitchPTInventoryItemFragment.h"
 1143: #include "WitchPTInventoryFragment_Stackable.generated.h"
 1144: 
 1145: /**
 1146:  *
 1147:  */
 1148: UCLASS()
 1149: class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
 1150: {
 1151: 	GENERATED_BODY()
 1152: public:
 1153: 
 1154: 	int32 GetMaxStackSize() const { return MaxStackSize; }
 1155: 	int32 GetStackCount() const { return StackCount; }
 1156: 	void SetStackCount(int32 Count) { StackCount = Count; }
 1157: 
 1158: private:
 1159: 
 1160: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 1161: 	int32 MaxStackSize{1};
 1162: 
 1163: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 1164: 	int32 StackCount{1};
 1165: };
 1166: </file>
 1167: 
 1168: <file path="Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h">
 1169: // Fill out your copyright notice in the Description page of Project Settings.
 1170: 
 1171: #pragma once
 1172: 
 1173: #include "CoreMinimal.h"
 1174: #include "GameplayTagContainer.h"
 1175: #include "WitchPTInventoryItemFragment.h"
 1176: #include "WitchPTInventoryFragment_UIDetails.generated.h"
 1177: 
 1178: /**
 1179:  *
 1180:  */
 1181: UCLASS()
 1182: class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
 1183: {
 1184: 	GENERATED_BODY()
 1185: public:
 1186: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1187: 	FText Title;
 1188: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1189: 	FText Description;
 1190: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1191: 	TSubclassOf<UUserWidget> IconWidget;
 1192: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1193: 	FGameplayTag TierTag;
 1194: 
 1195: 
 1196: };
 1197: </file>
 1198: 
 1199: <file path="Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h">
 1200: // Fill out your copyright notice in the Description page of Project Settings.
 1201: 
 1202: #pragma once
 1203: 
 1204: #include "CoreMinimal.h"
 1205: #include "GameplayTagContainer.h"
 1206: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 1207: #include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"
 1208: 
 1209: USTRUCT(BlueprintType)
 1210: struct FBaseIngredientData
 1211: {
 1212: 	GENERATED_BODY()
 1213: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1214: 	FGameplayTag BaseLiquidTypeTag;
 1215: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1216: 	int32 DefaultChargesProvided;
 1217: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1218: 	float StabilityModifier;
 1219: };
 1220: 
 1221: USTRUCT(BlueprintType)
 1222: struct FPrincipalIngredientData
 1223: {
 1224: 	GENERATED_BODY()
 1225: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1226: 	FGameplayTag PrincipalEssenceTag;
 1227: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1228: 	float BasePotency;
 1229: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1230: 	float BaseDuration;
 1231: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1232: 	bool bIsRitualEssence;
 1233: };
 1234: 
 1235: USTRUCT(BlueprintType)
 1236: struct FModifierIngredientData
 1237: {
 1238: 	GENERATED_BODY()
 1239: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1240: 	FGameplayTagContainer ModifierEffectTags;
 1241: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1242: 	float PotencyModificationValue;
 1243: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1244: 	float DurationModificationValue;
 1245: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1246: 	FGameplayTag GrantedPropertyTag;
 1247: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1248: 	FGameplayTag AddedEffectTag;
 1249: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1250: 	float StrengthOfModifier;
 1251: 
 1252: };
 1253: UCLASS()
 1254: class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
 1255: {
 1256: 	GENERATED_BODY()
 1257: public:
 1258: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1259: 	FGameplayTag SlotUsageTag;
 1260: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1261: 	FGameplayTag TierTag;
 1262: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1263: 	FGameplayTag CategoryTag;
 1264: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1265: 	FBaseIngredientData BaseIngredientData;
 1266: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1267: 	FPrincipalIngredientData PrincipalIngredientData;
 1268: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 1269: 	FModifierIngredientData ModifierIngredientData;
 1270: 
 1271: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
 1272: };
 1273: </file>
 1274: 
 1275: <file path="Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h">
 1276: // Fill out your copyright notice in the Description page of Project Settings.
 1277: 
 1278: #pragma once
 1279: 
 1280: #include "CoreMinimal.h"
 1281: #include "Kismet/BlueprintFunctionLibrary.h"
 1282: #include "InventoryFunctionLibrary.generated.h"
 1283: 
 1284: class UInventoryWidgetController;
 1285: /**
 1286:  *
 1287:  */
 1288: UCLASS()
 1289: class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
 1290: {
 1291: 	GENERATED_BODY()
 1292: public:
 1293: 	UFUNCTION(BlueprintPure, Category="Inventory")
 1294: 	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
 1295: };
 1296: </file>
 1297: 
 1298: <file path="Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h">
 1299: // Fill out your copyright notice in the Description page of Project Settings.
 1300: 
 1301: #pragma once
 1302: 
 1303: #include "CoreMinimal.h"
 1304: #include "Kismet/BlueprintFunctionLibrary.h"
 1305: #include "WitchPTInventoryFunctionLibrary.generated.h"
 1306: 
 1307: class UWitchPTInventoryItemDefinition;
 1308: class UWitchPTInventoryItemFragment;
 1309: /**
 1310:  *
 1311:  */
 1312: UCLASS()
 1313: class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
 1314: {
 1315: 	GENERATED_BODY()
 1316: 	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
 1317: 	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
 1318: };
 1319: </file>
 1320: 
 1321: <file path="Source/WitchPT/Public/Item/Item.h">
 1322: // Fill out your copyright notice in the Description page of Project Settings.
 1323: 
 1324: #pragma once
 1325: 
 1326: #include "CoreMinimal.h"
 1327: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 1328: #include "GameFramework/Actor.h"
 1329: #include "Item.generated.h"
 1330: 
 1331: UCLASS()
 1332: class WITCHPT_API AItem : public AActor, public IInteractableTarget
 1333: {
 1334: 	GENERATED_BODY()
 1335: 
 1336: public:
 1337: 	// Sets default values for this actor's properties
 1338: 	AItem();
 1339: 
 1340: protected:
 1341: 	// Called when the game starts or when spawned
 1342: 	virtual void BeginPlay() override;
 1343: 	UPROPERTY(EditAnywhere)
 1344: 	FInteractionOption Option;
 1345: 
 1346: public:
 1347: 	// Called every frame
 1348: 	virtual void Tick(float DeltaTime) override;
 1349: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 1350: };
 1351: </file>
 1352: 
 1353: <file path="Source/WitchPT/Public/Item/PositionInterface.h">
 1354: // Fill out your copyright notice in the Description page of Project Settings.
 1355: 
 1356: #pragma once
 1357: 
 1358: #include "CoreMinimal.h"
 1359: #include "UObject/Interface.h"
 1360: #include "PositionInterface.generated.h"
 1361: 
 1362: class ARitualAltar;
 1363: // This class does not need to be modified.
 1364: UINTERFACE(MinimalAPI)
 1365: class UPositionInterface : public UInterface
 1366: {
 1367: 	GENERATED_BODY()
 1368: };
 1369: 
 1370: /**
 1371:  *
 1372:  */
 1373: class WITCHPT_API IPositionInterface
 1374: {
 1375: 	GENERATED_BODY()
 1376: 
 1377: 	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
 1378: public:
 1379: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
 1380: 	ARitualAltar* GetRitualAltarActor() const;
 1381: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
 1382: 	bool IsOccupied();
 1383: };
 1384: </file>
 1385: 
 1386: <file path="Source/WitchPT/Public/Systems/GameplayTagStack.cpp">
 1387: // Copyright Epic Games, Inc. All Rights Reserved.
 1388: 
 1389: #include "Systems/GameplayTagStack.h"
 1390: 
 1391: #include "UObject/Stack.h"
 1392: 
 1393: #include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)
 1394: 
 1395: //////////////////////////////////////////////////////////////////////
 1396: // FGameplayTagStack
 1397: 
 1398: FString FGameplayTagStack::GetDebugString() const
 1399: {
 1400: 	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
 1401: }
 1402: 
 1403: //////////////////////////////////////////////////////////////////////
 1404: // FGameplayTagStackContainer
 1405: 
 1406: void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
 1407: {
 1408: 	if (!Tag.IsValid())
 1409: 	{
 1410: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
 1411: 		return;
 1412: 	}
 1413: 
 1414: 	if (StackCount > 0)
 1415: 	{
 1416: 		for (FGameplayTagStack& Stack : Stacks)
 1417: 		{
 1418: 			if (Stack.Tag == Tag)
 1419: 			{
 1420: 				const int32 NewCount = Stack.StackCount + StackCount;
 1421: 				Stack.StackCount = NewCount;
 1422: 				TagToCountMap[Tag] = NewCount;
 1423: 				MarkItemDirty(Stack);
 1424: 				return;
 1425: 			}
 1426: 		}
 1427: 
 1428: 		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
 1429: 		MarkItemDirty(NewStack);
 1430: 		TagToCountMap.Add(Tag, StackCount);
 1431: 	}
 1432: }
 1433: 
 1434: void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
 1435: {
 1436: 	if (!Tag.IsValid())
 1437: 	{
 1438: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
 1439: 		return;
 1440: 	}
 1441: 
 1442: 	//@TODO: Should we error if you try to remove a stack that doesn't exist or has a smaller count?
 1443: 	if (StackCount > 0)
 1444: 	{
 1445: 		for (auto It = Stacks.CreateIterator(); It; ++It)
 1446: 		{
 1447: 			FGameplayTagStack& Stack = *It;
 1448: 			if (Stack.Tag == Tag)
 1449: 			{
 1450: 				if (Stack.StackCount <= StackCount)
 1451: 				{
 1452: 					It.RemoveCurrent();
 1453: 					TagToCountMap.Remove(Tag);
 1454: 					MarkArrayDirty();
 1455: 				}
 1456: 				else
 1457: 				{
 1458: 					const int32 NewCount = Stack.StackCount - StackCount;
 1459: 					Stack.StackCount = NewCount;
 1460: 					TagToCountMap[Tag] = NewCount;
 1461: 					MarkItemDirty(Stack);
 1462: 				}
 1463: 				return;
 1464: 			}
 1465: 		}
 1466: 	}
 1467: }
 1468: 
 1469: void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 1470: {
 1471: 	for (int32 Index : RemovedIndices)
 1472: 	{
 1473: 		const FGameplayTag Tag = Stacks[Index].Tag;
 1474: 		TagToCountMap.Remove(Tag);
 1475: 	}
 1476: }
 1477: 
 1478: void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 1479: {
 1480: 	for (int32 Index : AddedIndices)
 1481: 	{
 1482: 		const FGameplayTagStack& Stack = Stacks[Index];
 1483: 		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
 1484: 	}
 1485: }
 1486: 
 1487: void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 1488: {
 1489: 	for (int32 Index : ChangedIndices)
 1490: 	{
 1491: 		const FGameplayTagStack& Stack = Stacks[Index];
 1492: 		TagToCountMap[Stack.Tag] = Stack.StackCount;
 1493: 	}
 1494: }
 1495: </file>
 1496: 
 1497: <file path="Source/WitchPT/Public/Systems/GameplayTagStack.h">
 1498: // Copyright Epic Games, Inc. All Rights Reserved.
 1499: 
 1500: #pragma once
 1501: 
 1502: #include "GameplayTagContainer.h"
 1503: #include "Net/Serialization/FastArraySerializer.h"
 1504: 
 1505: #include "GameplayTagStack.generated.h"
 1506: 
 1507: struct FGameplayTagStackContainer;
 1508: struct FNetDeltaSerializeInfo;
 1509: 
 1510: /**
 1511:  * Represents one stack of a gameplay tag (tag + count)
 1512:  */
 1513: USTRUCT(BlueprintType)
 1514: struct FGameplayTagStack : public FFastArraySerializerItem
 1515: {
 1516: 	GENERATED_BODY()
 1517: 
 1518: 	FGameplayTagStack()
 1519: 	{}
 1520: 
 1521: 	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
 1522: 		: Tag(InTag)
 1523: 		, StackCount(InStackCount)
 1524: 	{
 1525: 	}
 1526: 
 1527: 	FString GetDebugString() const;
 1528: 
 1529: private:
 1530: 	friend FGameplayTagStackContainer;
 1531: 
 1532: 	UPROPERTY()
 1533: 	FGameplayTag Tag;
 1534: 
 1535: 	UPROPERTY()
 1536: 	int32 StackCount = 0;
 1537: };
 1538: 
 1539: /** Container of gameplay tag stacks */
 1540: USTRUCT(BlueprintType)
 1541: struct FGameplayTagStackContainer : public FFastArraySerializer
 1542: {
 1543: 	GENERATED_BODY()
 1544: 
 1545: 	FGameplayTagStackContainer()
 1546: 	//	: Owner(nullptr)
 1547: 	{
 1548: 	}
 1549: 
 1550: public:
 1551: 	// Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
 1552: 	void AddStack(FGameplayTag Tag, int32 StackCount);
 1553: 
 1554: 	// Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
 1555: 	void RemoveStack(FGameplayTag Tag, int32 StackCount);
 1556: 
 1557: 	// Returns the stack count of the specified tag (or 0 if the tag is not present)
 1558: 	int32 GetStackCount(FGameplayTag Tag) const
 1559: 	{
 1560: 		return TagToCountMap.FindRef(Tag);
 1561: 	}
 1562: 
 1563: 	// Returns true if there is at least one stack of the specified tag
 1564: 	bool ContainsTag(FGameplayTag Tag) const
 1565: 	{
 1566: 		return TagToCountMap.Contains(Tag);
 1567: 	}
 1568: 
 1569: 	//~FFastArraySerializer contract
 1570: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 1571: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 1572: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 1573: 	//~End of FFastArraySerializer contract
 1574: 
 1575: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
 1576: 	{
 1577: 		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
 1578: 	}
 1579: 
 1580: private:
 1581: 	// Replicated list of gameplay tag stacks
 1582: 	UPROPERTY()
 1583: 	TArray<FGameplayTagStack> Stacks;
 1584: 
 1585: 	// Accelerated list of tag stacks for queries
 1586: 	TMap<FGameplayTag, int32> TagToCountMap;
 1587: };
 1588: 
 1589: template<>
 1590: struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
 1591: {
 1592: 	enum
 1593: 	{
 1594: 		WithNetDeltaSerializer = true,
 1595: 	};
 1596: };
 1597: </file>
 1598: 
 1599: <file path="Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h">
 1600: // Fill out your copyright notice in the Description page of Project Settings.
 1601: 
 1602: #pragma once
 1603: 
 1604: #include "CoreMinimal.h"
 1605: #include "GameplayTagContainer.h"
 1606: #include "WitchPTWidgetController.h"
 1607: #include "OverlayWidgetController.generated.h"
 1608: class UWitchPTUserWidget;
 1609: 
 1610: USTRUCT()
 1611: struct FUIWidgetRow: public FTableRowBase
 1612: {
 1613: 	GENERATED_BODY()
 1614: 
 1615: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 1616: 	FGameplayTag MessageGameplayTag = FGameplayTag();
 1617: 
 1618: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 1619: 	FText Message = FText();
 1620: 
 1621: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 1622: 	TSubclassOf<UWitchPTUserWidget> MessageWidget;
 1623: 
 1624: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 1625: 	UTexture2D* Image = nullptr;
 1626: 
 1627: };
 1628: 
 1629: 
 1630: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);
 1631: 
 1632: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);
 1633: 
 1634: UCLASS(BlueprintType, Blueprintable)
 1635: class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
 1636: {
 1637: 	GENERATED_BODY()
 1638: public:
 1639: 	/**
 1640: 	 * Handles the reception of asset gameplay tags from a Gameplay Effect (GE).
 1641: 	 *
 1642: 	 * This method is triggered when a Gameplay Effect sends a set of gameplay tags
 1643: 	 * as part of its asset definition. It usually processes or reacts to the tags
 1644: 	 * received within the container.
 1645: 	 *
 1646: 	 * @param TagContainer A container of gameplay tags associated with the triggered Gameplay Effect.
 1647: 	 */
 1648: 	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
 1649: 	virtual void BroadcastInitialValues() override;
 1650: 
 1651: 	virtual void BindCallbacksToDependencies() override;
 1652: 
 1653: 
 1654: 
 1655: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1656: 	FOnAttributeChangedSignature OnHealthChanged;
 1657: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1658: 	FOnAttributeChangedSignature OnMaxHealthChanged;
 1659: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1660: 	FOnAttributeChangedSignature OnStaminaChanged;
 1661: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1662: 	FOnAttributeChangedSignature OnMaxStaminaChanged;
 1663: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1664: 	FOnAttributeChangedSignature OnAgeChanged;
 1665: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
 1666: 	FOnAttributeChangedSignature OnMaxAgeChanged;
 1667: 
 1668: 	UPROPERTY(BlueprintAssignable, Category="Widget Data")
 1669: 	FOnMessageWidgetRowSignature OnMessageWidgetRow;
 1670: protected:
 1671: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
 1672: 	TObjectPtr<UDataTable> MessageWidgetDataTable;
 1673: 
 1674: 	template<typename T>
 1675: T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
 1676: };
 1677: 
 1678: template <typename T>
 1679: T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
 1680: {
 1681: 	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));
 1682: 
 1683: }
 1684: </file>
 1685: 
 1686: <file path="Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h">
 1687: // Fill out your copyright notice in the Description page of Project Settings.
 1688: 
 1689: #pragma once
 1690: 
 1691: #include "CoreMinimal.h"
 1692: #include "UObject/Object.h"
 1693: #include "WitchPTWidgetController.generated.h"
 1694: 
 1695: class UAbilitySystemComponent;
 1696: class UAttributeSet;
 1697: /**
 1698:  * @struct FWidgetControllerParams
 1699:  * @brief A structure that encapsulates parameters required to initialize a widget controller.
 1700:  *
 1701:  * This structure is designed to pass necessary references into widget controllers for proper functionality,
 1702:  * primarily used in player-related widgets to access player-specific systems and attributes.
 1703:  *
 1704:  * It includes references to the Player Controller, Player State, Ability System Component,
 1705:  * and an Attribute Set. These references allow the widget controller to interact with the gameplay systems
 1706:  * linked to a player.
 1707:  *
 1708:  * @note Each of the parameters is a nullable pointer to account for scenarios where specific components
 1709:  * may not be initialized or required.
 1710:  */
 1711: USTRUCT(BlueprintType)
 1712: struct FWidgetControllerParams
 1713: {
 1714: 	GENERATED_BODY()
 1715: 	FWidgetControllerParams() {};
 1716: 	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
 1717: 	:
 1718: 	PlayerController(PC),
 1719: 	PlayerState(PS),
 1720: 	AbilitySystemComponent(ASC),
 1721: 	AttributeSet(AS)
 1722: 	{}
 1723: 
 1724: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 1725: 	TObjectPtr<APlayerController> PlayerController = nullptr;
 1726: 
 1727: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 1728: 	TObjectPtr<APlayerState> PlayerState = nullptr;
 1729: 
 1730: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 1731: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
 1732: 
 1733: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 1734: 	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
 1735: 
 1736: };
 1737: UCLASS()
 1738: class WITCHPT_API UWitchPTWidgetController : public UObject
 1739: {
 1740: 	GENERATED_BODY()
 1741: public:
 1742: 	UFUNCTION(BlueprintCallable)
 1743: 	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
 1744: 
 1745: 	UFUNCTION(BlueprintCallable)
 1746: 	virtual void BroadcastInitialValues();
 1747: 	virtual void BindCallbacksToDependencies();
 1748: protected:
 1749: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
 1750: 	TObjectPtr<APlayerController> PlayerController;
 1751: 
 1752: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
 1753: 	TObjectPtr<APlayerState> PlayerState;
 1754: 
 1755: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
 1756: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
 1757: 
 1758: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
 1759: 	TObjectPtr<UAttributeSet> AttributeSet;
 1760: };
 1761: </file>
 1762: 
 1763: <file path="Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h">
 1764: // Fill out your copyright notice in the Description page of Project Settings.
 1765: 
 1766: #pragma once
 1767: 
 1768: #include "CoreMinimal.h"
 1769: #include "UI/Widgets/WitchPTUserWidget.h"
 1770: #include "RitualUserWidget.generated.h"
 1771: 
 1772: /**
 1773:  *
 1774:  */
 1775: UCLASS()
 1776: class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
 1777: {
 1778: 	GENERATED_BODY()
 1779: };
 1780: </file>
 1781: 
 1782: <file path="Source/WitchPT/Public/UI/Widgets/PointerWidget.h">
 1783: // Fill out your copyright notice in the Description page of Project Settings.
 1784: 
 1785: #pragma once
 1786: 
 1787: #include "CoreMinimal.h"
 1788: #include "Blueprint/UserWidget.h"
 1789: #include "PointerWidget.generated.h"
 1790: 
 1791: /**
 1792:  *
 1793:  */
 1794: UCLASS()
 1795: class WITCHPT_API UPointerWidget : public UUserWidget
 1796: {
 1797: 	GENERATED_BODY()
 1798: public:
 1799: 
 1800: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
 1801: 	void ShowPickupMessage(const FString& Message);
 1802: 
 1803: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
 1804: 	void HidePickupMessage();
 1805: };
 1806: </file>
 1807: 
 1808: <file path="Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h">
 1809: // Fill out your copyright notice in the Description page of Project Settings.
 1810: 
 1811: #pragma once
 1812: 
 1813: #include "CoreMinimal.h"
 1814: #include "Blueprint/UserWidget.h"
 1815: #include "WitchPTUserWidget.generated.h"
 1816: 
 1817: /**
 1818:  *
 1819:  */
 1820: UCLASS()
 1821: class WITCHPT_API UWitchPTUserWidget : public UUserWidget
 1822: {
 1823: 	GENERATED_BODY()
 1824: public:
 1825: 	UFUNCTION(BlueprintCallable)
 1826: 	void SetWidgetController(UObject* InWidgetController);
 1827: 	UPROPERTY(BlueprintReadOnly)
 1828: 	TObjectPtr<UObject> WidgetController;
 1829: 
 1830: 	UFUNCTION(BlueprintImplementableEvent)
 1831: 	void OnWidgetControllerSet();
 1832: };
 1833: </file>
 1834: 
 1835: <file path="Source/WitchPT/Public/WitchPTAssetManager.h">
 1836: // Fill out your copyright notice in the Description page of Project Settings.
 1837: 
 1838: #pragma once
 1839: 
 1840: #include "CoreMinimal.h"
 1841: #include "Engine/AssetManager.h"
 1842: #include "WitchPTAssetManager.generated.h"
 1843: 
 1844: /**
 1845:  *
 1846:  */
 1847: UCLASS()
 1848: class WITCHPT_API UWitchPTAssetManager : public UAssetManager
 1849: {
 1850: 	GENERATED_BODY()
 1851: public:
 1852: 	static UWitchPTAssetManager& Get();
 1853: protected:
 1854: 	virtual void StartInitialLoading() override;
 1855: 
 1856: 
 1857: };
 1858: </file>
 1859: 
 1860: <file path="Source/WitchPT/WitchPT.cpp">
 1861: // Fill out your copyright notice in the Description page of Project Settings.
 1862: 
 1863: #include "WitchPT.h"
 1864: #include "Modules/ModuleManager.h"
 1865: 
 1866: IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );
 1867: </file>
 1868: 
 1869: <file path="Source/WitchPTEditor.Target.cs">
 1870: // Fill out your copyright notice in the Description page of Project Settings.
 1871: 
 1872: using UnrealBuildTool;
 1873: using System.Collections.Generic;
 1874: 
 1875: public class WitchPTEditorTarget : TargetRules
 1876: {
 1877: 	public WitchPTEditorTarget(TargetInfo Target) : base(Target)
 1878: 	{
 1879: 		Type = TargetType.Editor;
 1880: 		DefaultBuildSettings = BuildSettingsVersion.V5;
 1881: 
 1882: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
 1883: 	}
 1884: }
 1885: </file>
 1886: 
 1887: <file path="Config/DefaultInput.ini">
 1888: [/Script/Engine.InputSettings]
 1889: -AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 1890: -AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 1891: -AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 1892: -AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 1893: -AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 1894: -AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 1895: -AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 1896: +AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1897: +AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1898: +AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1899: +AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1900: +AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
 1901: +AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
 1902: +AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
 1903: +AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1904: +AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1905: +AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1906: +AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1907: +AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1908: +AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1909: +AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1910: +AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1911: +AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1912: +AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1913: +AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1914: +AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1915: +AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1916: +AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1917: +AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1918: +AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1919: +AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1920: +AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1921: +AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1922: +AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1923: +AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1924: +AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1925: +AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1926: +AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1927: +AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1928: +AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1929: +AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1930: +AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1931: +AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1932: +AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1933: +AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1934: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1935: +AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1936: +AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1937: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1938: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1939: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1940: +AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1941: +AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1942: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1943: +AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1944: +AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1945: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1946: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1947: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
 1948: bAltEnterTogglesFullscreen=True
 1949: bF11TogglesFullscreen=True
 1950: bUseMouseForTouch=False
 1951: bEnableMouseSmoothing=True
 1952: bEnableFOVScaling=True
 1953: bCaptureMouseOnLaunch=True
 1954: bEnableLegacyInputScales=True
 1955: bEnableMotionControls=True
 1956: bFilterInputByPlatformUser=False
 1957: bEnableInputDeviceSubsystem=True
 1958: bShouldFlushPressedKeysOnViewportFocusLost=True
 1959: bEnableDynamicComponentInputBinding=True
 1960: bAlwaysShowTouchInterface=False
 1961: bShowConsoleOnFourFingerTap=True
 1962: bEnableGestureRecognizer=False
 1963: bUseAutocorrect=False
 1964: DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
 1965: DefaultViewportMouseLockMode=LockOnCapture
 1966: FOVScale=0.011110
 1967: DoubleClickTime=0.200000
 1968: +ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Bottom)
 1969: +ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
 1970: +AxisMappings=(AxisName="Look Up / Down Gamepad",Scale=1.000000,Key=Gamepad_RightY)
 1971: +AxisMappings=(AxisName="Look Up / Down Mouse",Scale=-1.000000,Key=MouseY)
 1972: +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=Gamepad_LeftY)
 1973: +AxisMappings=(AxisName="Move Forward / Backward",Scale=-1.000000,Key=S)
 1974: +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=W)
 1975: +AxisMappings=(AxisName="Move Right / Left",Scale=-1.000000,Key=A)
 1976: +AxisMappings=(AxisName="Move Right / Left",Scale=1.000000,Key=D)
 1977: +AxisMappings=(AxisName="Move Right / Left",Scale=1.000000,Key=Gamepad_LeftX)
 1978: +AxisMappings=(AxisName="Turn Right / Left Gamepad",Scale=1.000000,Key=Gamepad_RightX)
 1979: +AxisMappings=(AxisName="Turn Right / Left Mouse",Scale=1.000000,Key=MouseX)
 1980: DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
 1981: DefaultInputComponentClass=/Script/WitchPT.WitchPTInputComponent
 1982: DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
 1983: -ConsoleKeys=Tilde
 1984: +ConsoleKeys=Tilde
 1985: </file>
 1986: 
 1987: <file path="Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp">
 1988: // Fill out your copyright notice in the Description page of Project Settings.
 1989: 
 1990: 
 1991: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 1992: 
 1993: #include "AbilitySystemComponent.h"
 1994: 
 1995: UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
 1996: 	:Super(ObjectInitializer)
 1997: {
 1998: 	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
 1999: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 2000: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 2001: 	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
 2002: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
 2003: }
 2004: 
 2005: void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
 2006:                                             const FGameplayAbilitySpec& Spec)
 2007: {
 2008: 	Super::OnGiveAbility(ActorInfo, Spec);
 2009: 	TryActivateAbilityOnSpawn(ActorInfo, Spec);
 2010: }
 2011: 
 2012: void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
 2013: 	const FGameplayAbilitySpec& Spec) const
 2014: {
 2015: 	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
 2016: 	{
 2017: 		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
 2018: 		AbilitySystem->TryActivateAbility(Spec.Handle);
 2019: 	}
 2020: }
 2021: </file>
 2022: 
 2023: <file path="Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp">
 2024: // Fill out your copyright notice in the Description page of Project Settings.
 2025: 
 2026: 
 2027: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
 2028: 
 2029: #include "AbilitySystemComponent.h"
 2030: #include "Engine/OverlapResult.h"
 2031: #include "Engine/World.h"
 2032: #include "GameFramework/Controller.h"
 2033: 
 2034: #include "TimerManager.h"
 2035: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 2036: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 2037: #include "AbilitySystem/Interaction/InteractionQuery.h"
 2038: #include "AbilitySystem/Interaction/InteractionStatics.h"
 2039: #include "WitchPT/WitchPT.h"
 2040: 
 2041: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
 2042: UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
 2043: 	: Super(ObjectInitializer)
 2044: {
 2045: }
 2046: void UAbilityTask_GrantNearbyInteraction::Activate()
 2047: {
 2048: 
 2049: 	SetWaitingOnAvatar();
 2050: 	UWorld* World = GetWorld();
 2051: 	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
 2052: 
 2053: }
 2054: 
 2055: void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
 2056: {
 2057: 	Super::OnGameplayTaskActivated(Task);
 2058: 
 2059: }
 2060: 
 2061: UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
 2062:                                                                                                              float InteractionScanRange, float InteractionScanRate)
 2063: {
 2064: 
 2065: 	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
 2066: 	MyObj->InteractionScanRange = InteractionScanRange;
 2067: 	MyObj->InteractionScanRate = InteractionScanRate;
 2068: 	return MyObj;
 2069: }
 2070: 
 2071: void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
 2072: {
 2073: 	// Limpiar el temporizador
 2074: 	UWorld* World = GetWorld();
 2075: 	if (World)
 2076: 	{
 2077: 		World->GetTimerManager().ClearTimer(QueryTimerHandle);
 2078: 	}
 2079: 
 2080: 	// Limpiar las habilidades concedidas
 2081: 	// if (AbilitySystemComponent)
 2082: 	// {
 2083: 	// 	// Limpiar habilidades de interacciÃ³n rÃ¡pida
 2084: 	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : InteractionAbilityCache)
 2085: 	// 	{
 2086: 	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
 2087: 	// 	}
 2088: 	//
 2089: 	// 	// Limpiar habilidades de interacciÃ³n mantenida
 2090: 	// 	for (const TPair<FObjectKey, FGameplayAbilitySpecHandle>& Entry : HoldInteractionAbilityCache)
 2091: 	// 	{
 2092: 	// 		AbilitySystemComponent->ClearAbility(Entry.Value);
 2093: 	// 	}
 2094: 	// }
 2095: 	//
 2096: 	// InteractionAbilityCache.Empty();
 2097: 	// HoldInteractionAbilityCache.Empty();
 2098: 
 2099: 	Super::OnDestroy(AbilityEnded);
 2100: }
 2101: 
 2102: void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
 2103: {
 2104: 	UWorld* World = GetWorld();
 2105: 	AActor* ActorOwner = GetAvatarActor();
 2106: 
 2107: 	if (World && ActorOwner)
 2108: 	{
 2109: 		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);
 2110: 
 2111: 		TArray<FOverlapResult> OverlapResults;
 2112: 		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);
 2113: 
 2114: 		if (OverlapResults.Num() > 0)
 2115: 		{
 2116: 			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 2117: 			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
 2118: 
 2119: 			FInteractionQuery InteractionQuery;
 2120: 			InteractionQuery.RequestingAvatar = ActorOwner;
 2121: 			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());
 2122: 
 2123: 			TArray<FInteractionOption> Options;
 2124: 			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
 2125: 			{
 2126: 				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
 2127: 				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
 2128: 			}
 2129: 
 2130: 			// Check if any of the options need to grant the ability to the user before they can be used.
 2131: 			for (FInteractionOption& Option : Options)
 2132: 			{
 2133: 				// Otorgar la habilidad de interacciÃ³n regular
 2134: 				if (Option.InteractionAbilityToGrant)
 2135: 				{
 2136: 					// Grant the ability to the GAS, otherwise it won't be able to do whatever the interaction is.
 2137: 					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
 2138: 					if (!InteractionAbilityCache.Find(ObjectKey))
 2139: 					{
 2140: 						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
 2141: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
 2142: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
 2143: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
 2144: 						InteractionAbilityCache.Add(ObjectKey, Handle);
 2145: 					}
 2146: 				}
 2147: 
 2148: 				// Otorgar la habilidad de interacciÃ³n mantenida si estÃ¡ disponible y soportada
 2149: 				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
 2150: 				{
 2151: 					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
 2152: 					if (!HoldInteractionAbilityCache.Find(ObjectKey))
 2153: 					{
 2154: 						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
 2155: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
 2156: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
 2157: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
 2158: 						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
 2159: 					}
 2160: 				}
 2161: 			}
 2162: 		}
 2163: 	}
 2164: }
 2165: </file>
 2166: 
 2167: <file path="Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp">
 2168: // Fill out your copyright notice in the Description page of Project Settings.
 2169: 
 2170: 
 2171: #include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"
 2172: 
 2173: #include "AbilitySystem/Interaction/InteractionStatics.h"
 2174: #include "Kismet/GameplayStatics.h"
 2175: 
 2176: UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
 2177: 	: Super(ObjectInitializer)
 2178: {
 2179: }
 2180: 
 2181: UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
 2182: 	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
 2183: 	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
 2184: 	bool bShowDebug)
 2185: {
 2186: 	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
 2187: 	MyObj->InteractionScanRange = InteractionScanRange;
 2188: 	MyObj->InteractionScanRate = InteractionScanRate;
 2189: 	MyObj->StartLocation = StartLocation;
 2190: 	MyObj->InteractionQuery = InteractionQuery;
 2191: 	MyObj->TraceProfile = TraceProfile;
 2192: 	MyObj->bShowDebug = bShowDebug;
 2193: 
 2194: 	return MyObj;
 2195: }
 2196: void UAT_WaitForInteractable_SLT::Activate()
 2197: {
 2198: 	SetWaitingOnAvatar();
 2199: 
 2200: 	UWorld* World = GetWorld();
 2201: 	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
 2202: }
 2203: 
 2204: void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
 2205: {
 2206: 	if (UWorld* World = GetWorld())
 2207: 	{
 2208: 		World->GetTimerManager().ClearTimer(TimerHandle);
 2209: 	}
 2210: 
 2211: 	Super::OnDestroy(AbilityEnded);
 2212: }
 2213: 
 2214: void UAT_WaitForInteractable_SLT::PerformTrace()
 2215: {
 2216: 	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
 2217: 
 2218: 	if (!AvatarActor)
 2219: 	{
 2220: 		return;
 2221: 	}
 2222: 
 2223: 	UWorld* World = GetWorld();
 2224: 
 2225: 	TArray<AActor*> ActorsToIgnore;
 2226: 	ActorsToIgnore.Add(AvatarActor);
 2227: 
 2228: 	const bool bTraceComplex = false;
 2229: 	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
 2230: 	Params.AddIgnoredActors(ActorsToIgnore);
 2231: 	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
 2232: 	FVector2D ViewportSize;
 2233: 	GEngine->GameViewport->GetViewportSize(ViewportSize);
 2234: 	const FVector2D ViewportCenter = ViewportSize / 2.f;
 2235: 	FVector TraceStart;
 2236: 	FVector Forward;
 2237: 	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;
 2238: 
 2239: 
 2240: 	FVector TraceEnd;
 2241: 	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);
 2242: 
 2243: 	FHitResult OutHitResult;
 2244: 	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);
 2245: 
 2246: 	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 2247: 	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);
 2248: 
 2249: 	UpdateInteractableOptions(InteractionQuery, InteractableTargets);
 2250: 
 2251: #if ENABLE_DRAW_DEBUG
 2252: 	if (bShowDebug)
 2253: 	{
 2254: 		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
 2255: 		if (OutHitResult.bBlockingHit)
 2256: 		{
 2257: 			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
 2258: 			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
 2259: 		}
 2260: 		else
 2261: 		{
 2262: 			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
 2263: 		}
 2264: 	}
 2265: #endif // ENABLE_DRAW_DEBUG
 2266: }
 2267: </file>
 2268: 
 2269: <file path="Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp">
 2270: // Fill out your copyright notice in the Description page of Project Settings.
 2271: 
 2272: 
 2273: #include "AbilitySystem/WitchPTAbilitySystemLibrary.h"
 2274: 
 2275: #include "Item/MechanicsInterface.h"
 2276: 
 2277: TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
 2278: {
 2279: 	if (!Actor)
 2280: 	{
 2281: 		return TScriptInterface<IMechanicsInterface>();
 2282: 
 2283: 	}
 2284: 	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
 2285: 	if (ComponentsImplementingInterface.Num() > 0)
 2286: 	{
 2287: 		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
 2288: 	}
 2289: 	return TScriptInterface<IMechanicsInterface>();
 2290: }
 2291: </file>
 2292: 
 2293: <file path="Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp">
 2294: // Fill out your copyright notice in the Description page of Project Settings.
 2295: 
 2296: 
 2297: #include "Character/WitchPTCharacterBase.h"
 2298: 
 2299: #include "AbilitySystemComponent.h"
 2300: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 2301: #include "AbilitySystem/WitchPTAttributeSet.h"
 2302: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2303: #include "Components/CapsuleComponent.h"
 2304: 
 2305: // Sets default values
 2306: AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
 2307: 	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
 2308: {
 2309:  	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 2310: 	PrimaryActorTick.bCanEverTick = true;
 2311: 	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 2312: 	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 2313: 
 2314: }
 2315: 
 2316: UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
 2317: {
 2318: 	return AbilitySystemComponent;
 2319: }
 2320: 
 2321: 
 2322: 
 2323: // Called to bind functionality to input
 2324: void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 2325: {
 2326: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 2327: 
 2328: }
 2329: 
 2330: void AWitchPTCharacterBase::InitializeDefaultAttributes()
 2331: {
 2332: 	ApplyGameplayEffectToSelf(DefaultAttributes);
 2333: 
 2334: 
 2335: }
 2336: 
 2337: void AWitchPTCharacterBase::GrantStartupAbilities()
 2338: {
 2339: 	if (!HasAuthority()) return;
 2340: 
 2341: 	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 2342: 
 2343: 	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
 2344: }
 2345: 
 2346: void AWitchPTCharacterBase::AddStartupEffects()
 2347: {
 2348: 	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
 2349: 	{
 2350: 		return;
 2351: 	}
 2352: 
 2353: 	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
 2354: 	EffectContext.AddSourceObject(this);
 2355: 
 2356: 	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
 2357: 	{
 2358: 		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
 2359: 		if (NewHandle.IsValid())
 2360: 		{
 2361: 			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
 2362: 		}
 2363: 	}
 2364: 
 2365: 	AbilitySystemComponent->bStartupEffectsApplied = true;
 2366: }
 2367: 
 2368: void AWitchPTCharacterBase::InitAbilityActorInfo()
 2369: {
 2370: }
 2371: 
 2372: void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
 2373: {
 2374: 	check(IsValid(GetAbilitySystemComponent()));
 2375: 	check(GameplayEffectClass);
 2376: 	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
 2377: 	EffectContextHandle.AddSourceObject(this);
 2378: 	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
 2379: 	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
 2380: 
 2381: }
 2382: 
 2383: float AWitchPTCharacterBase::GetHealth() const
 2384: {
 2385: 	if (IsValid(AttributeSet))
 2386: 	{
 2387: 		return AttributeSet->GetHealth();
 2388: 	}
 2389: 	return 0.f;
 2390: }
 2391: 
 2392: float AWitchPTCharacterBase::GetMaxHealth() const
 2393: {
 2394: 	if (IsValid(AttributeSet))
 2395: 	{
 2396: 		return AttributeSet->GetMaxHealth();
 2397: 	}
 2398: 	return 0.f;
 2399: }
 2400: 
 2401: float AWitchPTCharacterBase::GetStamina() const
 2402: {
 2403: 	if (IsValid(AttributeSet))
 2404: 	{
 2405: 		return AttributeSet->GetStamina();
 2406: 	}
 2407: 	return 0.f;
 2408: }
 2409: 
 2410: float AWitchPTCharacterBase::GetMaxStamina() const
 2411: {
 2412: 	if (IsValid(AttributeSet))
 2413: 	{
 2414: 		return AttributeSet->GetMaxStamina();
 2415: 	}
 2416: 	return 0.f;
 2417: }
 2418: 
 2419: float AWitchPTCharacterBase::GetAge() const
 2420: {
 2421: 	if (IsValid(AttributeSet))
 2422: 	{
 2423: 		return AttributeSet->GetAge();
 2424: 	}
 2425: 	return 0.f;
 2426: }
 2427: 
 2428: float AWitchPTCharacterBase::GetMaxAge() const
 2429: {
 2430: 	if (IsValid(AttributeSet))
 2431: 	{
 2432: 		return AttributeSet->GetMaxAge();
 2433: 	}
 2434: 	return 0.f;
 2435: }
 2436: 
 2437: float AWitchPTCharacterBase::GetMana() const
 2438: {
 2439: 	if (IsValid(AttributeSet))
 2440: 	{
 2441: 		return AttributeSet->GetMana();
 2442: 	}
 2443: 	return 0.f;
 2444: }
 2445: 
 2446: float AWitchPTCharacterBase::GetMaxMana() const
 2447: {
 2448: 	if (IsValid(AttributeSet))
 2449: 	{
 2450: 		return AttributeSet->GetMaxMana();
 2451: 	}
 2452: 	return 0.f;
 2453: }
 2454: 
 2455: float AWitchPTCharacterBase::GetSpeedMultiplier() const
 2456: {
 2457: 	if (IsValid(AttributeSet))
 2458: 	{
 2459: 		return AttributeSet->GetSpeedMultiplier();
 2460: 	}
 2461: 	return 0.f;
 2462: }
 2463: 
 2464: float AWitchPTCharacterBase::GetMoveSpeed() const
 2465: {
 2466: 	if (IsValid(AttributeSet))
 2467: 	{
 2468: 		return AttributeSet->GetMoveSpeed();
 2469: 	}
 2470: 	return 0.f;
 2471: }
 2472: 
 2473: float AWitchPTCharacterBase::GetMaxMoveSpeed() const
 2474: {
 2475: 	if (IsValid(AttributeSet))
 2476: 	{
 2477: 		return AttributeSet->GetMaxMoveSpeed();
 2478: 	}
 2479: 	return 0.f;
 2480: }
 2481: </file>
 2482: 
 2483: <file path="Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp">
 2484: // Fill out your copyright notice in the Description page of Project Settings.
 2485: 
 2486: 
 2487: #include "Inventory/WitchPTInventoryFunctionLibrary.h"
 2488: 
 2489: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2490: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 2491: 
 2492: const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
 2493: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
 2494: {
 2495: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
 2496: 	{
 2497: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
 2498: 	}
 2499: 	return nullptr;
 2500: }
 2501: </file>
 2502: 
 2503: <file path="Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp">
 2504: // Fill out your copyright notice in the Description page of Project Settings.
 2505: 
 2506: 
 2507: #include "Item/Ingredient/IngredientBase.h"
 2508: 
 2509: 
 2510: // Sets default values
 2511: AIngredientBase::AIngredientBase()
 2512: {
 2513: 
 2514: }
 2515: 
 2516: void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
 2517: 	FInteractionOptionBuilder& OptionBuilder)
 2518: {
 2519: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 2520: }
 2521: 
 2522: FItemManifest AIngredientBase::GetPickupInventory() const
 2523: {
 2524: 	return StaticInventory;
 2525: }
 2526: </file>
 2527: 
 2528: <file path="Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp">
 2529: // Fill out your copyright notice in the Description page of Project Settings.
 2530: 
 2531: 
 2532: #include "UI/Widgets/CauldronUserWidget.h"
 2533: 
 2534: void UCauldronUserWidget::NativeConstruct()
 2535: {
 2536: 	Super::NativeConstruct();
 2537: 	FInputModeGameAndUI InputMode;
 2538: 	// set the input mode to the player controller
 2539: 
 2540: 	if (APlayerController* OwningController = GetOwningPlayer())
 2541: 	{
 2542: 		OwningController->SetInputMode(InputMode);
 2543: 		OwningController->SetShowMouseCursor(true);
 2544: 	}
 2545: 
 2546: }
 2547: 
 2548: FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
 2549: {
 2550: 	return FReply::Handled();
 2551: }
 2552: </file>
 2553: 
 2554: <file path="Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp">
 2555: // Fill out your copyright notice in the Description page of Project Settings.
 2556: 
 2557: 
 2558: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 2559: 
 2560: FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
 2561: {
 2562: 
 2563: 	return FReply::Handled();
 2564: }
 2565: </file>
 2566: 
 2567: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h">
 2568: // Fill out your copyright notice in the Description page of Project Settings.
 2569: 
 2570: #pragma once
 2571: 
 2572: #include "CoreMinimal.h"
 2573: #include "Abilities/Tasks/AbilityTask.h"
 2574: #include "AbilityTask_GrantNearbyInteraction.generated.h"
 2575: 
 2576: /**
 2577:  *
 2578:  */
 2579: UCLASS()
 2580: class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
 2581: {
 2582: 	GENERATED_UCLASS_BODY()
 2583: 
 2584: 
 2585: 	virtual void Activate() override;
 2586: 	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;
 2587: 
 2588: 	/** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */
 2589: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
 2590: 	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);
 2591: 
 2592: private:
 2593: 	virtual void OnDestroy(bool AbilityEnded) override;
 2594: 
 2595: 	void QueryInteractables();
 2596: 	float InteractionScanRange = 100;
 2597: 	float InteractionScanRate = 0.100;
 2598: 	FTimerHandle QueryTimerHandle;
 2599: 
 2600: 	// Cache para habilidades de interacciÃ³n rÃ¡pida
 2601: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
 2602: 
 2603: 	// Cache para habilidades de interacciÃ³n mantenida
 2604: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;
 2605: 
 2606: };
 2607: </file>
 2608: 
 2609: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h">
 2610: // Fill out your copyright notice in the Description page of Project Settings.
 2611: 
 2612: #pragma once
 2613: 
 2614: #include "CoreMinimal.h"
 2615: #include "Abilities/Tasks/AbilityTask.h"
 2616: #include "Engine/CollisionProfile.h"
 2617: #include "InteractionOption.h"
 2618: #include "AbilityTask_WaitForInteractable.generated.h"
 2619: 
 2620: /**
 2621:  *
 2622:  */
 2623: class AActor;
 2624: class IInteractableTarget;
 2625: class UObject;
 2626: class UWorld;
 2627: struct FCollisionQueryParams;
 2628: struct FHitResult;
 2629: struct FInteractionQuery;
 2630: template <typename InterfaceType> class TScriptInterface;
 2631: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);
 2632: 
 2633: UCLASS(Abstract)
 2634: class UAbilityTask_WaitForInteractable : public UAbilityTask
 2635: {
 2636: 	GENERATED_UCLASS_BODY()
 2637: 
 2638: public:
 2639: 	UPROPERTY(BlueprintAssignable)
 2640: 	FInteractableObjectsChangedEvent InteractableObjectsChanged;
 2641: 
 2642: protected:
 2643: 
 2644: 	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);
 2645: 
 2646: 	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;
 2647: 
 2648: 	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);
 2649: 
 2650: 	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);
 2651: 
 2652: 	ECollisionChannel TraceProfile;
 2653: 
 2654: 	// Does the trace affect the aiming pitch
 2655: 	bool bTraceAffectsAimPitch = true;
 2656: 
 2657: 	TArray<FInteractionOption> CurrentOptions;
 2658: 
 2659: };
 2660: </file>
 2661: 
 2662: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h">
 2663: // Fill out your copyright notice in the Description page of Project Settings.
 2664: 
 2665: #pragma once
 2666: 
 2667: #include "CoreMinimal.h"
 2668: #include "InteractionQuery.h"
 2669: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 2670: #include "AT_WaitForInteractable_SLT.generated.h"
 2671: struct FCollisionProfileName;
 2672: 
 2673: class UGameplayAbility;
 2674: class UObject;
 2675: struct FFrame;
 2676: /**
 2677:  *
 2678:  */
 2679: UCLASS()
 2680: class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
 2681: {
 2682: 	GENERATED_UCLASS_BODY()
 2683: 
 2684: 	virtual void Activate() override;
 2685: 
 2686: 	/** Wait until we trace new set of interactables.  This task automatically loops. */
 2687: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
 2688: 	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);
 2689: 
 2690: private:
 2691: 
 2692: 	virtual void OnDestroy(bool AbilityEnded) override;
 2693: 
 2694: 	void PerformTrace();
 2695: 
 2696: 	UPROPERTY()
 2697: 	FInteractionQuery InteractionQuery;
 2698: 
 2699: 	UPROPERTY()
 2700: 	FGameplayAbilityTargetingLocationInfo StartLocation;
 2701: 
 2702: 	float InteractionScanRange = 100;
 2703: 	float InteractionScanRate = 0.100;
 2704: 	bool bShowDebug = false;
 2705: 
 2706: 	FTimerHandle TimerHandle;
 2707: 
 2708: };
 2709: </file>
 2710: 
 2711: <file path="Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h">
 2712: // Fill out your copyright notice in the Description page of Project Settings.
 2713: 
 2714: #pragma once
 2715: 
 2716: #include "CoreMinimal.h"
 2717: #include "Kismet/BlueprintFunctionLibrary.h"
 2718: #include "WitchPTAbilitySystemLibrary.generated.h"
 2719: 
 2720: class IMechanicsInterface;
 2721: /**
 2722:  *
 2723:  */
 2724: UCLASS()
 2725: class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
 2726: {
 2727: 	GENERATED_BODY()
 2728: 	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
 2729: 	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
 2730: };
 2731: </file>
 2732: 
 2733: <file path="Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h">
 2734: // Fill out your copyright notice in the Description page of Project Settings.
 2735: 
 2736: #pragma once
 2737: 
 2738: #include "CoreMinimal.h"
 2739: #include "GameFramework/CharacterMovementComponent.h"
 2740: #include "WitchPTCharacterMovementComponent.generated.h"
 2741: 
 2742: 
 2743: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 2744: class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
 2745: {
 2746: 	GENERATED_BODY()
 2747: 
 2748: public:
 2749: 	UWitchPTCharacterMovementComponent();
 2750: 	uint8 RequestToStartSprinting : 1;
 2751: 	uint8 RequestToStartADS : 1;
 2752: 	virtual float GetMaxSpeed() const override;
 2753: 	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
 2754: 	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
 2755: 	// Sprint
 2756: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
 2757: 	void StartSprinting();
 2758: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
 2759: 	void StopSprinting();
 2760: 
 2761: 
 2762: 	// Aim Down Sights
 2763: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
 2764: 	void StartAimDownSights();
 2765: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
 2766: 	void StopAimDownSights();
 2767: };
 2768: </file>
 2769: 
 2770: <file path="Source/WitchPT/Public/Character/WitchPTCharacterBase.h">
 2771: // Fill out your copyright notice in the Description page of Project Settings.
 2772: 
 2773: #pragma once
 2774: 
 2775: #include "CoreMinimal.h"
 2776: #include "AbilitySystemInterface.h"
 2777: #include "GameFramework/Character.h"
 2778: #include "WitchPTCharacterBase.generated.h"
 2779: 
 2780: class UWitchPTAbilitySystemComponent;
 2781: class UWitchPTAttributeSet;
 2782: class UGameplayAbility;
 2783: class UGameplayEffect;
 2784: class UAttributeSet;
 2785: 
 2786: UCLASS(Abstract)
 2787: class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
 2788: {
 2789: 	GENERATED_BODY()
 2790: 
 2791: public:
 2792: 	// Sets default values for this character's properties
 2793: 	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);
 2794: 
 2795: 	// Getter for ASC Main Components
 2796: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
 2797: 	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }
 2798: 
 2799: protected:
 2800: 	UPROPERTY()
 2801: 	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
 2802: 	UPROPERTY()
 2803: 	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
 2804: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
 2805: 
 2806: 	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
 2807: 	TSubclassOf<UGameplayEffect> DefaultAttributes;
 2808: 	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
 2809: 	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
 2810: 
 2811: 	// These effects are only applied one time on startup
 2812: 	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
 2813: 	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;
 2814: 
 2815: 	virtual void InitializeDefaultAttributes();
 2816: 
 2817: 	virtual void GrantStartupAbilities();
 2818: 
 2819: 	virtual void AddStartupEffects();
 2820: 
 2821: 	virtual void InitAbilityActorInfo();
 2822: private:
 2823: 	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);
 2824: 
 2825: 
 2826: 
 2827: public:
 2828: 	/**
 2829: 	* Getters for attributes from GDAttributeSetBase
 2830: 	**/
 2831: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2832: 	float GetHealth() const;
 2833: 
 2834: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2835: 	float GetMaxHealth() const;
 2836: 
 2837: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2838: 	float GetStamina() const;
 2839: 
 2840: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2841: 	float GetMaxStamina() const;
 2842: 
 2843: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2844: 	float GetAge() const;
 2845: 
 2846: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2847: 	float GetMaxAge() const;
 2848: 
 2849: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2850: 	float GetMana() const;
 2851: 
 2852: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2853: 	float GetMaxMana() const;
 2854: 
 2855: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2856: 	float GetSpeedMultiplier() const;
 2857: 
 2858: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2859: 	float GetMoveSpeed() const;
 2860: 
 2861: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
 2862: 	float GetMaxMoveSpeed() const;
 2863: 
 2864: 
 2865: 
 2866: 
 2867: 
 2868: 
 2869: 
 2870: };
 2871: </file>
 2872: 
 2873: <file path="Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h">
 2874: // Fill out your copyright notice in the Description page of Project Settings.
 2875: 
 2876: #pragma once
 2877: 
 2878: #include "CoreMinimal.h"
 2879: #include "UObject/NoExportTypes.h"
 2880: #include "Kismet/BlueprintFunctionLibrary.h"
 2881: #include "WitchPTInventoryItemDefinition.generated.h"
 2882: 
 2883: class UWitchPTInventoryItemFragment;
 2884: struct FFrame;
 2885: /**
 2886:  *
 2887:  */
 2888: UCLASS(Blueprintable, Const, Abstract)
 2889: class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
 2890: {
 2891: 	GENERATED_BODY()
 2892: public:
 2893: 	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 2894: 
 2895: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
 2896: 	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;
 2897: 
 2898: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
 2899: };
 2900: </file>
 2901: 
 2902: <file path="Source/WitchPT/Public/Item/CauldronPosition.h">
 2903: // Fill out your copyright notice in the Description page of Project Settings.
 2904: 
 2905: #pragma once
 2906: 
 2907: #include "CoreMinimal.h"
 2908: #include "Item/BaseInteractionPosition.h"
 2909: #include "GameplayTagContainer.h" // Added for FGameplayTag
 2910: #include "CauldronPosition.generated.h"
 2911: 
 2912: // Forward Declarations
 2913: class ACauldronAltar;
 2914: class UAbilitySystemComponent;
 2915: struct FGameplayAbilitySpec;
 2916: class AController;
 2917: class UGameplayAbility;
 2918: class UBoxComponent;
 2919: class ACharacter;
 2920: 
 2921: /**
 2922:  * Position for interacting with a Cauldron altar
 2923:  */
 2924: UCLASS()
 2925: class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
 2926: {
 2927:     GENERATED_BODY()
 2928: 
 2929: public:
 2930:     // Sets default values for this actor's properties
 2931:     ACauldronPosition();
 2932: 
 2933:     //~ Begin AActor Interface
 2934:     virtual void BeginPlay() override;
 2935:     //~ End AActor Interface
 2936: 
 2937:     //~ Begin IInteraction Interface (from AItem)
 2938:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 2939:     //~ End IInteraction Interface
 2940: 
 2941:     //~ Getters
 2942:     UFUNCTION(BlueprintPure, Category = "Cauldron")
 2943:     ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
 2944:     //~ End Getters
 2945: 
 2946:     //~ Setters
 2947:     UFUNCTION(BlueprintCallable)
 2948:     void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
 2949:     //~ End Setters
 2950:     //
 2951:     // /**
 2952:     //  * Posiciona un personaje en esta ubicaciÃ³n
 2953:     //  * @param Character El personaje a posicionar
 2954:     //  * @return True si el personaje fue posicionado correctamente
 2955:     //  */
 2956:     // UFUNCTION(BlueprintCallable, Category = "Cauldron|Interaction")
 2957:     // bool PositionCharacter(ACharacter* Character);
 2958:     //
 2959:     // /**
 2960:     //  * Comprueba si esta posiciÃ³n estÃ¡ ocupada
 2961:     //  * @return True si la posiciÃ³n estÃ¡ ocupada por un personaje
 2962:     //  */
 2963:     // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 2964:     // bool IsOccupied() const;
 2965:     //
 2966:     // /**
 2967:     //  * Establece el estado de ocupaciÃ³n de esta posiciÃ³n
 2968:     //  * @param bInOccupied Si la posiciÃ³n estÃ¡ ocupada
 2969:     //  * @param InOccupyingCharacter El personaje que ocupa la posiciÃ³n
 2970:     //  */
 2971:     // UFUNCTION(BlueprintCallable, Category = "Cauldron|State")
 2972:     // void SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter = nullptr);
 2973:     //
 2974:     // /**
 2975:     //  * Obtiene el personaje que ocupa esta posiciÃ³n
 2976:     //  * @return El personaje que ocupa la posiciÃ³n, o nullptr si no estÃ¡ ocupada
 2977:     //  */
 2978:     // UFUNCTION(BlueprintPure, Category = "Cauldron|State")
 2979:     // ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
 2980: 
 2981: protected:
 2982:     // Reference to the parent altar
 2983:     UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
 2984:     TObjectPtr<ACauldronAltar> CauldronAltar;
 2985: 
 2986:     // Interaction Logic Helper
 2987:     virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
 2988: 
 2989: private:
 2990:     // Find the CauldronAltar if not set
 2991:     void FindCauldronAltar();
 2992:     //
 2993:     // // Character currently occupying this position
 2994:     // UPROPERTY()
 2995:     // TObjectPtr<ACharacter> OccupyingCharacter;
 2996:     //
 2997:     // // Whether this position is currently occupied
 2998:     // UPROPERTY()
 2999:     // bool bIsOccupied;
 3000: };
 3001: </file>
 3002: 
 3003: <file path="Source/WitchPT/Public/Item/Ingredient/IngredientBase.h">
 3004: // Fill out your copyright notice in the Description page of Project Settings.
 3005: 
 3006: #pragma once
 3007: 
 3008: #include "CoreMinimal.h"
 3009: #include "Inventory/Collectable.h"
 3010: #include "Item/Item.h"
 3011: #include "IngredientBase.generated.h"
 3012: 
 3013: UCLASS()
 3014: class WITCHPT_API AIngredientBase : public AItem, public ICollectable
 3015: {
 3016: 	GENERATED_BODY()
 3017: 
 3018: public:
 3019: 
 3020: 	AIngredientBase();
 3021: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 3022: 	virtual FItemManifest GetPickupInventory() const override;
 3023: 
 3024: protected:
 3025: 
 3026: 	UPROPERTY(EditAnywhere)
 3027: 	FItemManifest StaticInventory;
 3028: 
 3029: };
 3030: </file>
 3031: 
 3032: <file path="Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h">
 3033: // Fill out your copyright notice in the Description page of Project Settings.
 3034: 
 3035: #pragma once
 3036: 
 3037: #include "CoreMinimal.h"
 3038: #include "WitchPTUserWidget.h"
 3039: #include "CauldronUserWidget.generated.h"
 3040: 
 3041: /**
 3042:  *
 3043:  */
 3044: UCLASS()
 3045: class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
 3046: {
 3047: 	GENERATED_BODY()
 3048: private:
 3049: 	virtual void NativeConstruct() override;
 3050: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
 3051: };
 3052: </file>
 3053: 
 3054: <file path="Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h">
 3055: // Fill out your copyright notice in the Description page of Project Settings.
 3056: 
 3057: #pragma once
 3058: 
 3059: #include "CoreMinimal.h"
 3060: #include "UI/Widgets/WitchPTUserWidget.h"
 3061: #include "InventoryUserWidget.generated.h"
 3062: 
 3063: /**
 3064:  *
 3065:  */
 3066: UCLASS()
 3067: class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
 3068: {
 3069: 	GENERATED_BODY()
 3070: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
 3071: 
 3072: };
 3073: </file>
 3074: 
 3075: <file path="Config/DefaultEditor.ini">
 3076: [/Script/AdvancedPreviewScene.SharedProfiles]
 3077: +Profiles=(ProfileName="Epic Headquarters",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=False,bShowGrid=False,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=True,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=True,bShowMeshEdges=False)
 3078: +Profiles=(ProfileName="Grey Wireframe",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=False,bShowFloor=False,bShowGrid=True,EnvironmentColor=(R=0.039216,G=0.039216,B=0.039216,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=True)
 3079: </file>
 3080: 
 3081: <file path="Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp">
 3082: // Fill out your copyright notice in the Description page of Project Settings.
 3083: 
 3084: 
 3085: #include "AbilitySystem/WitchPTAttributeSet.h"
 3086: 
 3087: #include "AbilitySystemBlueprintLibrary.h"
 3088: #include "GameplayEffectExtension.h"
 3089: #include "GameFramework/Character.h"
 3090: #include "Net/UnrealNetwork.h"
 3091: #include "WitchPT/WitchPT.h"
 3092: 
 3093: void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 3094: {
 3095: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 3096: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
 3097: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)
 3098: 
 3099: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
 3100: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)
 3101: 
 3102: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
 3103: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
 3104: 
 3105: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
 3106: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
 3107: 
 3108: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
 3109: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
 3110: 
 3111: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
 3112: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)
 3113: 
 3114: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
 3115: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
 3116: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)
 3117: 
 3118: 
 3119: }
 3120: 
 3121: UWitchPTAttributeSet::UWitchPTAttributeSet()
 3122: {
 3123: }
 3124: 
 3125: void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
 3126: {
 3127: 	Super::PreAttributeChange(Attribute, NewValue);
 3128: }
 3129: 
 3130: void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 3131: {
 3132: 	Super::PostGameplayEffectExecute(Data);
 3133: 	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
 3134: 	{
 3135: 		// SetMoveSpeed(FMath::Clamp(GetMoveSpeed(), 0.f, GetMaxMoveSpeed()));
 3136: 	}
 3137: 	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
 3138: 	{
 3139: 		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
 3140: 	}
 3141: }
 3142: 
 3143: void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 3144: {
 3145: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
 3146: }
 3147: 
 3148: void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
 3149: {
 3150: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
 3151: }
 3152: void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
 3153: {
 3154: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
 3155: }
 3156: 
 3157: void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
 3158: {
 3159: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
 3160: }
 3161: 
 3162: void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
 3163: {
 3164: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
 3165: }
 3166: 
 3167: void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
 3168: {
 3169: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
 3170: }
 3171: 
 3172: void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
 3173: {
 3174: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
 3175: }
 3176: 
 3177: void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
 3178: {
 3179: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
 3180: }
 3181: 
 3182: void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
 3183: {
 3184: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
 3185: }
 3186: 
 3187: void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
 3188: {
 3189: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
 3190: }
 3191: 
 3192: void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
 3193: {
 3194: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
 3195: }
 3196: 
 3197: void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
 3198: {
 3199: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
 3200: }
 3201: 
 3202: void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
 3203: {
 3204: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
 3205: }
 3206: 
 3207: void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
 3208: {
 3209: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
 3210: }
 3211: 
 3212: void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
 3213: {
 3214: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
 3215: }
 3216: </file>
 3217: 
 3218: <file path="Source/WitchPT/Private/Character/WitchPTEnemy.cpp">
 3219: // Fill out your copyright notice in the Description page of Project Settings.
 3220: 
 3221: 
 3222: #include "Character/WitchPTEnemy.h"
 3223: 
 3224: 
 3225: // Sets default values
 3226: AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 3227: {
 3228: 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 3229: 	PrimaryActorTick.bCanEverTick = true;
 3230: }
 3231: 
 3232: // Called when the game starts or when spawned
 3233: void AWitchPTEnemy::BeginPlay()
 3234: {
 3235: 	Super::BeginPlay();
 3236: 
 3237: }
 3238: 
 3239: // Called every frame
 3240: void AWitchPTEnemy::Tick(float DeltaTime)
 3241: {
 3242: 	Super::Tick(DeltaTime);
 3243: }
 3244: 
 3245: // Called to bind functionality to input
 3246: void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 3247: {
 3248: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 3249: 	// Test commi
 3250: }
 3251: </file>
 3252: 
 3253: <file path="Source/WitchPT/Private/Inventory/Collectable.cpp">
 3254: // Fill out your copyright notice in the Description page of Project Settings.
 3255: 
 3256: 
 3257: #include "Inventory/Collectable.h"
 3258: 
 3259: #include "Inventory/WitchPTInventoryManagerComponent.h"
 3260: 
 3261: UCollectableStatics::UCollectableStatics()
 3262: : Super(FObjectInitializer::Get())
 3263: {
 3264: }
 3265: 
 3266: TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
 3267: {
 3268: 	TScriptInterface<ICollectable> PickupableActor(Actor);
 3269: 	if (PickupableActor)
 3270: 	{
 3271: 		return PickupableActor;
 3272: 	}
 3273: 
 3274: 	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
 3275: 	if (PickupableComponents.Num() > 0)
 3276: 	{
 3277: 		return TScriptInterface<ICollectable>(PickupableComponents[0]);
 3278: 	}
 3279: 
 3280: 	return TScriptInterface<ICollectable>();
 3281: }
 3282: 
 3283: 
 3284: void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
 3285: 	TScriptInterface<ICollectable> Collectable)
 3286: {
 3287: 	if (InventoryComponent && Collectable)
 3288: 	{
 3289: 		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
 3290: 		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
 3291: 	}
 3292: }
 3293: </file>
 3294: 
 3295: <file path="Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp">
 3296: #pragma once
 3297: 
 3298: #include "Inventory/FastArray/FastArrayList.h"
 3299: 
 3300: #include "CoreMinimal.h"
 3301: #include "Inventory/WitchPTInventoryItemDefinition.h"
 3302: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 3303: #include "Inventory/WitchPTInventoryItemInstance.h"
 3304: #include "Inventory/WitchPTInventoryManagerComponent.h"
 3305: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 3306: 
 3307: 
 3308: class FLifetimeProperty;
 3309: struct FReplicationFlags;
 3310: //////////////////////////////////////////////////////////////////////
 3311: // FWitchPTInventoryEntry
 3312: FString FWitchPTInventoryEntry::GetDebugString() const
 3313: {
 3314: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 3315: 	if (Instance != nullptr)
 3316: 	{
 3317: 		ItemDef = Instance->GetItemDef();
 3318: 	}
 3319: 
 3320: 	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
 3321: }
 3322: 
 3323: 
 3324: 
 3325: //////////////////////////////////////////////////////////////////////
 3326: // FWitchPTInventoryList
 3327: void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 3328: {
 3329: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 3330: 	if (!IsValid(IMC)) return;
 3331: 	for (int32 Index : RemovedIndices)
 3332: 	{
 3333: 		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
 3334: 	}
 3335: }
 3336: 
 3337: void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 3338: {
 3339: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 3340: 	if (!IsValid(IMC)) return;
 3341: 	for (int32 Index : AddedIndices)
 3342: 	{
 3343: 		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
 3344: 	}
 3345: }
 3346: 
 3347: void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 3348: {
 3349: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 3350: 	if (!IsValid(IMC)) return;
 3351: 
 3352: 	for (int32 Index : ChangedIndices)
 3353: 	{
 3354: 		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
 3355: 	}
 3356: }
 3357: 
 3358: UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 3359: {
 3360: 	UWitchPTInventoryItemInstance* Result = nullptr;
 3361: 
 3362: 	check(ItemDef != nullptr);
 3363: 	check(OwnerComponent);
 3364: 
 3365: 	AActor* OwningActor = OwnerComponent->GetOwner();
 3366: 	check(OwningActor->HasAuthority());
 3367: 
 3368: 
 3369: 	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
 3370: 	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
 3371: 	NewEntry.Instance->SetItemDef(ItemDef);
 3372: 	// ------ Stack stuff
 3373: 	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 3374: 	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 3375: 	if (IsValid(StackableFragment))
 3376: 	{
 3377: 		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
 3378: 	}
 3379: 	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
 3380: 	{
 3381: 		if (Fragment != nullptr)
 3382: 		{
 3383: 			Fragment->OnInstanceCreated(NewEntry.Instance);
 3384: 		}
 3385: 	}
 3386: 
 3387: 	Result = NewEntry.Instance;
 3388: 
 3389: 
 3390: 	MarkItemDirty(NewEntry);
 3391: 
 3392: 	return Result;
 3393: }
 3394: 
 3395: void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
 3396: {
 3397: 	unimplemented();
 3398: }
 3399: 
 3400: void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
 3401: {
 3402: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
 3403: 	{
 3404: 		FWitchPTInventoryEntry& Entry = *EntryIt;
 3405: 		if (Entry.Instance == Instance)
 3406: 		{
 3407: 			EntryIt.RemoveCurrent();
 3408: 			MarkArrayDirty();
 3409: 		}
 3410: 	}
 3411: }
 3412: TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
 3413: {
 3414: 	TArray<UWitchPTInventoryItemInstance*> Results;
 3415: 	Results.Reserve(Entries.Num());
 3416: 	for (const FWitchPTInventoryEntry& Entry : Entries)
 3417: 	{
 3418: 		if (Entry.Instance != nullptr) //@TODO: Would prefer to not deal with this here and hide it further?
 3419: 		{
 3420: 			Results.Add(Entry.Instance);
 3421: 		}
 3422: 	}
 3423: 	return Results;
 3424: }
 3425: </file>
 3426: 
 3427: <file path="Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp">
 3428: // Fill out your copyright notice in the Description page of Project Settings.
 3429: 
 3430: 
 3431: #include "Inventory/WitchPTInventoryItemDefinition.h"
 3432: 
 3433: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 3434: 
 3435: UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
 3436: : Super(ObjectInitializer)
 3437: 
 3438: {
 3439: }
 3440: 
 3441: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
 3442: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
 3443: {
 3444: 	if (FragmentClass != nullptr)
 3445: 	{
 3446: 		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
 3447: 		{
 3448: 			if (Fragment && Fragment->IsA(FragmentClass))
 3449: 			{
 3450: 				return Fragment;
 3451: 			}
 3452: 		}
 3453: 	}
 3454: 
 3455: 	return nullptr;
 3456: }
 3457: </file>
 3458: 
 3459: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h">
 3460: // Copyright Epic Games, Inc. All Rights Reserved.
 3461: 
 3462: #pragma once
 3463: 
 3464: #include "CoreMinimal.h"
 3465: #include "Abilities/GameplayAbility.h"
 3466: #include "InteractionOption.h"
 3467: #include "IInteractableTarget.generated.h"
 3468: 
 3469: struct FInteractionQuery;
 3470: 
 3471: /**  */
 3472: class FInteractionOptionBuilder
 3473: {
 3474: public:
 3475: 	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
 3476: 		: Scope(InterfaceTargetScope)
 3477: 		, Options(InteractOptions)
 3478: 	{
 3479: 	}
 3480: 
 3481: 	void AddInteractionOption(const FInteractionOption& Option)
 3482: 	{
 3483: 		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
 3484: 		OptionEntry.InteractableTarget = Scope;
 3485: 	}
 3486: 
 3487: private:
 3488: 	TScriptInterface<IInteractableTarget> Scope;
 3489: 	TArray<FInteractionOption>& Options;
 3490: };
 3491: 
 3492: /**  */
 3493: UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
 3494: class UInteractableTarget : public UInterface
 3495: {
 3496: 	GENERATED_BODY()
 3497: };
 3498: 
 3499: 
 3500: class IInteractableTarget
 3501: {
 3502: 	GENERATED_BODY()
 3503: 
 3504: public:
 3505: 	/**  */
 3506: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;
 3507: 
 3508: 	/**  */
 3509: 	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
 3510: 
 3511: 	/**
 3512: 	 * Determina si este objeto interactuable soporta interacciÃ³n mantenida
 3513: 	 * @return Verdadero si el objeto soporta interacciÃ³n mantenida, falso en caso contrario
 3514: 	 */
 3515: 	virtual bool SupportsHoldInteraction() const { return false; }
 3516: 
 3517: 	/**
 3518: 	 * Obtiene la habilidad que se debe activar cuando se realiza una interacciÃ³n mantenida
 3519: 	 * @return El handle de la habilidad para interacciÃ³n mantenida
 3520: 	 */
 3521: 	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
 3522: };
 3523: </file>
 3524: 
 3525: <file path="Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h">
 3526: // Fill out your copyright notice in the Description page of Project Settings.
 3527: 
 3528: #pragma once
 3529: 
 3530: #include "CoreMinimal.h"
 3531: #include "AbilitySystemComponent.h"
 3532: #include "AttributeSet.h"
 3533: #include "WitchPTAttributeSet.generated.h"
 3534: 
 3535: /**
 3536:  *
 3537:  */
 3538: // Macro for attribute accessors
 3539: // Functions: Getter, Setter, Initializer. The initializer set the base and current value!
 3540: #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 3541: GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 3542: GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 3543: GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 3544: GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 3545: 
 3546: // This syntax is a fucking nightmare, but...ok
 3547: UCLASS()
 3548: class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
 3549: {
 3550: 	GENERATED_BODY()
 3551: public:
 3552: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 3553: 	UWitchPTAttributeSet();
 3554: 	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
 3555: 	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 3556: 
 3557: 
 3558: 	/**
 3559: 	 * Vital Attributes
 3560: 	 */
 3561: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
 3562: 	FGameplayAttributeData Age;
 3563: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
 3564: 
 3565: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
 3566: 	FGameplayAttributeData MaxAge;
 3567: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
 3568: 
 3569: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
 3570: 	FGameplayAttributeData Health;
 3571: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
 3572: 
 3573: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
 3574: 	FGameplayAttributeData MaxHealth;
 3575: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
 3576: 
 3577: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
 3578: 	FGameplayAttributeData Strength;
 3579: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
 3580: 
 3581: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
 3582: 	FGameplayAttributeData MaxStrength;
 3583: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
 3584: 
 3585: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
 3586: 	FGameplayAttributeData Mana;
 3587: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
 3588: 
 3589: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
 3590: 	FGameplayAttributeData MaxMana;
 3591: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
 3592: 
 3593: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
 3594: 	FGameplayAttributeData Stamina;
 3595: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
 3596: 
 3597: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
 3598: 	FGameplayAttributeData MaxStamina;
 3599: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);
 3600: 
 3601: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
 3602: 	FGameplayAttributeData SpeedMultiplier;
 3603: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);
 3604: 
 3605: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
 3606: 	FGameplayAttributeData MaxSpeedMultiplier;
 3607: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);
 3608: 
 3609: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
 3610: 	FGameplayAttributeData MoveSpeed;
 3611: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);
 3612: 
 3613: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
 3614: 	FGameplayAttributeData MaxMoveSpeed;
 3615: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);
 3616: 
 3617: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
 3618: 	FGameplayAttributeData MinMoveSpeed;
 3619: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);
 3620: 
 3621: 
 3622: 
 3623: 
 3624: 	// Replication functions
 3625: 	UFUNCTION()
 3626: 	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
 3627: 	UFUNCTION()
 3628: 	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
 3629: 	UFUNCTION()
 3630: 	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
 3631: 	UFUNCTION()
 3632: 	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
 3633: 	UFUNCTION()
 3634: 	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
 3635: 	UFUNCTION()
 3636: 	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
 3637: 	UFUNCTION()
 3638: 	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
 3639: 	UFUNCTION()
 3640: 	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
 3641: 	UFUNCTION()
 3642: 	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
 3643: 	UFUNCTION()
 3644: 	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
 3645: 	UFUNCTION()
 3646: 	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
 3647: 	UFUNCTION()
 3648: 	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
 3649: 	UFUNCTION()
 3650: 	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
 3651: 	UFUNCTION()
 3652: 	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
 3653: 	UFUNCTION()
 3654: 	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
 3655: };
 3656: </file>
 3657: 
 3658: <file path="Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h">
 3659: #pragma once
 3660: 
 3661: #include "CoreMinimal.h"
 3662: #include "Net/Serialization/FastArraySerializer.h"
 3663: 
 3664: #include "FastArrayList.generated.h"
 3665: 
 3666: class UWitchPTInventoryItemDefinition;
 3667: class UWitchPTInventoryItemInstance;
 3668: class UWitchPTInventoryManagerComponent;
 3669: struct FWitchPTInventoryList;
 3670: 
 3671: /**
 3672:  * FWitchPTInventoryEntry
 3673:  *
 3674:  * Represents a single item entry in the inventory.
 3675:  * Uses FastArraySerializer for efficient replication.
 3676:  */
 3677: USTRUCT(BlueprintType)
 3678: struct FWitchPTInventoryEntry : public FFastArraySerializerItem
 3679: {
 3680: 	GENERATED_BODY()
 3681: 
 3682: 	FWitchPTInventoryEntry()
 3683: 	{}
 3684: 
 3685: 	/**
 3686: 	 * Get a debug string representation of this inventory entry
 3687: 	 * @return FString - A string describing the item instance and its definition
 3688: 	 */
 3689: 	FString GetDebugString() const;
 3690: 
 3691: private:
 3692: 	friend FWitchPTInventoryList;
 3693: 	friend UWitchPTInventoryManagerComponent;
 3694: 
 3695: 	/** The actual item instance this entry represents */
 3696: 	UPROPERTY()
 3697: 	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
 3698: 
 3699: };
 3700: 
 3701: /**
 3702:  * FWitchPTInventoryList
 3703:  *
 3704:  * A collection of inventory entries that supports efficient replication.
 3705:  * Uses FastArraySerializer to minimize network traffic when replicating inventory changes.
 3706:  * Handles adding, removing, and updating inventory items.
 3707:  */
 3708: USTRUCT(BlueprintType)
 3709: struct FWitchPTInventoryList : public FFastArraySerializer
 3710: {
 3711: 	GENERATED_BODY()
 3712: 
 3713: 	/** Default constructor */
 3714: 	FWitchPTInventoryList()
 3715: 		: OwnerComponent(nullptr)
 3716: 	{
 3717: 	}
 3718: 
 3719: 	/**
 3720: 	 * Constructor with owner component
 3721: 	 * @param InOwnerComponent - The component that owns this inventory list
 3722: 	 */
 3723: 	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
 3724: 		: OwnerComponent(InOwnerComponent)
 3725: 	{
 3726: 	}
 3727: 
 3728: 	/**
 3729: 	 * Get all item instances in the inventory
 3730: 	 * @return TArray<UWitchPTInventoryItemInstance*> - Array of all item instances
 3731: 	 */
 3732: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 3733: 
 3734: public:
 3735: 	//~FFastArraySerializer contract
 3736: 	/**
 3737: 	 * Called before items are removed during replication
 3738: 	 * Broadcasts the OnItemRemoved event for each removed item
 3739: 	 */
 3740: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 3741: 
 3742: 	/**
 3743: 	 * Called after items are added during replication
 3744: 	 * Broadcasts the OnItemAdded event for each added item
 3745: 	 */
 3746: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 3747: 
 3748: 	/**
 3749: 	 * Called after items are changed during replication
 3750: 	 * Broadcasts the OnItemStackChanged event for each changed item
 3751: 	 */
 3752: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 3753: 	//~End of FFastArraySerializer contract
 3754: 
 3755: 	/**
 3756: 	 * Serializes the delta between two states of the array
 3757: 	 * Required for FastArraySerializer functionality
 3758: 	 */
 3759: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
 3760: 	{
 3761: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
 3762: 	}
 3763: 
 3764: 	/**
 3765: 	 * Create a new inventory entry with the specified item definition
 3766: 	 * Initializes the item instance and sets up its stack count based on the definition
 3767: 	 *
 3768: 	 * @param ItemClass The class of the inventory item to add
 3769: 	 * @return A pointer to the newly created inventory item instance
 3770: 	 */
 3771: 	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
 3772: 
 3773: 	/**
 3774: 	 * Adds an existing item instance to the inventory list
 3775: 	 *
 3776: 	 * @param Instance The inventory item instance to add
 3777: 	 */
 3778: 	void AddEntry(UWitchPTInventoryItemInstance* Instance);
 3779: 
 3780: 	/**
 3781: 	 * Removes an item instance from the inventory list
 3782: 	 *
 3783: 	 * @param Instance The inventory item instance to remove
 3784: 	 */
 3785: 	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);
 3786: 
 3787: private:
 3788: 	friend UWitchPTInventoryManagerComponent;
 3789: 
 3790: private:
 3791: 	/** Replicated list of inventory entries */
 3792: 	UPROPERTY()
 3793: 	TArray<FWitchPTInventoryEntry> Entries;
 3794: 
 3795: 	/** Non-replicated reference to the owner component */
 3796: 	UPROPERTY(NotReplicated)
 3797: 	TObjectPtr<UActorComponent> OwnerComponent;
 3798: };
 3799: 
 3800: /**
 3801:  * Trait specification for FWitchPTInventoryList
 3802:  * Enables network delta serialization for efficient replication
 3803:  */
 3804: template<>
 3805: struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
 3806: {
 3807: 	enum { WithNetDeltaSerializer = true };
 3808: };
 3809: </file>
 3810: 
 3811: <file path="Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h">
 3812: // Fill out your copyright notice in the Description page of Project Settings.
 3813: 
 3814: #pragma once
 3815: 
 3816: #include "CoreMinimal.h"
 3817: #include "Templates/SubclassOf.h"
 3818: #include "WitchPTInventoryItemFragment.generated.h"
 3819: 
 3820: template <typename T> class TSubclassOf;
 3821: 
 3822: class UWitchPTInventoryItemInstance;
 3823: /**
 3824:  *
 3825:  */
 3826: UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
 3827: class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
 3828: {
 3829: 	GENERATED_BODY()
 3830: 
 3831: public:
 3832: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
 3833: 
 3834: };
 3835: </file>
 3836: 
 3837: <file path="Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp">
 3838: // Fill out your copyright notice in the Description page of Project Settings.
 3839: 
 3840: 
 3841: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 3842: #include "AbilitySystemComponent.h"
 3843: #include "Engine/World.h"
 3844: #include "GameFramework/PlayerController.h"
 3845: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 3846: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
 3847: struct FInteractionQuery;
 3848: 
 3849: UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
 3850: 	: Super(ObjectInitializer)
 3851: {
 3852: }
 3853: void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
 3854: {
 3855: 	check(World);
 3856: 
 3857: 	OutHitResult = FHitResult();
 3858: 	FHitResult HitResult;
 3859: 	// World->LineTraceMultiByProfile(HitResults, Start, End, CollisionChannel, Params);
 3860: 	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
 3861: 	OutHitResult.TraceStart = Start;
 3862: 	OutHitResult.TraceEnd = End;
 3863: 
 3864: 	OutHitResult = HitResult;
 3865: }
 3866: 
 3867: void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
 3868: {
 3869: 	if (!Ability) // Server and launching client only
 3870: 	{
 3871: 		return;
 3872: 	}
 3873: 
 3874: 	//@TODO: Bots?
 3875: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 3876: 	check(PC);
 3877: 
 3878: 	FVector ViewStart;
 3879: 	FRotator ViewRot;
 3880: 	PC->GetPlayerViewPoint(ViewStart, ViewRot);
 3881: 
 3882: 	const FVector ViewDir = ViewRot.Vector();
 3883: 	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);
 3884: 
 3885: 	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);
 3886: 
 3887: 	FHitResult HitResult;
 3888: 	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);
 3889: 
 3890: 	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));
 3891: 
 3892: 	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;
 3893: 
 3894: 	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
 3895: 	if (AdjustedAimDir.IsZero())
 3896: 	{
 3897: 		AdjustedAimDir = ViewDir;
 3898: 	}
 3899: 
 3900: 	if (!bTraceAffectsAimPitch && bUseTraceResult)
 3901: 	{
 3902: 		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();
 3903: 
 3904: 		if (!OriginalAimDir.IsZero())
 3905: 		{
 3906: 			// Convert to angles and use original pitch
 3907: 			const FRotator OriginalAimRot = OriginalAimDir.Rotation();
 3908: 
 3909: 			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
 3910: 			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;
 3911: 
 3912: 			AdjustedAimDir = AdjustedAimRot.Vector();
 3913: 		}
 3914: 	}
 3915: 
 3916: 	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
 3917: }
 3918: 
 3919: bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
 3920: {
 3921: 	FVector CameraToCenter = AbilityCenter - CameraLocation;
 3922: 	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
 3923: 	if (DotToCenter >= 0)		//If this fails, we're pointed away from the center, but we might be inside the sphere and able to find a good exit point.
 3924: 	{
 3925: 		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
 3926: 		float RadiusSquared = (AbilityRange * AbilityRange);
 3927: 		if (DistanceSquared <= RadiusSquared)
 3928: 		{
 3929: 			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
 3930: 			float DistanceAlongRay = DotToCenter + DistanceFromCamera;						//Subtracting instead of adding will get the other intersection point
 3931: 			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);		//Cam aim point clipped to range sphere
 3932: 			return true;
 3933: 		}
 3934: 	}
 3935: 	return false;
 3936: }
 3937: 
 3938: void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
 3939: {
 3940: 	TArray<FInteractionOption> NewOptions;
 3941: 
 3942: 	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
 3943: 	{
 3944: 		TArray<FInteractionOption> TempOptions;
 3945: 		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
 3946: 		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);
 3947: 
 3948: 		for (FInteractionOption& Option : TempOptions)
 3949: 		{
 3950: 			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;
 3951: 
 3952: 			// if there is a handle an a target ability system, we're triggering the ability on the target.
 3953: 			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
 3954: 			{
 3955: 				// Find the spec
 3956: 				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
 3957: 			}
 3958: 			// If there's an interaction ability then we're activating it on ourselves.
 3959: 			else if (Option.InteractionAbilityToGrant)
 3960: 			{
 3961: 				// Find the spec
 3962: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);
 3963: 
 3964: 				if (InteractionAbilitySpec)
 3965: 				{
 3966: 					// update the option
 3967: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
 3968: 					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
 3969: 				}
 3970: 			}
 3971: 			if (Option.HoldInteractionAbilityToGrant)
 3972: 			{
 3973: 				// Find the spec
 3974: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);
 3975: 
 3976: 				if (InteractionAbilitySpec)
 3977: 				{
 3978: 					// update the option
 3979: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
 3980: 					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
 3981: 				}
 3982: 			}
 3983: 			if (InteractionAbilitySpec)
 3984: 			{
 3985: 				// Filter any options that we can't activate right now for whatever reason.
 3986: 				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
 3987: 				{
 3988: 					NewOptions.Add(Option);
 3989: 				}
 3990: 			}
 3991: 		}
 3992: 	}
 3993: 
 3994: 	bool bOptionsChanged = false;
 3995: 	if (NewOptions.Num() == CurrentOptions.Num())
 3996: 	{
 3997: 		NewOptions.Sort();
 3998: 
 3999: 		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
 4000: 		{
 4001: 			const FInteractionOption& NewOption = NewOptions[OptionIndex];
 4002: 			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];
 4003: 
 4004: 			if (NewOption != CurrentOption)
 4005: 			{
 4006: 				bOptionsChanged = true;
 4007: 				break;
 4008: 			}
 4009: 		}
 4010: 	}
 4011: 	else
 4012: 	{
 4013: 		bOptionsChanged = true;
 4014: 	}
 4015: 
 4016: 	if (bOptionsChanged)
 4017: 	{
 4018: 		CurrentOptions = NewOptions;
 4019: 		InteractableObjectsChanged.Broadcast(CurrentOptions);
 4020: 	}
 4021: }
 4022: </file>
 4023: 
 4024: <file path="Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp">
 4025: // Fill out your copyright notice in the Description page of Project Settings.
 4026: 
 4027: 
 4028: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 4029: 
 4030: #include "AbilitySystemComponent.h"
 4031: #include "GameplayTagContainer.h"
 4032: #include "Character/WitchPTCharacterBase.h"
 4033: 
 4034: 
 4035: 
 4036: UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
 4037: {
 4038: 
 4039: 	PrimaryComponentTick.bCanEverTick = true;
 4040: 
 4041: 
 4042: }
 4043: 
 4044: float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
 4045: {
 4046: 
 4047: 	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());
 4048: 
 4049: 	if (!Owner)
 4050: 	{
 4051: 
 4052: 		return Super::GetMaxSpeed();
 4053: 	}
 4054: 
 4055: 
 4056: 
 4057: 	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
 4058: 	{
 4059: 
 4060: 		return 0.0f;
 4061: 	}
 4062: 
 4063: 	float FinalSpeed = Owner->GetMoveSpeed();
 4064: 	if (RequestToStartSprinting)
 4065: 	{
 4066: 		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
 4067: 
 4068: 	}
 4069: 	// else if (RequestToStartCrouching)
 4070: 	// {
 4071: 	// 	// FinalSpeed = Owner->GetMoveSpeed() * CrouchSpeedMultiplier;
 4072: 	// 	// UE_LOG(LogTemp, Warning, TEXT("Character %s is Crouching - Speed: %f"), *GetOwner()->GetName(), FinalSpeed);
 4073: 	// }
 4074: 
 4075: 
 4076: 	return FinalSpeed;
 4077: }
 4078: 
 4079: void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
 4080: {
 4081: 	Super::UpdateFromCompressedFlags(Flags);
 4082: }
 4083: 
 4084: class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
 4085: {
 4086: 	return Super::GetPredictionData_Client();
 4087: }
 4088: 
 4089: 
 4090: void UWitchPTCharacterMovementComponent::StartSprinting()
 4091: {
 4092: 	RequestToStartSprinting = true;
 4093: }
 4094: 
 4095: void UWitchPTCharacterMovementComponent::StopSprinting()
 4096: {
 4097: 	RequestToStartSprinting = false;
 4098: }
 4099: 
 4100: void UWitchPTCharacterMovementComponent::StartAimDownSights()
 4101: {
 4102: 	RequestToStartADS = true;
 4103: }
 4104: 
 4105: void UWitchPTCharacterMovementComponent::StopAimDownSights()
 4106: {
 4107: 	RequestToStartADS = false;
 4108: 
 4109: }
 4110: </file>
 4111: 
 4112: <file path="Source/WitchPT/Private/Item/BaseInteractionPosition.cpp">
 4113: #include "Item/BaseInteractionPosition.h"
 4114: #include "Net/UnrealNetwork.h"
 4115: #include "Engine/ActorChannel.h"
 4116: #include "AbilitySystemComponent.h"
 4117: #include "Components/BoxComponent.h"
 4118: #include "GameFramework/Character.h"
 4119: 
 4120: ABaseInteractionPosition::ABaseInteractionPosition()
 4121: {
 4122:     // Set this actor to call Tick() every frame
 4123:     PrimaryActorTick.bCanEverTick = true;
 4124: 
 4125:     // Make sure this actor replicates
 4126:     bReplicates = true;
 4127:     bAlwaysRelevant = true;
 4128: }
 4129: 
 4130: void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 4131: {
 4132:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 4133: 
 4134:     // Replicate the occupied state and occupying character
 4135:     DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
 4136:     DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
 4137:     DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
 4138: 
 4139:     // PositionTag and Altar are usually set once and don't need replication unless they can change dynamically
 4140: }
 4141: 
 4142: void ABaseInteractionPosition::BeginPlay()
 4143: {
 4144:     Super::BeginPlay();
 4145: 
 4146:     // Additional initialization could go here if needed
 4147: }
 4148: 
 4149: void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 4150: {
 4151:     // This should be overridden by derived classes
 4152:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 4153: }
 4154: 
 4155: bool ABaseInteractionPosition::IsOccupied() const
 4156: {
 4157:     return bIsOccupied;
 4158: }
 4159: 
 4160: void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
 4161: {
 4162:     if (GetLocalRole() != ROLE_Authority)
 4163:     {
 4164:         return;
 4165:     }
 4166: 
 4167:     OccupyingCharacter = Character;
 4168:     bIsOccupied = (Character != nullptr);
 4169: }
 4170: 
 4171: void ABaseInteractionPosition::SetUnoccupied()
 4172: {
 4173:     if (GetLocalRole() != ROLE_Authority)
 4174:     {
 4175:         return;
 4176:     }
 4177: 
 4178:     RemoveCharacterFromPosition();
 4179: }
 4180: 
 4181: void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
 4182: {
 4183:     PositionTag = NewTag;
 4184: }
 4185: 
 4186: void ABaseInteractionPosition::OnRep_IsOccupied()
 4187: {
 4188:     // Handle any visuals or sounds when occupation state changes
 4189: }
 4190: 
 4191: void ABaseInteractionPosition::OnRep_OccupyingCharacter()
 4192: {
 4193:     // Handle any visuals or sounds when the occupying character changes
 4194: }
 4195: 
 4196: void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
 4197: {
 4198:     // Base implementation - should be overridden by child classes
 4199:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
 4200:         *GetName(), *InteractingCharacter->GetName());
 4201: }
 4202: 
 4203: void ABaseInteractionPosition::RemoveCharacterFromPosition()
 4204: {
 4205:     OccupyingCharacter = nullptr;
 4206:     bIsOccupied = false;
 4207: }
 4208: </file>
 4209: 
 4210: <file path="Source/WitchPT/Private/Item/CauldronPosition.cpp">
 4211: #include "Item/CauldronPosition.h"
 4212: #include "AbilitySystemComponent.h"
 4213: #include "GameFramework/Character.h"
 4214: #include "Item/CauldronAltar.h" // Include the Altar header
 4215: #include "Kismet/GameplayStatics.h"
 4216: 
 4217: ACauldronPosition::ACauldronPosition()
 4218: {
 4219:     // No need to set up replication here - it's handled by the base class
 4220:     bIsOccupied = false;
 4221:     OccupyingCharacter = nullptr;
 4222: }
 4223: 
 4224: void ACauldronPosition::BeginPlay()
 4225: {
 4226:     Super::BeginPlay();
 4227: 
 4228:     // // Try to find the CauldronAltar if it wasn't set in the editor
 4229:     // if (!CauldronAltar)
 4230:     // {
 4231:     //     FindCauldronAltar();
 4232:     // }
 4233: }
 4234: 
 4235: void ACauldronPosition::FindCauldronAltar()
 4236: {
 4237:     // First check if we are attached to an altar
 4238:     // AActor* ParentActor = GetAttachParentActor();
 4239:     // if (ParentActor)
 4240:     // {
 4241:     //     ACauldronAltar* PotentialAltar = Cast<ACauldronAltar>(ParentActor);
 4242:     //     if (PotentialAltar)
 4243:     //     {
 4244:     //         CauldronAltar = PotentialAltar;
 4245:     //         UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found attached CauldronAltar %s"),
 4246:     //             *GetName(), *CauldronAltar->GetName());
 4247:     //         return;
 4248:     //     }
 4249:     // }
 4250:     //
 4251:     // // If not attached, try to find any altar in the world
 4252:     // TArray<AActor*> FoundAltars;
 4253:     // UGameplayStatics::GetAllActorsOfClass(GetWorld(), ACauldronAltar::StaticClass(), FoundAltars);
 4254:     //
 4255:     // if (FoundAltars.Num() > 0)
 4256:     // {
 4257:     //     CauldronAltar = Cast<ACauldronAltar>(FoundAltars[0]);
 4258:     //     UE_LOG(LogTemp, Log, TEXT("[CauldronPosition] %s found world CauldronAltar %s"),
 4259:     //         *GetName(), *CauldronAltar->GetName());
 4260:     // }
 4261:     // else
 4262:     // {
 4263:     //     UE_LOG(LogTemp, Warning, TEXT("[CauldronPosition] %s couldn't find a CauldronAltar!"), *GetName());
 4264:     // }
 4265: }
 4266: 
 4267: void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 4268: {
 4269:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 4270: 
 4271:     // // Cauldron-specific interaction options
 4272:     //
 4273:     // ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
 4274:     //
 4275:     // // If no player is occupying the position, let a player take the position
 4276:     // if (!IsOccupied() && InteractingCharacterPtr)
 4277:     // {
 4278:     //     OptionBuilder.AddDefaultInteraction(
 4279:     //         FText::FromString("Take Position"), // Text for the interaction
 4280:     //         [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 4281:     //         {
 4282:     //             HandleInteraction(InteractingCharacterPtr);
 4283:     //         }
 4284:     //     );
 4285:     // }
 4286:     //
 4287:     // // Special case: if the character is standing at a position and we're in Inactive state, they can initiate brewing
 4288:     // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 4289:     // {
 4290:     //     // Check cauldron state
 4291:     //     if (CauldronAltar->GetCurrentState() == EInteractionState::Inactive)
 4292:     //     {
 4293:     //         OptionBuilder.AddDefaultInteraction(
 4294:     //             FText::FromString("Start Brewing"), // Text for the interaction
 4295:     //             [this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 4296:     //             {
 4297:     //                 if (CauldronAltar)
 4298:     //                 {
 4299:     //                     // Cast to the appropriate start brewing function
 4300:     //                     CauldronAltar->StartBrewing(InteractingCharacterPtr);
 4301:     //                 }
 4302:     //             }
 4303:     //         );
 4304:     //     }
 4305:     // }
 4306:     //
 4307:     // // If this player is at a position and brewing is active, they can add ingredients
 4308:     // if (IsOccupied() && CauldronAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 4309:     // {
 4310:     //     if (CauldronAltar->GetCurrentState() == EInteractionState::Active)
 4311:     //     {
 4312:     //         // Get the player's current expected input
 4313:     //         FGameplayTag ExpectedInput = CauldronAltar->GetCurrentExpectedInputForPlayer(InteractingCharacterPtr);
 4314:     //
 4315:     //         if (ExpectedInput.IsValid())
 4316:     //         {
 4317:     //             // Determine the ingredient name
 4318:     //             FString TagString = ExpectedInput.ToString();
 4319:     //             FString IngredientName = "Unknown Ingredient";
 4320:     //
 4321:     //             if (TagString.Contains("Ingredient1"))
 4322:     //             {
 4323:     //                 IngredientName = "Red Mushroom";
 4324:     //             }
 4325:     //             else if (TagString.Contains("Ingredient2"))
 4326:     //             {
 4327:     //                 IngredientName = "Frog Leg";
 4328:     //             }
 4329:     //             else if (TagString.Contains("Ingredient3"))
 4330:     //             {
 4331:     //                 IngredientName = "Bat Wing";
 4332:     //             }
 4333:     //             else if (TagString.Contains("Ingredient4"))
 4334:     //             {
 4335:     //                 IngredientName = "Snake Venom";
 4336:     //             }
 4337:     //             else if (TagString.Contains("Ingredient5"))
 4338:     //             {
 4339:     //                 IngredientName = "Dragon Scale";
 4340:     //             }
 4341:     //
 4342:     //             // Give the player the option to add the correct ingredient
 4343:     //             OptionBuilder.AddDefaultInteraction(
 4344:     //                 FText::FromString(FString::Printf(TEXT("Add %s"), *IngredientName)),
 4345:     //                 [this, InteractingCharacterPtr, ExpectedInput](const FInteractionExecuteContext& Context)
 4346:     //                 {
 4347:     //                     if (CauldronAltar)
 4348:     //                     {
 4349:     //                         CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, ExpectedInput);
 4350:     //                     }
 4351:     //                 }
 4352:     //             );
 4353:     //
 4354:     //             // Also add wrong ingredient options for fun/challenge
 4355:     //             for (int32 i = 1; i <= 5; ++i)
 4356:     //             {
 4357:     //                 FString WrongTagString = FString::Printf(TEXT("Input.Cauldron.Ingredient%d"), i);
 4358:     //                 FGameplayTag WrongTag = FGameplayTag::RequestGameplayTag(FName(*WrongTagString));
 4359:     //
 4360:     //                 // Skip if this is the correct ingredient
 4361:     //                 if (WrongTag == ExpectedInput)
 4362:     //                 {
 4363:     //                     continue;
 4364:     //                 }
 4365:     //
 4366:     //                 // Determine wrong ingredient name
 4367:     //                 FString WrongIngredientName = "Unknown Ingredient";
 4368:     //                 switch (i)
 4369:     //                 {
 4370:     //                 case 1: WrongIngredientName = "Red Mushroom"; break;
 4371:     //                 case 2: WrongIngredientName = "Frog Leg"; break;
 4372:     //                 case 3: WrongIngredientName = "Bat Wing"; break;
 4373:     //                 case 4: WrongIngredientName = "Snake Venom"; break;
 4374:     //                 case 5: WrongIngredientName = "Dragon Scale"; break;
 4375:     //                 }
 4376:     //
 4377:     //                 OptionBuilder.AddDefaultInteraction(
 4378:     //                     FText::FromString(FString::Printf(TEXT("Add %s"), *WrongIngredientName)),
 4379:     //                     [this, InteractingCharacterPtr, WrongTag](const FInteractionExecuteContext& Context)
 4380:     //                     {
 4381:     //                         if (CauldronAltar)
 4382:     //                         {
 4383:     //                             CauldronAltar->HandlePlayerInput(InteractingCharacterPtr, WrongTag);
 4384:     //                         }
 4385:     //                     }
 4386:     //                 );
 4387:     //             }
 4388:     //         }
 4389:     //     }
 4390:     // }
 4391: }
 4392: 
 4393: void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
 4394: {
 4395:     Super::HandleInteraction(InteractingCharacter);
 4396: 
 4397:     if (!InteractingCharacter || !CauldronAltar)
 4398:     {
 4399:         return;
 4400:     }
 4401: 
 4402:     // Call the cauldron altar to handle occupation
 4403:     // CauldronAltar->OccupyPosition(InteractingCharacter, this);
 4404: }
 4405: 
 4406: // bool ACauldronPosition::PositionCharacter(ACharacter* Character)
 4407: // {
 4408: //     if (!Character)
 4409: //     {
 4410: //         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Invalid character"));
 4411: //         return false;
 4412: //     }
 4413: //
 4414: //     // No permitir posicionar si ya estÃ¡ ocupado
 4415: //     if (bIsOccupied && OccupyingCharacter != Character)
 4416: //     {
 4417: //         UE_LOG(LogTemp, Warning, TEXT("ACauldronPosition::PositionCharacter: Position already occupied"));
 4418: //         return false;
 4419: //     }
 4420: //
 4421: //     // Teleportar al personaje a la ubicaciÃ³n de este actor
 4422: //     FVector TargetLocation = GetActorLocation();
 4423: //     FRotator TargetRotation = GetActorRotation();
 4424: //
 4425: //     bool bSuccess = Character->SetActorLocationAndRotation(
 4426: //         TargetLocation,
 4427: //         TargetRotation,
 4428: //         false,
 4429: //         nullptr,
 4430: //         ETeleportType::TeleportPhysics);
 4431: //
 4432: //     if (bSuccess)
 4433: //     {
 4434: //         // Marcar esta posiciÃ³n como ocupada
 4435: //         SetOccupied(true, Character);
 4436: //
 4437: //         UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::PositionCharacter: Character positioned at %s"),
 4438: //                *GetName());
 4439: //     }
 4440: //
 4441: //     return bSuccess;
 4442: // }
 4443: //
 4444: // bool ACauldronPosition::IsOccupied() const
 4445: // {
 4446: //     return bIsOccupied && OccupyingCharacter != nullptr;
 4447: // }
 4448: //
 4449: // void ACauldronPosition::SetOccupied(bool bInOccupied, ACharacter* InOccupyingCharacter)
 4450: // {
 4451: //     bIsOccupied = bInOccupied;
 4452: //
 4453: //     if (bInOccupied)
 4454: //     {
 4455: //         OccupyingCharacter = InOccupyingCharacter;
 4456: //     }
 4457: //     else
 4458: //     {
 4459: //         OccupyingCharacter = nullptr;
 4460: //     }
 4461: //
 4462: //     UE_LOG(LogTemp, Log, TEXT("ACauldronPosition::SetOccupied: %s is now %s"),
 4463: //            *GetName(), bIsOccupied ? TEXT("occupied") : TEXT("unoccupied"));
 4464: // }
 4465: </file>
 4466: 
 4467: <file path="Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp">
 4468: // Fill out your copyright notice in the Description page of Project Settings.
 4469: 
 4470: 
 4471: #include "Item/Ritual/RitualFunctionLibrary.h"
 4472: 
 4473: #include "Kismet/GameplayStatics.h"
 4474: #include "Player/WitchPTPlayerState.h"
 4475: #include "UI/HUD/WitchPTHUD.h"
 4476: #include "UI/WidgetControllers/CauldronWidgetController.h"
 4477: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 4478: 
 4479: URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
 4480: {
 4481: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
 4482: 	{
 4483: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
 4484: 		{
 4485: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
 4486: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
 4487: 			UAttributeSet* AS = PS->GetAttributeSet();
 4488: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
 4489: 
 4490: 			return WitchPTHUD->SetRitualWidgetController(WCParams);
 4491: 		}
 4492: 	}
 4493: 	return nullptr;
 4494: }
 4495: 
 4496: UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
 4497: {
 4498: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
 4499: 	{
 4500: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
 4501: 		{
 4502: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
 4503: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
 4504: 			UAttributeSet* AS = PS->GetAttributeSet();
 4505: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
 4506: 			return WitchPTHUD->SetCauldronWidgetController(WCParams);
 4507: 		}
 4508: 	}
 4509: 	return nullptr;
 4510: }
 4511: </file>
 4512: 
 4513: <file path="Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h">
 4514: // Fill out your copyright notice in the Description page of Project Settings.
 4515: 
 4516: #pragma once
 4517: 
 4518: #include "CoreMinimal.h"
 4519: #include "Abilities/GameplayAbility.h"
 4520: #include "WitchPTGameplayAbility.generated.h"
 4521: 
 4522: /**
 4523:  *
 4524:  */
 4525: UENUM(BlueprintType)
 4526: enum class EPrototypeAbilityActivationPolicy: uint8
 4527: {
 4528: 	// Try to activate the ability when the input is triggered.
 4529: 	OnInputTriggered,
 4530: 
 4531: 	// Continually try to activate the ability while the input is active.
 4532: 	WhileInputActive,
 4533: 
 4534: 	// Try to activate the ability when an avatar is assigned.
 4535: 	OnSpawn,
 4536: 
 4537: 	OnTriggeredEvent
 4538: };
 4539: UCLASS()
 4540: class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
 4541: {
 4542: 	GENERATED_BODY()
 4543: public:
 4544: 	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 4545: 	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
 4546: 	UPROPERTY(EditDefaultsOnly, Category="Input")
 4547: 	FGameplayTag StartupInputTag;
 4548: 	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
 4549: protected:
 4550: 
 4551: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
 4552: 	EPrototypeAbilityActivationPolicy ActivationPolicy;
 4553: 
 4554: 	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
 4555: };
 4556: </file>
 4557: 
 4558: <file path="Source/WitchPT/Public/Inventory/Collectable.h">
 4559: // Fill out your copyright notice in the Description page of Project Settings.
 4560: 
 4561: #pragma once
 4562: 
 4563: #include "CoreMinimal.h"
 4564: #include "Kismet/BlueprintFunctionLibrary.h"
 4565: #include "Templates/SubclassOf.h"
 4566: #include "UObject/Interface.h"
 4567: #include "UObject/ObjectPtr.h"
 4568: #include "Collectable.generated.h"
 4569: template <typename InterfaceType> class TScriptInterface;
 4570: // This class does not need to be modified.
 4571: 
 4572: class AActor;
 4573: class UWitchPTInventoryItemDefinition;
 4574: class UWitchPTInventoryItemInstance;
 4575: class UWitchPTInventoryManagerComponent;
 4576: class UObject;
 4577: struct FFrame;
 4578: // ------------------------- STRUCTS ---------------------- //
 4579: USTRUCT(BlueprintType)
 4580: struct FItemManifest
 4581: {
 4582: 	GENERATED_BODY()
 4583: 
 4584: public:
 4585: 	UPROPERTY(EditAnywhere)
 4586: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 4587: };
 4588: 
 4589: 
 4590: UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
 4591: class UCollectable : public UInterface
 4592: {
 4593: 	GENERATED_BODY()
 4594: };
 4595: 
 4596: /**
 4597:  *
 4598:  */
 4599: class WITCHPT_API ICollectable
 4600: {
 4601: 	GENERATED_BODY()
 4602: 
 4603: public:
 4604: 	/**
 4605: 	 * This is the functions you call from the GA_Interact_Collect
 4606: 	 */
 4607: 	UFUNCTION(BlueprintCallable)
 4608: 	virtual FItemManifest GetPickupInventory() const = 0;
 4609: };
 4610: 
 4611: UCLASS()
 4612: class UCollectableStatics : public UBlueprintFunctionLibrary
 4613: {
 4614: 	GENERATED_BODY()
 4615: 
 4616: public:
 4617: 	UCollectableStatics();
 4618: 
 4619: 	UFUNCTION(BlueprintPure)
 4620: 	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);
 4621: 
 4622: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
 4623: 	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
 4624: };
 4625: </file>
 4626: 
 4627: <file path="Source/WitchPT/Public/Item/BaseInteractionPosition.h">
 4628: // Fill out your copyright notice in the Description page of Project Settings.
 4629: 
 4630: #pragma once
 4631: 
 4632: #include "CoreMinimal.h"
 4633: #include "Item/Item.h"
 4634: #include "AbilitySystem/Interaction/InteractionOption.h"
 4635: #include "GameplayTagContainer.h" // Added for FGameplayTag
 4636: #include "MechanicsInterface.h"
 4637: #include "BaseInteractionPosition.generated.h"
 4638: 
 4639: class UAbilitySystemComponent;
 4640: struct FGameplayAbilitySpec;
 4641: class AController;
 4642: class UGameplayAbility;
 4643: class UBoxComponent;
 4644: class ACharacter;
 4645: class ABaseInteractableAltar;
 4646: 
 4647: /**
 4648:  * Base class for interaction positions (rituals, cauldrons, etc)
 4649:  */
 4650: UCLASS(Abstract)
 4651: class WITCHPT_API ABaseInteractionPosition : public AItem
 4652: {
 4653:     GENERATED_BODY()
 4654: 
 4655: public:
 4656:     // Sets default values for this actor's properties
 4657:     ABaseInteractionPosition();
 4658: 
 4659:     //~ Begin AActor Interface
 4660:     virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
 4661:     virtual void BeginPlay() override;
 4662:     //~ End AActor Interface
 4663: 
 4664:     //~ Begin IInteraction Interface (from AItem presumably)
 4665:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 4666:     //~ End IInteraction Interface
 4667: 
 4668:     //~ Getters
 4669: 
 4670:     UFUNCTION(BlueprintPure, Category = "Interaction")
 4671:     ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
 4672: 
 4673:     UFUNCTION(BlueprintPure, Category = "Interaction")
 4674:     FGameplayTag GetPositionTag() const { return PositionTag; }
 4675:     //~ End Getters
 4676:     virtual bool IsOccupied() const;
 4677: 
 4678:     //~ Setters
 4679:     UFUNCTION()
 4680:     void SetOccupied(ACharacter* Character);
 4681: 
 4682:     UFUNCTION()
 4683:     void SetUnoccupied();
 4684: 
 4685:     UFUNCTION()
 4686:     void SetPositionTag(const FGameplayTag& NewTag);
 4687: 
 4688: protected:
 4689:     // Unique tag identifying this position (e.g., Ritual.Position.1). Set per instance.
 4690:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
 4691:     FGameplayTag PositionTag;
 4692: 
 4693:     // Is this position currently occupied by a player? Replicated.
 4694:     UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
 4695:     bool bIsOccupied = false;
 4696: 
 4697:     // Which character is currently occupying this position? Replicated.
 4698:     UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
 4699:     TObjectPtr<ACharacter> OccupyingCharacter = nullptr;
 4700: 
 4701:     // Variables potentially used by the base AItem interaction system
 4702:     UPROPERTY()
 4703:     TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;
 4704: 
 4705:     UPROPERTY()
 4706:     TWeakObjectPtr<AController> InteractingController;
 4707: 
 4708:     //~ Replication Notifies
 4709:     UFUNCTION()
 4710:     void OnRep_IsOccupied();
 4711: 
 4712:     UFUNCTION()
 4713:     void OnRep_OccupyingCharacter();
 4714:     //~ End Replication Notifies
 4715: 
 4716:     // Interaction Logic Helper (Called from GatherInteractionOptions or a specific interaction GA)
 4717:     virtual void HandleInteraction(ACharacter* InteractingCharacter);
 4718: 
 4719: private:
 4720:     void RemoveCharacterFromPosition();
 4721: };
 4722: </file>
 4723: 
 4724: <file path="Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h">
 4725: // Fill out your copyright notice in the Description page of Project Settings.
 4726: 
 4727: #pragma once
 4728: 
 4729: #include "CoreMinimal.h"
 4730: #include "Kismet/BlueprintFunctionLibrary.h"
 4731: #include "UI/WidgetControllers/CauldronWidgetController.h"
 4732: #include "RitualFunctionLibrary.generated.h"
 4733: 
 4734: class UWitchPTWidgetController;
 4735: class URitualWidgetController;
 4736: /**
 4737:  *
 4738:  */
 4739: UCLASS()
 4740: class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
 4741: {
 4742: 	GENERATED_BODY()
 4743: public:
 4744: 	UFUNCTION(Category="Ritual")
 4745: 	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
 4746: 	UFUNCTION(Category="Cauldron")
 4747: 	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
 4748: };
 4749: </file>
 4750: 
 4751: <file path="Source/WitchPT/Public/UI/HUD/WitchPTHUD.h">
 4752: // Fill out your copyright notice in the Description page of Project Settings.
 4753: 
 4754: #pragma once
 4755: 
 4756: #include "CoreMinimal.h"
 4757: #include "GameFramework/HUD.h"
 4758: #include "WitchPTHUD.generated.h"
 4759: 
 4760: class UCauldronWidgetController;
 4761: class UWitchPTWidgetController;
 4762: class URitualWidgetController;
 4763: class UAbilitySystemComponent;
 4764: class UAttributeSet;
 4765: class UWitchPTUserWidget;
 4766: class UInventoryWidgetController;
 4767: struct FWidgetControllerParams;
 4768: class UOverlayWidgetController;
 4769: /**
 4770:  *
 4771:  */
 4772: UCLASS()
 4773: class WITCHPT_API AWitchPTHUD : public AHUD
 4774: {
 4775: 	GENERATED_BODY()
 4776: public:
 4777: 	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
 4778: 	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
 4779: 	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
 4780: 	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
 4781: 
 4782: 	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 4783: 
 4784: 
 4785: 
 4786: private:
 4787: 	UPROPERTY()
 4788: 	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
 4789: 	UPROPERTY(EditAnywhere)
 4790: 	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;
 4791: 
 4792: 
 4793: 	UPROPERTY()
 4794: 	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
 4795: 	UPROPERTY(EditAnywhere)
 4796: 	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;
 4797: 
 4798: 	UPROPERTY()
 4799: 	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
 4800: 	UPROPERTY(EditAnywhere)
 4801: 	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;
 4802: 
 4803: 	UPROPERTY()
 4804: 	TObjectPtr<URitualWidgetController> RitualWidgetController;
 4805: 	UPROPERTY(EditAnywhere)
 4806: 	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;
 4807: 
 4808: 	UPROPERTY()
 4809: 	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
 4810: 	UPROPERTY(EditAnywhere)
 4811: 	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
 4812: };
 4813: </file>
 4814: 
 4815: <file path="Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp">
 4816: // Fill out your copyright notice in the Description page of Project Settings.
 4817: 
 4818: 
 4819: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 4820: 
 4821: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 4822: 
 4823: 
 4824: void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
 4825: 	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
 4826: {
 4827: 	if (!AbilitiesToGrant.IsEmpty())
 4828: 	{
 4829: 		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
 4830: 		{
 4831: 			if (!AbilityClass)
 4832: 			{
 4833: 				continue;
 4834: 			}
 4835: 
 4836: 			// Obtener la clase de habilidad para acceder a la propiedad StartupInputTag
 4837: 			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
 4838: 			if (!AbilityCDO)
 4839: 			{
 4840: 				continue;
 4841: 			}
 4842: 
 4843: 			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
 4844: 			// Source of the ability is the ASC
 4845: 			AbilitySpec.SourceObject = this;
 4846: 			// Add the startup input tag to the ability spec
 4847: 			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
 4848: 			// Give the ability to the ASC
 4849: 			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
 4850: 			// Store the handle of the ability
 4851: 			GrantedAbilities.Add(AbilitySpecHandle);
 4852: 		}
 4853: 	}
 4854: }
 4855: 
 4856: void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
 4857: {
 4858: 	if (InputTag.IsValid())
 4859: 	{
 4860: 
 4861: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 4862: 		{
 4863: 			// print each ability
 4864: 
 4865: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 4866: 			{
 4867: 				//GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, AbilitySpec.Ability->GetName());
 4868: 				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
 4869: 				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
 4870: 			}
 4871: 		}
 4872: 	}
 4873: }
 4874: 
 4875: void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
 4876: {
 4877: 	if (!InputTag.IsValid()) return;
 4878: 	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
 4879: 	{
 4880: 		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
 4881: 		{
 4882: 			AbilitySpecInputPressed(AbilitySpec);
 4883: 			if (!AbilitySpec.IsActive())
 4884: 			{
 4885: 				TryActivateAbility(AbilitySpec.Handle);
 4886: 			}
 4887: 		}
 4888: 	}
 4889: }
 4890: 
 4891: void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
 4892: {
 4893: 	if (InputTag.IsValid())
 4894: 	{
 4895: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 4896: 		{
 4897: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 4898: 			{
 4899: 				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
 4900: 				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
 4901: 			}
 4902: 		}
 4903: 	}
 4904: }
 4905: 
 4906: void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
 4907: {
 4908: 	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
 4909: }
 4910: 
 4911: void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
 4912: {
 4913: 		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
 4914: 	AbilitiesToActivate.Reset();
 4915: 	//
 4916: 	// Process all abilities that activate when the input is held.
 4917: 	//
 4918: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
 4919: 	{
 4920: 
 4921: 
 4922: 		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 4923: 		{
 4924: 			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
 4925: 			{
 4926: 				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
 4927: 				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
 4928: 				{
 4929: 					// --- MODIFICACION AQUI ---
 4930: 					// Solo aÃ±adir si la polÃ­tica es WhileInputActive y NO es la nueva On Triggered Event
 4931: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
 4932: 					{
 4933: 						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
 4934: 					}
 4935: 				}
 4936: 			}
 4937: 		}
 4938: 	}
 4939: 	//
 4940: 	// Process all abilities that had their input pressed this frame.
 4941: 	//
 4942: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
 4943: 	{
 4944: 
 4945: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 4946: 		{
 4947: 			if (AbilitySpec->Ability)
 4948: 			{
 4949: 				AbilitySpec->InputPressed = true;
 4950: 
 4951: 				if (AbilitySpec->IsActive())
 4952: 				{
 4953: 
 4954: 
 4955: 					// Ability is active so pass along the input event.
 4956: 					AbilitySpecInputPressed(*AbilitySpec);
 4957: 				}
 4958: 				else
 4959: 				{
 4960: 					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
 4961: 
 4962: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
 4963: 					{
 4964: 						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
 4965: 						{
 4966: 							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
 4967: 						}
 4968: 					}
 4969: 				}
 4970: 			}
 4971: 		}
 4972: 	}
 4973: 	//
 4974: 	// Try to activate all the abilities that are from presses and holds.
 4975: 	// We do it all at once so that held inputs don't activate the ability
 4976: 	// and then also send a input event to the ability because of the press.
 4977: 	//
 4978: 	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
 4979: 	{
 4980: 		TryActivateAbility(AbilitySpecHandle);
 4981: 	}
 4982: 	//
 4983: 	// Process all abilities that had their input released this frame.
 4984: 	//
 4985: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
 4986: 	{
 4987: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
 4988: 		{
 4989: 			if (AbilitySpec->Ability)
 4990: 			{
 4991: 				AbilitySpec->InputPressed = false;
 4992: 
 4993: 				if (AbilitySpec->IsActive())
 4994: 				{
 4995: 					// Ability is active so pass along the input event.
 4996: 					AbilitySpecInputReleased(*AbilitySpec);
 4997: 				}
 4998: 			}
 4999: 		}
 5000: 	}
 5001: 
 5002: 	//
 5003: 	// Clear the cached ability handles.
 5004: 	//
 5005: 	InputPressedSpecHandles.Reset();
 5006: 	InputReleasedSpecHandles.Reset();
 5007: 
 5008: }
 5009: 
 5010: void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
 5011: {
 5012: 	Super::AbilitySpecInputPressed(Spec);
 5013: 	// We don't support UGameplayAbility::bReplicateInputDirectly.
 5014: 	// Use replicated events instead so that the WaitInputPress ability task works.
 5015: 	if (Spec.IsActive())
 5016: 	{
 5017: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
 5018: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
 5019: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
 5020: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
 5021: 
 5022: 		// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.
 5023: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
 5024: 	}
 5025: 
 5026: }
 5027: 
 5028: void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
 5029: {
 5030: 	Super::AbilitySpecInputReleased(Spec);
 5031: 	// We don't support UGameplayAbility::bReplicateInputDirectly.
 5032: 	// Use replicated events instead so that the WaitInputRelease ability task works.
 5033: 	if (Spec.IsActive())
 5034: 	{
 5035: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
 5036: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
 5037: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
 5038: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
 5039: 
 5040: 		// Invoke the InputReleased event. This is not replicated here. If someone is listening, they may replicate the InputReleased event to the server.
 5041: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
 5042: 	}
 5043: }
 5044: 
 5045: void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
 5046: 	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
 5047: {
 5048: 	FGameplayTagContainer TagContainer;
 5049: 	EffectSpec.GetAllAssetTags(TagContainer);
 5050: 
 5051: 	OnEffectAssetTags.Broadcast(TagContainer);
 5052: }
 5053: </file>
 5054: 
 5055: <file path="Source/WitchPT/Private/Player/WitchPTPlayerState.cpp">
 5056: // Fill out your copyright notice in the Description page of Project Settings.
 5057: 
 5058: 
 5059: #include "Player/WitchPTPlayerState.h"
 5060: 
 5061: #include "AbilitySystemComponent.h"
 5062: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5063: #include "AbilitySystem/WitchPTAttributeSet.h"
 5064: #include "Item/RitualPosition.h"
 5065: 
 5066: AWitchPTPlayerState::AWitchPTPlayerState()
 5067: {
 5068: 	SetNetUpdateFrequency(100.f);
 5069: 
 5070: 	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
 5071: 	AbilitySystemComponent->SetIsReplicated(true);
 5072: 	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
 5073: 
 5074: 	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");
 5075: 
 5076: 
 5077: }
 5078: 
 5079: UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
 5080: {
 5081: 	return AbilitySystemComponent;
 5082: }
 5083: </file>
 5084: 
 5085: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h">
 5086: #pragma once
 5087: 
 5088: #include "CoreMinimal.h"
 5089: #include "Abilities/GameplayAbility.h"
 5090: #include "InteractionOption.generated.h"
 5091: 
 5092: class IInteractableTarget;
 5093: // class UUserWidget;
 5094: 
 5095: /**  */
 5096: USTRUCT(BlueprintType)
 5097: struct FInteractionOption
 5098: {
 5099: 	GENERATED_BODY()
 5100: 
 5101: public:
 5102: 	/** The interactable target */
 5103: 	UPROPERTY(BlueprintReadWrite)
 5104: 	TScriptInterface<IInteractableTarget> InteractableTarget;
 5105: 
 5106: 	/** Simple text the interaction might return */
 5107: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 5108: 	FText Text;
 5109: 
 5110: 	/** Simple sub-text the interaction might return */
 5111: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 5112: 	FText SubText;
 5113: 
 5114: 	// METHODS OF INTERACTION
 5115: 	//--------------------------------------------------------------
 5116: 
 5117: 	// 1) Place an ability on the avatar that they can activate when they perform interaction.
 5118: 
 5119: 	/** The ability to grant the avatar when they get near interactable objects. */
 5120: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 5121: 	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;
 5122: 
 5123: 	// - OR -
 5124: 
 5125: 	// 2) Allow the object we're interacting with to have its own ability system and interaction ability, that we can activate instead.
 5126: 
 5127: 	/** The ability system on the target that can be used for the TargetInteractionHandle and sending the event, if needed. */
 5128: 	UPROPERTY(BlueprintReadOnly)
 5129: 	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;
 5130: 
 5131: 	/** The ability spec to activate on the object for this option. */
 5132: 	UPROPERTY(BlueprintReadOnly)
 5133: 	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
 5134: 
 5135: 	/** Indica si esta opciÃ³n de interacciÃ³n soporta interacciÃ³n mantenida */
 5136: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 5137: 	bool bSupportsHoldInteraction = false;
 5138: 
 5139: 	/** La habilidad a activar cuando se mantiene presionado el botÃ³n de interacciÃ³n */
 5140: 	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
 5141: 	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
 5142: 
 5143: 	/** La habilidad para interacciÃ³n mantenida en el objetivo */
 5144: 	UPROPERTY(BlueprintReadOnly)
 5145: 	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;
 5146: 
 5147: 	// UI
 5148: 	//--------------------------------------------------------------
 5149: 
 5150: 	/** The widget to show for this kind of interaction. */
 5151: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 5152: 	TSoftClassPtr<UUserWidget> InteractionWidgetClass;
 5153: 
 5154: 	//--------------------------------------------------------------
 5155: 
 5156: public:
 5157: 	FORCEINLINE bool operator==(const FInteractionOption& Other) const
 5158: 	{
 5159: 		return InteractableTarget == Other.InteractableTarget &&
 5160: 			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
 5161: 			TargetAbilitySystem == Other.TargetAbilitySystem &&
 5162: 			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
 5163: 			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
 5164: 			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
 5165: 			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
 5166: 			// InteractionWidgetClass == Other.InteractionWidgetClass &&
 5167: 			Text.IdenticalTo(Other.Text) &&
 5168: 			SubText.IdenticalTo(Other.SubText);
 5169: 	}
 5170: 
 5171: 	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
 5172: 	{
 5173: 		return !operator==(Other);
 5174: 	}
 5175: 
 5176: 	FORCEINLINE bool operator<(const FInteractionOption& Other) const
 5177: 	{
 5178: 		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
 5179: 	}
 5180: };
 5181: </file>
 5182: 
 5183: <file path="Source/WitchPT/Public/Player/WitchPTPlayerState.h">
 5184: // Fill out your copyright notice in the Description page of Project Settings.
 5185: 
 5186: #pragma once
 5187: 
 5188: #include "CoreMinimal.h"
 5189: #include "AbilitySystemInterface.h"
 5190: #include "GameFramework/PlayerState.h"
 5191: #include "WitchPTPlayerState.generated.h"
 5192: class ARitualPosition;
 5193: class ARitualAltar;
 5194: class UAbilitySystemComponent;
 5195: class UAttributeSet;
 5196: /**
 5197:  *
 5198:  */
 5199: UCLASS()
 5200: class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
 5201: {
 5202: 	GENERATED_BODY()
 5203: 	AWitchPTPlayerState();
 5204: public:
 5205: 
 5206: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
 5207: 	UAttributeSet* GetAttributeSet() const { return AttributeSet; }
 5208: 
 5209: protected:
 5210: 	UPROPERTY(VisibleAnywhere)
 5211: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
 5212: 	UPROPERTY(VisibleAnywhere)
 5213: 	TObjectPtr<UAttributeSet> AttributeSet;
 5214: 
 5215: 
 5216: };
 5217: </file>
 5218: 
 5219: <file path="Source/WitchPT/WitchPT.h">
 5220: // Fill out your copyright notice in the Description page of Project Settings.
 5221: 
 5222: #pragma once
 5223: 
 5224: #include "CoreMinimal.h"
 5225: #define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
 5226: #define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
 5227: #define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)
 5228: </file>
 5229: 
 5230: <file path="WitchPT.uproject">
 5231: {
 5232: 	"FileVersion": 3,
 5233: 	"EngineAssociation": "5.5",
 5234: 	"Category": "",
 5235: 	"Description": "",
 5236: 	"Modules": [
 5237: 		{
 5238: 			"Name": "WitchPT",
 5239: 			"Type": "Runtime",
 5240: 			"LoadingPhase": "Default",
 5241: 			"AdditionalDependencies": [
 5242: 				"Engine",
 5243: 				"CoreUObject"
 5244: 			]
 5245: 		}
 5246: 	],
 5247: 	"Plugins": [
 5248: 		{
 5249: 			"Name": "ModelingToolsEditorMode",
 5250: 			"Enabled": true,
 5251: 			"TargetAllowList": [
 5252: 				"Editor"
 5253: 			]
 5254: 		},
 5255: 		{
 5256: 			"Name": "GameplayAbilities",
 5257: 			"Enabled": true
 5258: 		},
 5259: 		{
 5260: 			"Name": "ElectronicNodes",
 5261: 			"Enabled": true,
 5262: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/5cb2a394d0c04e73891762be4cbd7216"
 5263: 		},
 5264: 		{
 5265: 			"Name": "FlatNodes",
 5266: 			"Enabled": true,
 5267: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/b719437f3fb54c259b34227363df8cab"
 5268: 		},
 5269: 		{
 5270: 			"Name": "BlueprintAssist",
 5271: 			"Enabled": true,
 5272: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/9e895371fa3a471c87337860d6f341ff"
 5273: 		},
 5274: 		{
 5275: 			"Name": "ActorPalette",
 5276: 			"Enabled": true
 5277: 		}
 5278: 	]
 5279: }
 5280: </file>
 5281: 
 5282: <file path="Config/DefaultGameplayTags.ini">
 5283: ;METADATA=(Diff=true, UseCommands=true)
 5284: [/Script/GameplayTags.GameplayTagsSettings]
 5285: ImportTagsFromConfig=True
 5286: WarnOnInvalidTags=True
 5287: ClearInvalidTags=False
 5288: AllowEditorTagUnloading=True
 5289: AllowGameTagUnloading=False
 5290: FastReplication=False
 5291: bDynamicReplication=False
 5292: InvalidTagCharacters="\"\',"
 5293: NumBitsForContainerSize=6
 5294: NetIndexFirstBitSegment=16
 5295: +GameplayTagList=(Tag="Ability.Altar.Participating",DevComment="")
 5296: +GameplayTagList=(Tag="Ability.Altar.Start",DevComment="")
 5297: +GameplayTagList=(Tag="Character.State.Cauldron.Brewing",DevComment="")
 5298: +GameplayTagList=(Tag="InputTag.F",DevComment="")
 5299: +GameplayTagList=(Tag="InputTag.Interact",DevComment="")
 5300: +GameplayTagList=(Tag="State.Ritual.Blocked",DevComment="")
 5301: +GameplayTagList=(Tag="State.Ritual.Moving",DevComment="")
 5302: </file>
 5303: 
 5304: <file path="Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp">
 5305: // Fill out your copyright notice in the Description page of Project Settings.
 5306: 
 5307: 
 5308: #include "UI/HUD/WitchPTHUD.h"
 5309: 
 5310: #include "UI/WidgetControllers/CauldronWidgetController.h"
 5311: #include "UI/WidgetControllers/InventoryWidgetController.h"
 5312: #include "UI/WidgetControllers/OverlayWidgetController.h"
 5313: #include "UI/WidgetControllers/RitualWidgetController.h"
 5314: #include "UI/Widgets/WitchPTUserWidget.h"
 5315: 
 5316: UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
 5317: {
 5318: 	if (OverlayWidgetController == nullptr)
 5319: 	{
 5320: 		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
 5321: 		OverlayWidgetController->SetWidgetControllerParams(WCParams);
 5322: 		OverlayWidgetController->BindCallbacksToDependencies();
 5323: 	}
 5324: 	return OverlayWidgetController;
 5325: }
 5326: 
 5327: UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
 5328: {
 5329: 	if (CauldronWidgetController == nullptr)
 5330: 	{
 5331: 		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
 5332: 		CauldronWidgetController->SetWidgetControllerParams(WCParams);
 5333: 		// CauldronWidgetController->BindCallbacksToDependencies();
 5334: 	}
 5335: 	return CauldronWidgetController;
 5336: }
 5337: 
 5338: UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
 5339: {
 5340: 	if (InventoryWidgetController == nullptr)
 5341: 	{
 5342: 		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
 5343: 		InventoryWidgetController->SetWidgetControllerParams(WCParams);
 5344: 		InventoryWidgetController->BindCallbacksToDependencies();
 5345: 	}
 5346: 	return InventoryWidgetController;
 5347: }
 5348: 
 5349: URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
 5350: {
 5351: 	if (RitualWidgetController == nullptr)
 5352: 	{
 5353: 		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
 5354: 		RitualWidgetController->SetWidgetControllerParams(WCParams);
 5355: 	}
 5356: 	return RitualWidgetController;
 5357: }
 5358: 
 5359: void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
 5360: {
 5361: 	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
 5362: 	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));
 5363: 
 5364: 
 5365: 	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
 5366: 	OverlayWidget = Cast<UWitchPTUserWidget>(Widget);
 5367: 
 5368: 	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
 5369: 	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);
 5370: 
 5371: 	OverlayWidget->SetWidgetController(WidgetController);
 5372: 	WidgetController->BroadcastInitialValues();
 5373: 	Widget->AddToViewport();
 5374: }
 5375: </file>
 5376: 
 5377: <file path="Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h">
 5378: // Fill out your copyright notice in the Description page of Project Settings.
 5379: 
 5380: #pragma once
 5381: 
 5382: #include "CoreMinimal.h"
 5383: #include "AbilitySystemComponent.h"
 5384: #include "WitchPTAbilitySystemComponent.generated.h"
 5385: 
 5386: DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& /* Asset tags that the GE have*/)
 5387: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 5388: class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
 5389: {
 5390: 	GENERATED_BODY()
 5391: 
 5392: public:
 5393: 	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
 5394: 
 5395: 	void AbilityInputTagPressed(const FGameplayTag& InputTag);
 5396: 	void AbilityInputTagHeld(const FGameplayTag& InputTag);
 5397: 	void AbilityInputTagReleased(const FGameplayTag& InputTag);
 5398: 	void AbilityActorInfoHaveBeenSet();
 5399: 
 5400: 	FEffectAssetTags OnEffectAssetTags;
 5401: 
 5402: 	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
 5403: 
 5404: 	bool bCharacterAbilitiesGiven = false;
 5405: 	bool bStartupEffectsApplied = false;
 5406: 
 5407: 	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;
 5408: 
 5409: 	// Handles to abilities that had their input pressed this frame.
 5410: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 5411: 	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;
 5412: 
 5413: 	// Handles to abilities that had their input released this frame.
 5414: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 5415: 	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;
 5416: 
 5417: 
 5418: 	// Handles to abilities that have their input held.
 5419: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
 5420: 	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
 5421: 
 5422: protected:
 5423: 	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
 5424: 	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
 5425: 	UFUNCTION(Client, Reliable)
 5426: 	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
 5427: 
 5428: };
 5429: </file>
 5430: 
 5431: <file path="Source/WitchPT/WitchPT.Build.cs">
 5432: // Fill out your copyright notice in the Description page of Project Settings.
 5433: 
 5434: using UnrealBuildTool;
 5435: 
 5436: public class WitchPT : ModuleRules
 5437: {
 5438: 	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
 5439: 	{
 5440: 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
 5441: 
 5442: 		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });
 5443: 
 5444: 		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });
 5445: 
 5446: 		// Uncomment if you are using Slate UI
 5447: 		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
 5448: 
 5449: 		// Uncomment if you are using online features
 5450: 		// PrivateDependencyModuleNames.Add("OnlineSubsystem");
 5451: 
 5452: 		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
 5453: 	}
 5454: }
 5455: </file>
 5456: 
 5457: <file path="Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp">
 5458: // Fill out your copyright notice in the Description page of Project Settings.
 5459: 
 5460: 
 5461: #include "Inventory/WitchPTInventoryItemInstance.h"
 5462: 
 5463: #include "GameplayTagContainer.h"
 5464: #include "Inventory/WitchPTInventoryItemDefinition.h"
 5465: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5466: #include "Net/UnrealNetwork.h"
 5467: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
 5468: class FLifetimeProperty;
 5469: UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
 5470: 	:Super(ObjectInitializer)
 5471: {
 5472: }
 5473: 
 5474: void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 5475: {
 5476: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 5477: 
 5478: 	DOREPLIFETIME(ThisClass, ItemDef);
 5479: 	DOREPLIFETIME(ThisClass, TotalStackCount);
 5480: }
 5481: 
 5482: 
 5483: 
 5484: void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
 5485: {
 5486: 	ItemDef = InDef;
 5487: }
 5488: 
 5489: 
 5490: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
 5491: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
 5492: {
 5493: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
 5494: 	{
 5495: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
 5496: 	}
 5497: 
 5498: 	return nullptr;
 5499: }
 5500: </file>
 5501: 
 5502: <file path="Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp">
 5503: // Fill out your copyright notice in the Description page of Project Settings.
 5504: 
 5505: 
 5506: #include "UI/WidgetControllers/CauldronWidgetController.h"
 5507: 
 5508: #include "Item/CauldronAltar.h"
 5509: 
 5510: UCauldronWidgetController::UCauldronWidgetController()
 5511: {
 5512: }
 5513: 
 5514: void UCauldronWidgetController::BroadcastInitialValues()
 5515: {
 5516: 	if(CauldronAltar)
 5517: 	{
 5518: 		OnBaseIngredientSet.Broadcast(CauldronAltar->GetBaseIngredient());
 5519: 
 5520: 	}
 5521: 
 5522: }
 5523: 
 5524: void UCauldronWidgetController::BindCallbacksToDependencies()
 5525: {
 5526: 	Super::BindCallbacksToDependencies();
 5527: 	if(CauldronAltar)
 5528: 	{
 5529: 		CauldronAltar->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
 5530: 		CauldronAltar->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
 5531: 		CauldronAltar->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
 5532: 		CauldronAltar->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
 5533: 		CauldronAltar->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
 5534: 		CauldronAltar->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
 5535: 	}
 5536: }
 5537: 
 5538: void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
 5539: {
 5540: 	if (InCauldronAltar != nullptr)
 5541: 	{
 5542: 		CauldronAltar = InCauldronAltar;
 5543: 	}
 5544: 
 5545: }
 5546: 
 5547: void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 5548: {
 5549: 	OnBaseIngredientSet.Broadcast(IngredientInstance);
 5550: }
 5551: 
 5552: void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
 5553: {
 5554: 	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
 5555: }
 5556: 
 5557: void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 5558: {
 5559: 	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
 5560: }
 5561: 
 5562: void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
 5563: {
 5564: 	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
 5565: }
 5566: 
 5567: void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
 5568: {
 5569: 	OnModifierIngredientSet.Broadcast(IngredientInstance);
 5570: }
 5571: 
 5572: void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
 5573: {
 5574: 	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
 5575: }
 5576: </file>
 5577: 
 5578: <file path="Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp">
 5579: // Fill out your copyright notice in the Description page of Project Settings.
 5580: 
 5581: 
 5582: #include "UI/WidgetControllers/InventoryWidgetController.h"
 5583: 
 5584: #include "Inventory/WitchPTInventoryItemInstance.h"
 5585: #include "Inventory/WitchPTInventoryManagerComponent.h"
 5586: #include "Player/WitchPTPlayerController.h"
 5587: 
 5588: void UInventoryWidgetController::BindCallbacksToDependencies()
 5589: {
 5590: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 5591: 	if (WitchPtPlayerController)
 5592: 	{
 5593: 		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 5594: 		if (InventoryManager)
 5595: 		{
 5596: 			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 5597: 			{
 5598: 				OnItemAddedDelegate.Broadcast(ItemAdded);
 5599: 			});
 5600: 			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 5601: 			{
 5602: 				OnItemStackChangedDelegate.Broadcast(ItemAdded);
 5603: 			});
 5604: 			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
 5605: 			{
 5606: 				OnItemRemovedDelegate.Broadcast(ItemRemoved);
 5607: 			});
 5608: 		}
 5609: 	}
 5610: }
 5611: 
 5612: void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 5613: {
 5614: 	if (!ItemInstance)
 5615: 	{
 5616: 		return;
 5617: 	}
 5618: 
 5619: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 5620: 	if (!WitchPtPlayerController)
 5621: 	{
 5622: 		return;
 5623: 	}
 5624: 
 5625: 	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 5626: 	if (!InventoryManager)
 5627: 	{
 5628: 		return;
 5629: 	}
 5630: 
 5631: 	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
 5632: 
 5633: 	// If we only have 1 item left and trying to remove 1 or more, remove the item completely
 5634: 	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
 5635: 	{
 5636: 		InventoryManager->Server_RemoveItemInstance(ItemInstance);
 5637: 	}
 5638: 	else
 5639: 	{
 5640: 		// Otherwise, reduce the stack count by the requested amount
 5641: 		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
 5642: 	}
 5643: }
 5644: </file>
 5645: 
 5646: <file path="Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h">
 5647: // Fill out your copyright notice in the Description page of Project Settings.
 5648: 
 5649: #pragma once
 5650: 
 5651: #include "CoreMinimal.h"
 5652: #include "WitchPTWidgetController.h"
 5653: #include "CauldronWidgetController.generated.h"
 5654: 
 5655: class ACauldronAltar;
 5656: class UWitchPTInventoryItemInstance;
 5657: 
 5658: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
 5659: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
 5660: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
 5661: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
 5662: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
 5663: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
 5664: /**
 5665:  *
 5666:  */
 5667: UCLASS(BlueprintType, Blueprintable)
 5668: class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
 5669: {
 5670: 	GENERATED_BODY()
 5671: public:
 5672: 	UCauldronWidgetController();
 5673: 	virtual void BroadcastInitialValues() override;
 5674: 	virtual void BindCallbacksToDependencies() override;
 5675: 
 5676: 	// Delegates for widgets to subscribe to
 5677: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5678: 	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
 5679: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5680: 	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
 5681: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5682: 	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
 5683: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5684: 	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
 5685: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5686: 	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
 5687: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
 5688: 	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;
 5689: 
 5690: 	UFUNCTION(Category = "Cauldron")
 5691: 	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);
 5692: 
 5693: 	// Getter for the current ritual altar
 5694: 	UFUNCTION(BlueprintPure, Category = "Cauldron")
 5695: 	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
 5696: 
 5697: 
 5698: protected:
 5699: 	// Reference to the ritual altar that this widget controls
 5700: 	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
 5701: 	TObjectPtr<ACauldronAltar> CauldronAltar;
 5702: 
 5703: 	UFUNCTION(Category = "Cauldron")
 5704: 	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
 5705: 	UFUNCTION(Category = "Cauldron")
 5706: 	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
 5707: 	UFUNCTION(Category = "Cauldron")
 5708: 	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
 5709: 	UFUNCTION(Category = "Cauldron")
 5710: 	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
 5711: 	UFUNCTION(Category = "Cauldron")
 5712: 	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
 5713: 	UFUNCTION(Category = "Cauldron")
 5714: 	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
 5715: };
 5716: </file>
 5717: 
 5718: <file path="Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h">
 5719: // Fill out your copyright notice in the Description page of Project Settings.
 5720: 
 5721: #pragma once
 5722: 
 5723: #include "CoreMinimal.h"
 5724: #include "WitchPTWidgetController.h"
 5725: #include "InventoryWidgetController.generated.h"
 5726: 
 5727: /**
 5728:  *
 5729:  */
 5730: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
 5731: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);
 5732: 
 5733: UCLASS(BlueprintType, Blueprintable)
 5734: class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
 5735: {
 5736: 	GENERATED_BODY()
 5737: 
 5738: public:
 5739: 	UFUNCTION(BlueprintCallable)
 5740: 	virtual void BindCallbacksToDependencies() override;
 5741: 
 5742: 	/**
 5743: 	 * Removes a stack or specified amount from an inventory item instance
 5744: 	 * If there's only one stack left and count is 1, removes the item completely
 5745: 	 * @param ItemInstance - The item instance to remove from
 5746: 	 * @param AmountToRemove - The amount to remove, defaults to 1
 5747: 	 */
 5748: 	UFUNCTION(BlueprintCallable, Category = "Inventory")
 5749: 	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);
 5750: 
 5751: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
 5752: 	FOnItemAddedSignature OnItemAddedDelegate;
 5753: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
 5754: 	FOnItemAddedSignature OnItemStackChangedDelegate;
 5755: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
 5756: 	FOnItemRemovedSignature OnItemRemovedDelegate;
 5757: };
 5758: </file>
 5759: 
 5760: <file path="Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h">
 5761: // Fill out your copyright notice in the Description page of Project Settings.
 5762: 
 5763: #pragma once
 5764: 
 5765: #include "CoreMinimal.h"
 5766: #include "InteractionOption.h"
 5767: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 5768: #include "GameplayAbility_Interact.generated.h"
 5769: 
 5770: class UObject;
 5771: struct FFrame;
 5772: struct FGameplayAbilityActorInfo;
 5773: struct FGameplayEventData;
 5774: 
 5775: // Delegado para notificar cuando se completa una interacciÃ³n
 5776: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);
 5777: 
 5778: /**
 5779:  *
 5780:  */
 5781: UCLASS(Abstract)
 5782: class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
 5783: {
 5784: 	GENERATED_BODY()
 5785: 	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 5786: 	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 5787: 
 5788: 	UFUNCTION(BlueprintCallable)
 5789: 	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
 5790: 
 5791: 	// MÃ©todo para interacciÃ³n de pulsaciÃ³n rÃ¡pida
 5792: 	UFUNCTION(BlueprintCallable)
 5793: 	void TriggerInteraction();
 5794: 
 5795: 	// MÃ©todo para interacciÃ³n manteniendo pulsado
 5796: 	UFUNCTION(BlueprintCallable)
 5797: 	void TriggerHoldInteraction();
 5798: 
 5799: 	// MÃ©todo llamado cuando se presiona el botÃ³n de interacciÃ³n
 5800: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 5801: 	void OnInteractionButtonPressed();
 5802: 
 5803: 	// MÃ©todo llamado cuando se suelta el botÃ³n de interacciÃ³n
 5804: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 5805: 	void OnInteractionButtonReleased();
 5806: 
 5807: 	// MÃ©todo llamado cuando se cumple el tiempo de interacciÃ³n mantenida
 5808: 	UFUNCTION()
 5809: 	void OnHoldInteractionTimeElapsed();
 5810: 
 5811:     // MÃ©todo que verifica si el objeto bajo el trace sigue siendo el mismo
 5812:     UFUNCTION()
 5813:     void CheckInteractionValidity();
 5814: 
 5815:     // MÃ©todo que cancela una interacciÃ³n en curso
 5816:     UFUNCTION(BlueprintCallable, Category = "Interaction")
 5817:     void CancelCurrentInteraction();
 5818: 
 5819:     // MÃ©todo de seguridad que se activa si una interacciÃ³n dura demasiado tiempo
 5820:     UFUNCTION()
 5821:     void OnMaxInteractionTimeElapsed();
 5822: 
 5823: 	// Delegado que se dispara cuando se completa una interacciÃ³n
 5824: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 5825: 	FOnInteractionComplete OnInteractionComplete;
 5826: 
 5827: 	// Delegado que se dispara cuando se completa una interacciÃ³n mantenida
 5828: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 5829: 	FOnInteractionComplete OnHoldInteractionComplete;
 5830: 
 5831:     // Delegado que se dispara cuando se cancela una interacciÃ³n
 5832:     UPROPERTY(BlueprintAssignable, Category = "Interaction")
 5833:     FOnInteractionComplete OnInteractionCancelled;
 5834: 
 5835: protected:
 5836: 
 5837: 	UPROPERTY(BlueprintReadWrite)
 5838: 	TArray<FInteractionOption> CurrentOptions;
 5839: 
 5840: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
 5841: 	float InteractionScanRate = 0.1f;
 5842: 
 5843: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
 5844: 	float InteractionScanRange = 500;
 5845: 
 5846: 	// Tiempo mÃ­nimo que debe mantenerse presionado el botÃ³n para considerar una interacciÃ³n mantenida
 5847: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botÃ³n para activar una interacciÃ³n mantenida"))
 5848: 	float HoldInteractionTime = 1.0f;
 5849: 
 5850:     // Frecuencia para verificar si el objeto interactuable sigue siendo vÃ¡lido durante una interacciÃ³n mantenida
 5851:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
 5852:     float ValidityCheckRate = 0.1f;
 5853: 
 5854:     // Tiempo mÃ¡ximo que puede durar cualquier interacciÃ³n antes de ser cancelada automÃ¡ticamente
 5855:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo mÃ¡ximo en segundos que puede durar una interacciÃ³n antes de ser cancelada automÃ¡ticamente"))
 5856:     float MaxInteractionTime = 10.0f;
 5857: 
 5858: 	// Temporizador para detectar interacciÃ³n mantenida
 5859: 	FTimerHandle HoldInteractionTimerHandle;
 5860: 
 5861:     // Temporizador para verificar la validez del objeto interactuable
 5862:     FTimerHandle ValidityCheckTimerHandle;
 5863: 
 5864:     // Temporizador de seguridad para forzar el reinicio despuÃ©s de un tiempo mÃ¡ximo
 5865:     FTimerHandle MaxInteractionTimeTimerHandle;
 5866: 
 5867: 	// Estado del botÃ³n de interacciÃ³n (presionado o no)
 5868: 	bool bIsInteractionButtonHeld = false;
 5869: 
 5870: 	// Tiempo en que se iniciÃ³ la pulsaciÃ³n
 5871: 	float InteractionStartTime = 0.0f;
 5872: 
 5873: 	// Indica si ya se disparÃ³ una interacciÃ³n mantenida para la pulsaciÃ³n actual
 5874: 	bool bHoldInteractionFired = false;
 5875: 
 5876:     // Guarda el objeto con el que se iniciÃ³ la interacciÃ³n para compararlo
 5877:     TScriptInterface<IInteractableTarget> InitialInteractableTarget;
 5878: 
 5879: 	UPROPERTY(EditDefaultsOnly)
 5880: 	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
 5881: 
 5882: 
 5883: };
 5884: </file>
 5885: 
 5886: <file path=".gitignore">
 5887: Binaries
 5888: DerivedDataCache
 5889: Intermediate
 5890: Saved
 5891: Build
 5892: Plugins
 5893: Content/WitchHag
 5894: Content/BattleWitch
 5895: Content/UltraDynamicSky
 5896: Content/MagicCircleVFX
 5897: Content/PIP_Herbals_Potions
 5898: Content/fullscreen_flat_gui
 5899: Content/Village
 5900: Content/LootDrop_VFX
 5901: 
 5902: .vscode
 5903: .vs
 5904: *.VC.db
 5905: *.opensdf
 5906: *.opendb
 5907: *.sdf
 5908: *.sln
 5909: *.suo
 5910: *.xcodeproj
 5911: *.xcworkspace
 5912: # ignore all related to .idea
 5913: .idea
 5914: 
 5915: .codebuddy/.gitignore
 5916: .idea/.idea.Aura.dir/.idea/workspace.xml
 5917: 
 5918: Source/WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h
 5919: 
 5920: Source/WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp
 5921: 
 5922: Source/WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp
 5923: 
 5924: Source/WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h
 5925: </file>
 5926: 
 5927: <file path="Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h">
 5928: // Fill out your copyright notice in the Description page of Project Settings.
 5929: 
 5930: #pragma once
 5931: 
 5932: #include "CoreMinimal.h"
 5933: #include "Systems/GameplayTagStack.h"
 5934: #include "Templates/SubclassOf.h"
 5935: #include "WitchPTInventoryItemInstance.generated.h"
 5936: class UWitchPTInventoryItemFragment;
 5937: class UWitchPTInventoryItemDefinition;
 5938: struct FFrame;
 5939: struct FGameplayTag;
 5940: 
 5941: /**
 5942:  *
 5943:  */
 5944: UCLASS(BlueprintType)
 5945: class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
 5946: {
 5947: 	GENERATED_BODY()
 5948: public:
 5949: 	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 5950: 	friend struct FWitchPTInventoryList;
 5951: 
 5952: 	//~UObject interface
 5953: 	virtual bool IsSupportedForNetworking() const override { return true; }
 5954: 	//~End of UObject interface
 5955: 
 5956: 
 5957: 	UFUNCTION(BlueprintCallable)
 5958: 	int32 GetTotalStackCount() const { return TotalStackCount; }
 5959: 
 5960: 	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
 5961: 	UFUNCTION(BlueprintCallable)
 5962: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
 5963: 	{
 5964: 		return ItemDef;
 5965: 	}
 5966: 
 5967: 	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
 5968: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
 5969: 
 5970: 	template <typename ResultClass>
 5971: 	const ResultClass* FindFragmentByClass() const
 5972: 	{
 5973: 		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
 5974: 	}
 5975: 
 5976: 	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);
 5977: 
 5978: 
 5979: private:
 5980: 	UPROPERTY(Replicated)
 5981: 	int32 TotalStackCount{0};
 5982: 
 5983: 	UPROPERTY(Replicated)
 5984: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 5985: 
 5986: };
 5987: </file>
 5988: 
 5989: <file path="Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp">
 5990: // Fill out your copyright notice in the Description page of Project Settings.
 5991: 
 5992: 
 5993: #include "AbilitySystem/Interaction/GameplayAbility_Interact.h"
 5994: 
 5995: #include "AbilitySystemComponent.h"
 5996: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
 5997: #include "AbilitySystem/Interaction/InteractionStatics.h"
 5998: #include "NativeGameplayTags.h"
 5999: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 6000: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 6001: #include "Engine/World.h"
 6002: #include "Player/WitchPTPlayerController.h"
 6003: 
 6004: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
 6005: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");
 6006: 
 6007: UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
 6008: 	: Super(ObjectInitializer)
 6009: {
 6010: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
 6011: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 6012: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 6013: }
 6014: 
 6015: void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
 6016: 	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
 6017: 	const FGameplayEventData* TriggerEventData)
 6018: {
 6019: 	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
 6020: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 6021: 	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
 6022: 	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
 6023: 	{
 6024: 
 6025: 		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
 6026: 		Task->ReadyForActivation();
 6027: 
 6028: 	}
 6029: }
 6030: 
 6031: void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
 6032: {
 6033: 
 6034: 	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
 6035: 	{
 6036: 
 6037: 
 6038: 		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
 6039: 
 6040: 		CurrentOptions = InteractiveOptions;
 6041: 
 6042: 		for (const FInteractionOption& InteractionOption : InteractiveOptions)
 6043: 		{
 6044: 			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 6045: 
 6046: 			if (InteractableTargetActor)
 6047: 			{
 6048: 				FString ActorName = InteractableTargetActor->GetName();
 6049: 				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
 6050: 			}
 6051: 
 6052: 
 6053: 		}
 6054: 		if (InteractiveOptions.Num() == 0)
 6055: 		{
 6056: 			WitchPt->HUDWidget->HidePickupMessage();
 6057: 		}
 6058: 
 6059: 	}
 6060: 
 6061: 	CurrentOptions = InteractiveOptions;
 6062: }
 6063: 
 6064: void UGameplayAbility_Interact::TriggerInteraction()
 6065: {
 6066: 	if (CurrentOptions.Num() == 0)
 6067: 	{
 6068: 		return;
 6069: 	}
 6070: 
 6071: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 6072: 	if (AbilitySystem)
 6073: 	{
 6074: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 6075: 
 6076: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 6077: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 6078: 
 6079: 		// Allow the target to customize the event data we're about to pass in, in case the ability needs custom data
 6080: 		// that only the actor knows.
 6081: 		FGameplayEventData Payload;
 6082: 		Payload.EventTag = TAG_Ability_Interaction_Activate;
 6083: 		Payload.Instigator = Instigator;
 6084: 		Payload.Target = InteractableTargetActor;
 6085: 
 6086: 		// If needed we allow the interactable target to manipulate the event data so that for example, a button on the wall
 6087: 		// may want to specify a door actor to execute the ability on, so it might choose to override Target to be the
 6088: 		// door actor.
 6089: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
 6090: 
 6091: 
 6092: 		// Grab the target actor off the payload we're going to use it as the 'avatar' for the interaction, and the
 6093: 		// source InteractableTarget actor as the owner actor.
 6094: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
 6095: 
 6096: 		// The actor info needed for the interaction.
 6097: 		FGameplayAbilityActorInfo ActorInfo;
 6098: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
 6099: 
 6100: 		// Trigger the ability using event tag.
 6101: 
 6102: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
 6103: 			InteractionOption.TargetInteractionAbilityHandle,
 6104: 			&ActorInfo,
 6105: 			TAG_Ability_Interaction_Activate,
 6106: 			&Payload,
 6107: 			*InteractionOption.TargetAbilitySystem
 6108: 		);
 6109: 
 6110: 		// Notificar que se completÃ³ la interacciÃ³n
 6111: 		OnInteractionComplete.Broadcast();
 6112: 	}
 6113: }
 6114: 
 6115: void UGameplayAbility_Interact::TriggerHoldInteraction()
 6116: {
 6117: 	if (CurrentOptions.Num() == 0)
 6118: 	{
 6119: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacciÃ³n disponibles"));
 6120: 		OnInteractionCancelled.Broadcast();
 6121: 		return;
 6122: 	}
 6123: 
 6124: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 6125: 	if (AbilitySystem)
 6126: 	{
 6127: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 6128: 
 6129: 		// Verificar si la opciÃ³n de interacciÃ³n soporta interacciÃ³n mantenida
 6130: 		if (!InteractionOption.bSupportsHoldInteraction)
 6131: 		{
 6132: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacciÃ³n mantenida, usando interacciÃ³n normal"));
 6133: 			// Si no soporta interacciÃ³n mantenida, podemos usar la interacciÃ³n normal en su lugar
 6134: 			TriggerInteraction();
 6135: 			return;
 6136: 		}
 6137: 
 6138: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacciÃ³n mantenida en objeto que la soporta"));
 6139: 
 6140: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 6141: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 6142: 
 6143: 		// Configurar los datos del evento para la interacciÃ³n mantenida
 6144: 		FGameplayEventData Payload;
 6145: 		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
 6146: 		Payload.Instigator = Instigator;
 6147: 		Payload.Target = InteractableTargetActor;
 6148: 
 6149: 		// Permitir que el objetivo personalice los datos del evento
 6150: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);
 6151: 
 6152: 		// Obtener el actor objetivo
 6153: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
 6154: 
 6155: 		// La informaciÃ³n del actor necesaria para la interacciÃ³n
 6156: 		FGameplayAbilityActorInfo ActorInfo;
 6157: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
 6158: 
 6159: 		// Usar el handle de habilidad especÃ­fico para interacciÃ³n mantenida, si estÃ¡ disponible
 6160: 		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
 6161: 
 6162: 		// Si no hay un handle especÃ­fico para interacciÃ³n mantenida, usar el handle normal
 6163: 		if (!AbilityHandle.IsValid())
 6164: 		{
 6165: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle especÃ­fico para interacciÃ³n mantenida, usando el handle normal"));
 6166: 			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
 6167: 		}
 6168: 		else
 6169: 		{
 6170: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle especÃ­fico para interacciÃ³n mantenida"));
 6171: 		}
 6172: 
 6173: 		// Activar la habilidad usando la etiqueta de evento de interacciÃ³n mantenida
 6174: 		// UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Intentando activar habilidad con tag %s"), *TAG_Ability_Interaction_Hold_Activate.ToString());
 6175: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
 6176: 			AbilityHandle,
 6177: 			&ActorInfo,
 6178: 			TAG_Ability_Interaction_Hold_Activate,
 6179: 			&Payload,
 6180: 			*InteractionOption.TargetAbilitySystem
 6181: 		);
 6182: 
 6183: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activaciÃ³n: %s"), bSuccess ? TEXT("Ã‰xito") : TEXT("Fallido"));
 6184: 
 6185: 		// Notificar que se completÃ³ la interacciÃ³n mantenida
 6186: 		OnHoldInteractionComplete.Broadcast();
 6187: 	}
 6188: }
 6189: 
 6190: void UGameplayAbility_Interact::OnInteractionButtonPressed()
 6191: {
 6192: 	if (CurrentOptions.Num() == 0)
 6193: 	{
 6194: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No hay opciones de interacciÃ³n disponibles"));
 6195: 		OnInteractionCancelled.Broadcast();
 6196: 		return;
 6197: 	}
 6198: 
 6199: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: BotÃ³n de interacciÃ³n presionado"));
 6200: 	bIsInteractionButtonHeld = true;
 6201: 	bHoldInteractionFired = false; // Reiniciamos la bandera al comenzar una nueva interacciÃ³n
 6202: 	InteractionStartTime = GetWorld()->GetTimeSeconds();
 6203: 
 6204: 	// Guardar el objetivo interactuable actual para validaciones posteriores
 6205: 	if (CurrentOptions.Num() > 0)
 6206: 	{
 6207: 		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
 6208: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Guardando objetivo inicial de interacciÃ³n"));
 6209: 	}
 6210: 
 6211: 	// Configurar un temporizador para detectar si el botÃ³n se mantiene presionado durante el tiempo requerido
 6212: 	GetWorld()->GetTimerManager().SetTimer(
 6213: 		HoldInteractionTimerHandle,
 6214: 		this,
 6215: 		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
 6216: 		HoldInteractionTime,
 6217: 		false
 6218: 	);
 6219: 
 6220: 	// Iniciar comprobaciÃ³n periÃ³dica de validez
 6221: 	GetWorld()->GetTimerManager().SetTimer(
 6222: 		ValidityCheckTimerHandle,
 6223: 		this,
 6224: 		&UGameplayAbility_Interact::CheckInteractionValidity,
 6225: 		ValidityCheckRate,
 6226: 		true // Repetitivo
 6227: 	);
 6228: 
 6229: 	// Configurar el temporizador de seguridad para forzar un reinicio despuÃ©s de un tiempo mÃ¡ximo
 6230: 	GetWorld()->GetTimerManager().SetTimer(
 6231: 		MaxInteractionTimeTimerHandle,
 6232: 		this,
 6233: 		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
 6234: 		MaxInteractionTime,
 6235: 		false // No repetitivo
 6236: 	);
 6237: 
 6238: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizadores configurados. Hold: %f segundos, Max: %f segundos"),
 6239: 	// 	HoldInteractionTime, MaxInteractionTime);
 6240: }
 6241: 
 6242: void UGameplayAbility_Interact::OnInteractionButtonReleased()
 6243: {
 6244: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: BotÃ³n de interacciÃ³n liberado"));
 6245: 
 6246: 	if (!bIsInteractionButtonHeld)
 6247: 	{
 6248: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botÃ³n no estaba siendo mantenido, ignorando liberaciÃ³n"));
 6249: 		return;
 6250: 	}
 6251: 
 6252: 	bIsInteractionButtonHeld = false;
 6253: 
 6254: 	// Cancelar los temporizadores
 6255: 	if (GetWorld())
 6256: 	{
 6257: 		// Temporizador de validez
 6258: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
 6259: 		{
 6260: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
 6261: 		}
 6262: 
 6263: 		// Temporizador de seguridad
 6264: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
 6265: 		{
 6266: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
 6267: 		}
 6268: 
 6269: 		// Temporizador de interacciÃ³n mantenida
 6270: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
 6271: 		{
 6272: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Temporizador de hold cancelado"));
 6273: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
 6274: 
 6275: 			// Verificamos si ya se lanzÃ³ una interacciÃ³n mantenida
 6276: 			if (bHoldInteractionFired)
 6277: 			{
 6278: 				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Ya se disparÃ³ una interacciÃ³n mantenida, ignorando interacciÃ³n rÃ¡pida"));
 6279: 				return; // Si ya se disparÃ³ una interacciÃ³n mantenida, no lanzamos la rÃ¡pida
 6280: 			}
 6281: 
 6282: 			// Si el botÃ³n se soltÃ³ antes del tiempo de interacciÃ³n mantenida, considerarlo como una pulsaciÃ³n rÃ¡pida
 6283: 			float CurrentTime = GetWorld()->GetTimeSeconds();
 6284: 			float HoldTime = CurrentTime - InteractionStartTime;
 6285: 
 6286: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo mantenido: %f / Requerido: %f"), HoldTime, HoldInteractionTime);
 6287: 
 6288: 			if (HoldTime < HoldInteractionTime)
 6289: 			{
 6290: 				// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacciÃ³n rÃ¡pida"));
 6291: 				// Llamar a la interacciÃ³n de pulsaciÃ³n rÃ¡pida
 6292: 				TriggerInteraction();
 6293: 
 6294: 				// Llamar a InteractPressScan despuÃ©s de la interacciÃ³n para restaurar el estado
 6295: 				// y prepararse para la siguiente interacciÃ³n
 6296: 				// Nota: Esto debe implementarse en el blueprint conectando la salida de este nodo
 6297: 				// a la entrada del nodo InteractPressScan
 6298: 			}
 6299: 		}
 6300: 		else
 6301: 		{
 6302: 			// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: No habÃ­a temporizador activo al liberar el botÃ³n"));
 6303: 		}
 6304: 	}
 6305: 
 6306: 	// Limpiar la referencia al objetivo inicial
 6307: 	InitialInteractableTarget = nullptr;
 6308: }
 6309: 
 6310: void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
 6311: {
 6312: 	// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Tiempo de interacciÃ³n mantenida alcanzado"));
 6313: 
 6314: 	if (bIsInteractionButtonHeld)
 6315: 	{
 6316: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Activando interacciÃ³n mantenida"));
 6317: 		// Marcamos que ya se disparÃ³ la interacciÃ³n mantenida
 6318: 		bHoldInteractionFired = true;
 6319: 
 6320: 		// El botÃ³n se ha mantenido presionado durante el tiempo requerido
 6321: 		// Llamar a la interacciÃ³n mantenida
 6322: 		TriggerHoldInteraction();
 6323: 
 6324: 		// Nota: DespuÃ©s de llamar a TriggerHoldInteraction,
 6325: 		// es necesario llamar a InteractPressScan en el blueprint
 6326: 		// para restaurar el estado y prepararse para la siguiente interacciÃ³n
 6327: 		// Esto se logra escuchando al delegado OnHoldInteractionComplete
 6328: 	}
 6329: 	else
 6330: 	{
 6331: 		// UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: El botÃ³n ya no estÃ¡ presionado, no se activa interacciÃ³n mantenida"));
 6332: 	}
 6333: }
 6334: 
 6335: void UGameplayAbility_Interact::CheckInteractionValidity()
 6336: {
 6337: 	// Si no estamos en un estado de interacciÃ³n, no necesitamos verificar
 6338: 	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
 6339: 	{
 6340: 		return;
 6341: 	}
 6342: 
 6343: 	// Log adicional para verificar estado actual
 6344: 	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacciÃ³n. Opciones actuales: %d"), CurrentOptions.Num());
 6345: 
 6346: 	// Verificar si aÃºn hay opciones de interacciÃ³n disponibles
 6347: 	bool bHasValidInteraction = false;
 6348: 
 6349: 	if (CurrentOptions.Num() > 0)
 6350: 	{
 6351: 		// Buscar el objetivo inicial en cualquier posiciÃ³n del array
 6352: 		for (const FInteractionOption& Option : CurrentOptions)
 6353: 		{
 6354: 			if (Option.InteractableTarget == InitialInteractableTarget)
 6355: 			{
 6356: 				bHasValidInteraction = true;
 6357: 				break;
 6358: 			}
 6359: 		}
 6360: 
 6361: 		// Log detallado sobre la validaciÃ³n
 6362: 		if (bHasValidInteraction)
 6363: 		{
 6364: 			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacciÃ³n aÃºn es vÃ¡lido"));
 6365: 		}
 6366: 		else
 6367: 		{
 6368: 			// Intentar identificar quÃ© cambiÃ³
 6369: 			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
 6370: 			AActor* CurrentActor = CurrentOptions.Num() > 0 ?
 6371: 				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
 6372: 
 6373: 			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacciÃ³n invÃ¡lido. Inicial: %s, Actual: %s"),
 6374: 				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
 6375: 				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
 6376: 		}
 6377: 	}
 6378: 	else
 6379: 	{
 6380: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacciÃ³n disponibles"));
 6381: 	}
 6382: 
 6383: 	// Si no hay una interacciÃ³n vÃ¡lida, cancelar la interacciÃ³n actual
 6384: 	if (!bHasValidInteraction)
 6385: 	{
 6386: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacciÃ³n ha cambiado o no es vÃ¡lido, cancelando interacciÃ³n"));
 6387: 		CancelCurrentInteraction();
 6388: 	}
 6389: }
 6390: 
 6391: void UGameplayAbility_Interact::CancelCurrentInteraction()
 6392: {
 6393: 	// Si no estamos en un estado de interacciÃ³n, no hay nada que cancelar
 6394: 	if (!bIsInteractionButtonHeld)
 6395: 	{
 6396: 		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacciÃ³n activa para cancelar"));
 6397: 		return;
 6398: 	}
 6399: 
 6400: 	// Obtener informaciÃ³n del objeto inicial para el log
 6401: 	FString InitialObjectName = TEXT("Desconocido");
 6402: 	if (InitialInteractableTarget.GetInterface())
 6403: 	{
 6404: 		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
 6405: 		if (InitialActor)
 6406: 		{
 6407: 			InitialObjectName = InitialActor->GetName();
 6408: 		}
 6409: 	}
 6410: 
 6411: 	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacciÃ³n actual con %s"), *InitialObjectName);
 6412: 
 6413: 	// Detener temporizadores
 6414: 	if (GetWorld())
 6415: 	{
 6416: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
 6417: 		{
 6418: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
 6419: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
 6420: 		}
 6421: 
 6422: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
 6423: 		{
 6424: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
 6425: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacciÃ³n mantenida detenido"));
 6426: 		}
 6427: 
 6428: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
 6429: 		{
 6430: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
 6431: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
 6432: 		}
 6433: 	}
 6434: 
 6435: 	// Restablecer variables de estado
 6436: 	bIsInteractionButtonHeld = false;
 6437: 	bHoldInteractionFired = false;
 6438: 
 6439: 	// Hacer una copia de la referencia antes de limpiarla para poder notificar
 6440: 	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
 6441: 	InitialInteractableTarget = nullptr;
 6442: 
 6443: 	// Log para confirmar que el estado ha sido restablecido
 6444: 	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacciÃ³n restablecido completamente"));
 6445: 
 6446: 	// Notificar la cancelaciÃ³n
 6447: 	OnInteractionCancelled.Broadcast();
 6448: }
 6449: 
 6450: void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
 6451: {
 6452: 	// Si todavÃ­a estamos en un estado de interacciÃ³n, forzar una cancelaciÃ³n
 6453: 	if (bIsInteractionButtonHeld)
 6454: 	{
 6455: 		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Â¡Tiempo mÃ¡ximo de interacciÃ³n alcanzado! Forzando cancelaciÃ³n despuÃ©s de %f segundos"), MaxInteractionTime);
 6456: 		CancelCurrentInteraction();
 6457: 
 6458: 		// Forzar un reinicio del escaneo de interacciones
 6459: 		OnInteractionCancelled.Broadcast();
 6460: 	}
 6461: }
 6462: </file>
 6463: 
 6464: <file path="Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h">
 6465: // Fill out your copyright notice in the Description page of Project Settings.
 6466: 
 6467: #pragma once
 6468: 
 6469: #include "CoreMinimal.h"
 6470: #include "Components/ActorComponent.h"
 6471: #include "Item/MechanicsInterface.h"
 6472: #include "WitchPTMechanicComponent.generated.h"
 6473: 
 6474: class ACauldronAltar;
 6475: 
 6476: UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
 6477: class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
 6478: {
 6479: 	GENERATED_BODY()
 6480: 
 6481: public:
 6482: 	// Sets default values for this component's properties
 6483: 	UWitchPTMechanicComponent();
 6484: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 6485: 
 6486: 	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
 6487: 	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
 6488: 	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
 6489: 	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
 6490: 	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
 6491: 	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
 6492: 	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
 6493: 	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
 6494: 	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
 6495: 	virtual void RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
 6496: 
 6497: 	UFUNCTION(Server, Reliable)
 6498: 	void Server_RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
 6499: 
 6500: 
 6501: 
 6502: 
 6503: 	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
 6504: 	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
 6505: 	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
 6506: 	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
 6507: 	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
 6508: 
 6509: 
 6510: 
 6511: 
 6512: protected:
 6513: 
 6514: 
 6515: 	virtual void BeginPlay() override;
 6516: 
 6517: public:
 6518: 	// Called every frame
 6519: 	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
 6520: };
 6521: </file>
 6522: 
 6523: <file path="Source/WitchPT/Public/Character/WitchPTCharacter.h">
 6524: // Fill out your copyright notice in the Description page of Project Settings.
 6525: 
 6526: #pragma once
 6527: 
 6528: #include "CoreMinimal.h"
 6529: #include "WitchPTCharacterBase.h"
 6530: #include "Item/CauldronAltar.h"
 6531: #include "Item/MechanicsInterface.h"
 6532: #include "Blueprint/UserWidget.h"
 6533: #include "Components/WidgetComponent.h" // Necesitas un Widget Component
 6534: #include "UObject/ConstructorHelpers.h"
 6535: #include "WitchPTCharacter.generated.h"
 6536: 
 6537: class UWitchPTMechanicComponent;
 6538: class ACauldronAltar;
 6539: class ARitualPosition;
 6540: 
 6541: UCLASS()
 6542: class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
 6543: {
 6544: 	GENERATED_BODY()
 6545: 
 6546: public:
 6547: 	// Sets default values for this character's properties
 6548: 	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
 6549: 	virtual void PossessedBy(AController* NewController) override;
 6550: 	virtual void OnRep_PlayerState() override;
 6551: 
 6552: 	virtual void InitAbilityActorInfo() override;
 6553: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
 6554: 	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
 6555: 
 6556: 
 6557: 
 6558: 
 6559: 
 6560: 
 6561: 
 6562: 
 6563: 
 6564: 
 6565: };
 6566: </file>
 6567: 
 6568: <file path="WitchPT.uproject.DotSettings.user">
 6569: <wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
 6570: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AAndroidTargetPlatform_002EBuild_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FProgram_0020Files_003FEpic_0020Games_003FUE_005F5_002E5_003FEngine_003FSource_003FDeveloper_003FAndroid_003FAndroidTargetPlatform_003FAndroidTargetPlatform_002EBuild_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
 6571: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ADuqasom_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FByfowyz_003FDuqasom_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6572: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AFonijyx_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FQukibov_003FFonijyx_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6573: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AHojanux_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FPolafon_003FHojanux_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6574: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AKalevut_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FTivupeq_003FKalevut_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6575: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ALekocyf_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FPuqyhac_003FLekocyf_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6576: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AMeganim_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FBilanag_003FMeganim_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6577: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003Amimalloc_002Dinternal_002Eh_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FProgram_0020Files_003FEpic_0020Games_003FUE_005F5_002E5_003FEngine_003FSource_003FThirdParty_003Fmimalloc_003F2_002E0_002E0_003Finclude_003Fmimalloc_002Dinternal_002Eh/@EntryIndexedValue">ForceIncluded</s:String>
 6578: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ASegivyw_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FFyxodat_003FSegivyw_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6579: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AWyrataj_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FKilamyk_003FWyrataj_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6580: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AZowixan_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FMufytyw_003FZowixan_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6581: 	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=c037d507_002Dd9ad_002D4d6b_002Db7d1_002D94b80280b02c/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" IsActive="True" Name="All tests from Solution" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
 6582:   &lt;Solution /&gt;&#xD;
 6583: &lt;/SessionState&gt;</s:String></wpf:ResourceDictionary>
 6584: </file>
 6585: 
 6586: <file path="Source/WitchPT/Private/Item/RitualPosition.cpp">
 6587: // Fill out your copyright notice in the Description page of Project Settings.
 6588: 
 6589: #include "Item/RitualPosition.h"
 6590: #include "Net/UnrealNetwork.h"
 6591: #include "GameFramework/Character.h"
 6592: #include "Item/RitualAltar.h" // Include the Altar header
 6593: #include "GameplayTagContainer.h" // For tags
 6594: #include "AbilitySystemComponent.h"
 6595: #include "AbilitySystemBlueprintLibrary.h"
 6596: #include "FWitchPTGameplayTags.h"
 6597: #include "GameplayEffect.h"
 6598: #include "GameFramework/CharacterMovementComponent.h"
 6599: #include "Components/CapsuleComponent.h"
 6600: #include "Kismet/GameplayStatics.h"
 6601: #include "Character/Components/WitchPTMechanicComponent.h" // Required for new RPC calls
 6602: 
 6603: // Sets default values
 6604: ARitualPosition::ARitualPosition()
 6605: {
 6606: 	// No need to set up replication here - it's handled by the base class
 6607: }
 6608: 
 6609: void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 6610: {
 6611: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6612: 
 6613: 	DOREPLIFETIME(ARitualPosition, RitualAltar);
 6614: }
 6615: 
 6616: // void ARitualPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
 6617: // {
 6618: // 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6619: //
 6620: // 	DOREPLIFETIME(ARitualPosition, bIsOccupied);
 6621: // 	DOREPLIFETIME(ARitualPosition, OccupyingCharacter);
 6622: // 	// RitualAltar and PositionTag are usually set once and don't need replication unless they can change dynamically
 6623: // }
 6624: 
 6625: void ARitualPosition::BeginPlay()
 6626: {
 6627: 	Super::BeginPlay();
 6628: 
 6629: 	// Try to find the RitualAltar if it wasn't set in the editor
 6630: 
 6631: }
 6632: 
 6633: 
 6634: void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 6635: {
 6636: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 6637: 
 6638: 	// Ritual-specific interaction options
 6639: 
 6640: 	// ACharacter* InteractingCharacterPtr = Cast<ACharacter>(InteractQuery.User);
 6641: 	//
 6642: 	// // If no player is occupying the position, let a player take the position
 6643: 	// if (!IsOccupied() && InteractingCharacterPtr)
 6644: 	// {
 6645: 	// 	OptionBuilder.AddDefaultInteraction(
 6646: 	// 		FText::FromString("Take Position"), // Text for the interaction
 6647: 	// 		[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 6648: 	// 		{
 6649: 	// 			HandleInteraction(InteractingCharacterPtr);
 6650: 	// 		}
 6651: 	// 	);
 6652: 	// }
 6653: 	//
 6654: 	// // Special case: if the character is standing at a position and we're in Inactive state, they can initiate the ritual
 6655: 	// if (IsOccupied() && RitualAltar && GetOccupyingCharacter() == InteractingCharacterPtr)
 6656: 	// {
 6657: 	// 	// Check ritual state
 6658: 	// 	if (RitualAltar->GetCurrentState() == EInteractionState::Inactive)
 6659: 	// 	{
 6660: 	// 		OptionBuilder.AddDefaultInteraction(
 6661: 	// 			FText::FromString("Start Ritual"), // Text for the interaction
 6662: 	// 			[this, InteractingCharacterPtr](const FInteractionExecuteContext& Context)
 6663: 	// 			{
 6664: 	// 				if (RitualAltar)
 6665: 	// 				{
 6666: 	// 					// Cast to the appropriate start ritual function
 6667: 	// 					RitualAltar->StartRitual(InteractingCharacterPtr);
 6668: 	// 				}
 6669: 	// 			}
 6670: 	// 		);
 6671: 	// 	}
 6672: 	// }
 6673: }
 6674: 
 6675: ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
 6676: {
 6677: 	if (RitualAltar)
 6678: 	{
 6679: 		return RitualAltar;
 6680: 	}
 6681: 	return nullptr;
 6682: }
 6683: 
 6684: bool ARitualPosition::IsOccupied_Implementation()
 6685: {
 6686: 	return bIsOccupied;
 6687: }
 6688: 
 6689: 
 6690: void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
 6691: {
 6692: 	Super::HandleInteraction(InteractingCharacter);
 6693: 
 6694: 	if (!InteractingCharacter || !RitualAltar)
 6695: 	{
 6696: 		return;
 6697: 	}
 6698: 
 6699: }
 6700: 
 6701: 
 6702: 
 6703: 
 6704: 
 6705: // void ARitualPosition::SetOccupied(ACharacter* Character)
 6706: // {
 6707: // 	if (!HasAuthority())
 6708: // 	{
 6709: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: no authority"));
 6710: // 		return;
 6711: // 	}
 6712: //
 6713: // 	if (!Character)
 6714: // 	{
 6715: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: invalid character"));
 6716: // 		return;
 6717: // 	}
 6718: //
 6719: // 	if (bIsOccupied)
 6720: // 	{
 6721: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] SetCharacterToPosition failed: position %s already occupied by %s"),
 6722: // 			*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
 6723: // 		return;
 6724: // 	}
 6725: //
 6726: // 	// Set as occupied
 6727: // 	bIsOccupied = true;
 6728: // 	OccupyingCharacter = Character;
 6729: //
 6730: // 	// Force OnReps if needed immediately on server
 6731: // 	OnRep_IsOccupied();
 6732: // 	OnRep_OccupyingCharacter();
 6733: //
 6734: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Occupied by %s"), *GetName(), *Character->GetName());
 6735: // }
 6736: 
 6737: // Called on the Server by the Altar (or potentially a GA)
 6738: // void ARitualPosition::RemoveCharacterFromPosition()
 6739: // {
 6740: // 	if (!HasAuthority())
 6741: // 	{
 6742: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: no authority"));
 6743: // 		return;
 6744: // 	}
 6745: //
 6746: // 	if (!bIsOccupied || !OccupyingCharacter)
 6747: // 	{
 6748: // 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL-POS] RemoveCharacterFromPosition failed: position %s is not occupied"), *GetName());
 6749: // 		return;
 6750: // 	}
 6751: //
 6752: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removing %s from position %s"),
 6753: // 		*OccupyingCharacter->GetName(), *GetName());
 6754: //
 6755: // 	// Remove the occupying position tag from the character
 6756: // 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OccupyingCharacter);
 6757: // 	if (ASC)
 6758: // 	{
 6759: // 		const FWitchPTGameplayTags& gameplayTags = FWitchPTGameplayTags::Get();
 6760: //
 6761: // 		// Remove the State.Ritual.OccupyingPosition tag
 6762: // 		// This would typically be done by removing the GE that applied it
 6763: //
 6764: // 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Removed State.Ritual.OccupyingPosition tag from %s"), *OccupyingCharacter->GetName());
 6765: // 	}
 6766: //
 6767: // 	// Clear state
 6768: // 	bIsOccupied = false;
 6769: // 	ACharacter* OldCharacter = OccupyingCharacter;
 6770: // 	OccupyingCharacter = nullptr;
 6771: //
 6772: // 	// Force OnReps if needed immediately on server
 6773: // 	OnRep_IsOccupied();
 6774: // 	OnRep_OccupyingCharacter();
 6775: //
 6776: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s set to Unoccupied (was %s)"),
 6777: // 		*GetName(), OldCharacter ? *OldCharacter->GetName() : TEXT("nullptr"));
 6778: // }
 6779: //
 6780: // void ARitualPosition::OnRep_IsOccupied()
 6781: // {
 6782: // 	// Client-side reaction to occupancy change
 6783: // 	// Example: Change material, play sound, update UI attached to this position
 6784: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupancy changed to: %s"),
 6785: // 		*GetName(), bIsOccupied ? TEXT("OCCUPIED") : TEXT("VACANT"));
 6786: // }
 6787: //
 6788: // void ARitualPosition::OnRep_OccupyingCharacter()
 6789: // {
 6790: // 	// Client-side reaction to character change
 6791: // 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL-POS] Position %s occupying character changed to: %s"),
 6792: // 		*GetName(), OccupyingCharacter ? *OccupyingCharacter->GetName() : TEXT("None"));
 6793: // }
 6794: </file>
 6795: 
 6796: <file path="Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h">
 6797: // Fill out your copyright notice in the Description page of Project Settings.
 6798: 
 6799: #pragma once
 6800: 
 6801: #include "CoreMinimal.h"
 6802: #include "Components/ActorComponent.h"
 6803: #include "FastArray/FastArrayList.h"
 6804: #include "Net/Serialization/FastArraySerializer.h"
 6805: #include "WitchPTInventoryManagerComponent.generated.h"
 6806: 
 6807: class UInventoryUserWidget;
 6808: class UWitchPTInventoryItemDefinition;
 6809: class UWitchPTInventoryItemInstance;
 6810: class UWitchPTInventoryManagerComponent;
 6811: class UObject;
 6812: struct FFrame;
 6813: struct FNetDeltaSerializeInfo;
 6814: struct FWitchPTInventoryList;
 6815: struct FReplicationFlags;
 6816: 
 6817: /**
 6818:  * Delegate for inventory item events.
 6819:  * Used to broadcast when items are added, removed, or their stack counts change.
 6820:  * @param UWitchPTInventoryItemInstance* - The item instance that was affected
 6821:  */
 6822: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);
 6823: 
 6824: /**
 6825:  * WitchPTInventoryManagerComponent
 6826:  *
 6827:  * A component that manages a player's inventory of items.
 6828:  * Handles adding, removing, and stacking items, as well as replicating inventory state across the network.
 6829:  * Uses a fast array serializer for efficient replication of inventory items.
 6830:  */
 6831: UCLASS(BlueprintType)
 6832: class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
 6833: {
 6834: 	GENERATED_BODY()
 6835: protected:
 6836: 	virtual void BeginPlay() override;
 6837: 
 6838: public:
 6839: 	UFUNCTION(BlueprintCallable)
 6840: 	UInventoryUserWidget* GetInventoryMenuWidget() const { return InventoryMenu; }
 6841: 
 6842: 	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 6843: 
 6844: 
 6845: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
 6846: 	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 6847: 
 6848: 
 6849: 	UFUNCTION(Server, Reliable)
 6850: 	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 6851: 
 6852: 
 6853: 	UFUNCTION(Server, Reliable)
 6854: 	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 6855: 
 6856: 
 6857: 	UFUNCTION(Server, Reliable)
 6858: 	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);
 6859: 
 6860: 
 6861: 	UFUNCTION(Server, Reliable)
 6862: 	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);
 6863: 
 6864: 
 6865: 	UFUNCTION(Server, Reliable)
 6866: 	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);
 6867: 
 6868: 
 6869: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
 6870: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 6871: 
 6872: 
 6873: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
 6874: 	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 6875: 
 6876: 
 6877: 	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 6878: 
 6879: 
 6880: 	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);
 6881: 
 6882: 	// Delegates for inventory events
 6883: 
 6884: 	/** Fired when a new item is added to the inventory */
 6885: 	FOnItemChanged OnItemAdded;
 6886: 
 6887: 	/** Fired when an item's stack count changes */
 6888: 	FOnItemChanged OnItemStackChanged;
 6889: 
 6890: 	/** Fired when an item is removed from the inventory */
 6891: 	FOnItemChanged OnItemRemoved;
 6892: 
 6893: 	//~UObject interface
 6894: 	/**
 6895: 	 * Replicates all inventory item instances as subobjects
 6896: 	 * Required for proper replication of the inventory system
 6897: 	 */
 6898: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 6899: 
 6900: 	/**
 6901: 	 * Called when the component is ready for replication
 6902: 	 * Registers all existing inventory items for replication
 6903: 	 */
 6904: 	virtual void ReadyForReplication() override;
 6905: 	//~End of UObject interface
 6906: 
 6907: private:
 6908: 	/**
 6909: 	 * The replicated list of inventory items
 6910: 	 * Uses a fast array serializer for efficient replication
 6911: 	 */
 6912: 	UPROPERTY(Replicated)
 6913: 	FWitchPTInventoryList InventoryList;
 6914: 	UPROPERTY()
 6915: 	TObjectPtr<UInventoryUserWidget> InventoryMenu;
 6916: 
 6917: 
 6918: 	UPROPERTY(EditAnywhere, Category = "Inventory")
 6919: 	TSubclassOf<UInventoryUserWidget> InventoryMenuClass;
 6920: 
 6921: 	TWeakObjectPtr<APlayerController> OwningController;
 6922: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 6923: 	void ToggleInventoryMenu();
 6924: 	void ConstructInventory();
 6925: 	bool bInventoryMenuOpen;
 6926: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 6927: 	void OpenInventoryMenu();
 6928: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 6929: 	void CloseInventoryMenu();
 6930: };
 6931: </file>
 6932: 
 6933: <file path="Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp">
 6934: // Fill out your copyright notice in the Description page of Project Settings.
 6935: 
 6936: 
 6937: #include "Character/Components/WitchPTMechanicComponent.h"
 6938: #include "Item/CauldronAltar.h"
 6939: #include "Net/UnrealNetwork.h"
 6940: #include "GameFramework/Character.h"
 6941: #include "Item/RitualAltar.h"
 6942: 
 6943: // Sets default values for this component's properties
 6944: UWitchPTMechanicComponent::UWitchPTMechanicComponent()
 6945: {
 6946: 	// Set this component to be initialized when the game starts, and to be ticked every frame.
 6947: 	PrimaryComponentTick.bCanEverTick = true;
 6948: 	SetIsReplicatedByDefault(true);
 6949: }
 6950: 
 6951: void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 6952: {
 6953: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 6954: 
 6955: 	// Agregar propiedades replicadas aquÃ­ si es necesario
 6956: }
 6957: 
 6958: // Called when the game starts
 6959: void UWitchPTMechanicComponent::BeginPlay()
 6960: {
 6961: 	Super::BeginPlay();
 6962: 
 6963: }
 6964: 
 6965: // Called every frame
 6966: void UWitchPTMechanicComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
 6967: {
 6968: 	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
 6969: }
 6970: 
 6971: // --- RITUAL IMPLEMENTATION ---
 6972: void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
 6973: {
 6974: 	if (!TargetAltar)
 6975: 	{
 6976: 		return;
 6977: 	}
 6978: 
 6979: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 6980: 	if (!Character)
 6981: 	{
 6982: 		return;
 6983: 	}
 6984: 
 6985: 	if (Character->HasAuthority())
 6986: 	{
 6987: 		TargetAltar->StartBrewingPotion(Character);
 6988: 	}
 6989: }
 6990: 
 6991: void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
 6992: {
 6993: 	if (!TargetAltar)
 6994: 	{
 6995: 		return;
 6996: 	}
 6997: 
 6998: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 6999: 	if (!Character)
 7000: 	{
 7001: 		return;
 7002: 	}
 7003: 
 7004: 	if (GetOwnerRole() == ROLE_Authority)
 7005: 	{
 7006: 		// Si estamos en el servidor, llamamos directamente
 7007: 		TargetAltar->StartCarryCauldron(Character);
 7008: 	}
 7009: 
 7010: }
 7011: 
 7012: void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 7013: {
 7014: 	if (!TargetAltar)
 7015: 	{
 7016: 		return;
 7017: 	}
 7018: 
 7019: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7020: 	if (!Character)
 7021: 	{
 7022: 		return;
 7023: 	}
 7024: 
 7025: 	if (GetOwnerRole() == ROLE_Authority)
 7026: 	{
 7027: 		// Si estamos en el servidor, llamamos directamente
 7028: 		TargetAltar->StartPlacementPreview(Character);
 7029: 	}
 7030: }
 7031: 
 7032: void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
 7033: {
 7034: 	if (!TargetAltar)
 7035: 	{
 7036: 		return;
 7037: 	}
 7038: 
 7039: 	if (GetOwnerRole() == ROLE_Authority)
 7040: 	{
 7041: 		// Si estamos en el servidor, llamamos directamente
 7042: 		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
 7043: 	}
 7044: }
 7045: 
 7046: void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 7047: {
 7048: 	if (!TargetAltar)
 7049: 	{
 7050: 		return;
 7051: 	}
 7052: 
 7053: 	if (GetOwnerRole() == ROLE_Authority)
 7054: 	{
 7055: 		// Si estamos en el servidor, llamamos directamente
 7056: 		TargetAltar->CancelPlacement();
 7057: 	}
 7058: 
 7059: }
 7060: 
 7061: void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
 7062: {
 7063: 	if (!TargetAltar)
 7064: 	{
 7065: 		return;
 7066: 	}
 7067: 
 7068: 	if (GetOwnerRole() == ROLE_Authority)
 7069: 	{
 7070: 		// Si estamos en el servidor, llamamos directamente
 7071: 		TargetAltar->FinalizePlacement();
 7072: 	}
 7073: 
 7074: }
 7075: 
 7076: void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
 7077: {
 7078: 	if (!TargetCauldron) return;
 7079: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7080: 	if (GetOwnerRole() == ROLE_Authority)
 7081: 	{
 7082: 		TargetCauldron->UnoccupyPosition(Character, nullptr);
 7083: 	}
 7084: }
 7085: 
 7086: void UWitchPTMechanicComponent::RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
 7087: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
 7088: {
 7089: 	if (!TargetAltar) return;
 7090: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7091: 
 7092: 
 7093: 	if(GetOwnerRole() == ROLE_Authority)
 7094: 	{
 7095: 		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
 7096: 	}
 7097: 	else
 7098: 	{
 7099: 		Server_RequestSetBaseIngredient(TargetAltar, IngredientItemDef);
 7100: 	}
 7101: 
 7102: 
 7103: 
 7104: }
 7105: 
 7106: void UWitchPTMechanicComponent::Server_RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
 7107: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
 7108: {
 7109: 	if (!TargetAltar) return;
 7110: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7111: 
 7112: 	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
 7113: 
 7114: }
 7115: 
 7116: void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
 7117: {
 7118: 
 7119: 	if (!TargetAltar) return;
 7120: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7121: 
 7122: 	if (GetOwnerRole() == ROLE_Authority)
 7123: 	{
 7124: 		TargetAltar->OccupyPosition(Character, Position);
 7125: 	}
 7126: 
 7127: }
 7128: 
 7129: void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
 7130: 	ABaseInteractionPosition* Position)
 7131: {
 7132: 	if (!TargetAltar) return;
 7133: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7134: 	if (GetOwnerRole() == ROLE_Authority)
 7135: 	{
 7136: 		TargetAltar->UnoccupyPosition(Character, Position);
 7137: 	}
 7138: 
 7139: }
 7140: 
 7141: void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
 7142: {
 7143: 	if (!TargetAltar) return;
 7144: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7145: 	if (GetOwnerRole() == ROLE_Authority)
 7146: 	{
 7147: 		TargetAltar->StartRitual(Character);
 7148: 	}
 7149: }
 7150: 
 7151: void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
 7152: {
 7153: 	if (!TargetAltar) return;
 7154: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 7155: 	if (GetOwnerRole() == ROLE_Authority)
 7156: 	{
 7157: 		TargetAltar->HandlePlayerInput(Character, InputTag);
 7158: 	}
 7159: }
 7160: </file>
 7161: 
 7162: <file path="Source/WitchPT/Private/Item/BaseInteractableAltar.cpp">
 7163: #include "Item/BaseInteractableAltar.h"
 7164: 
 7165: #include "FWitchPTGameplayTags.h"
 7166: #include "Item/BaseInteractionPosition.h"
 7167: #include "Net/UnrealNetwork.h"
 7168: #include "GameFramework/Character.h"
 7169: #include "Item/RitualAltar.h"
 7170: #include "Item/RitualPosition.h"
 7171: 
 7172: // Sets default values
 7173: ABaseInteractableAltar::ABaseInteractableAltar()
 7174: {
 7175:     // Set this actor to call Tick() every frame
 7176:     PrimaryActorTick.bCanEverTick = true;
 7177: 
 7178:     // Make sure it replicates
 7179:     bReplicates = true;
 7180:     bAlwaysRelevant = true;
 7181: 
 7182:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
 7183:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
 7184:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
 7185:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);
 7186: 
 7187: }
 7188: 
 7189: void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 7190: {
 7191:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 7192: 
 7193:     DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
 7194:     DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
 7195:     DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
 7196:     DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
 7197: 
 7198: }
 7199: 
 7200: // Called when the game starts or when spawned
 7201: void ABaseInteractableAltar::BeginPlay()
 7202: {
 7203:     Super::BeginPlay();
 7204: 
 7205:     // Initialize interaction positions
 7206:     CreateAltarPositions();
 7207: }
 7208: 
 7209: // Called every frame
 7210: void ABaseInteractableAltar::Tick(float DeltaTime)
 7211: {
 7212:     Super::Tick(DeltaTime);
 7213: 
 7214:     // Child classes will implement specific tick behavior
 7215: }
 7216: 
 7217: 
 7218: 
 7219: void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 7220: {
 7221:     if (!Player || !Position || !HasAuthority())
 7222:     {
 7223:         return;
 7224:     }
 7225: 
 7226:     Position->SetOccupied(nullptr);
 7227: 
 7228:     // Remove from participating players if they're not in the list
 7229:     ParticipatingPlayers.Remove(Player);
 7230: 
 7231: }
 7232: void ABaseInteractableAltar::CreateAltarPositions()
 7233: {
 7234:     if (!HasAuthority() || !PositionClass)
 7235:     {
 7236:         return;
 7237:     }
 7238: 
 7239:     // Make sure we have no previous positions
 7240:     DestroyAltarPositions();
 7241: 
 7242:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
 7243:     int positionIndex = 0;
 7244:     // Spawn a CauldronPosition for each transform
 7245:     for (const FTransform& PosTransform : PositionTransforms)
 7246:     {
 7247:         // Transform relative to world space
 7248:         FTransform WorldTransform = PosTransform * GetActorTransform();
 7249: 
 7250:         // Get location and rotation from the transform
 7251:         FVector Location = WorldTransform.GetLocation();
 7252:         FRotator Rotation = WorldTransform.Rotator();
 7253: 
 7254:         // Spawn parameters
 7255:         FActorSpawnParameters SpawnParams;
 7256:         SpawnParams.Owner = this;
 7257:         SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 7258: 
 7259:         // Spawn the brewing position
 7260:         ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
 7261:             PositionClass,
 7262:             Location,
 7263:             Rotation,
 7264:             SpawnParams);
 7265: 
 7266:         if (NewPosition)
 7267:         {
 7268:             // Initialize the position
 7269:             // Note: Implement this method in CauldronPosition if needed
 7270:             // NewPosition->SetCauldronAltar(this);
 7271:             NewPosition->SetPositionTag(TagsPositions[positionIndex]);
 7272:             ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
 7273:             if (RitualPosition)
 7274:             {
 7275:                 RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
 7276:             }
 7277:             positionIndex++;
 7278: 
 7279: 
 7280:             // Add to our array
 7281:             InteractionPositions.Add(NewPosition);
 7282: 
 7283:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
 7284:         }
 7285:     }
 7286: }
 7287: 
 7288: 
 7289: 
 7290: void ABaseInteractableAltar::DestroyAltarPositions()
 7291: {
 7292:     // Only destroy positions on the server
 7293:     if (!HasAuthority())
 7294:     {
 7295:         return;
 7296:     }
 7297: 
 7298:     // Destroy all brewing positions
 7299:     for (ABaseInteractionPosition* Position : InteractionPositions)
 7300:     {
 7301:         if (Position)
 7302:         {
 7303:             Position->Destroy();
 7304:         }
 7305:     }
 7306: 
 7307:     // Clear the array
 7308:     InteractionPositions.Empty();
 7309: 
 7310:     UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
 7311: }
 7312: 
 7313: 
 7314: void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
 7315: {
 7316:     // Update visuals or play sounds based on state change
 7317:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
 7318: }
 7319: 
 7320: void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 7321: {
 7322:     // Play success feedback
 7323:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
 7324: }
 7325: 
 7326: void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 7327: {
 7328:     // Play failure feedback
 7329:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
 7330: }
 7331: 
 7332: 
 7333: 
 7334: void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
 7335: {
 7336:     // Update client-side UI or visuals for players
 7337: }
 7338: 
 7339: 
 7340: void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
 7341: {
 7342:     // Base implementation - to be overridden by child classes
 7343:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
 7344: }
 7345: 
 7346: void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
 7347: {
 7348: 
 7349: }
 7350: 
 7351: void ABaseInteractableAltar::CheckState()
 7352: {
 7353:     // Base implementation - to be overridden by child classes
 7354:     // This would check if the interaction is complete or failed
 7355: }
 7356: 
 7357: void ABaseInteractableAltar::CleanupInteraction()
 7358: {
 7359: 
 7360: }
 7361: 
 7362: void ABaseInteractableAltar::SpawnReward()
 7363: {
 7364: 
 7365: }
 7366: 
 7367: void ABaseInteractableAltar::SpawnDemon()
 7368: {
 7369: 
 7370: }
 7371: 
 7372: bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
 7373: {
 7374:     // Base implementation - to be overridden by child classes
 7375:     // Check if the player is valid and in the participating list
 7376:     return Player && ParticipatingPlayers.Contains(Player);
 7377: }
 7378: </file>
 7379: 
 7380: <file path="Source/WitchPT/Public/Item/BaseInteractableAltar.h">
 7381: // Fill out your copyright notice in the Description page of Project Settings.
 7382: 
 7383: #pragma once
 7384: 
 7385: #include "CoreMinimal.h"
 7386: #include "GameFramework/Actor.h"
 7387: #include "GameplayTagContainer.h" // Include for FGameplayTag
 7388: #include "BaseInteractableAltar.generated.h"
 7389: 
 7390: class UWitchPTUserWidget;
 7391: class ABaseInteractionPosition;
 7392: class ACharacter;
 7393: 
 7394: /**
 7395:  * Base state enum for interaction state
 7396:  */
 7397: UENUM(BlueprintType)
 7398: enum class EInteractionState : uint8
 7399: {
 7400:     Inactive    UMETA(DisplayName = "Inactive"),
 7401:     WaitingForPlayers UMETA(DisplayName = "Waiting For Players"), // At least one player in position
 7402:     Preparing   UMETA(DisplayName = "Preparing"), // Players occupying positions
 7403:     Active      UMETA(DisplayName = "Active"),    // Sequence running
 7404:     Succeeded   UMETA(DisplayName = "Succeeded"),
 7405:     Failed      UMETA(DisplayName = "Failed"),
 7406:     FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
 7407: };
 7408: 
 7409: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
 7410: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);
 7411: 
 7412: // Estructura para mapear un jugador a su tag de posiciÃ³n
 7413: USTRUCT(BlueprintType)
 7414: struct FPlayerPositionTagEntry
 7415: {
 7416:     GENERATED_BODY();
 7417: 
 7418:     UPROPERTY(BlueprintReadWrite)
 7419:     TObjectPtr<ACharacter> Player = nullptr;
 7420: 
 7421:     UPROPERTY(BlueprintReadWrite)
 7422:     FGameplayTag PositionTag;
 7423: };
 7424: 
 7425: /**
 7426:  * Base class for interactive altars/cauldrons that players can interact with
 7427:  */
 7428: UCLASS(Abstract)
 7429: class WITCHPT_API ABaseInteractableAltar : public AActor
 7430: {
 7431:     GENERATED_BODY()
 7432: 
 7433: public:
 7434:     // Sets default values for this actor's properties
 7435:     ABaseInteractableAltar();
 7436:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 7437: 
 7438:     // Current interaction state
 7439:     UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
 7440:     EInteractionState CurrentState = EInteractionState::Inactive;
 7441: 
 7442:     // Transforms defining brewing positions around the cauldron
 7443:     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
 7444:     TArray<FTransform> PositionTransforms;
 7445: 
 7446:     // The class to spawn for brewing positions
 7447:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
 7448:     TSubclassOf<ABaseInteractionPosition> PositionClass;
 7449: 
 7450:     UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
 7451:     TArray<FGameplayTag> TagsPositions;
 7452: 
 7453:     // List of players participating in the interaction
 7454:     UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
 7455:     TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
 7456: 
 7457: 
 7458:     // Positions for interaction
 7459:     UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 7460:     TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;
 7461: 
 7462:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 7463:     TArray<FPlayerPositionTagEntry> PlayerPositionTags;
 7464: 
 7465:     // Basic interaction methods
 7466: 
 7467:     virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
 7468: 
 7469: 
 7470:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 7471:     virtual void CreateAltarPositions();
 7472: 
 7473: 
 7474:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 7475:     virtual void DestroyAltarPositions();
 7476: 
 7477: 
 7478: 
 7479:     // Multicast RPCs for notifications
 7480:     UFUNCTION(NetMulticast, Reliable)
 7481:     void Multicast_OnStateChanged(EInteractionState NewState);
 7482: 
 7483:     UFUNCTION(NetMulticast, Reliable)
 7484:     virtual void Multicast_OnInputSuccess(ACharacter* Character);
 7485: 
 7486:     UFUNCTION(NetMulticast, Reliable)
 7487:     virtual void Multicast_OnInputFailed(ACharacter* Character);
 7488: 
 7489: 
 7490:     // Getters for Blueprint/HUD access
 7491:     UFUNCTION(BlueprintPure, Category = "Interaction")
 7492:     EInteractionState GetCurrentState() const { return CurrentState; }
 7493: 
 7494:     UPROPERTY(EditDefaultsOnly)
 7495:     TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;
 7496: 
 7497: protected:
 7498:     virtual void BeginPlay() override;
 7499:     virtual void Tick(float DeltaTime) override;
 7500: 
 7501: 
 7502: 
 7503:     UFUNCTION()
 7504:     virtual void OnRep_ParticipatingPlayers();
 7505: 
 7506: 
 7507:     // Helper functions
 7508:     virtual void HandleInputSuccess(ACharacter* Player);
 7509:     virtual void HandleInputFailure(ACharacter* Player);
 7510:     virtual void CheckState();
 7511:     virtual void CleanupInteraction();
 7512:     virtual void SpawnReward();
 7513:     virtual void SpawnDemon();
 7514:     virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
 7515: 
 7516: };
 7517: </file>
 7518: 
 7519: <file path="Source/WitchPT/Public/Item/RitualPosition.h">
 7520: // Fill out your copyright notice in the Description page of Project Settings.
 7521: 
 7522: #pragma once
 7523: 
 7524: #include "CoreMinimal.h"
 7525: #include "Item/BaseInteractionPosition.h"
 7526: #include "GameplayTagContainer.h" // Added for FGameplayTag
 7527: #include "MechanicsInterface.h" // For GetRitualAltarActor & IsOccuppied if still needed
 7528: #include "PositionInterface.h"
 7529: #include "RitualPosition.generated.h"
 7530: 
 7531: // Forward Declarations
 7532: class ARitualAltar;
 7533: class UAbilitySystemComponent;
 7534: struct FGameplayAbilitySpec;
 7535: class AController;
 7536: class UGameplayAbility;
 7537: class UBoxComponent;
 7538: class ACharacter;
 7539: 
 7540: UCLASS()
 7541: class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
 7542: {
 7543: 	GENERATED_BODY()
 7544: 
 7545: public:
 7546: 	// Sets default values for this actor's properties
 7547: 	ARitualPosition();
 7548: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 7549: 
 7550: 	//~ Begin AActor Interface
 7551: 	virtual void BeginPlay() override;
 7552: 	//~ End AActor Interface
 7553: 
 7554: 	//~ Begin IInteraction Interface (from AItem)
 7555: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 7556: 	//~ End IInteraction Interface
 7557: 
 7558: 	// Still part of IMechanicsInterface if these are general queries
 7559: 	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
 7560: 
 7561: 
 7562: 	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
 7563: 	virtual bool IsOccupied_Implementation() override;
 7564: 
 7565: protected:
 7566: 	// Reference to the parent altar
 7567: 	UPROPERTY(EditInstanceOnly, Replicated)
 7568: 	TObjectPtr<ARitualAltar> RitualAltar;
 7569: 
 7570: 	// Interaction Logic Helper
 7571: 	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
 7572: 
 7573: private:
 7574: 	// Find the RitualAltar if not set
 7575: 
 7576: };
 7577: </file>
 7578: 
 7579: <file path="Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp">
 7580: // Fill out your copyright notice in the Description page of Project Settings.
 7581: 
 7582: 
 7583: #include "Inventory/WitchPTInventoryManagerComponent.h"
 7584: 
 7585: #include "Blueprint/UserWidget.h"
 7586: #include "Engine/ActorChannel.h"
 7587: #include "Inventory/WitchPTInventoryItemDefinition.h"
 7588: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 7589: #include "Inventory/WitchPTInventoryItemInstance.h"
 7590: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 7591: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 7592: #include "Net/UnrealNetwork.h"
 7593: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 7594: 
 7595: 
 7596: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)
 7597: 
 7598: 
 7599: void UWitchPTInventoryManagerComponent::BeginPlay()
 7600: {
 7601: 	Super::BeginPlay();
 7602: 	ConstructInventory();
 7603: }
 7604: 
 7605: UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
 7606: : Super(ObjectInitializer)
 7607: 	, InventoryList(this)
 7608: {
 7609: 	PrimaryComponentTick.bCanEverTick = false;
 7610: 	SetIsReplicatedByDefault(true);
 7611: 	bReplicateUsingRegisteredSubObjectList = true;
 7612: }
 7613: void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
 7614: {
 7615: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 7616: 
 7617: 	DOREPLIFETIME(ThisClass, InventoryList);
 7618: }
 7619: 
 7620: // --------------- Inventory Manager Component Functions ---------------------------
 7621: 
 7622: void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 7623: {
 7624: 	if(IsValid(ItemDef))
 7625: 	{
 7626: 		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 7627: 		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 7628: 		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 7629: 
 7630: 		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
 7631: 		Server_UpdateItemStackCount(FoundItem, NewStackCount);
 7632: 	}
 7633: }
 7634: 
 7635: void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
 7636: {
 7637: 	if (IsValid(ItemInstance))
 7638: 	{
 7639: 		ItemInstance->SetTotalStackCount(NewCount);
 7640: 
 7641: 		// Marcar la entrada como sucia para la replicaciÃ³n
 7642: 		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 7643: 		{
 7644: 			if (Entry.Instance == ItemInstance)
 7645: 			{
 7646: 				InventoryList.MarkItemDirty(Entry);
 7647: 				break;
 7648: 			}
 7649: 		}
 7650: 
 7651: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 7652: 		{
 7653: 			OnItemStackChanged.Broadcast(ItemInstance);
 7654: 		}
 7655: 	}
 7656: }
 7657: 
 7658: void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
 7659: {
 7660: 	if (IsValid(ItemInstance))
 7661: 	{
 7662: 		// Notificar antes de eliminar para que los listeners puedan usar la informaciÃ³n del item
 7663: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 7664: 		{
 7665: 			OnItemRemoved.Broadcast(ItemInstance);
 7666: 		}
 7667: 
 7668: 		// Eliminar el item de la lista de inventario
 7669: 		InventoryList.RemoveEntry(ItemInstance);
 7670: 
 7671: 		// Desregistrar el subobjeto para la replicaciÃ³n
 7672: 		if (IsUsingRegisteredSubObjectList())
 7673: 		{
 7674: 			RemoveReplicatedSubObject(ItemInstance);
 7675: 		}
 7676: 	}
 7677: }
 7678: 
 7679: void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 7680: {
 7681: 	if (IsValid(ItemInstance))
 7682: 	{
 7683: 		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
 7684: 		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
 7685: 
 7686: 		// Si el nuevo conteo es cero, eliminar el item completamente
 7687: 		if (NewCount <= 0)
 7688: 		{
 7689: 			Server_RemoveItemInstance(ItemInstance);
 7690: 		}
 7691: 		else
 7692: 		{
 7693: 			// Actualizar el conteo de stacks
 7694: 			Server_UpdateItemStackCount(ItemInstance, NewCount);
 7695: 		}
 7696: 	}
 7697: }
 7698: 
 7699: TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
 7700: {
 7701: 	return InventoryList.GetAllItems();
 7702: }
 7703: 
 7704: bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 7705: {
 7706: 	if (!ItemDef)
 7707: 	{
 7708: 		return false;
 7709: 	}
 7710: 
 7711: 	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 7712: 	if (FoundItem)
 7713: 	{
 7714: 		Server_AddStacksToItem(ItemDef);
 7715: 		return false;
 7716: 	}
 7717: 	else
 7718: 	{
 7719: 		Server_AddItem(ItemDef);
 7720: 		return true;
 7721: 	}
 7722: }
 7723: 
 7724: 
 7725: 
 7726: void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 7727: {
 7728: 	UWitchPTInventoryItemInstance* NewItem = nullptr;
 7729: 	if (ItemDef != nullptr)
 7730: 	{
 7731: 		NewItem = InventoryList.AddEntry(ItemDef);
 7732: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 7733: 		{
 7734: 			OnItemAdded.Broadcast(NewItem);
 7735: 		}
 7736: 
 7737: 		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
 7738: 		{
 7739: 			AddReplicatedSubObject(NewItem);
 7740: 		}
 7741: 	}
 7742: 
 7743: }
 7744: 
 7745: 
 7746: 
 7747: // void UWitchPTInventoryManagerComponent::RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance)
 7748: // {
 7749: // 	InventoryList.RemoveEntry(ItemInstance);
 7750: //
 7751: // 	if (ItemInstance && IsUsingRegisteredSubObjectList())
 7752: // 	{
 7753: // 		RemoveReplicatedSubObject(ItemInstance);
 7754: // 	}
 7755: // }
 7756: 
 7757: 
 7758: UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
 7759: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
 7760: {
 7761: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 7762: 	{
 7763: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 7764: 
 7765: 		if (IsValid(Instance))
 7766: 		{
 7767: 			if (Instance->GetItemDef() == ItemDef)
 7768: 			{
 7769: 				return Instance;
 7770: 			}
 7771: 		}
 7772: 	}
 7773: 
 7774: 	return nullptr;
 7775: }
 7776: 
 7777: int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
 7778: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
 7779: {
 7780: 	int32 TotalCount = 0;
 7781: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 7782: 	{
 7783: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 7784: 
 7785: 		if (IsValid(Instance))
 7786: 		{
 7787: 			if (Instance->GetItemDef() == ItemDef)
 7788: 			{
 7789: 				++TotalCount;
 7790: 			}
 7791: 		}
 7792: 	}
 7793: 
 7794: 	return TotalCount;
 7795: }
 7796: 
 7797: bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
 7798: 	int32 NumToConsume)
 7799: {
 7800: 	AActor* OwningActor = GetOwner();
 7801: 	if (!OwningActor || !OwningActor->HasAuthority())
 7802: 	{
 7803: 		return false;
 7804: 	}
 7805: 
 7806: 	//@TODO: N squared right now as there's no acceleration structure
 7807: 	int32 TotalConsumed = 0;
 7808: 	while (TotalConsumed < NumToConsume)
 7809: 	{
 7810: 		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
 7811: 		{
 7812: 			InventoryList.RemoveEntry(Instance);
 7813: 			++TotalConsumed;
 7814: 		}
 7815: 		else
 7816: 		{
 7817: 			return false;
 7818: 		}
 7819: 	}
 7820: 
 7821: 	return TotalConsumed == NumToConsume;
 7822: }
 7823: 
 7824: 
 7825: bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
 7826:                                                             FReplicationFlags* RepFlags)
 7827: {
 7828: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
 7829: 
 7830: 	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 7831: 	{
 7832: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 7833: 
 7834: 		if (Instance && IsValid(Instance))
 7835: 		{
 7836: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
 7837: 		}
 7838: 	}
 7839: 
 7840: 	return WroteSomething;
 7841: }
 7842: 
 7843: void UWitchPTInventoryManagerComponent::ReadyForReplication()
 7844: {
 7845: 	Super::ReadyForReplication();
 7846: 
 7847: 	if (IsUsingRegisteredSubObjectList())
 7848: 	{
 7849: 		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 7850: 		{
 7851: 			UWitchPTInventoryItemInstance* Instance = Entry.Instance;
 7852: 
 7853: 			if (IsValid(Instance))
 7854: 			{
 7855: 				AddReplicatedSubObject(Instance);
 7856: 			}
 7857: 		}
 7858: 	}
 7859: }
 7860: 
 7861: void UWitchPTInventoryManagerComponent::ToggleInventoryMenu()
 7862: {
 7863: 	if (bInventoryMenuOpen)
 7864: 	{
 7865: 		CloseInventoryMenu();
 7866: 	}
 7867: 	else
 7868: 	{
 7869: 		OpenInventoryMenu();
 7870: 	}
 7871: }
 7872: 
 7873: void UWitchPTInventoryManagerComponent::ConstructInventory()
 7874: {
 7875: 	OwningController = Cast<APlayerController>(GetOwner());
 7876: 	checkf(OwningController.IsValid(), TEXT("Inventory Component should have a Player Controller as Owner."))
 7877: 	if (!OwningController->IsLocalController()) return;
 7878: 	InventoryMenu = CreateWidget<UInventoryUserWidget>(OwningController.Get(), InventoryMenuClass);
 7879: 	InventoryMenu->AddToViewport();
 7880: 	CloseInventoryMenu();
 7881: }
 7882: 
 7883: void UWitchPTInventoryManagerComponent::OpenInventoryMenu()
 7884: {
 7885: 	if (!IsValid(InventoryMenu)) return;
 7886: 
 7887: 	InventoryMenu->SetVisibility(ESlateVisibility::Visible);
 7888: 	bInventoryMenuOpen = true;
 7889: 
 7890: 	if (!OwningController.IsValid()) return;
 7891: 
 7892: 	FInputModeGameAndUI InputMode;
 7893: 
 7894: 	OwningController->SetInputMode(InputMode);
 7895: 	OwningController->SetShowMouseCursor(true);
 7896: }
 7897: 
 7898: void UWitchPTInventoryManagerComponent::CloseInventoryMenu()
 7899: {
 7900: 	if (!IsValid(InventoryMenu)) return;
 7901: 
 7902: 	InventoryMenu->SetVisibility(ESlateVisibility::Collapsed);
 7903: 	bInventoryMenuOpen = false;
 7904: 
 7905: 	if (!OwningController.IsValid()) return;
 7906: 
 7907: 	FInputModeGameOnly InputMode;
 7908: 	OwningController->SetInputMode(InputMode);
 7909: 	OwningController->SetShowMouseCursor(false);
 7910: }
 7911: </file>
 7912: 
 7913: <file path="Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h">
 7914: // Fill out your copyright notice in the Description page of Project Settings.
 7915: 
 7916: #pragma once
 7917: 
 7918: #include "CoreMinimal.h"
 7919: #include "GameplayTagContainer.h"
 7920: #include "WitchPTWidgetController.h"
 7921: #include "Item/RitualAltar.h"
 7922: #include "RitualWidgetController.generated.h"
 7923: 
 7924: enum class ERitualInput : uint8;
 7925: class ARitualAltar;
 7926: class ACharacter;
 7927: enum class EInteractionState : uint8;
 7928: 
 7929: // Delegate to notify when the expected input in the ritual changes
 7930: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
 7931: // Delegate to notify when the ready players count changes
 7932: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
 7933: // Delegate to notify when the countdown ticks
 7934: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
 7935: // Delegate to notify when turn data changes
 7936: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
 7937: // Delegate to notify ritual state changes
 7938: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
 7939: // Delegate to notify corruption changes
 7940: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
 7941: // Delegate to notify sequence progress changes
 7942: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
 7943: // Delegate to notify when the ritual is completed
 7944: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);
 7945: 
 7946: /**
 7947:  * Widget Controller to manage the ritual UI
 7948:  */
 7949: UCLASS(BlueprintType, Blueprintable)
 7950: class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
 7951: {
 7952: 	GENERATED_BODY()
 7953: 
 7954: public:
 7955: 	URitualWidgetController();
 7956: 
 7957: 	virtual void BroadcastInitialValues() override;
 7958: 	virtual void BindCallbacksToDependencies() override;
 7959: 
 7960: 	// Method to set the associated ritual altar
 7961: 	UFUNCTION(Category = "Ritual")
 7962: 	void SetRitualAltar(ARitualAltar* InRitualAltar);
 7963: 
 7964: 	// Getter for the current ritual altar
 7965: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 7966: 	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
 7967: 
 7968: 	// Checks if the current player is the active player in the ritual
 7969: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 7970: 	bool IsLocalPlayerActive() const;
 7971: 
 7972: 	// Delegates for widgets to subscribe to
 7973: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7974: 	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;
 7975: 
 7976: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7977: 	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;
 7978: 
 7979: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7980: 	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
 7981: 
 7982: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7983: 	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
 7984: 
 7985: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7986: 	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
 7987: 
 7988: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7989: 	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
 7990: 
 7991: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7992: 	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
 7993: 
 7994: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 7995: 	FOnRitualCompletedSignature_WC OnRitualCompleted;
 7996: 
 7997: protected:
 7998: 	// Reference to the ritual altar that this widget controls
 7999: 	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
 8000: 	TObjectPtr<ARitualAltar> RitualAltar;
 8001: 
 8002: 	// Callbacks for altar changes
 8003: 	UFUNCTION()
 8004: 	void HandleRitualStateChanged(EInteractionState NewState);
 8005: 
 8006: 	UFUNCTION()
 8007: 	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
 8008: 
 8009: 	UFUNCTION()
 8010: 	void HandleCountdownTick(int32 CountdownValue);
 8011: 
 8012: 	UFUNCTION()
 8013: 	void HandleTurnDataChanged(FUIRitualData TurnData);
 8014: 
 8015: 	UFUNCTION()
 8016: 	void HandleCorruptionChanged(float CorruptionPercentage);
 8017: 
 8018: 	UFUNCTION()
 8019: 	void HandleSequenceProgressChanged(float ProgressPercentage);
 8020: 
 8021: 	UFUNCTION()
 8022: 	void HandleRitualCompleted(bool bWasSuccessful);
 8023: 
 8024: private:
 8025: 	// Helper function to determine if local player's turn and update turn data accordingly
 8026: 	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
 8027: };
 8028: </file>
 8029: 
 8030: <file path="Source/WitchPT/Private/Character/WitchPTCharacter.cpp">
 8031: // Fill out your copyright notice in the Description page of Project Settings.
 8032: 
 8033: 
 8034: #include "Character/WitchPTCharacter.h"
 8035: 
 8036: #include "AbilitySystemComponent.h"
 8037: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 8038: #include "AbilitySystem/WitchPTAttributeSet.h"
 8039: #include "Character/Components/WitchPTMechanicComponent.h"
 8040: #include "Item/RitualAltar.h"
 8041: #include "Item/RitualPosition.h"
 8042: #include "Player/WitchPTPlayerController.h"
 8043: #include "Player/WitchPTPlayerState.h"
 8044: #include "UI/HUD/WitchPTHUD.h"
 8045: #include "WitchPT/WitchPT.h"
 8046: 
 8047: 
 8048: // Sets default values
 8049: AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 8050: {
 8051: 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
 8052: 	PrimaryActorTick.bCanEverTick = true;
 8053: 	// Initialize the MechanicComponent
 8054: 	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
 8055: 
 8056: }
 8057: 
 8058: void AWitchPTCharacter::PossessedBy(AController* NewController)
 8059: {
 8060: 	Super::PossessedBy(NewController);
 8061: 
 8062: 	// Init ability actor info for the Server
 8063: 	InitAbilityActorInfo();
 8064: 
 8065: 
 8066: 	// Solo conceder habilidades si AbilitySystemComponent fue inicializado correctamente
 8067: 	if (AbilitySystemComponent)
 8068: 	{
 8069: 		GrantStartupAbilities();
 8070: 		AddStartupEffects();
 8071: 	}
 8072: }
 8073: 
 8074: void AWitchPTCharacter::OnRep_PlayerState()
 8075: {
 8076: 	Super::OnRep_PlayerState();
 8077: 	// Init ability actor info for the Client
 8078: 	InitAbilityActorInfo();
 8079: 	AddStartupEffects();
 8080: }
 8081: 
 8082: void AWitchPTCharacter::InitAbilityActorInfo()
 8083: {
 8084: 	Super::InitAbilityActorInfo();
 8085: 	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
 8086: 
 8087: 	if (!WitchPtPlayerState)
 8088: 	{
 8089: 		return;
 8090: 	}
 8091: 
 8092: 	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);
 8093: 
 8094: 	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
 8095: 	if (!AbilitySystemComponent)
 8096: 	{
 8097: 		return;
 8098: 	}
 8099: 
 8100: 	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
 8101: 	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
 8102: 
 8103: 
 8104: 
 8105: 	/*
 8106: 	* Here we initialize the Overlay because we have all the data we need: the player controller, player state, ability system component and attribute set.
 8107: 	* Also, the HUD is accessible from the player controller.
 8108: 	*/
 8109: 	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
 8110: 	{
 8111: 		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
 8112: 		{
 8113: 			WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
 8114: 		}
 8115: 	}
 8116: 	InitializeDefaultAttributes();
 8117: }
 8118: </file>
 8119: 
 8120: <file path="Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp">
 8121: // Fill out your copyright notice in the Description page of Project Settings.
 8122: 
 8123: #include "UI/WidgetControllers/RitualWidgetController.h"
 8124: #include "Item/RitualAltar.h"
 8125: #include "GameFramework/Character.h"
 8126: #include "GameFramework/PlayerController.h"
 8127: #include "AbilitySystemComponent.h"
 8128: #include "AbilitySystemBlueprintLibrary.h"
 8129: #include "FWitchPTGameplayTags.h"
 8130: 
 8131: URitualWidgetController::URitualWidgetController()
 8132: {
 8133:     // Constructor
 8134: }
 8135: 
 8136: void URitualWidgetController::BroadcastInitialValues()
 8137: {
 8138:     // If we have an altar, broadcast its initial values
 8139:     if (RitualAltar)
 8140:     {
 8141:         // Broadcast current state
 8142:         OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
 8143: 
 8144:         // Broadcast ready players data
 8145:         FRitualReadyPlayersData ReadyPlayersData;
 8146:         ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
 8147:         ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
 8148:         OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 8149: 
 8150:         // Broadcast current turn data (processed for local player)
 8151:         FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
 8152:         FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
 8153:         OnTurnDataChanged.Broadcast(ProcessedTurnData);
 8154: 
 8155:         // Broadcast corruption
 8156:         OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
 8157: 
 8158:         // Broadcast sequence progress
 8159:         OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
 8160:     }
 8161: }
 8162: 
 8163: void URitualWidgetController::BindCallbacksToDependencies()
 8164: {
 8165:     // Bind to altar delegates if it exists
 8166:     if (RitualAltar)
 8167:     {
 8168:         // Bind to all the new dynamic multicast delegates
 8169:         RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
 8170:         RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
 8171:         RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
 8172:         RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
 8173:         RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
 8174:         RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
 8175:         RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
 8176:     }
 8177: }
 8178: 
 8179: void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
 8180: {
 8181:     // Unbind any existing callbacks first
 8182:     if (RitualAltar != nullptr)
 8183:     {
 8184:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 8185:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 8186:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 8187:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 8188:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 8189:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 8190:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 8191:     }
 8192: 
 8193:     // Assign the new altar
 8194:     RitualAltar = InRitualAltar;
 8195: 
 8196:     // Rebind and broadcast if we have a valid altar
 8197:     if (RitualAltar)
 8198:     {
 8199:         BindCallbacksToDependencies();
 8200:         BroadcastInitialValues();
 8201:     }
 8202: }
 8203: 
 8204: bool URitualWidgetController::IsLocalPlayerActive() const
 8205: {
 8206:     if (!RitualAltar || !PlayerController)
 8207:     {
 8208:         return false;
 8209:     }
 8210: 
 8211:     // Get the local character
 8212:     ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
 8213:     if (!LocalCharacter)
 8214:     {
 8215:         return false;
 8216:     }
 8217: 
 8218:     // Check if this character is the active player
 8219:     return RitualAltar->GetCurrentActivePlayer() == LocalCharacter;
 8220: }
 8221: 
 8222: FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
 8223: {
 8224:     FUIRitualData ProcessedData = InTurnData;
 8225: 
 8226:     // Determine if it's the local player's turn
 8227:     ProcessedData.bIsMyTurn = IsLocalPlayerActive();
 8228: 
 8229:     // If it's not the local player's turn, clear sensitive data
 8230:     if (!ProcessedData.bIsMyTurn)
 8231:     {
 8232:         ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
 8233:         ProcessedData.CurrentInputTimeRemaining = 0.0f;
 8234:     }
 8235: 
 8236:     return ProcessedData;
 8237: }
 8238: 
 8239: // ----------------------------------- CALLBACK HANDLERS ---------------------------------------------- //
 8240: 
 8241: void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
 8242: {
 8243:     OnRitualStateChanged.Broadcast(NewState);
 8244: }
 8245: 
 8246: void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
 8247: {
 8248:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 8249: }
 8250: 
 8251: void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
 8252: {
 8253:     OnRitualCountdownTick.Broadcast(CountdownValue);
 8254: }
 8255: 
 8256: void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
 8257: {
 8258:     // Process the turn data for the local player before broadcasting
 8259:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
 8260:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
 8261: 
 8262:     // Also broadcast the expected input separately for backward compatibility
 8263:     if (ProcessedTurnData.bIsMyTurn)
 8264:     {
 8265:         OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
 8266:     }
 8267:     else
 8268:     {
 8269:         OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
 8270:     }
 8271: }
 8272: 
 8273: void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
 8274: {
 8275:     OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
 8276: }
 8277: 
 8278: void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
 8279: {
 8280:     OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
 8281: }
 8282: 
 8283: void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
 8284: {
 8285:     OnRitualCompleted.Broadcast(bWasSuccessful);
 8286: 
 8287:     // Unbind all delegates when ritual is completed to prevent memory leaks
 8288:     if (RitualAltar)
 8289:     {
 8290:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 8291:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 8292:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 8293:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 8294:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 8295:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 8296:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 8297:     }
 8298: }
 8299: </file>
 8300: 
 8301: <file path="Source/WitchPT/Public/FWitchPTGameplayTags.cpp">
 8302: #include "FWitchPTGameplayTags.h"
 8303: 
 8304: #include "GameplayTagsManager.h"
 8305: 
 8306: FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;
 8307: 
 8308: void FWitchPTGameplayTags::InitializeGameplayTags()
 8309: {
 8310: 	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
 8311: 	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
 8312: 	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
 8313: 	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
 8314: 	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
 8315: 	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
 8316: 	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
 8317: 	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
 8318: 	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
 8319: 	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
 8320: 	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
 8321: 	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
 8322: 	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
 8323: 	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
 8324: 	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
 8325: 	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
 8326: 	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));
 8327: 
 8328: 	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
 8329: 	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
 8330: 	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
 8331: 	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
 8332: 
 8333: 	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
 8334: 	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
 8335: 	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
 8336: 	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
 8337: 	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
 8338: 	// Cauldron Abilities
 8339: 	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
 8340: 	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
 8341: 	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
 8342: 	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
 8343: 	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
 8344: 	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
 8345: 	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));
 8346: 
 8347: 	/**
 8348: 	 * Input Tags
 8349: 	 */
 8350: 	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
 8351: 	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
 8352: 	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
 8353: 	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
 8354: 	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
 8355: 	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
 8356: 	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
 8357: 	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
 8358: 	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
 8359: 	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
 8360: 	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
 8361: 	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
 8362: 	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
 8363: 	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
 8364: 	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
 8365: 	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
 8366: 	// Ritual
 8367: 	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
 8368: 	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
 8369: 	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
 8370: 	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));
 8371: 
 8372: 	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
 8373: 	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
 8374: 	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
 8375: 	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));
 8376: 
 8377: 	// --- Ritual Event Tags ---
 8378: 	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
 8379: 	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
 8380: 	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
 8381: 	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
 8382: 	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
 8383: 	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
 8384: 	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));
 8385: 
 8386: 
 8387: 	// Cauldron Tags
 8388: 	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
 8389: 	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
 8390: 	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
 8391: 
 8392: 
 8393: 	// Communication Messages
 8394: 	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));
 8395: 
 8396: 	// --- Items Tags ---
 8397: 	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
 8398: 	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
 8399: 	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
 8400: 	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
 8401: 	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
 8402: 	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
 8403: 	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));
 8404: 
 8405: 	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
 8406: 	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
 8407: 	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
 8408: 	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
 8409: 	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));
 8410: 
 8411: 
 8412: 
 8413: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
 8414: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
 8415: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
 8416: 
 8417: 	// Base Category Tags
 8418: 	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
 8419: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
 8420: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
 8421: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));
 8422: 
 8423: 	// Principal Category Tags
 8424: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
 8425: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
 8426: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
 8427: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));
 8428: 
 8429: 	// Modifier Category Tags
 8430: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
 8431: 
 8432: 	// Modifier Potency Tags
 8433: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
 8434: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
 8435: 
 8436: 	// Modifier Duration Tags
 8437: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
 8438: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
 8439: 
 8440: 	// Modifier Charges Tags
 8441: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
 8442: 
 8443: 	// Modifier Target Tags
 8444: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
 8445: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
 8446: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));
 8447: 
 8448: }
 8449: </file>
 8450: 
 8451: <file path="Source/WitchPT/Public/FWitchPTGameplayTags.h">
 8452: #pragma once
 8453: 
 8454: #include "CoreMinimal.h"
 8455: #include "GameplayTagContainer.h"
 8456: 	/**
 8457: 	 * @brief Singleton accessor to all native GameplayTags.
 8458: 	 *
 8459: 	 * @return Reference to the singleton instance of WitchPTGameplayTags.
 8460: 	 * @note To use the Singleton:
 8461: 	 * const FAuraGameplayTags& AuraGameplayTags = FAuraGameplayTags::Get();
 8462: 	 */
 8463: struct FWitchPTGameplayTags
 8464: {
 8465: public:
 8466: 	static FWitchPTGameplayTags& Get() { return GameplayTags; }
 8467: 	static void InitializeGameplayTags();
 8468: 
 8469: 
 8470: 	/**
 8471: 	* Attributes Primary Tags
 8472: 	*/
 8473: 	FGameplayTag Attributes_Primary_Health;
 8474: 	FGameplayTag Attributes_Primary_Age;
 8475: 	FGameplayTag Attributes_Secondary_Mana;
 8476: 	FGameplayTag Attributes_Secondary_Stamina;
 8477: 	// State Tags
 8478: 	FGameplayTag Character_State_Movement_Sprinting;
 8479: 	FGameplayTag Character_State_Movement_Crouching;
 8480: 	FGameplayTag Character_State_Movement_MovingToPosition;
 8481: 	FGameplayTag Character_State_Dead;
 8482: 	FGameplayTag Character_State_Aim;
 8483: 	FGameplayTag Character_State_Blocked;
 8484: 
 8485: 	FGameplayTag Character_State_Cauldron_InPosition;
 8486: 	FGameplayTag Character_State_Cauldron_Carrying;
 8487: 	FGameplayTag Character_State_Cauldron_Placing;
 8488: 	FGameplayTag Character_State_Cauldron_InGame;
 8489: 	FGameplayTag Character_State_Cauldron_BrewingPotion;
 8490: 
 8491: 	FGameplayTag Character_State_Ritual_InPosition;
 8492: 	FGameplayTag Character_State_Ritual_InGame;
 8493: 
 8494: 	// Ability Tags
 8495: 	FGameplayTag Ability_Interact;
 8496: 	FGameplayTag Ability_Sprint;
 8497: 	FGameplayTag Ability_Jump;
 8498: 	FGameplayTag Ability_Crouch;
 8499: 	FGameplayTag Ability_Ritual_GoToPosition;
 8500: 	FGameplayTag Ability_Ritual_ParticipatingInRitual;
 8501: 	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
 8502: 	FGameplayTag Ability_Ritual_Start;
 8503: 	FGameplayTag Ability_Ritual_SendInput;
 8504: 
 8505: 
 8506: 
 8507: 
 8508: 
 8509: 
 8510: 	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
 8511: 	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
 8512: 	FGameplayTag Ability_Cauldron_CarryingCauldron;
 8513: 	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
 8514: 	FGameplayTag Ability_Cauldron_SetInPlace;
 8515: 	FGameplayTag Ability_Cauldron_CancelSetInPlace;
 8516: 
 8517: 
 8518: 
 8519: 
 8520: 
 8521: 
 8522: 	// Input Tags
 8523: 	FGameplayTag InputTag_LMB;
 8524: 	FGameplayTag InputTag_RMB;
 8525: 	FGameplayTag InputTag_1;
 8526: 	FGameplayTag InputTag_2;
 8527: 	FGameplayTag InputTag_3;
 8528: 	FGameplayTag InputTag_4;
 8529: 	FGameplayTag InputTag_5;
 8530: 	FGameplayTag InputTag_6;
 8531: 	FGameplayTag InputTag_7;
 8532: 	FGameplayTag InputTag_8;
 8533: 	FGameplayTag InputTag_9;
 8534: 	FGameplayTag InputTag_0;
 8535: 	FGameplayTag InputTag_Ctrl;
 8536: 	FGameplayTag InputTag_Alt;
 8537: 	FGameplayTag InputTag_Shift;
 8538: 	FGameplayTag InputTag_Tab;
 8539: 
 8540: 
 8541: 	// --- Ritual Position Tags ---
 8542: 	FGameplayTag Ritual_Position_1;
 8543: 	FGameplayTag Ritual_Position_2;
 8544: 	FGameplayTag Ritual_Position_3;
 8545: 	FGameplayTag Ritual_Position_4;
 8546: 
 8547: 	FGameplayTag Ritual_Input_Up;
 8548: 	FGameplayTag Ritual_Input_Down;
 8549: 	FGameplayTag Ritual_Input_Left;
 8550: 	FGameplayTag Ritual_Input_Right;
 8551: 
 8552: 	// --- Ritual Event Tags ---
 8553: 	FGameplayTag Event_Ritual_InputSuccess;
 8554: 	FGameplayTag Event_Ritual_InputFailure;
 8555: 	FGameplayTag Event_Ritual_SequenceSuccess;
 8556: 	FGameplayTag Event_Ritual_SequenceFailure;
 8557: 	FGameplayTag Event_Ritual_CatastrophicFailure;
 8558: 
 8559: 
 8560: 
 8561: 	// --- Event Tags ---
 8562: 	FGameplayTag Event_Ritual_InputReceived;
 8563: 	FGameplayTag Event_Ritual_TurnAdvanced;
 8564: 	FGameplayTag Event_Ritual_SequenceFail;
 8565: 	FGameplayTag Event_Ritual_CatastrophicFail;
 8566: 
 8567: 	// Cauldron Tags
 8568: 	FGameplayTag Cauldron_State_Empty;
 8569: 	FGameplayTag Cauldron_State_Full;
 8570: 	FGameplayTag Cauldron_State_PotionReady;
 8571: 	FGameplayTag Event_Cauldron_CharacterPositioned;
 8572: 
 8573: 
 8574: 	// Communication tags
 8575: 	FGameplayTag Communication_Message;
 8576: 
 8577: 	// --- Items Tags ---
 8578: 	FGameplayTag Item;
 8579: 	FGameplayTag Item_Consumable;
 8580: 	FGameplayTag Item_Consumable_Potion;
 8581: 	FGameplayTag Item_Consumable_Potion_Tier_0;
 8582: 	FGameplayTag Item_Consumable_Potion_Tier_1;
 8583: 	FGameplayTag Item_Consumable_Potion_Tier_2;
 8584: 	FGameplayTag Item_Consumable_Potion_Tier_3;
 8585: 
 8586: 	FGameplayTag Item_Consumable_Ingredient;
 8587: 	FGameplayTag Item_Consumable_Ingredient_Tier_0;
 8588: 	FGameplayTag Item_Consumable_Ingredient_Tier_1;
 8589: 	FGameplayTag Item_Consumable_Ingredient_Tier_2;
 8590: 	FGameplayTag Item_Consumable_Ingredient_Tier_3;
 8591: 
 8592: 
 8593: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
 8594: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
 8595: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;
 8596: 
 8597: 	FGameplayTag Item_Consumable_Ingredient_Category_Base;
 8598: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
 8599: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
 8600: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
 8601: 
 8602: 
 8603: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
 8604: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
 8605: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
 8606: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;
 8607: 
 8608: 
 8609: 
 8610: 
 8611: 
 8612: 
 8613: 	// --------------------------- Modifier Tags ---------------------------
 8614: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
 8615: 	// --------------------------- Modifier Potency Tags ---------------------------
 8616: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
 8617: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
 8618: 	// --------------------------- Modifier Duration Tags ---------------------------
 8619: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
 8620: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
 8621: 	// --------------------------- Modifier Charges Tags ---------------------------
 8622: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
 8623: 	// --------------------------- Modifier Application Tags ---------------------------
 8624: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
 8625: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
 8626: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
 8627: 
 8628: 
 8629: 
 8630: 
 8631: 
 8632: private:
 8633: 	static FWitchPTGameplayTags GameplayTags;
 8634: 
 8635: 
 8636: };
 8637: </file>
 8638: 
 8639: <file path="Source/WitchPT/Public/Item/MechanicsInterface.h">
 8640: // Fill out your copyright notice in the Description page of Project Settings.
 8641: 
 8642: #pragma once
 8643: 
 8644: #include "CoreMinimal.h"
 8645: #include "GameplayTagContainer.h"
 8646: #include "UObject/Interface.h"
 8647: #include "MechanicsInterface.generated.h"
 8648: 
 8649: class UWitchPTInventoryItemDefinition;
 8650: class UWitchPTInventoryItemInstance;
 8651: class ABaseInteractionPosition;
 8652: class ACauldronAltar;
 8653: class ARitualPosition;
 8654: class ARitualAltar;
 8655: class ACharacter;
 8656: 
 8657: // This class does not need to be modified.
 8658: UINTERFACE(MinimalAPI)
 8659: class UMechanicsInterface : public UInterface
 8660: {
 8661: 	GENERATED_BODY()
 8662: };
 8663: 
 8664: /**
 8665:  *
 8666:  */
 8667: class WITCHPT_API IMechanicsInterface
 8668: {
 8669: 	GENERATED_BODY()
 8670: 
 8671: 	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
 8672: 
 8673: public:
 8674: 	// ------------------------------------ RITUAL IMPLEMENTATION ---------------------------------
 8675: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
 8676: 	void RequestStartRitual(ARitualAltar* TargetAltar);
 8677: 
 8678: 
 8679: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
 8680: 	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);
 8681: 
 8682: 
 8683: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
 8684: 	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
 8685: 
 8686: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
 8687: 	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
 8688: 
 8689: 	// ----------------------------------- CAULDRON IMPLEMENTATION ---------------------------------
 8690: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8691: 	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);
 8692: 
 8693: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8694: 	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);
 8695: 
 8696: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8697: 	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);
 8698: 
 8699: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8700: 	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);
 8701: 
 8702: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8703: 	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);
 8704: 
 8705: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8706: 	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);
 8707: 
 8708: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8709: 	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);
 8710: 
 8711: 	// ----------------------------------- CAULDRON INGREDIENT IMPLEMENTATION ---------------------------------
 8712: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
 8713: 	void RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
 8714: 
 8715: 
 8716: 	// General Queries that might be implemented by positions or other interactables
 8717: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
 8718: 	ARitualAltar* GetRitualAltarActor() const;
 8719: 
 8720: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
 8721: 	bool IsOccuppied() const;
 8722: 
 8723: };
 8724: </file>
 8725: 
 8726: <file path="Source/WitchPT/Public/Player/WitchPTPlayerController.h">
 8727: // Fill out your copyright notice in the Description page of Project Settings.
 8728: 
 8729: #pragma once
 8730: 
 8731: #include "CoreMinimal.h"
 8732: #include "GameFramework/PlayerController.h"
 8733: #include "UI/Widgets/PointerWidget.h"
 8734: #include "WitchPTPlayerController.generated.h"
 8735: 
 8736: class UCauldronUserWidget;
 8737: class ABaseInteractableAltar;
 8738: class ACauldronAltar;
 8739: class ARitualAltar;
 8740: class UWitchPTInventoryManagerComponent;
 8741: struct FGameplayTag;
 8742: class UWitchPTAbilitySystemComponent;
 8743: class UWitchPTInputConfig;
 8744: struct FInputActionValue;
 8745: class UInputAction;
 8746: class UInputMappingContext;
 8747: /**
 8748:  *
 8749:  */
 8750: UCLASS()
 8751: class WITCHPT_API AWitchPTPlayerController : public APlayerController
 8752: {
 8753: 	GENERATED_BODY()
 8754: public:
 8755: 	AWitchPTPlayerController();
 8756: 	virtual void PlayerTick(float DeltaTime) override;
 8757: 	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
 8758: 	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
 8759: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 8760: 
 8761: 	void LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar);
 8762: 	bool HasRitualWidgetInitialized(ABaseInteractableAltar* Altar);
 8763: 	void LocalToggleCauldronMenu();
 8764: 
 8765: 
 8766: 
 8767: 
 8768: 	UFUNCTION(Client, Reliable)
 8769: 	void Client_InitializeRitualUserWidget(ABaseInteractableAltar* Altar);
 8770: 
 8771: 	UFUNCTION(Client, Reliable)
 8772: 	void Client_ToggleCauldronMenu();
 8773: 
 8774: 
 8775: 	UPROPERTY(Replicated, VisibleAnywhere)
 8776: 	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
 8777: 	UPROPERTY()
 8778: 	TObjectPtr<UPointerWidget> HUDWidget;
 8779: 	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
 8780: protected:
 8781: 	virtual void BeginPlay() override;
 8782: 	virtual void SetupInputComponent() override;
 8783: 
 8784: 	// Actions
 8785: 	UPROPERTY(EditAnywhere, Category="Input")
 8786: 	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
 8787: 	UPROPERTY(EditAnywhere, Category="Input")
 8788: 	TObjectPtr<UInputAction> MoveAction;
 8789: 	UPROPERTY(EditAnywhere, Category= "Input")
 8790: 	TObjectPtr<UInputAction> LookAction;
 8791: 	//InputConfig
 8792: 	UPROPERTY(EditDefaultsOnly, Category= "Input")
 8793: 	TObjectPtr<UWitchPTInputConfig> InputConfig;
 8794: 
 8795: 	// Ability System Component
 8796: 	UPROPERTY()
 8797: 	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;
 8798: 
 8799: 	UWitchPTAbilitySystemComponent* GetASC();
 8800: 
 8801: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 8802: 	TSubclassOf<UPointerWidget> HUDWidgetClass;
 8803: 
 8804: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 8805: 	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;
 8806: 
 8807: 
 8808: 
 8809: private:
 8810: 
 8811: 	void Move(const FInputActionValue& InputActionValue);
 8812: 
 8813: 	void Look(const FInputActionValue& Value);
 8814: 
 8815: 	void AbilityInputTagPressed(FGameplayTag InputTag);
 8816: 	void AbilityInputTagReleased(FGameplayTag InputTag);
 8817: 	void AbilityInputTagHeld(FGameplayTag InputTag);
 8818: 
 8819: 	void ConstructCauldronWidget();
 8820: 
 8821: 	void CreateHUDWidget();
 8822: 	void OpenCauldronMenu();
 8823: 	void CloseCauldronMenu();
 8824: 	bool bCauldronMenuOpen = false;
 8825: 
 8826: 	// Array de altares para los que ya se ha creado un widget
 8827: 	UPROPERTY()
 8828: 	TObjectPtr<ARitualAltar> ThisRitualAltarHasWidget;
 8829: 	UPROPERTY()
 8830: 	TObjectPtr<UCauldronUserWidget> CauldronAltarMenu;
 8831: 
 8832: };
 8833: </file>
 8834: 
 8835: <file path="Source/WitchPT/Private/Player/WitchPTPlayerController.cpp">
 8836: // Fill out your copyright notice in the Description page of Project Settings.
 8837: 
 8838: 
 8839: #include "Player/WitchPTPlayerController.h"
 8840: 
 8841: #include "AbilitySystemBlueprintLibrary.h"
 8842: #include "EnhancedInputSubsystems.h"
 8843: #include "InputActionValue.h"
 8844: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 8845: #include "Blueprint/UserWidget.h"
 8846: #include "Input/WitchPTInputComponent.h"
 8847: #include "Inventory/WitchPTInventoryManagerComponent.h"
 8848: #include "Item/CauldronAltar.h"
 8849: #include "Item/RitualAltar.h"
 8850: #include "Item/Ritual/RitualFunctionLibrary.h"
 8851: #include "Kismet/GameplayStatics.h"
 8852: #include "Net/UnrealNetwork.h"
 8853: #include "UI/HUD/WitchPTHUD.h"
 8854: #include "UI/WidgetControllers/CauldronWidgetController.h"
 8855: #include "UI/WidgetControllers/RitualWidgetController.h"
 8856: #include "UI/Widgets/CauldronUserWidget.h"
 8857: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 8858: #include "WitchPT/WitchPT.h"
 8859: 
 8860: AWitchPTPlayerController::AWitchPTPlayerController()
 8861: {
 8862: 	bReplicates = true;
 8863: 	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
 8864: 	InventoryManager->SetIsReplicated(true);
 8865: 
 8866: 
 8867: }
 8868: 
 8869: void AWitchPTPlayerController::PlayerTick(float DeltaTime)
 8870: {
 8871: 	Super::PlayerTick(DeltaTime);
 8872: }
 8873: 
 8874: void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
 8875: {
 8876: 	Super::PreProcessInput(DeltaTime, bGamePaused);
 8877: }
 8878: 
 8879: void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
 8880: {
 8881: 	if (WitchPtAbilitySystemComponent)
 8882: 	{
 8883: 		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
 8884: 	}
 8885: 	Super::PostProcessInput(DeltaTime, bGamePaused);
 8886: }
 8887: 
 8888: void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 8889: {
 8890: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 8891: 	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
 8892: }
 8893: void AWitchPTPlayerController::LocalToggleCauldronMenu()
 8894: {
 8895: 
 8896: 	if (bCauldronMenuOpen)
 8897: 	{
 8898: 		CloseCauldronMenu();
 8899: 	}
 8900: 	else
 8901: 	{
 8902: 		OpenCauldronMenu();
 8903: 	}
 8904: }
 8905: 
 8906: void AWitchPTPlayerController::LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar)
 8907: {
 8908: 	if (!Altar || !Altar->AltarUserWidgetClass || !IsLocalController())
 8909: 	{
 8910: 		UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Invalid altar or widget class!"));
 8911: 		return;
 8912: 	}
 8913: 
 8914: 	if (Altar->IsA<ARitualAltar>())
 8915: 	{
 8916: 		// Cast the altar to a ritual altar
 8917: 		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
 8918: 
 8919: 		if (!ThisRitualAltarHasWidget || ThisRitualAltarHasWidget != RitualAltar)
 8920: 		{
 8921: 			ThisRitualAltarHasWidget = RitualAltar;
 8922: 		}
 8923: 
 8924: 		URitualUserWidget* RitualUserWidget = CreateWidget<URitualUserWidget>(this, Altar->AltarUserWidgetClass);
 8925: 
 8926: 		if (IsValid(RitualUserWidget))
 8927: 		{
 8928: 			// Get or create the ritual widget controller
 8929: 			URitualWidgetController* RitualWidgetController = URitualFunctionLibrary::SetRitualWidgetController(this);
 8930: 
 8931: 			if (!RitualWidgetController)
 8932: 			{
 8933: 				UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Failed to get or create RitualWidgetController!"));
 8934: 				return;
 8935: 			}
 8936: 
 8937: 			RitualWidgetController->SetRitualAltar(RitualAltar);
 8938: 			// Set widget controller reference for the user widget
 8939: 			RitualUserWidget->SetWidgetController(RitualWidgetController);
 8940: 
 8941: 
 8942: 			// Add the widget to viewport
 8943: 			RitualUserWidget->AddToViewport();
 8944: 		}
 8945: 
 8946: 	}
 8947: 
 8948: 
 8949: }
 8950: 
 8951: bool AWitchPTPlayerController::HasRitualWidgetInitialized(ABaseInteractableAltar* Altar)
 8952: {
 8953: 	if (Altar->IsA<ARitualAltar>())
 8954: 	{
 8955: 		return ThisRitualAltarHasWidget == Altar;
 8956: 	}
 8957: 	return false;
 8958: }
 8959: 
 8960: void AWitchPTPlayerController::OpenCauldronMenu()
 8961: {
 8962: 	if (!IsValid(CauldronAltarMenu)) return;
 8963: 
 8964: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Visible);
 8965: 	bCauldronMenuOpen = true;
 8966: 
 8967: 	FInputModeGameAndUI InputMode;
 8968: 
 8969: 	SetInputMode(InputMode);
 8970: 	SetShowMouseCursor(true);
 8971: }
 8972: 
 8973: void AWitchPTPlayerController::CloseCauldronMenu()
 8974: {
 8975: 	if (!IsValid(CauldronAltarMenu)) return;
 8976: 
 8977: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Collapsed);
 8978: 	bCauldronMenuOpen = false;
 8979: 
 8980: 
 8981: 
 8982: 	FInputModeGameOnly InputMode;
 8983: 	SetInputMode(InputMode);
 8984: 	SetShowMouseCursor(false);
 8985: }
 8986: 
 8987: void AWitchPTPlayerController::Client_InitializeRitualUserWidget_Implementation(ABaseInteractableAltar* Altar)
 8988: {
 8989: 	if (!HasRitualWidgetInitialized(Altar))
 8990: 	{
 8991: 		LocalInitializeRitualUserWidget(Altar);
 8992: 	}
 8993: }
 8994: 
 8995: void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
 8996: {
 8997: 	LocalToggleCauldronMenu();
 8998: }
 8999: void AWitchPTPlayerController::BeginPlay()
 9000: {
 9001: 	Super::BeginPlay();
 9002: 	check(WitchPtiInputMappingContext)
 9003: 	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
 9004: 	if (Subsystem)
 9005: 	{
 9006: 		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
 9007: 	}
 9008: 	CreateHUDWidget();
 9009: 	ConstructCauldronWidget();
 9010: }
 9011: 
 9012: void AWitchPTPlayerController::SetupInputComponent()
 9013: {
 9014: 	Super::SetupInputComponent();
 9015: 	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
 9016: 	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
 9017: 	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
 9018: 	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
 9019: 
 9020: }
 9021: 
 9022: void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
 9023: {
 9024: 	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
 9025: 	const FRotator Rotation = GetControlRotation();
 9026: 	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);
 9027: 
 9028: 	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
 9029: 	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
 9030: 
 9031: 	if (APawn* ControlledPawn = GetPawn<APawn>())
 9032: 	{
 9033: 		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
 9034: 		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
 9035: 	}
 9036: 
 9037: }
 9038: 
 9039: void AWitchPTPlayerController::Look(const FInputActionValue& Value)
 9040: {
 9041: 	// input is a Vector2D
 9042: 	FVector2D LookAxisVector = Value.Get<FVector2D>();
 9043: 
 9044: 	if (APawn* ControlledPawn = GetPawn<APawn>())
 9045: 	{
 9046: 		// add yaw and pitch input to controller
 9047: 		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
 9048: 		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
 9049: 	}
 9050: }
 9051: 
 9052: void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
 9053: {
 9054: 	if (GetASC())
 9055: 	{
 9056: 		GetASC()->AbilityInputTagPressed(InputTag);
 9057: 	}
 9058: }
 9059: 
 9060: void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
 9061: {
 9062: 	if (GetASC())
 9063: 	{
 9064: 		GetASC()->AbilityInputTagReleased(InputTag);
 9065: 	}
 9066: }
 9067: 
 9068: void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
 9069: {
 9070: 	if (GetASC())
 9071: 	{
 9072: 		GetASC()->AbilityInputTagHeld(InputTag);
 9073: 	}
 9074: }
 9075: 
 9076: void AWitchPTPlayerController::ConstructCauldronWidget()
 9077: {
 9078: 	if (!this->IsLocalController()) return;
 9079: 	CauldronAltarMenu = CreateWidget<UCauldronUserWidget>(this, CauldronAltarWidgetClass);
 9080: 	UCauldronWidgetController* CauldronWidgetController = URitualFunctionLibrary::SetCauldronWidgetController(this);
 9081: 	CauldronAltarMenu->SetWidgetController(CauldronWidgetController);
 9082: 	// Find ACauldronAltar in the level
 9083: 	ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass()));
 9084: 	if (CauldronAltar)
 9085: 	{
 9086: 		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
 9087: 	}
 9088: 	CauldronWidgetController->BindCallbacksToDependencies();
 9089: 	CauldronAltarMenu->AddToViewport();
 9090: 	CloseCauldronMenu();
 9091: }
 9092: 
 9093: void AWitchPTPlayerController::CreateHUDWidget()
 9094: {
 9095: 	if (!IsLocalController()) return;
 9096: 	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
 9097: 	if (IsValid(HUDWidget))
 9098: 	{
 9099: 		HUDWidget->AddToViewport();
 9100: 	}
 9101: }
 9102: 
 9103: 
 9104: UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
 9105: {
 9106: 	if (WitchPtAbilitySystemComponent == nullptr)
 9107: 	{
 9108: 		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
 9109: 	}
 9110: 	return WitchPtAbilitySystemComponent;
 9111: }
 9112: </file>
 9113: 
 9114: <file path="Config/DefaultEngine.ini">
 9115: [/Script/EngineSettings.GameMapsSettings]
 9116: GameDefaultMap=/Game/Blueprints/Maps/Default.Default
 9117: EditorStartupMap=/Game/Blueprints/Maps/Default.Default
 9118: 
 9119: [/Script/Engine.RendererSettings]
 9120: r.AllowStaticLighting=False
 9121: 
 9122: r.GenerateMeshDistanceFields=True
 9123: 
 9124: r.DynamicGlobalIlluminationMethod=0
 9125: 
 9126: r.ReflectionMethod=0
 9127: 
 9128: r.SkinCache.CompileShaders=True
 9129: 
 9130: r.RayTracing=True
 9131: 
 9132: r.Shadow.Virtual.Enable=1
 9133: 
 9134: r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True
 9135: 
 9136: r.DefaultFeature.LocalExposure.HighlightContrastScale=0.8
 9137: 
 9138: r.DefaultFeature.LocalExposure.ShadowContrastScale=0.8
 9139: 
 9140: [/Script/WindowsTargetPlatform.WindowsTargetSettings]
 9141: DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
 9142: DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
 9143: -D3D12TargetedShaderFormats=PCD3D_SM5
 9144: +D3D12TargetedShaderFormats=PCD3D_SM6
 9145: -D3D11TargetedShaderFormats=PCD3D_SM5
 9146: +D3D11TargetedShaderFormats=PCD3D_SM5
 9147: Compiler=Default
 9148: AudioSampleRate=48000
 9149: AudioCallbackBufferFrameSize=1024
 9150: AudioNumBuffersToEnqueue=1
 9151: AudioMaxChannels=0
 9152: AudioNumSourceWorkers=4
 9153: SpatializationPlugin=
 9154: SourceDataOverridePlugin=
 9155: ReverbPlugin=
 9156: OcclusionPlugin=
 9157: CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
 9158: CacheSizeKB=65536
 9159: MaxChunkSizeOverrideKB=0
 9160: bResampleForDevice=False
 9161: MaxSampleRate=48000.000000
 9162: HighSampleRate=32000.000000
 9163: MedSampleRate=24000.000000
 9164: LowSampleRate=12000.000000
 9165: MinSampleRate=8000.000000
 9166: CompressionQualityModifier=1.000000
 9167: AutoStreamingThreshold=0.000000
 9168: SoundCueCookQualityIndex=-1
 9169: 
 9170: [/Script/LinuxTargetPlatform.LinuxTargetSettings]
 9171: -TargetedRHIs=SF_VULKAN_SM5
 9172: +TargetedRHIs=SF_VULKAN_SM6
 9173: 
 9174: [/Script/HardwareTargeting.HardwareTargetingSettings]
 9175: TargetedHardwareClass=Desktop
 9176: AppliedTargetedHardwareClass=Desktop
 9177: DefaultGraphicsPerformance=Maximum
 9178: AppliedDefaultGraphicsPerformance=Maximum
 9179: 
 9180: [/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
 9181: CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'
 9182: 
 9183: [/Script/Engine.UserInterfaceSettings]
 9184: bAuthorizeAutomaticWidgetVariableCreation=False
 9185: FontDPIPreset=Standard
 9186: FontDPI=72
 9187: 
 9188: [/Script/Engine.Engine]
 9189: +ActiveGameNameRedirects=(OldGameName="TP_BlankBP",NewGameName="/Script/WitchPT")
 9190: +ActiveGameNameRedirects=(OldGameName="/Script/TP_BlankBP",NewGameName="/Script/WitchPT")
 9191: AssetManagerClassName=/Script/WitchPT.WitchPTAssetManager
 9192: 
 9193: [/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
 9194: bEnablePlugin=True
 9195: bAllowNetworkConnection=True
 9196: SecurityToken=E3BD176F4C42D74EBD24B5984F1936CC
 9197: bIncludeInShipping=False
 9198: bAllowExternalStartInShipping=False
 9199: bCompileAFSProject=False
 9200: bUseCompression=False
 9201: bLogFiles=False
 9202: bReportStats=False
 9203: ConnectionType=USBOnly
 9204: bUseManualIPAddress=False
 9205: ManualIPAddress=
 9206: 
 9207: 
 9208: [CoreRedirects]
 9209: +ClassRedirects=(OldName="/Script/WitchPT.WitchPT",NewName="/Script/WitchPT.WitchPTPlayerState")
 9210: +EnumRedirects=(OldName="/Script/WitchPT.ERitualState",NewName="/Script/WitchPT.EInteractionState")
 9211: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.OnPressInteraction",NewName="/Script/WitchPT.CauldronAltar.StartBrewingPotions")
 9212: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.OnHoldInteraction",NewName="/Script/WitchPT.CauldronAltar.StartCarryCauldron")
 9213: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.StartBrewingPotions",NewName="/Script/WitchPT.CauldronAltar.StartBrewingPotion")
 9214: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.BrewingPositionTransforms",NewName="/Script/WitchPT.CauldronAltar.PositionTransforms")
 9215: +PropertyRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.CauldronPositionClass",NewName="/Script/WitchPT.BaseInteractableAltar.PositionClass")
 9216: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.CreateBrewingPositions",NewName="/Script/WitchPT.BaseInteractableAltar.CreateAltarPositions")
 9217: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.DestroyBrewingPositions",NewName="/Script/WitchPT.BaseInteractableAltar.DestroyAltarPositions")
 9218: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputFailed",NewName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputFailed")
 9219: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputSuccess",NewName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputSuccess")
 9220: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputSuccess",NewName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputSuccess")
 9221: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputFailed",NewName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputFailed")
 9222: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.AttachToCharacter",NewName="/Script/WitchPT.CauldronAltar.Server_AttachToCharacter")
 9223: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.DetachFromCharacter",NewName="/Script/WitchPT.CauldronAltar.Server_DetachFromCharacter")
 9224: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.StartPlacementPreview",NewName="/Script/WitchPT.CauldronAltar.Server_StartPlacementPreview")
 9225: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.FinalizePlacement",NewName="/Script/WitchPT.CauldronAltar.Server_FinalizePlacement")
 9226: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.CancelPlacement",NewName="/Script/WitchPT.CauldronAltar.Server_CancelPlacement")
 9227: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.PositionCharacterForBrewing",NewName="/Script/WitchPT.CauldronAltar.Server_PositionCharacterForBrewing")
 9228: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Server_AttachToCharacter",NewName="/Script/WitchPT.CauldronAltar.AttachToCharacter")
 9229: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Server_PositionCharacterForBrewing",NewName="/Script/WitchPT.CauldronAltar.PositionCharacterForBrewing")
 9230: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Multicas_StartBrewingPotion",NewName="/Script/WitchPT.CauldronAltar.Multicast_StartBrewingPotion")
 9231: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTUserWidget.WidgetControllerSet",NewName="/Script/WitchPT.WitchPTUserWidget.OnWidgetControllerSet")
 9232: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTOverlayWidgetController",NewName="/Script/WitchPT.OverlayWidgetController")
 9233: +ClassRedirects=(OldName="/Script/WitchPT.OverlayWidgetController",NewName="/Script/WitchPT.OverlayWidgetController")
 9234: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTInventoryFragment_Details",NewName="/Script/WitchPT.WitchPTInventoryFragment_UIDetails")
 9235: +StructRedirects=(OldName="/Script/WitchPT.PickupTemplate",NewName="/Script/WitchPT.ItemManifest")
 9236: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTInventoryManagerComponent.CanAddItemDefinition",NewName="/Script/WitchPT.WitchPTInventoryManagerComponent.TryAddItemDefinition")
 9237: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTInventoryManagerComponent.AddItemDefinition",NewName="/Script/WitchPT.WitchPTInventoryManagerComponent.Server_AddItem")
 9238: +PropertyRedirects=(OldName="/Script/WitchPT.InventoryWidgetController.OnItemStackChanged",NewName="/Script/WitchPT.InventoryWidgetController.OnItemStackChangedDelegate")
 9239: +PropertyRedirects=(OldName="/Script/WitchPT.InventoryWidgetController.OnItemAdded",NewName="/Script/WitchPT.InventoryWidgetController.OnItemAddedDelegate")
 9240: +FunctionRedirects=(OldName="/Script/WitchPT.RitualFunctionLibrary.SetInventoryWidgetController",NewName="/Script/WitchPT.RitualFunctionLibrary.SetRitualWidgetController")
 9241: +FunctionRedirects=(OldName="/Script/WitchPT.RitualAltar.Multicast_PlayersReadyNumberChanged",NewName="/Script/WitchPT.RitualAltar.Multicast_NumberOfPlayersReadyHasChanged")
 9242: +PropertyRedirects=(OldName="/Script/WitchPT.RitualWidgetController.OnRitualActivePlayerChanged",NewName="/Script/WitchPT.RitualWidgetController.OnIsMyTurnChangedDelegate")
 9243: +PropertyRedirects=(OldName="/Script/WitchPT.RitualWidgetController.OnRitualActivePlayerChangedDelegate",NewName="/Script/WitchPT.RitualWidgetController.OnIsMyTurnChangedDelegate")
 9244: +PropertyRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.RitualUserWidgetClass",NewName="/Script/WitchPT.BaseInteractableAltar.AltarUserWidgetClass")
 9245: +PropertyRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.RitualAltarWidget",NewName="/Script/WitchPT.WitchPTPlayerController.ThisRitualAltarHasWidget")
 9246: +PropertyRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.CauldronAltarWidget",NewName="/Script/WitchPT.WitchPTPlayerController.CauldronAltarMenu")
 9247: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.Client_OpenCauldronMenu",NewName="/Script/WitchPT.WitchPTPlayerController.Client_ToggleCauldronMenu")
 9248: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronWidgetController.OnBaseIngredientDropped",NewName="/Script/WitchPT.CauldronWidgetController.OnBaseIngredientSet")
 9249: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronWidgetController.HandleBaseIngredientDropped",NewName="/Script/WitchPT.CauldronWidgetController.HandleBaseIngredientSet")
 9250: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTInventoryItemFragment_IngredientDetails",NewName="/Script/WitchPT.WitchPTInventoryItemFragment_IngredientCraftingProperties")
 9251: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.PotentiatorIngredient",NewName="/Script/WitchPT.CauldronAltar.ModifierIngredient")
 9252: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.PotentiatorIngredientIcon",NewName="/Script/WitchPT.CauldronAltar.ModifierIngredientIcon")
 9253: 
 9254: [/Script/Engine.CollisionProfile]
 9255: -Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
 9256: -Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
 9257: -Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
 9258: -Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
 9259: -Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
 9260: -Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
 9261: -Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
 9262: -Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
 9263: -Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
 9264: -Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
 9265: -Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
 9266: -Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
 9267: -Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
 9268: -Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
 9269: -Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
 9270: -Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
 9271: -Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
 9272: -Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
 9273: +Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
 9274: +Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
 9275: +Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
 9276: +Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
 9277: +Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
 9278: +Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
 9279: +Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
 9280: +Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
 9281: +Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
 9282: +Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
 9283: +Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
 9284: +Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
 9285: +Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
 9286: +Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
 9287: +Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
 9288: +Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
 9289: +Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
 9290: +Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
 9291: +Profiles=(Name="Interactable_BlockDynamic",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WitchPT_TraceChannel_Interaction",Response=ECR_Overlap)),HelpMessage="Needs description")
 9292: +Profiles=(Name="Interactable_OverlapDynamic",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="WitchPT_TraceChannel_Interaction",Response=ECR_Overlap)),HelpMessage="Needs description")
 9293: +Profiles=(Name="Item",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="WitchPT_TraceChannel_Interaction")),HelpMessage="Needs description")
 9294: +DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Ignore,bTraceType=True,bStaticObject=False,Name="WitchPT_TraceChannel_Interaction")
 9295: -ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
 9296: -ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
 9297: -ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
 9298: -ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
 9299: -ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
 9300: +ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
 9301: +ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
 9302: +ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
 9303: +ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
 9304: +ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
 9305: -CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
 9306: -CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
 9307: -CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
 9308: -CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
 9309: +CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
 9310: +CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
 9311: +CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
 9312: +CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
 9313: </file>
 9314: 
 9315: <file path="Source/WitchPT/Private/Item/CauldronAltar.cpp">
 9316: #include "Item/CauldronAltar.h"
 9317: 
 9318: #include "AbilitySystemBlueprintLibrary.h"
 9319: #include "Item/CauldronPosition.h"
 9320: #include "Net/UnrealNetwork.h"
 9321: #include "GameFramework/Character.h"
 9322: #include "Kismet/GameplayStatics.h"
 9323: #include "TimerManager.h"
 9324: #include "Components/SkeletalMeshComponent.h"
 9325: #include "Components/CapsuleComponent.h"
 9326: #include "Components/StaticMeshComponent.h"
 9327: #include "Engine/World.h"
 9328: #include "DrawDebugHelpers.h"
 9329: #include "FWitchPTGameplayTags.h"
 9330: #include "Engine/ActorChannel.h"
 9331: #include "Inventory/WitchPTInventoryItemDefinition.h"
 9332: #include "Inventory/WitchPTInventoryItemInstance.h"
 9333: #include "Inventory/WitchPTInventoryManagerComponent.h"
 9334: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 9335: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 9336: #include "Player/WitchPTPlayerController.h"
 9337: 
 9338: // Sets default values
 9339: ACauldronAltar::ACauldronAltar()
 9340: {
 9341:     // Set this actor to call Tick() every frame
 9342:     PrimaryActorTick.bCanEverTick = true;
 9343: 
 9344:     // Make sure it replicates
 9345:     bReplicates = true;
 9346:     bAlwaysRelevant = true;
 9347:     CauldronPhysicState = ECauldronPhysicState::Static;
 9348:     CarryingCharacter = nullptr;
 9349:     CurrentPlacementState = ECauldronPlacementState::None;
 9350:     bReplicateUsingRegisteredSubObjectList = true;
 9351: 
 9352: }
 9353: 
 9354: void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 9355: {
 9356:     // Set up the interaction option based on the cauldron state
 9357:     FInteractionOption InteractionOption = Option;
 9358: 
 9359:     // Configure the interaction option to support hold interaction
 9360:     InteractionOption.bSupportsHoldInteraction = true;
 9361: 
 9362:     // Add the interaction option to the builder
 9363:     OptionBuilder.AddInteractionOption(InteractionOption);
 9364: }
 9365: 
 9366: void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 9367: {
 9368:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 9369: 
 9370:     DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
 9371:     DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
 9372:     DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
 9373:     DOREPLIFETIME(ACauldronAltar, BaseIngredientIcon);
 9374:     DOREPLIFETIME(ACauldronAltar, PrincipalIngredientIcon);
 9375:     DOREPLIFETIME(ACauldronAltar, ModifierIngredientIcon);
 9376: 
 9377: }
 9378: 
 9379: 
 9380: void ACauldronAltar::OnRep_CauldronPhysicState()
 9381: {
 9382:     // Update visual representation based on the new state
 9383:     if (CauldronPhysicState == ECauldronPhysicState::Moving)
 9384:     {
 9385:         // Cauldron is being carried - update visuals if needed
 9386:         SetActorEnableCollision(false);
 9387:     }
 9388:     else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
 9389:     {
 9390:         // Cauldron is in preview mode - update visuals
 9391:         SetActorEnableCollision(false);
 9392: 
 9393: 
 9394:     }
 9395: 
 9396: }
 9397: 
 9398: 
 9399: 
 9400: void ACauldronAltar::OnRep_BaseIngredientIcon()
 9401: {
 9402:     BroadcastBaseIngredientIconSet();
 9403: }
 9404: 
 9405: void ACauldronAltar::OnRep_PrincipalIngredientIcon()
 9406: {
 9407:     BroadcastPrincipalIngredientIconSet();
 9408: }
 9409: 
 9410: void ACauldronAltar::OnRep_PotentiatorIngredientIcon()
 9411: {
 9412:     BroadcastModifierIngredientIconSet();
 9413: }
 9414: 
 9415: // --- Interaction Functions ---
 9416: 
 9417: void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
 9418: {
 9419:     if (!InteractingCharacter)
 9420:     {
 9421:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
 9422:         return;
 9423:     }
 9424: 
 9425:     // Si el caldero estÃ¡ en modo de previsualizaciÃ³n, finalizar la colocaciÃ³n
 9426:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 9427:     {
 9428:         FinalizePlacement();
 9429:         return;
 9430:     }
 9431: 
 9432:     // Otherwise, try to position the character for brewing
 9433:     PositionCharacterForBrewing(InteractingCharacter);
 9434: }
 9435: 
 9436: void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
 9437: {
 9438:     if (!HasAuthority())
 9439:     {
 9440:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Not authority"));
 9441:         return;
 9442:     }
 9443: 
 9444:     if (CauldronPhysicState != ECauldronPhysicState::Static)
 9445:     {
 9446:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
 9447:         return;
 9448:     }
 9449: 
 9450:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
 9451:     if (!PC)
 9452:     {
 9453:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
 9454:         return;
 9455:     }
 9456: 
 9457:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
 9458:     if (!InventoryManager)
 9459:     {
 9460:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
 9461:         return;
 9462:     }
 9463: 
 9464:     UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);
 9465: 
 9466:     if (!InstanceFromInventory)
 9467:     {
 9468:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
 9469:         return;
 9470:     }
 9471: 
 9472:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 9473:     if (!IngredientCraftingDetails)
 9474:     {
 9475:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
 9476:         return;
 9477:     }
 9478: 
 9479:     // Determine ingredient type based on SlotUsageTag
 9480:     const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
 9481:     bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
 9482:     bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
 9483:     bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);
 9484: 
 9485:     // Check if the appropriate slot is already occupied
 9486:     if (bIsBaseIngredient && BaseIngredient != nullptr)
 9487:     {
 9488:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
 9489:         return;
 9490:     }
 9491: 
 9492:     if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
 9493:     {
 9494:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
 9495:         return;
 9496:     }
 9497: 
 9498:     if (bIsModifierIngredient && ModifierIngredient != nullptr)
 9499:     {
 9500:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
 9501:         return;
 9502:     }
 9503: 
 9504:     // If none of the slot usage tags match, this ingredient can't be used
 9505:     if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
 9506:     {
 9507:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
 9508:         return;
 9509:     }
 9510: 
 9511:     bool bConsumedSuccessfully = false;
 9512:     int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
 9513: 
 9514:     if (CurrentStackCount > 0)
 9515:     {
 9516:         UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
 9517: 
 9518:         if (CurrentStackCount == 1)
 9519:         {
 9520:             IngredientToSet = InstanceFromInventory;
 9521:             InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
 9522:             bConsumedSuccessfully = true;
 9523:         }
 9524:         else
 9525:         {
 9526:             InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
 9527:             IngredientToSet = InstanceFromInventory;
 9528:             bConsumedSuccessfully = true;
 9529:         }
 9530: 
 9531:         // Get UI fragment for icon
 9532:         const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
 9533:         TSubclassOf<UUserWidget> IngredientIcon = nullptr;
 9534:         if (IsValid(UIFragment))
 9535:         {
 9536:             IngredientIcon = UIFragment->IconWidget;
 9537:         }
 9538: 
 9539:         // Set the ingredient in the appropriate slot
 9540:         if (bIsBaseIngredient)
 9541:         {
 9542:             BaseIngredient = IngredientToSet;
 9543:             BaseIngredientIcon = IngredientIcon;
 9544:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient set successfully"));
 9545: 
 9546:             if (HasAuthority())
 9547:             {
 9548:                 BroadcastBaseIngredientIconSet();
 9549:             }
 9550:         }
 9551:         else if (bIsPrincipalIngredient)
 9552:         {
 9553:             PrincipalIngredient = IngredientToSet;
 9554:             PrincipalIngredientIcon = IngredientIcon;
 9555:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient set successfully"));
 9556: 
 9557:             if (HasAuthority())
 9558:             {
 9559:                 BroadcastPrincipalIngredientIconSet();
 9560:             }
 9561:         }
 9562:         else if (bIsModifierIngredient)
 9563:         {
 9564:             ModifierIngredient = IngredientToSet;
 9565:             ModifierIngredientIcon = IngredientIcon;
 9566:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient set successfully"));
 9567: 
 9568:             if (HasAuthority())
 9569:             {
 9570:                 BroadcastModifierIngredientIconSet();
 9571:             }
 9572:         }
 9573:     }
 9574: }
 9575: 
 9576: 
 9577: void ACauldronAltar::BeginPlay()
 9578: {
 9579:     Super::BeginPlay();
 9580:     SetReplicateMovement(true);
 9581: }
 9582: 
 9583: bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
 9584:     FReplicationFlags* RepFlags)
 9585: {
 9586:     return Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
 9587: }
 9588: 
 9589: 
 9590: void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
 9591: {
 9592:     if (!InteractingCharacter)
 9593:     {
 9594:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
 9595:         return;
 9596:     }
 9597: 
 9598:     // Si el caldero estÃ¡ en modo de previsualizaciÃ³n, cancelar y volver a adjuntar al personaje
 9599:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 9600:     {
 9601:         CancelPlacement();
 9602:         return;
 9603:     }
 9604: 
 9605:     // Check if the cauldron can be picked up
 9606:     if (!CanBePickedUp())
 9607:     {
 9608:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
 9609:         return;
 9610:     }
 9611: 
 9612:     // Attach the cauldron to the character
 9613:     AttachToCharacter(InteractingCharacter);
 9614: }
 9615: 
 9616: bool ACauldronAltar::CanBePickedUp() const
 9617: {
 9618:     // Check if the cauldron is already being carried
 9619:     if (IsBeingCarried() || IsInPlacementPreview())
 9620:     {
 9621:         return false;
 9622:     }
 9623: 
 9624:     // Add any additional conditions here (e.g., cauldron is empty, not brewing, etc.)
 9625: 
 9626:     return true;
 9627: }
 9628: 
 9629: bool ACauldronAltar::IsBeingCarried() const
 9630: {
 9631:     return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
 9632: }
 9633: 
 9634: bool ACauldronAltar::IsInPlacementPreview() const
 9635: {
 9636:     return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
 9637: }
 9638: 
 9639: 
 9640: ACharacter* ACauldronAltar::GetCarryingCharacter() const
 9641: {
 9642:     return CarryingCharacter;
 9643: }
 9644: 
 9645: void ACauldronAltar::AttachToCharacter(ACharacter* Character)
 9646: {
 9647:     if (!Character || !HasAuthority())
 9648:     {
 9649:         return;
 9650:     }
 9651: 
 9652:     // First destroy any brewing positions
 9653:     DestroyAltarPositions();
 9654: 
 9655:     // Set the cauldron state to moving
 9656:     CauldronPhysicState = ECauldronPhysicState::Moving;
 9657:     CarryingCharacter = Character;
 9658: 
 9659:     // Attach the cauldron to the character's back
 9660:     FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget,
 9661:                                           EAttachmentRule::KeepWorld, true);
 9662: 
 9663:     // Find the socket to attach to
 9664:     USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
 9665:     if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
 9666:     {
 9667:         // Attach to the socket
 9668:         AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
 9669: 
 9670:         // Disable collision
 9671:         SetActorEnableCollision(false);
 9672: 
 9673:         // Reduce de Scale of the Cauldron
 9674:         SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
 9675: 
 9676:         UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
 9677:     }
 9678: 
 9679: 
 9680: }
 9681: 
 9682: void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
 9683: {
 9684:     if (!Character || !HasAuthority() || Character != CarryingCharacter)
 9685:     {
 9686:         return;
 9687:     }
 9688: 
 9689:     // Detach from the character
 9690:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
 9691: 
 9692:     // Place the cauldron in front of the character
 9693:     FVector CharacterLocation = Character->GetActorLocation();
 9694:     FRotator CharacterRotation = Character->GetActorRotation();
 9695:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
 9696: 
 9697:     // Set the cauldron's location
 9698:     SetActorLocation(CharacterLocation + PlacementOffset);
 9699: 
 9700:     // Reset the cauldron state
 9701:     CauldronPhysicState = ECauldronPhysicState::Static;
 9702:     CarryingCharacter = nullptr;
 9703: 
 9704:     // Reset cauldron scale to normal
 9705:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 9706: 
 9707:     // Enable collision
 9708:     SetActorEnableCollision(true);
 9709: 
 9710:     // Create brewing positions around the cauldron
 9711:     CreateAltarPositions();
 9712: 
 9713:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
 9714: 
 9715:     // Play placement sound or effects
 9716:     // PlayPlacementEffects();
 9717: }
 9718: 
 9719: void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
 9720: {
 9721:     if (!Character || !HasAuthority())
 9722:     {
 9723:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
 9724:         return;
 9725:     }
 9726: 
 9727:     // Obtener una posiciÃ³n disponible
 9728:     ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
 9729: 
 9730:     if (BrewingPosition)
 9731:     {
 9732:         Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
 9733:         ParticipatingPlayers.Add(Character);
 9734: 
 9735:         if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
 9736:         {
 9737: 
 9738:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 9739:             {
 9740:                 PC->LocalToggleCauldronMenu();
 9741:             }
 9742:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
 9743:         {
 9744: 
 9745:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 9746:             {
 9747:                 PC->Client_ToggleCauldronMenu();
 9748:             }
 9749:         }
 9750:         FGameplayEventData Payload;
 9751:         Payload.OptionalObject = Character;
 9752:         FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
 9753:         UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
 9754:         return BrewingPosition->SetOccupied(Character);
 9755: 
 9756:         // Teleport the character to the position facing the cauldron
 9757: 
 9758: 
 9759:     }
 9760: 
 9761: 
 9762: 
 9763: 
 9764:     // Call the ritual state delegate for Listen Server
 9765: 
 9766: }
 9767: 
 9768: 
 9769: ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
 9770: {
 9771:     // Verificar que tengamos posiciones
 9772:     if (InteractionPositions.Num() == 0)
 9773:     {
 9774:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
 9775:         return nullptr;
 9776:     }
 9777: 
 9778:     // Buscar la primera posiciÃ³n disponible
 9779:     for (ABaseInteractionPosition* Position : InteractionPositions)
 9780:     {
 9781:         if (Position && !Position->IsOccupied())
 9782:         {
 9783:             return Position;
 9784:         }
 9785:     }
 9786: 
 9787:     // Todas las posiciones estÃ¡n ocupadas
 9788:     UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
 9789: 
 9790:     return nullptr;
 9791: }
 9792: 
 9793: // --- Nueva implementaciÃ³n para colocaciÃ³n del caldero ---
 9794: 
 9795: void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
 9796: {
 9797:     if (!Character || Character != CarryingCharacter || !HasAuthority())
 9798:     {
 9799:         return;
 9800:     }
 9801: 
 9802:     // Desacoplar el caldero del personaje
 9803:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
 9804: 
 9805:     // Establecer el estado de previsualizaciÃ³n
 9806:     CauldronPhysicState = ECauldronPhysicState::Previewing;
 9807: 
 9808:     // Guardar los materiales originales para restaurarlos despuÃ©s
 9809:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
 9810:     if (MeshComponent)
 9811:     {
 9812:         OriginalMaterials.Empty();
 9813:         for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
 9814:         {
 9815:             OriginalMaterials.Add(MeshComponent->GetMaterial(i));
 9816:         }
 9817:     }
 9818: 
 9819:     // Aplicar material de previsualizaciÃ³n
 9820:     CurrentPlacementState = ECauldronPlacementState::Invalid; // Por defecto, invÃ¡lido hasta que se verifique
 9821:     // ApplyPlacementPreviewMaterial();
 9822: 
 9823:     // Desactivar colisiones durante la previsualizaciÃ³n
 9824:     SetActorEnableCollision(false);
 9825: 
 9826:     // Colocar inicialmente el caldero frente al personaje
 9827:     FVector CharacterLocation = Character->GetActorLocation();
 9828:     FRotator CharacterRotation = Character->GetActorRotation();
 9829:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
 9830: 
 9831:     // Guardar la posiciÃ³n inicial
 9832:     PreviewLocation = CharacterLocation + PlacementOffset;
 9833:     // PreviewRotation = CharacterRotation;
 9834:     // Reset z rotation
 9835:     PreviewRotation.Pitch = 0;
 9836:     PreviewRotation.Roll = 0;
 9837:     PreviewRotation.Yaw = 0;
 9838:     // Establecer la posiciÃ³n del caldero
 9839:     SetActorLocation(PreviewLocation);
 9840:     SetActorRotation(PreviewRotation);
 9841: 
 9842:     // Restablecer la escala normal
 9843:     Multicast_FinalizePlacement();
 9844: 
 9845: 
 9846: }
 9847: 
 9848: void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
 9849: {
 9850: 
 9851: 
 9852:     // Actualizar el material segÃºn el estado
 9853:     // ApplyPlacementPreviewMaterial();
 9854: }
 9855: 
 9856: void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
 9857: {
 9858:     // Llamar a la implementaciÃ³n del cliente para actualizar la previsualizaciÃ³n
 9859:     // Client_UpdatePlacementPreview(HitLocation, HitNormal);
 9860:     if (!IsInPlacementPreview())
 9861:     {
 9862:         return;
 9863:     }
 9864: 
 9865:     // Guardar la nueva posiciÃ³n de previsualizaciÃ³n
 9866:     PreviewLocation = HitLocation;
 9867: 
 9868:     // Calcular la rotaciÃ³n para alinear con la superficie
 9869:     FRotator SurfaceAlignedRotation = HitNormal.Rotation();
 9870: 
 9871:     // Ajustar la rotaciÃ³n para que el caldero se alinee con la superficie pero mantenga su orientaciÃ³n "hacia arriba"
 9872:     // Necesitamos solo el componente de inclinaciÃ³n de la superficie
 9873:     FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
 9874: 
 9875:     // Limitar la inclinaciÃ³n mÃ¡xima
 9876:     if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
 9877:     {
 9878:         AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
 9879:     }
 9880: 
 9881:     if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
 9882:     {
 9883:         AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
 9884:     }
 9885: 
 9886:     PreviewRotation = AdjustedRotation;
 9887:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 9888:     SetActorLocation(PreviewLocation);
 9889: 
 9890: 
 9891:     // Verificar si la posiciÃ³n es vÃ¡lida
 9892:     CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
 9893: }
 9894: 
 9895: 
 9896: 
 9897: void ACauldronAltar::FinalizePlacement()
 9898: {
 9899:     if (!IsInPlacementPreview() || !HasAuthority())
 9900:     {
 9901:         return;
 9902:     }
 9903: 
 9904:     // Establecer la posiciÃ³n final
 9905:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 9906:     SetActorLocation(PreviewLocation);
 9907:     SetActorRotation(PreviewRotation);
 9908: 
 9909:     // Restaurar los materiales originales
 9910:     RestoreOriginalMaterials();
 9911: 
 9912:     // Activar colisiones
 9913:     SetActorEnableCollision(true);
 9914: 
 9915:     // Cambiar el estado
 9916:     CauldronPhysicState = ECauldronPhysicState::Static;
 9917:     CarryingCharacter = nullptr;
 9918:     CurrentPlacementState = ECauldronPlacementState::None;
 9919: 
 9920:     OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
 9921: 
 9922:     // Crear posiciones de elaboraciÃ³n alrededor del caldero
 9923:     CreateAltarPositions();
 9924: 
 9925:     // Multicast finalizar placement
 9926:     Multicast_FinalizePlacement();
 9927: 
 9928:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
 9929: }
 9930: 
 9931: void ACauldronAltar::CancelPlacement()
 9932: {
 9933:     if (!IsInPlacementPreview() || !HasAuthority())
 9934:     {
 9935:         return;
 9936:     }
 9937: 
 9938:     // Restaurar materiales originales
 9939:     RestoreOriginalMaterials();
 9940: 
 9941:     // Recolocar el caldero en el personaje
 9942:     ACharacter* Character = CarryingCharacter;
 9943: 
 9944:     // Reiniciar estado
 9945:     CauldronPhysicState = ECauldronPhysicState::Moving;
 9946:     CarryingCharacter = nullptr;
 9947:     CurrentPlacementState = ECauldronPlacementState::None;
 9948: 
 9949:     // Volver a adjuntar el caldero al personaje
 9950:     if (Character)
 9951:     {
 9952:         AttachToCharacter(Character);
 9953:     }
 9954: 
 9955:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
 9956: }
 9957: 
 9958: void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
 9959: {
 9960:     // Find the position occupied by the player
 9961:     for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
 9962:     {
 9963:         if(PositionOccupied->GetOccupyingCharacter() == Character)
 9964:         {
 9965:             // Close the cauldron menu
 9966:              if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled()) // Im the listen server
 9967:         {
 9968: 
 9969:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 9970:             {
 9971:                 PC->LocalToggleCauldronMenu();
 9972: 
 9973:             }
 9974:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled()) // The call is from the client
 9975:         {
 9976: 
 9977:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
 9978:             {
 9979:                 PC->Client_ToggleCauldronMenu();
 9980: 
 9981:             }
 9982:         }
 9983:             PositionOccupied->SetOccupied(nullptr);
 9984:             break;
 9985:         }
 9986:     }
 9987: 
 9988: }
 9989: 
 9990: 
 9991: 
 9992: 
 9993: void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
 9994: {
 9995:     // Reset de scale for all clients
 9996:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
 9997:     SetActorEnableCollision(true);
 9998: }
 9999: 
10000: ECauldronPlacementState ACauldronAltar::GetPlacementState() const
10001: {
10002:     return CurrentPlacementState;
10003: }
10004: 
10005: void ACauldronAltar::ApplyPlacementPreviewMaterial()
10006: {
10007:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
10008:     if (!MeshComponent)
10009:     {
10010:         return;
10011:     }
10012: 
10013:     // Determinar quÃ© material aplicar segÃºn el estado
10014:     UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ?
10015:         ValidPlacementMaterial : InvalidPlacementMaterial;
10016: 
10017:     // Si no tenemos un material especÃ­fico, no hacemos nada
10018:     if (!MaterialToApply)
10019:     {
10020:         return;
10021:     }
10022: 
10023:     // Aplicar el material a todos los elementos del mesh
10024:     for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
10025:     {
10026:         MeshComponent->SetMaterial(i, MaterialToApply);
10027:     }
10028: }
10029: 
10030: void ACauldronAltar::RestoreOriginalMaterials()
10031: {
10032:     // Restaurar los materiales originales si estamos fuera del modo de previsualizaciÃ³n
10033:     if (CauldronPhysicState != ECauldronPhysicState::Previewing)
10034:     {
10035:         UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
10036:         if (MeshComponent && OriginalMaterials.Num() > 0)
10037:         {
10038:             for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
10039:             {
10040:                 if (OriginalMaterials[i])
10041:                 {
10042:                     MeshComponent->SetMaterial(i, OriginalMaterials[i]);
10043:                 }
10044:             }
10045:         }
10046:     }
10047: }
10048: 
10049: bool ACauldronAltar::IsPlacementValid() const
10050: {
10051:     if (!GetWorld())
10052:     {
10053:         return false;
10054:     }
10055: 
10056:     // 1. Comprobar si hay objetos en el radio de colisiÃ³n
10057:     TArray<FOverlapResult> Overlaps;
10058:     FCollisionQueryParams QueryParams;
10059:     QueryParams.AddIgnoredActor(this);
10060: 
10061:     if (CarryingCharacter)
10062:     {
10063:         QueryParams.AddIgnoredActor(CarryingCharacter);
10064:     }
10065: 
10066:     bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
10067:         Overlaps,
10068:         PreviewLocation,
10069:         FQuat::Identity,
10070:         FCollisionObjectQueryParams::AllObjects,
10071:         FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
10072:         QueryParams
10073:     );
10074: 
10075:     if (bHasOverlaps)
10076:     {
10077:         // Encontramos solapamientos, verificar si son relevantes
10078:         for (const FOverlapResult& Overlap : Overlaps)
10079:         {
10080:             // Ignorar actores que no tienen colisiÃ³n (podrÃ­an ser efectos visuales, etc.)
10081:             if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
10082:             {
10083:                 // Si encontramos algÃºn actor con colisiÃ³n, la posiciÃ³n no es vÃ¡lida
10084:                 return false;
10085:             }
10086:         }
10087:     }
10088: 
10089:     // 2. Comprobar si el caldero estÃ¡ alineado con el suelo
10090:     // Hacer un trazado hacia abajo para ver si hay suelo cerca
10091:     FHitResult HitResult;
10092:     FVector TraceStart = PreviewLocation;
10093:     FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
10094: 
10095:     bool bHitGround = GetWorld()->LineTraceSingleByChannel(
10096:         HitResult,
10097:         TraceStart,
10098:         TraceEnd,
10099:         ECC_Visibility,
10100:         QueryParams
10101:     );
10102: 
10103:     if (!bHitGround)
10104:     {
10105:         // No encontramos suelo debajo del caldero
10106:         return false;
10107:     }
10108: 
10109:     // Comprobar la distancia al suelo
10110:     float DistanceToGround = (HitResult.Location - TraceStart).Size();
10111:     if (DistanceToGround > MaxGroundAlignmentHeight)
10112:     {
10113:         // El caldero estÃ¡ demasiado lejos del suelo
10114:         return false;
10115:     }
10116: 
10117:     // La posiciÃ³n es vÃ¡lida
10118:     return true;
10119: }
10120: // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
10121: void ACauldronAltar::BroadcastBaseIngredientDropped() const
10122: {
10123:     OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
10124: }
10125: 
10126: void ACauldronAltar::BroadcastBaseIngredientIconSet() const
10127: {
10128:     OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
10129: }
10130: 
10131: void ACauldronAltar::BroadcastPrincipalIngredientDropped() const
10132: {
10133:     OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
10134: }
10135: 
10136: void ACauldronAltar::BroadcastPrincipalIngredientIconSet() const
10137: {
10138:     OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
10139: }
10140: 
10141: void ACauldronAltar::BroadcastModifierIngredientDropped() const
10142: {
10143:     OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
10144: }
10145: 
10146: void ACauldronAltar::BroadcastModifierIngredientIconSet() const
10147: {
10148:     OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
10149: }
10150: 
10151: UWitchPTInventoryItemInstance* ACauldronAltar::GetBaseIngredient() const
10152: {
10153:     return BaseIngredient;
10154: }
10155: 
10156: UWitchPTInventoryItemInstance* ACauldronAltar::GetPrincipalIngredient() const
10157: {
10158:     return PrincipalIngredient;
10159: }
10160: 
10161: UWitchPTInventoryItemInstance* ACauldronAltar::GetModifierIngredient() const
10162: {
10163:     return ModifierIngredient;
10164: }
10165: </file>
10166: 
10167: <file path="Source/WitchPT/Public/Item/CauldronAltar.h">
10168: // Fill out your copyright notice in the Description page of Project Settings.
10169: 
10170: #pragma once
10171: 
10172: #include "CoreMinimal.h"
10173: #include "Item/BaseInteractableAltar.h"
10174: #include "GameplayTagContainer.h" // Include for FGameplayTag
10175: #include "MechanicsInterface.h"
10176: #include "AbilitySystem/Interaction/IInteractableTarget.h"
10177: #include "CauldronAltar.generated.h"
10178: 
10179: class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
10180: class UWitchPTInventoryItemFragment;
10181: class UCauldronUserWidget;
10182: class ACauldronPosition;
10183: class ACharacter;
10184: 
10185: // Estructura para contener secuencias de ingredientes
10186: USTRUCT(BlueprintType)
10187: struct FIngredientSequence
10188: {
10189:     GENERATED_BODY()
10190: 
10191:     UPROPERTY(BlueprintReadOnly)
10192:     TArray<FGameplayTag> Ingredients;
10193: };
10194: 
10195: // Enum for cauldron inputs
10196: UENUM(BlueprintType)
10197: enum class ECauldronInput : uint8
10198: {
10199:     Ingredient1 UMETA(DisplayName = "Ingredient 1"),
10200:     Ingredient2 UMETA(DisplayName = "Ingredient 2"),
10201:     Ingredient3 UMETA(DisplayName = "Ingredient 3"),
10202:     Ingredient4 UMETA(DisplayName = "Ingredient 4"),
10203:     Ingredient5 UMETA(DisplayName = "Ingredient 5"),
10204:     None        UMETA(DisplayName = "None")
10205: };
10206: 
10207: UENUM(BlueprintType)
10208: enum ECauldronPhysicState
10209: {
10210:     Static UMETA(DisplayName = "InPlace"),
10211:     Moving UMETA(DisplayName = "Moving"),
10212:     Previewing UMETA(DisplayName = "Previewing")
10213: };
10214: 
10215: // Enum para el estado de validaciÃ³n de la posiciÃ³n del caldero
10216: UENUM(BlueprintType)
10217: enum class ECauldronPlacementState : uint8
10218: {
10219:     Valid UMETA(DisplayName = "Valid"),
10220:     Invalid UMETA(DisplayName = "Invalid"),
10221:     None UMETA(DisplayName = "None")
10222: };
10223: 
10224: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
10225: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
10226: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
10227: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
10228: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
10229: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
10230: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
10231: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
10232: 
10233: /**
10234:  * Cauldron altar allows players to add ingredients in any order (unlike ritual's sequential inputs)
10235:  */
10236: UCLASS()
10237: class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
10238: {
10239:     GENERATED_BODY()
10240: 
10241: public:
10242:     // Sets default values for this actor's properties
10243:     ACauldronAltar();
10244: 
10245:     // Overrides
10246:     virtual void BeginPlay() override;
10247:     virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
10248:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
10249:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
10250:     virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
10251: 
10252:     // Core Properties
10253:     UPROPERTY(EditAnywhere)
10254:     FInteractionOption Option;
10255: 
10256:     UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
10257:     TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;
10258: 
10259:     // Base ingredient
10260:     UPROPERTY(VisibleAnywhere)
10261:     UWitchPTInventoryItemInstance* BaseIngredient;
10262:     UPROPERTY(VisibleAnywhere)
10263:     UWitchPTInventoryItemInstance* PrincipalIngredient;
10264:     UPROPERTY(VisibleAnywhere)
10265:     UWitchPTInventoryItemInstance* ModifierIngredient;
10266: 
10267:     UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
10268:     TSubclassOf<UUserWidget> BaseIngredientIcon;
10269: 
10270:     UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
10271:     TSubclassOf<UUserWidget> PrincipalIngredientIcon;
10272: 
10273:     UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
10274:     TSubclassOf<UUserWidget> ModifierIngredientIcon;
10275: 
10276:     // ----------------------------------- DELEGATES  ---------------------------------------------- //
10277: 
10278:     FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
10279:     FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
10280:     FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
10281:     FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
10282:     FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
10283:     FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
10284:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
10285:     FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
10286: 
10287:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
10288:     FOnCharacterPositioned OnCharacterPositioned;
10289: 
10290:     // UI Properties
10291:     UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
10292:     TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
10293: 
10294:     // Placement Properties
10295:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
10296:     UMaterialInterface* ValidPlacementMaterial;
10297: 
10298:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
10299:     UMaterialInterface* InvalidPlacementMaterial;
10300: 
10301:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
10302:     float PlacementCollisionCheckRadius = 50.0f;
10303: 
10304:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
10305:     float MaxGroundAlignmentHeight = 20.0f;
10306: 
10307:     // ----------------------------------- BREWING FUNCTIONS ---------------------------------------------- //
10308: 
10309:     void StartBrewingPotion(ACharacter* InteractingCharacter);
10310: 
10311:     void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
10312: 
10313:     // ----------------------------------- ON REP FUNCTIONS ---------------------------------------------- //
10314: 
10315:     UFUNCTION()
10316:     void OnRep_CauldronPhysicState();
10317:     UFUNCTION()
10318:     void OnRep_BaseIngredientIcon();
10319:     UFUNCTION()
10320:     void OnRep_PrincipalIngredientIcon();
10321:     UFUNCTION()
10322:     void OnRep_PotentiatorIngredientIcon();
10323: 
10324:     UFUNCTION()
10325:     void PositionCharacterForBrewing(ACharacter* Character);
10326: 
10327:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
10328:     ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
10329: 
10330: 
10331:     // ----------------------------------- CAULDRON MOVEMENT FUNCTIONS ---------------------------------------------- //
10332:     void StartCarryCauldron(ACharacter* InteractingCharacter);
10333: 
10334:     UFUNCTION()
10335:     void AttachToCharacter(ACharacter* Character);
10336: 
10337:     UFUNCTION()
10338:     void DetachFromCharacter(ACharacter* Character);
10339: 
10340:     // ----------------------------------- PLACEMENT FUNCTIONS ---------------------------------------------- //
10341:     void StartPlacementPreview(ACharacter* Character);
10342:     void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
10343:     void FinalizePlacement();
10344:     void CancelPlacement();
10345:     void ApplyPlacementPreviewMaterial();
10346: 
10347:     UFUNCTION(Client, Unreliable)
10348:     void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
10349: 
10350:     UFUNCTION(NetMulticast, Reliable)
10351:     void Multicast_FinalizePlacement();
10352: 
10353:     // ----------------------------------- STATE QUERY FUNCTIONS ---------------------------------------------- //
10354:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
10355:     bool CanBePickedUp() const;
10356: 
10357:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
10358:     bool IsBeingCarried() const;
10359: 
10360:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
10361:     ACharacter* GetCarryingCharacter() const;
10362: 
10363:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
10364:     ECauldronPlacementState GetPlacementState() const;
10365: 
10366:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
10367:     bool IsInPlacementPreview() const;
10368:     // ----------------------------------- GETTERS ---------------------------------------------- //
10369: 
10370:     UWitchPTInventoryItemInstance* GetBaseIngredient() const;
10371:     UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
10372:     UWitchPTInventoryItemInstance* GetModifierIngredient() const;
10373: 
10374: protected:
10375:     // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
10376: 	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
10377:     void BroadcastBaseIngredientDropped() const;
10378:     void BroadcastBaseIngredientIconSet() const;
10379:     void BroadcastPrincipalIngredientDropped() const;
10380:     void BroadcastPrincipalIngredientIconSet() const;
10381:     void BroadcastModifierIngredientDropped() const;
10382:     void BroadcastModifierIngredientIconSet() const;
10383: 
10384: 
10385: private:
10386:     UPROPERTY(Replicated)
10387:     TObjectPtr<ACharacter> CarryingCharacter;
10388: 
10389:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
10390:     FName BackAttachSocketName = "BackpackSocket";
10391: 
10392:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
10393:     FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
10394: 
10395:     // Placement Properties
10396:     UPROPERTY(Replicated)
10397:     ECauldronPlacementState CurrentPlacementState;
10398: 
10399:     UPROPERTY()
10400:     TArray<UMaterialInterface*> OriginalMaterials;
10401: 
10402:     FVector PreviewLocation;
10403:     FRotator PreviewRotation;
10404: 
10405:     // Private Utility Functions
10406:     void RestoreOriginalMaterials();
10407:     bool IsPlacementValid() const;
10408: };
10409: </file>
10410: 
10411: <file path="Source/WitchPT/Public/Item/RitualAltar.h">
10412: // Fill out your copyright notice in the Description page of Project Settings.
10413: 
10414: #pragma once
10415: 
10416: #include "CoreMinimal.h"
10417: #include "Item/BaseInteractableAltar.h"
10418: #include "GameplayTagContainer.h" // Include for FGameplayTag
10419: #include "RitualAltar.generated.h"
10420: 
10421: class URitualUserWidget;
10422: class ARitualPosition;
10423: 
10424: // Enum defining the possible inputs for the ritual sequence
10425: UENUM(BlueprintType)
10426: enum class ERitualInput : uint8
10427: {
10428: 	Up		UMETA(DisplayName = "Up"),
10429: 	Down	UMETA(DisplayName = "Down"),
10430: 	Left	UMETA(DisplayName = "Left"),
10431: 	Right	UMETA(DisplayName = "Right"),
10432: 	None	UMETA(DisplayName = "None") // Optional: For default/invalid state
10433: };
10434: 
10435: USTRUCT(BlueprintType)
10436: struct FUIRitualData
10437: {
10438: 	GENERATED_BODY()
10439: 	UPROPERTY(BlueprintReadOnly)
10440: 	bool bIsMyTurn = false;
10441: 	UPROPERTY(BlueprintReadOnly)
10442: 	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
10443: 	UPROPERTY(BlueprintReadOnly)
10444: 	float RitualPercentageCompleted = 0.0f;
10445: 	UPROPERTY(BlueprintReadOnly)
10446: 	float CorruptionPercentage = 0.0f;
10447: 	UPROPERTY(BlueprintReadOnly)
10448: 	float CurrentInputTimeRemaining = 0.0f;
10449: };
10450: 
10451: // Replicated struct for ready players data
10452: USTRUCT(BlueprintType)
10453: struct FRitualReadyPlayersData
10454: {
10455: 	GENERATED_BODY()
10456: 
10457: 	UPROPERTY(BlueprintReadOnly)
10458: 	int32 TotalPlayers = 0;
10459: 
10460: 	UPROPERTY(BlueprintReadOnly)
10461: 	int32 ReadyPlayers = 0;
10462: 
10463: 	bool operator==(const FRitualReadyPlayersData& Other) const
10464: 	{
10465: 		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
10466: 	}
10467: 
10468: 	bool operator!=(const FRitualReadyPlayersData& Other) const
10469: 	{
10470: 		return !(*this == Other);
10471: 	}
10472: };
10473: 
10474: // Delegates for UI updates - these will be called from OnRep functions
10475: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
10476: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
10477: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
10478: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
10479: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
10480: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
10481: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);
10482: 
10483: UCLASS()
10484: class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
10485: {
10486: 	GENERATED_BODY()
10487: 
10488: public:
10489: 	// Sets default values for this actor's properties
10490: 	ARitualAltar();
10491: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
10492: 
10493: 	// ----------------------------------- REPLICATED PROPERTIES ---------------------------------------------- //
10494: 	// Current ritual state
10495: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
10496: 	EInteractionState CurrentRitualState = EInteractionState::Inactive;
10497: 
10498: 	// Current sequence of inputs required for the ritual
10499: 	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
10500: 	TArray<FGameplayTag> InputSequence;
10501: 
10502: 	// Current index in the sequence
10503: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
10504: 	int32 CurrentSequenceIndex = -1;
10505: 
10506: 	// Players who have confirmed they're ready to start
10507: 	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
10508: 	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
10509: 
10510: 	// Ready players data for UI
10511: 	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
10512: 	FRitualReadyPlayersData ReadyPlayersData;
10513: 
10514: 	// Current countdown value (when starting ritual)
10515: 	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
10516: 	int32 StartCountdown = 3;
10517: 
10518: 	// Current player whose turn it is to input
10519: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
10520: 	TObjectPtr<ACharacter> CurrentActivePlayer;
10521: 
10522: 	// Timer for the current input
10523: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
10524: 	float CurrentInputTimer;
10525: 
10526: 	// Current turn data for UI
10527: 	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
10528: 	FUIRitualData CurrentTurnData;
10529: 
10530: 	// Current corruption level
10531: 	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
10532: 	float CorruptionAmount = 0.0f;
10533: 
10534: 	// Maximum corruption allowed before catastrophic failure
10535: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10536: 	float MaxCorruption = 100.0f;
10537: 
10538: 	// Corruption increase per failure
10539: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10540: 	float CorruptionIncreasePerFail = 10.0f;
10541: 
10542: 	// Base time window for inputs
10543: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10544: 	float BaseInputTimeWindow = 10.0f;
10545: 
10546: 	// Scaling multiplier for difficulty
10547: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
10548: 	float DifficultyScalingMultiplier = 1.0f;
10549: 
10550: 	// Ritual completion status
10551: 	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
10552: 	bool bRitualCompleted = false;
10553: 
10554: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
10555: 	bool bRitualWasSuccessful = false;
10556: 
10557: 	// ----------------------------------- DELEGATES ---------------------------------------------- //
10558: 	FOnRitualStateChanged OnRitualStateChangedEvent;
10559: 
10560: 	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
10561: 
10562: 	FOnCountdownTick OnCountdownTickEvent;
10563: 
10564: 	FOnTurnDataChanged OnTurnDataChangedEvent;
10565: 
10566: 	FOnCorruptionChanged OnCorruptionChangedEvent;
10567: 
10568: 	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
10569: 	UPROPERTY(BlueprintAssignable)
10570: 	FOnRitualCompleted OnRitualCompletedEvent;
10571: 
10572: 	// ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
10573: 	UFUNCTION()
10574: 	void OnRep_CurrentRitualState();
10575: 
10576: 	UFUNCTION()
10577: 	void OnRep_CurrentSequenceIndex();
10578: 
10579: 	UFUNCTION()
10580: 	void OnRep_ReadyPlayersData();
10581: 
10582: 	UFUNCTION()
10583: 	void OnRep_StartCountdown();
10584: 
10585: 	UFUNCTION()
10586: 	void OnRep_CurrentActivePlayer();
10587: 
10588: 	UFUNCTION()
10589: 	void OnRep_TurnData();
10590: 
10591: 	UFUNCTION()
10592: 	void OnRep_CorruptionAmount();
10593: 
10594: 	UFUNCTION()
10595: 	void OnRep_RitualCompleted();
10596: 
10597: 	// ----------------------------------- MAIN FUNCTIONS ---------------------------------------------- //
10598: 	UFUNCTION(NetMulticast, Reliable)
10599: 	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
10600: 
10601: 	void StartRitual(ACharacter* RequestingCharacter);
10602: 	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
10603: 
10604: 	// New function to check player ready status
10605: 	UFUNCTION(BlueprintPure, Category = "Ritual")
10606: 	bool IsPlayerReady(ACharacter* Player) const;
10607: 
10608: 	// New function to check if all players are ready
10609: 	UFUNCTION(BlueprintPure, Category = "Ritual")
10610: 	bool AreAllPlayersReady() const;
10611: 
10612: 	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
10613: 	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
10614: 
10615: 	// Multicast RPCs for notifications
10616: 	UFUNCTION(NetMulticast, Reliable)
10617: 	void Multicast_OnRitualSucceeded();
10618: 
10619: 	UFUNCTION(NetMulticast, Reliable)
10620: 	void Multicast_OnRitualCatastrophicFail();
10621: 
10622: 	// New multicast RPC for countdown
10623: 	UFUNCTION(NetMulticast, Reliable)
10624: 	void Multicast_OnCountdownTick(int32 CountdownValue);
10625: 
10626: 	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
10627: 
10628: 	// ---------------------------- GETTERS FOR WC ---------------------------- //
10629: 	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
10630: 	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
10631: 	float GetCorruptionPercentage() const;
10632: 	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
10633: 	float GetCurrentSequenceProgress() const;
10634: 	FGameplayTag GetCurrentExpectedInput() const;
10635: 	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
10636: 	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
10637: 	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }
10638: 
10639: 
10640: protected:
10641: 	virtual void BeginPlay() override;
10642: 	virtual void Tick(float DeltaTime) override;
10643: 
10644: 	// Timer handle for the ritual start countdown
10645: 	FTimerHandle RitualStartCountdownHandle;
10646: 
10647: 	// Timer handles
10648: 	FTimerHandle InputTimerHandle;
10649: 
10650: 	// ----------------------------------- LOGIC FUNCTIONS ---------------------------------------------- //
10651: 	void GenerateInputSequence();
10652: 	void AdvanceToNextPlayer();
10653: 	virtual void HandleInputSuccess(ACharacter* Player) override;
10654: 	virtual void HandleInputFailure(ACharacter* Player) override;
10655: 	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
10656: 	void StartInputTimer();
10657: 	void OnInputTimerExpired();
10658: 	void CheckRitualState();
10659: 	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
10660: 	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
10661: 	void CleanupRitual();
10662: 	void SpawnReward();
10663: 	void SpawnDemon();
10664: 	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
10665: 	void UpdateTurnData();
10666: 	void UpdateReadyPlayersData();
10667: 
10668: 	// New helper functions for the ready system
10669: 	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
10670: 	void StartRitualCountdown();
10671: 	void ProcessCountdownTick();
10672: 	void ActivateRitual();
10673: 
10674: 	// ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
10675: 	// These functions handle event broadcasting and are called both from server-side code and OnRep functions
10676: 	void BroadcastRitualStateChanged();
10677: 	void BroadcastReadyPlayersChanged();
10678: 	void BroadcastCountdownTick();
10679: 	void BroadcastTurnDataChanged();
10680: 	void BroadcastCorruptionChanged();
10681: 	void BroadcastSequenceProgressChanged();
10682: 	void BroadcastRitualCompleted();
10683: 
10684: 	UPROPERTY(EditDefaultsOnly)
10685: 	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
10686: 	UPROPERTY(EditDefaultsOnly)
10687: 	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
10688: 	UPROPERTY(EditDefaultsOnly)
10689: 	TObjectPtr<UAnimMontage> FailedAnimMontage;
10690: 	UPROPERTY(EditDefaultsOnly)
10691: 	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
10692: 
10693: 	// Animation montages specifically for ritual
10694: 	UPROPERTY(EditDefaultsOnly)
10695: 	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
10696: 	UPROPERTY(EditDefaultsOnly)
10697: 	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
10698: };
10699: </file>
10700: 
10701: <file path="Source/WitchPT/Private/Item/RitualAltar.cpp">
10702: // Fill out your copyright notice in the Description page of Project Settings.
10703: 
10704: #include "Item/RitualAltar.h"
10705: #include "Net/UnrealNetwork.h"
10706: #include "Item/RitualPosition.h"
10707: #include "GameFramework/Character.h"
10708: #include "AbilitySystemComponent.h"
10709: #include "AbilitySystemBlueprintLibrary.h"
10710: #include "FWitchPTGameplayTags.h"
10711: #include "Player/WitchPTPlayerController.h"
10712: 
10713: // Sets default values
10714: ARitualAltar::ARitualAltar()
10715: {
10716: 	// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
10717: 	PrimaryActorTick.bCanEverTick = true;
10718: 
10719: 	bReplicates = true;
10720: 
10721: 	// Default values
10722: 	CurrentRitualState = EInteractionState::Inactive;
10723: 	CurrentSequenceIndex = -1;
10724: 	CurrentInputTimer = 0.0f;
10725: 	CorruptionAmount = 0.0f;
10726: 	MaxCorruption = 100.0f;
10727: 	StartCountdown = 3;
10728: 	bRitualCompleted = false;
10729: 	bRitualWasSuccessful = false;
10730: }
10731: 
10732: void ARitualAltar::BeginPlay()
10733: {
10734: 	Super::BeginPlay();
10735: 
10736: 	// // Auto-discover RitualPositions if not set in editor
10737: 	// if (RitualPositions.Num() == 0 && HasAuthority())
10738: 	// {
10739: 	// 	TArray<AActor*> FoundActors;
10740: 	// 	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ARitualPosition::StaticClass(), FoundActors);
10741: 	//
10742: 	// 	for (AActor* Actor : FoundActors)
10743: 	// 	{
10744: 	// 		ARitualPosition* Position = Cast<ARitualPosition>(Actor);
10745: 	// 		if (Position)
10746: 	// 		{
10747: 	// 			RitualPositions.Add(Position);
10748: 	// 			Position->SetRitualAltar(this);
10749: 	// 		}
10750: 	// 	}
10751: 	// }
10752: }
10753: 
10754: void ARitualAltar::Tick(float DeltaTime)
10755: {
10756: 	Super::Tick(DeltaTime);
10757: }
10758: 
10759: void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
10760: {
10761: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
10762: 
10763: 	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
10764: 	DOREPLIFETIME(ARitualAltar, InputSequence);
10765: 	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
10766: 	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
10767: 	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
10768: 	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
10769: 	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
10770: 	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
10771: 	DOREPLIFETIME(ARitualAltar, MaxCorruption);
10772: 	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
10773: 	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
10774: 	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
10775: 	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
10776: 	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
10777: 	DOREPLIFETIME(ARitualAltar, StartCountdown);
10778: 	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
10779: 	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
10780: }
10781: 
10782: // ----------------------------------- ONREP FUNCTIONS ---------------------------------------------- //
10783: 
10784: void ARitualAltar::OnRep_CurrentRitualState()
10785: {
10786: 	BroadcastRitualStateChanged();
10787: }
10788: 
10789: void ARitualAltar::OnRep_CurrentSequenceIndex()
10790: {
10791: 	// Just broadcast sequence progress change - turn data updates are handled by OnRep_TurnData
10792: 	BroadcastSequenceProgressChanged();
10793: }
10794: 
10795: void ARitualAltar::OnRep_ReadyPlayersData()
10796: {
10797: 	BroadcastReadyPlayersChanged();
10798: }
10799: 
10800: void ARitualAltar::OnRep_StartCountdown()
10801: {
10802: 	BroadcastCountdownTick();
10803: }
10804: 
10805: void ARitualAltar::OnRep_CurrentActivePlayer()
10806: {
10807: 	// Turn data updates are handled by OnRep_TurnData
10808: 	// This OnRep function is kept for potential future use
10809: }
10810: 
10811: void ARitualAltar::OnRep_TurnData()
10812: {
10813: 	BroadcastTurnDataChanged();
10814: }
10815: 
10816: void ARitualAltar::OnRep_CorruptionAmount()
10817: {
10818: 	BroadcastCorruptionChanged();
10819: }
10820: 
10821: void ARitualAltar::OnRep_RitualCompleted()
10822: {
10823: 	if (bRitualCompleted)
10824: 	{
10825: 		BroadcastRitualCompleted();
10826: 	}
10827: }
10828: 
10829: // ----------------------------------- BROADCAST HELPER FUNCTIONS ---------------------------------------------- //
10830: 
10831: void ARitualAltar::BroadcastRitualStateChanged()
10832: {
10833: 	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
10834: }
10835: 
10836: void ARitualAltar::BroadcastReadyPlayersChanged()
10837: {
10838: 	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
10839: }
10840: 
10841: void ARitualAltar::BroadcastCountdownTick()
10842: {
10843: 	OnCountdownTickEvent.Broadcast(StartCountdown);
10844: }
10845: 
10846: void ARitualAltar::BroadcastTurnDataChanged()
10847: {
10848: 	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
10849: }
10850: 
10851: void ARitualAltar::BroadcastCorruptionChanged()
10852: {
10853: 	float CorruptionPercentage = GetCorruptionPercentage();
10854: 	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
10855: }
10856: 
10857: void ARitualAltar::BroadcastSequenceProgressChanged()
10858: {
10859: 	float Progress = GetCurrentSequenceProgress();
10860: 	OnSequenceProgressChangedEvent.Broadcast(Progress);
10861: }
10862: 
10863: void ARitualAltar::BroadcastRitualCompleted()
10864: {
10865: 	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
10866: }
10867: 
10868: // ----------------------------------- HELPER FUNCTIONS ---------------------------------------------- //
10869: 
10870: void ARitualAltar::UpdateTurnData()
10871: {
10872: 	// This function can be called on both server and clients
10873: 	// On server: updates the replicated CurrentTurnData
10874: 	// On clients: called from OnRep functions to update local UI data
10875: 
10876: 	FUIRitualData NewTurnData;
10877: 	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
10878: 	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
10879: 	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
10880: 
10881: 	// Set expected input if we have valid data
10882: 	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
10883: 	{
10884: 		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
10885: 	}
10886: 	else
10887: 	{
10888: 		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
10889: 	}
10890: 
10891: 	// Always set bIsMyTurn to false here - the widget controller will determine the correct value
10892: 	NewTurnData.bIsMyTurn = false;
10893: 
10894: 	// On server, update the replicated data if it has changed
10895: 	if (HasAuthority())
10896: 	{
10897: 		// Only update if data has changed to avoid unnecessary replication
10898: 		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
10899: 			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
10900: 			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
10901: 			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
10902: 			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
10903: 		{
10904: 			CurrentTurnData = NewTurnData;
10905: 			// Broadcast on server for local UI updates (OnRep will handle clients)
10906: 			BroadcastTurnDataChanged();
10907: 		}
10908: 	}
10909: 	else
10910: 	{
10911: 		// On clients, just update the local data and broadcast
10912: 		CurrentTurnData = NewTurnData;
10913: 		BroadcastTurnDataChanged();
10914: 	}
10915: }
10916: 
10917: void ARitualAltar::UpdateReadyPlayersData()
10918: {
10919: 	if (!HasAuthority())
10920: 	{
10921: 		return;
10922: 	}
10923: 
10924: 	FRitualReadyPlayersData NewData;
10925: 	NewData.TotalPlayers = ParticipatingPlayers.Num();
10926: 	NewData.ReadyPlayers = ReadyPlayers.Num();
10927: 
10928: 	if (ReadyPlayersData != NewData)
10929: 	{
10930: 		ReadyPlayersData = NewData;
10931: 		// Broadcast on server for local UI updates (OnRep will handle clients)
10932: 		BroadcastReadyPlayersChanged();
10933: 	}
10934: }
10935: 
10936: // ----------------------------------- EXISTING FUNCTIONS (UPDATED) ---------------------------------------------- //
10937: 
10938: void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
10939: {
10940: 	// This is now handled by OnRep_ReadyPlayersData, but keeping for backward compatibility
10941: 	UpdateReadyPlayersData();
10942: }
10943: 
10944: void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
10945: {
10946: 	if (!HasAuthority() || !RequestingCharacter)
10947: 	{
10948: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
10949: 		return;
10950: 	}
10951: 
10952: 	// Check if the ritual is in a valid state
10953: 	if (CurrentRitualState != EInteractionState::Inactive &&
10954: 	    CurrentRitualState != EInteractionState::WaitingForPlayers)
10955: 	{
10956: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
10957: 		return;
10958: 	}
10959: 
10960: 	// Process the ready request
10961: 	ProcessRitualReadyRequest(RequestingCharacter);
10962: }
10963: 
10964: void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
10965: {
10966: 	if (!HasAuthority() || !RequestingCharacter)
10967: 	{
10968: 		return;
10969: 	}
10970: 
10971: 	// Check if player is already in the ready list
10972: 	if (ReadyPlayers.Contains(RequestingCharacter))
10973: 	{
10974: 		// Player is already ready, could allow them to un-ready if desired
10975: 		ReadyPlayers.Remove(RequestingCharacter);
10976: 		UpdateReadyPlayersData();
10977: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
10978: 		return;
10979: 	}
10980: 
10981: 	// Add player to ready list
10982: 	ReadyPlayers.Add(RequestingCharacter);
10983: 	UpdateReadyPlayersData();
10984: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
10985: 
10986: 	// Check if all players are ready
10987: 	if (AreAllPlayersReady())
10988: 	{
10989: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
10990: 		StartRitualCountdown();
10991: 	}
10992: }
10993: 
10994: bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
10995: {
10996: 	return ReadyPlayers.Contains(Player);
10997: }
10998: 
10999: bool ARitualAltar::AreAllPlayersReady() const
11000: {
11001: 	// Check if all participating players are in the ready list
11002: 	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
11003: 	{
11004: 		return false;
11005: 	}
11006: 
11007: 	for (ACharacter* Player : ParticipatingPlayers)
11008: 	{
11009: 		if (!ReadyPlayers.Contains(Player))
11010: 		{
11011: 			return false;
11012: 		}
11013: 	}
11014: 
11015: 	return true;
11016: }
11017: 
11018: void ARitualAltar::StartRitualCountdown()
11019: {
11020: 	if (!HasAuthority())
11021: 	{
11022: 		return;
11023: 	}
11024: 
11025: 	// Set the state to preparing
11026: 	CurrentRitualState = EInteractionState::Preparing;
11027: 	// Broadcast on server for local UI updates (OnRep will handle clients)
11028: 	BroadcastRitualStateChanged();
11029: 
11030: 	// Generate the ritual input sequence
11031: 	GenerateInputSequence();
11032: 
11033: 	// Reset countdown value
11034: 	StartCountdown = 3;
11035: 	// Broadcast on server for local UI updates (OnRep will handle clients)
11036: 	BroadcastCountdownTick();
11037: 
11038: 	// Start countdown timer
11039: 	GetWorldTimerManager().SetTimer(
11040: 		RitualStartCountdownHandle,
11041: 		this,
11042: 		&ARitualAltar::ProcessCountdownTick,
11043: 		1.0f,  // Fire every second
11044: 		true   // Looping
11045: 	);
11046: }
11047: 
11048: void ARitualAltar::ProcessCountdownTick()
11049: {
11050: 	if (!HasAuthority())
11051: 	{
11052: 		return;
11053: 	}
11054: 
11055: 	// Decrease countdown
11056: 	StartCountdown--;
11057: 	// Broadcast on server for local UI updates (OnRep will handle clients)
11058: 	BroadcastCountdownTick();
11059: 
11060: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
11061: 
11062: 	if (StartCountdown <= 0)
11063: 	{
11064: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
11065: 		ActivateRitual();
11066: 	}
11067: }
11068: 
11069: void ARitualAltar::ActivateRitual()
11070: {
11071: 	if (!HasAuthority())
11072: 	{
11073: 		return;
11074: 	}
11075: 
11076: 	// Set initial active player (from ready list)
11077: 	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
11078: 
11079: 	// Fallback
11080: 	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
11081: 	CurrentSequenceIndex = 0;
11082: 	CurrentRitualState = EInteractionState::Active;
11083: 
11084: 	// Start the input timer (this updates CurrentInputTimer)
11085: 	StartInputTimer();
11086: 
11087: 	// Now update turn data with all the new values
11088: 	UpdateTurnData();
11089: 
11090: 	// Broadcast state change on server for local UI updates (OnRep will handle clients)
11091: 	BroadcastRitualStateChanged();
11092: }
11093: 
11094: void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
11095: {
11096: 	// This is now handled by OnRep_StartCountdown, but keeping for backward compatibility
11097: 	StartCountdown = CountdownValue;
11098: }
11099: 
11100: void ARitualAltar::GenerateInputSequence()
11101: {
11102: 	if (!HasAuthority())
11103: 	{
11104: 		return;
11105: 	}
11106: 
11107: 	InputSequence.Empty();
11108: 
11109: 	// Number of inputs scales with the number of players and difficulty
11110: 	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
11111: 
11112: 	// Get gameplay tags from the native tag manager
11113: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11114: 
11115: 	TArray<FGameplayTag> PossibleInputs;
11116: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
11117: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
11118: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
11119: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
11120: 
11121: 	// Generate random sequence
11122: 	for (int32 i = 0; i < SequenceLength; ++i)
11123: 	{
11124: 		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
11125: 		InputSequence.Add(PossibleInputs[RandomIndex]);
11126: 	}
11127: 
11128: 	// Reset sequence index
11129: 
11130: 
11131: }
11132: 
11133: void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
11134: {
11135: 	if (!Character || !HasAuthority())
11136: 	{
11137: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
11138: 		return;
11139: 	}
11140: 
11141: 	// Check if the ritual is active
11142: 	if (CurrentRitualState != EInteractionState::Active)
11143: 	{
11144: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"),
11145: 			*Character->GetName(), static_cast<int32>(CurrentRitualState));
11146: 		return;
11147: 	}
11148: 
11149: 	// Check if it's this player's turn
11150: 	if (Character != CurrentActivePlayer)
11151: 	{
11152: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"),
11153: 			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
11154: 		return;
11155: 	}
11156: 
11157: 	// Check if we have a valid input to match against
11158: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
11159: 	{
11160: 		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"),
11161: 			CurrentSequenceIndex, InputSequence.Num());
11162: 		return;
11163: 	}
11164: 
11165: 	// Get the expected input for the current step
11166: 	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
11167: 
11168: 
11169: 	// Check if the input matches
11170: 	if (InputTag == ExpectedInput)
11171: 	{
11172: 		HandleInputSuccess(Character);
11173: 	}
11174: 	else
11175: 	{
11176: 		HandleInputFailure(Character);
11177: 	}
11178: }
11179: 
11180: void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
11181: {
11182: 
11183: 	if (Character)
11184: 	{
11185: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
11186: 		if (ASC)
11187: 		{
11188: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11189: 			FGameplayEventData EventData;
11190: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
11191: 			EventData.Instigator = this;
11192: 			EventData.Target = Character;
11193: 
11194: 			// Buscar el tag de posiciÃ³n del jugador en el array
11195: 			FGameplayTag* PositionTag = nullptr;
11196: 			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
11197: 			{
11198: 				if (Entry.Player == Character)
11199: 				{
11200: 					PositionTag = &Entry.PositionTag;
11201: 					break;
11202: 				}
11203: 			}
11204: 			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
11205: 			{
11206: 				EventData.OptionalObject = PrimaryAnimMontage;
11207: 			} else
11208: 			{
11209: 				EventData.OptionalObject = SecondaryAnimMontage;
11210: 			}
11211: 
11212: 
11213: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
11214: 		}
11215: 
11216: 
11217: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
11218: 	}
11219: }
11220: 
11221: void ARitualAltar::HandleInputSuccess(ACharacter* Player)
11222: {
11223: 	if (!HasAuthority() || !Player)
11224: 	{
11225: 		return;
11226: 	}
11227: 
11228: 	// Cancel the input timer
11229: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
11230: 
11231: 	// Advance to the next input
11232: 	CurrentSequenceIndex++;
11233: 
11234: 	// Send success feedback
11235: 	Multicast_OnInputSuccess(Player);
11236: 
11237: 	// Check if the sequence is complete
11238: 	if (CurrentSequenceIndex >= InputSequence.Num())
11239: 	{
11240: 		// Ritual succeeded
11241: 		CurrentRitualState = EInteractionState::Succeeded;
11242: 		bRitualCompleted = true;
11243: 		bRitualWasSuccessful = true;
11244: 
11245: 		// Update turn data with final state
11246: 		UpdateTurnData();
11247: 
11248: 		// Broadcast state and completion on server for local UI updates
11249: 		BroadcastRitualStateChanged();
11250: 		BroadcastRitualCompleted();
11251: 
11252: 		// Spawn reward and notify
11253: 		SpawnReward();
11254: 		Multicast_OnRitualSucceeded();
11255: 
11256: 		// Clean up
11257: 		CleanupRitual();
11258: 	}
11259: 	else
11260: 	{
11261: 		// Move to the next player's turn (this updates CurrentActivePlayer)
11262: 		AdvanceToNextPlayer();
11263: 
11264: 		// Start the input timer (this updates CurrentInputTimer)
11265: 		StartInputTimer();
11266: 
11267: 		// Now update turn data with all the new values
11268: 		UpdateTurnData();
11269: 	}
11270: }
11271: 
11272: void ARitualAltar::HandleInputFailure(ACharacter* Player)
11273: {
11274: 	if (!HasAuthority() || !Player)
11275: 	{
11276: 		return;
11277: 	}
11278: 
11279: 	// Cancel the input timer
11280: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
11281: 
11282: 	// Increase corruption
11283: 	CorruptionAmount += CorruptionIncreasePerFail;
11284: 	// Broadcast corruption change on server for local UI updates
11285: 	BroadcastCorruptionChanged();
11286: 
11287: 	// DO NOT advance to the next input on failure - only on success
11288: 	// CurrentSequenceIndex++; // REMOVED: Failed inputs should not advance the sequence
11289: 
11290: 	// Apply age penalty to the player
11291: 	ApplyAgePenalty(Player);
11292: 
11293: 	// Send failure feedback
11294: 	Multicast_OnInputFailed(Player);
11295: 
11296: 	// Check if corruption has reached the maximum
11297: 	if (CorruptionAmount >= MaxCorruption)
11298: 	{
11299: 		// Ritual failed catastrophically
11300: 		CurrentRitualState = EInteractionState::FailedCatastrophically;
11301: 		bRitualCompleted = true;
11302: 		bRitualWasSuccessful = false;
11303: 
11304: 		// Update turn data with final state
11305: 		UpdateTurnData();
11306: 
11307: 		// Broadcast state and completion on server for local UI updates
11308: 		BroadcastRitualStateChanged();
11309: 		BroadcastRitualCompleted();
11310: 
11311: 		// Apply catastrophic penalties to all players
11312: 		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
11313: 		{
11314: 			if (ParticipatingPlayer)
11315: 			{
11316: 				ApplyAgePenalty(ParticipatingPlayer, true);
11317: 			}
11318: 		}
11319: 
11320: 		// Spawn demon and notify
11321: 		SpawnDemon();
11322: 		Multicast_OnRitualCatastrophicFail();
11323: 
11324: 		// Clean up
11325: 		CleanupRitual();
11326: 	}
11327: 	else
11328: 	{
11329: 		// Move to the next player's turn (this updates CurrentActivePlayer)
11330: 		AdvanceToNextPlayer();
11331: 
11332: 		// Start the input timer (this updates CurrentInputTimer)
11333: 		StartInputTimer();
11334: 
11335: 		// Now update turn data with all the new values
11336: 		UpdateTurnData();
11337: 	}
11338: }
11339: 
11340: void ARitualAltar::StartInputTimer()
11341: {
11342: 	if (!HasAuthority())
11343: 	{
11344: 		return;
11345: 	}
11346: 
11347: 	// Calculate the time window for this input, possibly scaling down as the sequence progresses
11348: 	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
11349: 	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f)); // Up to 50% shorter at the end
11350: 
11351: 	// Set the timer value for client display
11352: 	CurrentInputTimer = ScaledTimeWindow;
11353: 
11354: 
11355: 	// Start the timer
11356: 	GetWorldTimerManager().SetTimer(
11357: 		InputTimerHandle,
11358: 		this,
11359: 		&ARitualAltar::OnInputTimerExpired,
11360: 		ScaledTimeWindow,
11361: 		false
11362: 	);
11363: 
11364: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"),
11365: 		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"),
11366: 		CurrentSequenceIndex, InputSequence.Num()-1);
11367: 
11368: 	// Log the expected input
11369: 	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
11370: 	{
11371: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"),
11372: 			*InputSequence[CurrentSequenceIndex].ToString());
11373: 	}
11374: }
11375: 
11376: void ARitualAltar::OnInputTimerExpired()
11377: {
11378: 	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
11379: 	{
11380: 		return;
11381: 	}
11382: 
11383: 	// If we get here, the player failed to input in time
11384: 	if (CurrentActivePlayer)
11385: 	{
11386: 		HandleInputFailure(CurrentActivePlayer);
11387: 	}
11388: 	else
11389: 	{
11390: 		// Fallback in case CurrentActivePlayer is null
11391: 		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
11392: 		AdvanceToNextPlayer();
11393: 		StartInputTimer();
11394: 	}
11395: }
11396: 
11397: void ARitualAltar::AdvanceToNextPlayer()
11398: {
11399: 	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
11400: 	{
11401: 		return;
11402: 	}
11403: 
11404: 
11405: 	// Find the index of the current active player
11406: 	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
11407: 
11408: 	// If not found or at the end, wrap around to the first player
11409: 	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
11410: 	{
11411: 		CurrentPlayerIndex = 0;
11412: 	}
11413: 	else
11414: 	{
11415: 		CurrentPlayerIndex++;
11416: 	}
11417: 
11418: 	// Safety check for eligible players
11419: 	int32 StartIndex = CurrentPlayerIndex;
11420: 	bool bFoundEligiblePlayer = false;
11421: 
11422: 	// Loop through players starting from CurrentPlayerIndex until we find an eligible one
11423: 	do
11424: 	{
11425: 		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
11426: 		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
11427: 		{
11428: 			CurrentActivePlayer = NextPlayer;
11429: 			bFoundEligiblePlayer = true;
11430: 			break;
11431: 		}
11432: 
11433: 		// Move to next player
11434: 		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
11435: 	}
11436: 	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
11437: 
11438: 	// If we couldn't find an eligible player, just use the first one as fallback
11439: 	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
11440: 	{
11441: 		CurrentActivePlayer = ParticipatingPlayers[0];
11442: 	}
11443: }
11444: 
11445: bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
11446: {
11447: 	if (!Player)
11448: 	{
11449: 		return false;
11450: 	}
11451: 
11452: 	// Check if the player is still in a ritual position
11453: 	bool bIsInPosition = false;
11454: 	for (const ABaseInteractionPosition* Position : InteractionPositions)
11455: 	{
11456: 		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
11457: 		{
11458: 			bIsInPosition = true;
11459: 			break;
11460: 		}
11461: 	}
11462: 
11463: 	// Check if the player has the OccupyingPosition tag
11464: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11465: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
11466: 	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
11467: 
11468: 	return bIsInPosition && bHasPositionTag;
11469: }
11470: 
11471: 
11472: void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
11473: {
11474: 	if (!HasAuthority() || !Player)
11475: 	{
11476: 		return;
11477: 	}
11478: 
11479: 	// Get the player's ASC
11480: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
11481: 	if (!ASC)
11482: 	{
11483: 		return;
11484: 	}
11485: 
11486: 	// TODO: Apply aging GameplayEffect
11487: 	// This would typically be implemented using a GameplayEffect that increases age
11488: 	// The effect class would be defined elsewhere and referenced here
11489: 
11490: 	// Pseudo-code:
11491: 	// TSubclassOf<UGameplayEffect> AgeEffect = bCatastrophic ? CatastrophicAgeEffectClass : StandardAgeEffectClass;
11492: 	// if (AgeEffect)
11493: 	// {
11494: 	//     FGameplayEffectContextHandle ContextHandle = ASC->MakeEffectContext();
11495: 	//     ContextHandle.AddSourceObject(this);
11496: 	//     FGameplayEffectSpecHandle SpecHandle = ASC->MakeOutgoingSpec(AgeEffect, 1.0f, ContextHandle);
11497: 	//     ASC->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
11498: 	// }
11499: 
11500: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"),
11501: 		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
11502: }
11503: 
11504: void ARitualAltar::SpawnReward()
11505: {
11506: 	if (!HasAuthority())
11507: 	{
11508: 		return;
11509: 	}
11510: 
11511: 	// TODO: Implement reward spawning logic
11512: 	// This would typically create a special item and add it to inventory
11513: 
11514: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
11515: }
11516: 
11517: void ARitualAltar::SpawnDemon()
11518: {
11519: 	if (!HasAuthority())
11520: 	{
11521: 		return;
11522: 	}
11523: 
11524: 	// TODO: Implement demon spawning logic
11525: 	// This would typically spawn an enemy character
11526: 
11527: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
11528: }
11529: 
11530: void ARitualAltar::CleanupRitual()
11531: {
11532: 	if (!HasAuthority())
11533: 	{
11534: 		return;
11535: 	}
11536: 
11537: 	// Clear timers
11538: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
11539: 
11540: 	// Reset ritual-specific variables
11541: 	CurrentSequenceIndex = 0;
11542: 	InputSequence.Empty();
11543: 	CurrentActivePlayer = nullptr;
11544: 
11545: 	// Don't reset corruption or state - these should persist for UI feedback
11546: 
11547: 	// Reset positions? This depends on design - maybe players stay in position
11548: 
11549: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up"));
11550: }
11551: 
11552: float ARitualAltar::GetCurrentSequenceProgress() const
11553: {
11554: 	if (InputSequence.Num() == 0)
11555: 	{
11556: 		return 0.0f;
11557: 	}
11558: 
11559: 	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
11560: }
11561: 
11562: FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
11563: {
11564: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
11565: 	{
11566: 
11567: 		return FGameplayTag();
11568: 	}
11569: 
11570: 	return InputSequence[CurrentSequenceIndex];
11571: }
11572: 
11573: 
11574: 
11575: FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
11576: {
11577: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11578: 
11579: 	switch (Input)
11580: 	{
11581: 	case ERitualInput::Up:
11582: 		return WitchPtGameplayTags.Ritual_Input_Up;
11583: 	case ERitualInput::Down:
11584: 		return WitchPtGameplayTags.Ritual_Input_Down;
11585: 	case ERitualInput::Left:
11586: 		return WitchPtGameplayTags.Ritual_Input_Left;
11587: 	case ERitualInput::Right:
11588: 		return WitchPtGameplayTags.Ritual_Input_Right;
11589: 	default:
11590: 		return FGameplayTag();
11591: 	}
11592: }
11593: 
11594: ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
11595: {
11596: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11597: 
11598: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
11599: 		return ERitualInput::Up;
11600: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
11601: 		return ERitualInput::Down;
11602: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
11603: 		return ERitualInput::Left;
11604: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
11605: 		return ERitualInput::Right;
11606: 
11607: 	return ERitualInput::None;
11608: }
11609: 
11610: void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
11611: {
11612: 	if (Character)
11613: 	{
11614: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
11615: 		if (ASC)
11616: 		{
11617: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
11618: 			FGameplayEventData EventData;
11619: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
11620: 			EventData.Instigator = this;
11621: 			EventData.Target = Character;
11622: 
11623: 			EventData.OptionalObject = FailedAnimMontage;
11624: 
11625: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
11626: 
11627: 		}
11628: 
11629: 
11630: 
11631: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
11632: 	}
11633: 
11634: 
11635: }
11636: 
11637: 
11638: 
11639: void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
11640: {
11641: 	// Print the local role por the RitualAltar and the Player
11642: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
11643: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
11644: 	if (Player->IsLocallyControlled())
11645: 	{
11646: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
11647: 	}
11648: 	else
11649: 	{
11650: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
11651: 	}
11652: 
11653: 	if (!Player || !Position || !HasAuthority())
11654: 	{
11655: 		return;
11656: 	}
11657: 
11658: 
11659: 	if (Position->IsOccupied())
11660: 	{
11661: 		//broadcast
11662: 		return;
11663: 	}
11664: 	Position->SetOccupied(Player);
11665: 
11666: 	bool bFound = false;
11667: 	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
11668: 	{
11669: 		if (Entry.Player == Player)
11670: 		{
11671: 			Entry.PositionTag = Position->GetPositionTag();
11672: 			bFound = true;
11673: 			break;
11674: 		}
11675: 	}
11676: 	if (!bFound)
11677: 	{
11678: 		FPlayerPositionTagEntry NewEntry;
11679: 		NewEntry.Player = Player;
11680: 		NewEntry.PositionTag = Position->GetPositionTag();
11681: 		PlayerPositionTags.Add(NewEntry);
11682: 	}
11683: 
11684: 	// Add to participating players if not already there
11685: 	if (!ParticipatingPlayers.Contains(Player))
11686: 	{
11687: 		ParticipatingPlayers.Add(Player);
11688: 	}
11689: 	CurrentRitualState = EInteractionState::WaitingForPlayers;
11690: 
11691: 	// Broadcast state change on server for local UI updates (OnRep will handle clients)
11692: 	if (HasAuthority())
11693: 	{
11694: 		BroadcastRitualStateChanged();
11695: 	}
11696: 
11697: 	// Update ready players data
11698: 	UpdateReadyPlayersData();
11699: 
11700: 	// Call the ritual state delegate for Listen Server
11701: 	if (Player->GetLocalRole() == ROLE_Authority && Player->IsLocallyControlled()) // Im the listen server
11702: 	{
11703: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
11704: 		if (!PC->HasRitualWidgetInitialized(this))
11705: 		{
11706: 			PC->LocalInitializeRitualUserWidget(this);
11707: 		}
11708: 	} else if (Player->HasAuthority() && !Player->IsLocallyControlled()) // The call is from the client
11709: 	{
11710: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
11711: 		if (!PC->HasRitualWidgetInitialized(this))
11712: 		{
11713: 			PC->Client_InitializeRitualUserWidget(this);
11714: 		}
11715: 	}
11716: }
11717: 
11718: void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
11719: {
11720: 	// Client-side feedback for ritual success
11721: 	// This would typically play sounds, particle effects, etc.
11722: 
11723: 	// Example: Play celebratory effects at altar location
11724: 	// UGameplayStatics::PlaySoundAtLocation(this, SuccessSound, GetActorLocation());
11725: 	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SuccessParticles, GetActorTransform());
11726: 
11727: 	// Set completion status for replication
11728: 	bRitualCompleted = true;
11729: 	bRitualWasSuccessful = true;
11730: 
11731: 	DestroyAltarPositions();
11732: 
11733: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback"));
11734: }
11735: 
11736: void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
11737: {
11738: 	// Client-side feedback for catastrophic failure
11739: 	// This would typically play sounds, particle effects, etc.
11740: 
11741: 	// Example: Play ominous effects at altar location
11742: 	// UGameplayStatics::PlaySoundAtLocation(this, CatastrophicFailSound, GetActorLocation());
11743: 	// UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), CatastrophicFailParticles, GetActorTransform());
11744: 
11745: 	// Set completion status for replication
11746: 	bRitualCompleted = true;
11747: 	bRitualWasSuccessful = false;
11748: 
11749: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback"));
11750: }
11751: 
11752: float ARitualAltar::GetCorruptionPercentage() const
11753: {
11754: 	if (MaxCorruption == 0.0f)
11755: 	{
11756: 		return 0.0f;
11757: 	}
11758: 
11759: 	return CorruptionAmount / MaxCorruption;
11760: }
11761: </file>
11762: 
11763: </files>
```

## File: repomix.config.json5
```json5
 1: {
 2:   "output": {
 3:     "style": "markdown",
 4:     "filePath": "AItools/repomix-output.md",
 5:     "removeComments": true,
 6:     "showLineNumbers": true,
 7:     "topFilesLength": 10
 8:   },
 9:   "ignore": {
10:     "customPatterns": ["*.test.ts", "docs/**"]
11:   }
12: }
```

## File: Source/WitchPT.Target.cs
```csharp
 1: using UnrealBuildTool;
 2: using System.Collections.Generic;
 3: 
 4: public class WitchPTTarget : TargetRules
 5: {
 6: 	public WitchPTTarget(TargetInfo Target) : base(Target)
 7: 	{
 8: 		Type = TargetType.Game;
 9: 		DefaultBuildSettings = BuildSettingsVersion.V5;
10: 
11: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
12: 	}
13: }
```

## File: Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
```cpp
  1: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/PlayerController.h"
  4: #include "Engine/World.h"
  5: #include "DrawDebugHelpers.h"
  6: #include "TimerManager.h"
  7: #include "GameFramework/Character.h"
  8: #include "Camera/CameraComponent.h"
  9: 
 10: UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer)
 12: {
 13: 	bTickingTask = true;
 14: 	TraceDistance = 500.0f;
 15: 	TraceRadius = 10.0f;
 16: 	bTraceComplex = false;
 17: 	bIgnoreBlockingHits = false;
 18: 	bShowDebug = false;
 19: 	LastHitLocation = FVector::ZeroVector;
 20: 	LastHitNormal = FVector::UpVector;
 21: }
 22: 
 23: UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
 24: 	UGameplayAbility* OwningAbility,
 25: 	float TraceDistance,
 26: 	float TraceRadius,
 27: 	bool TraceComplex,
 28: 	bool bIgnoreBlockingHits,
 29: 	bool bShowDebug)
 30: {
 31: 	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
 32: 
 33: 	MyObj->TraceDistance = TraceDistance;
 34: 	MyObj->TraceRadius = TraceRadius;
 35: 	MyObj->bTraceComplex = TraceComplex;
 36: 	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
 37: 	MyObj->bShowDebug = bShowDebug;
 38: 
 39: 	return MyObj;
 40: }
 41: 
 42: void UAT_WaitForPlacementLocation_SLT::Activate()
 43: {
 44: 	Super::Activate();
 45: 
 46: 
 47: 	SetWaitingOnAvatar();
 48: 
 49: 
 50: 	PerformTrace();
 51: }
 52: 
 53: void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
 54: {
 55: 
 56: 	UWorld* World = GetWorld();
 57: 	if (World)
 58: 	{
 59: 		World->GetTimerManager().ClearTimer(TraceTimerHandle);
 60: 	}
 61: 
 62: 	Super::OnDestroy(bInOwnerFinished);
 63: }
 64: 
 65: void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
 66: {
 67: 	Super::TickTask(DeltaTime);
 68: 
 69: 
 70: 	PerformTrace();
 71: }
 72: 
 73: void UAT_WaitForPlacementLocation_SLT::PerformTrace()
 74: {
 75: 	if (!Ability || !Ability->GetCurrentActorInfo())
 76: 	{
 77: 		return;
 78: 	}
 79: 
 80: 
 81: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 82: 	if (!PC)
 83: 	{
 84: 		return;
 85: 	}
 86: 
 87: 
 88: 	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
 89: 	if (!Character)
 90: 	{
 91: 		return;
 92: 	}
 93: 
 94: 
 95: 	FVector TraceStart;
 96: 	FVector TraceDirection;
 97: 
 98: 
 99: 	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
100: 	if (CameraComponent)
101: 	{
102: 
103: 		TraceStart = CameraComponent->GetComponentLocation();
104: 		TraceDirection = CameraComponent->GetForwardVector();
105: 	}
106: 	else
107: 	{
108: 
109: 		FRotator ControllerRotation = PC->GetControlRotation();
110: 		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
111: 		TraceDirection = ControllerRotation.Vector();
112: 	}
113: 
114: 	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
115: 
116: 
117: 	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
118: 	QueryParams.AddIgnoredActor(Character);
119: 
120: 
121: 	ECollisionChannel TraceChannel = ECC_Visibility;
122: 
123: 
124: 	FHitResult HitResult;
125: 	bool bHit = false;
126: 
127: 
128: 	if (TraceRadius > 0.0f)
129: 	{
130: 		bHit = GetWorld()->SweepSingleByChannel(
131: 			HitResult,
132: 			TraceStart,
133: 			TraceEnd,
134: 			FQuat::Identity,
135: 			TraceChannel,
136: 			FCollisionShape::MakeSphere(TraceRadius),
137: 			QueryParams
138: 		);
139: 	}
140: 	else
141: 	{
142: 		bHit = GetWorld()->LineTraceSingleByChannel(
143: 			HitResult,
144: 			TraceStart,
145: 			TraceEnd,
146: 			TraceChannel,
147: 			QueryParams
148: 		);
149: 	}
150: 
151: 
152: 	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
153: 	{
154: 
155: 		LastHitLocation = HitResult.ImpactPoint;
156: 		LastHitNormal = HitResult.ImpactNormal;
157: 
158: 
159: 		if (ShouldBroadcastAbilityTaskDelegates())
160: 		{
161: 			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
162: 		}
163: 	}
164: 
165: 
166: 	if (bShowDebug)
167: 	{
168: 		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
169: 
170: 		if (bHit)
171: 		{
172: 
173: 			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
174: 
175: 
176: 			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
177: 		}
178: 	}
179: }
```

## File: Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
```cpp
 1: #include "AbilitySystem/Interaction/InteractionStatics.h"
 2: 
 3: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 4: #include "Engine/OverlapResult.h"
 5: 
 6: UInteractionStatics::UInteractionStatics()
 7: 	: Super(FObjectInitializer::Get())
 8: {
 9: }
10: 
11: AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
12: {
13: 	if (UObject* Object = InteractableTarget.GetObject())
14: 	{
15: 		if (AActor* Actor = Cast<AActor>(Object))
16: 		{
17: 			return Actor;
18: 		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
19: 		{
20: 			AActor* ActorToReturn = ActorComponent->GetOwner();
21: 			return ActorToReturn;
22: 		} else
23: 		{
24: 			unimplemented()
25: 		}
26: 	}
27: 	return nullptr;
28: }
29: 
30: void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
31: 	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
32: {
33: 
34: 	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
35: 	if (InteractableActor)
36: 	{
37: 		OutInteractableTargets.Add(InteractableActor);
38: 	}
39: 
40: 
41: 	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
42: 	for (UActorComponent* InteractableComponent : InteractableComponents)
43: 	{
44: 		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
45: 	}
46: }
47: 
48: void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
49: {
50: 	for (const FOverlapResult& Overlap : OverlapResults)
51: 	{
52: 		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
53: 		if (InteractableActor)
54: 		{
55: 			OutInteractableTargets.AddUnique(InteractableActor);
56: 		}
57: 
58: 		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
59: 		if (InteractableComponent)
60: 		{
61: 			OutInteractableTargets.AddUnique(InteractableComponent);
62: 		}
63: 	}
64: }
65: 
66: void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
67: {
68: 	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
69: 	if (InteractableActor)
70: 	{
71: 		OutInteractableTargets.AddUnique(InteractableActor);
72: 	}
73: 
74: 	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
75: 	if (InteractableComponent)
76: 	{
77: 		OutInteractableTargets.AddUnique(InteractableComponent);
78: 	}
79: }
```

## File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
```cpp
1: #include "AbilitySystem/WitchPTAbilitySystemGlobals.h"
```

## File: Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
```cpp
1: #include "Game/WitchPTGameModeBase.h"
```

## File: Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
```cpp
1: #include "Input/WitchPTInputComponent.h"
```

## File: Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
```cpp
 1: #include "Input/WitchPTInputConfig.h"
 2: 
 3: const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
 4: {
 5: 	for (const FWitchPTInputAction& Pair: AbilityInputActions)
 6: 	{
 7: 		if (InputTag == Pair.InputTag)
 8: 		{
 9: 			return Pair.InputAction;
10: 		}
11: 	}
12: 	if (bLogNotFound)
13: 	{
14: 		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
15: 	}
16: 	return nullptr;
17: 
18: }
```

## File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
```cpp
1: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
```

## File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
```cpp
1: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
```

## File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
```cpp
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
2: 
3: #include "Inventory/WitchPTInventoryItemInstance.h"
4: 
5: void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
6: {
7: 
8: }
```

## File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
```cpp
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
```

## File: Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
```cpp
 1: #include "Inventory/InventoryFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 7: 
 8: UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
 9: {
10: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
11: 	{
12: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
13: 		{
14: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
15: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
16: 			UAttributeSet* AS = PS->GetAttributeSet();
17: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
18: 
19: 			return WitchPTHUD->SetInventoryWidgetController(WCParams);
20: 		}
21: 	}
22: 	return nullptr;
23: }
```

## File: Source/WitchPT/Private/Item/Item.cpp
```cpp
 1: #include "Item/Item.h"
 2: 
 3: 
 4: 
 5: AItem::AItem()
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AItem::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AItem::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
25: {
26: 	OptionBuilder.AddInteractionOption(Option);
27: }
```

## File: Source/WitchPT/Private/Item/MechanicsInterface.cpp
```cpp
1: #include "Item/MechanicsInterface.h"
```

## File: Source/WitchPT/Private/Item/PositionInterface.cpp
```cpp
1: #include "Item/PositionInterface.h"
```

## File: Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
```cpp
 1: #include "UI/WidgetControllers/OverlayWidgetController.h"
 2: 
 3: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAttributeSet.h"
 5: 
 6: void UOverlayWidgetController::BroadcastInitialValues()
 7: {
 8: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
 9: 
10: 	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
11: 	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
12: 	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
13: 	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
14: 	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
15: 	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
16: }
17: 
18: void UOverlayWidgetController::BindCallbacksToDependencies()
19: {
20: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
21: 
22: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
23: 	{
24: 		OnHealthChanged.Broadcast(Data.NewValue);
25: 	});
26: 
27: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
28: 	{
29: 		OnMaxHealthChanged.Broadcast(Data.NewValue);
30: 	});
31: 
32: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
33: 	{
34: 		OnStaminaChanged.Broadcast(Data.NewValue);
35: 	});
36: 
37: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
38: 	{
39: 		OnMaxStaminaChanged.Broadcast(Data.NewValue);
40: 	});
41: 
42: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
43: 	{
44: 		OnAgeChanged.Broadcast(Data.NewValue);
45: 	});
46: 
47: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
48: 	{
49: 		OnMaxAgeChanged.Broadcast(Data.NewValue);
50: 	});
51: 
52: 	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
53: 
54: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
55: 
56: 
57: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
58: 
59: 		[this](const FGameplayTagContainer& AssetTags)
60: 	{
61: 		for (const auto& Tag : AssetTags)
62: 		{
63: 
64: 			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
65: 			if (Tag.MatchesTag(ParentMessageGameplayTag))
66: 			{
67: 
68: 
69: 				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
70: 				OnMessageWidgetRow.Broadcast(*Row);
71: 
72: 			}
73: 
74: 		}
75: 	});
76: 
77: 
78: 
79: }
80: void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
81: {
82: 
83: }
```

## File: Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
```cpp
 1: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 2: 
 3: void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
 4: {
 5: 	PlayerController = WCParams.PlayerController;
 6: 	PlayerState = WCParams.PlayerState;
 7: 	AbilitySystemComponent = WCParams.AbilitySystemComponent;
 8: 	AttributeSet = WCParams.AttributeSet;
 9: }
10: 
11: void UWitchPTWidgetController::BroadcastInitialValues()
12: {
13: }
14: 
15: void UWitchPTWidgetController::BindCallbacksToDependencies()
16: {
17: }
```

## File: Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
```cpp
1: #include "UI/Widgets/Inventory/RitualUserWidget.h"
```

## File: Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
```cpp
1: #include "UI/Widgets/PointerWidget.h"
```

## File: Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
```cpp
1: #include "UI/Widgets/WitchPTUserWidget.h"
2: 
3: void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
4: {
5: 	WidgetController = InWidgetController;
6: 	OnWidgetControllerSet();
7: }
```

## File: Source/WitchPT/Private/WitchPTAssetManager.cpp
```cpp
 1: #include "WitchPTAssetManager.h"
 2: 
 3: #include "AbilitySystemGlobals.h"
 4: #include "FWitchPTGameplayTags.h"
 5: 
 6: UWitchPTAssetManager& UWitchPTAssetManager::Get()
 7: {
 8: 	check(GEngine)
 9: 	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
10: 	return *WitchPtAssetManager;
11: }
12: 
13: void UWitchPTAssetManager::StartInitialLoading()
14: {
15: 	Super::StartInitialLoading();
16: 	FWitchPTGameplayTags::InitializeGameplayTags();
17: 
18: 
19: 
20: 
21: 
22: 	UAbilitySystemGlobals::Get().InitGlobalData();
23: 
24: }
```

## File: Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AT_WaitForPlacementLocation_SLT.generated.h"
 6: 
 7: 
 8: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);
 9: 
10: 
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
25: 	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
26: 		UGameplayAbility* OwningAbility,
27: 		float TraceDistance = 500.0f,
28: 		float TraceRadius = 10.0f,
29: 		bool TraceComplex = false,
30: 		bool bIgnoreBlockingHits = false,
31: 		bool bShowDebug = false);
32: 
33: 
34: 	UPROPERTY(BlueprintAssignable)
35: 	FPlacementLocationFound OnLocationFound;
36: 
37: 
38: 	virtual void Activate() override;
39: 
40: 
41: 	virtual void OnDestroy(bool bInOwnerFinished) override;
42: 
43: private:
44: 
45: 	void PerformTrace();
46: 
47: 
48: 	void TickTask(float DeltaTime);
49: 
50: 
51: 	FTimerHandle TraceTimerHandle;
52: 
53: 
54: 	float TraceDistance;
55: 
56: 
57: 	float TraceRadius;
58: 
59: 
60: 	bool bTraceComplex;
61: 
62: 
63: 	bool bIgnoreBlockingHits;
64: 
65: 
66: 	bool bShowDebug;
67: 
68: 
69: 	FVector LastHitLocation;
70: 
71: 
72: 	FVector LastHitNormal;
73: };
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionQuery.generated.h"
 6: 
 7: 
 8: 
 9: USTRUCT(BlueprintType)
10: struct FInteractionQuery
11: {
12: 	GENERATED_BODY()
13: 
14: public:
15: 
16: 	UPROPERTY(BlueprintReadWrite)
17: 	TWeakObjectPtr<AActor> RequestingAvatar;
18: 
19: 
20: 	UPROPERTY(BlueprintReadWrite)
21: 	TWeakObjectPtr<AController> RequestingController;
22: 
23: 
24: 	UPROPERTY(BlueprintReadWrite)
25: 	TWeakObjectPtr<UObject> OptionalObjectData;
26: };
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "InteractionStatics.generated.h"
 6: 
 7: template <typename InterfaceType> class TScriptInterface;
 8: class AActor;
 9: class IInteractableTarget;
10: class UObject;
11: 
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UInteractionStatics();
21: 
22: public:
23: 	UFUNCTION(BlueprintCallable)
24: 	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);
25: 
26: 	UFUNCTION(BlueprintCallable)
27: 	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
28: 	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
29: 	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
30: };
```

## File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemGlobals.h"
 5: #include "WitchPTAbilitySystemGlobals.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
12: {
13: 	GENERATED_BODY()
14: };
```

## File: Source/WitchPT/Public/Character/WitchPTEnemy.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "WitchPTEnemy.generated.h"
 6: 
 7: UCLASS()
 8: class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
 9: {
10: 	GENERATED_BODY()
11: 
12: public:
13: 
14: 	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);
15: 
16: protected:
17: 
18: 	virtual void BeginPlay() override;
19: 
20: public:
21: 
22: 	virtual void Tick(float DeltaTime) override;
23: 
24: 
25: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
26: };
```

## File: Source/WitchPT/Public/Game/WitchPTGameModeBase.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/GameModeBase.h"
 5: #include "WitchPTGameModeBase.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
12: {
13: 	GENERATED_BODY()
14: };
```

## File: Source/WitchPT/Public/Input/WitchPTInputComponent.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "EnhancedInputComponent.h"
 5: #include "WitchPTInputConfig.h"
 6: 
 7: #include "WitchPTInputComponent.generated.h"
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
17: 	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);
18: 
19: };
20: 
21: template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
22: void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
23: 	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
24: {
25: 	check(InputConfig);
26: 	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
27: 	{
28: 		if (Action.InputAction && Action.InputTag.IsValid())
29: 		{
30: 			if (PressedFunc)
31: 			{
32: 				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
33: 			}
34: 			if (ReleasedFunc)
35: 			{
36: 				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
37: 			}
38: 			if (HeldFunc)
39: 			{
40: 				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
41: 			}
42: 		}
43: 	}
44: 
45: }
```

## File: Source/WitchPT/Public/Input/WitchPTInputConfig.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Engine/DataAsset.h"
 6: #include "WitchPTInputConfig.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FWitchPTInputAction
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly)
13: 	const class UInputAction* InputAction = nullptr;
14: 
15: 	UPROPERTY(EditDefaultsOnly)
16: 	FGameplayTag InputTag = FGameplayTag();
17: };
18: 
19: 
20: 
21: UCLASS()
22: class WITCHPT_API UWitchPTInputConfig : public UDataAsset
23: {
24: 	GENERATED_BODY()
25: 	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
26: public:
27: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
28: 	TArray<FWitchPTInputAction> AbilityInputActions;
29: 
30: };
```

## File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryFragment_Stackable.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	int32 GetMaxStackSize() const { return MaxStackSize; }
17: 	int32 GetStackCount() const { return StackCount; }
18: 	void SetStackCount(int32 Count) { StackCount = Count; }
19: 
20: private:
21: 
22: 	UPROPERTY(EditAnywhere, Category = "Inventory")
23: 	int32 MaxStackSize{1};
24: 
25: 	UPROPERTY(EditAnywhere, Category = "Inventory")
26: 	int32 StackCount{1};
27: };
```

## File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryFragment_UIDetails.generated.h"
 7: 
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	FText Title;
18: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
19: 	FText Description;
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
21: 	TSubclassOf<UUserWidget> IconWidget;
22: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
23: 	FGameplayTag TierTag;
24: 
25: 
26: };
```

## File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FBaseIngredientData
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
13: 	FGameplayTag BaseLiquidTypeTag;
14: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
15: 	int32 DefaultChargesProvided;
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	float StabilityModifier;
18: };
19: 
20: USTRUCT(BlueprintType)
21: struct FPrincipalIngredientData
22: {
23: 	GENERATED_BODY()
24: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
25: 	FGameplayTag PrincipalEssenceTag;
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
27: 	float BasePotency;
28: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
29: 	float BaseDuration;
30: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
31: 	bool bIsRitualEssence;
32: };
33: 
34: USTRUCT(BlueprintType)
35: struct FModifierIngredientData
36: {
37: 	GENERATED_BODY()
38: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
39: 	FGameplayTagContainer ModifierEffectTags;
40: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
41: 	float PotencyModificationValue;
42: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
43: 	float DurationModificationValue;
44: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
45: 	FGameplayTag GrantedPropertyTag;
46: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
47: 	FGameplayTag AddedEffectTag;
48: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
49: 	float StrengthOfModifier;
50: 
51: };
52: UCLASS()
53: class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
54: {
55: 	GENERATED_BODY()
56: public:
57: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
58: 	FGameplayTag SlotUsageTag;
59: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
60: 	FGameplayTag TierTag;
61: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
62: 	FGameplayTag CategoryTag;
63: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
64: 	FBaseIngredientData BaseIngredientData;
65: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
66: 	FPrincipalIngredientData PrincipalIngredientData;
67: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
68: 	FModifierIngredientData ModifierIngredientData;
69: 
70: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
71: };
```

## File: Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "InventoryFunctionLibrary.generated.h"
 6: 
 7: class UInventoryWidgetController;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UFUNCTION(BlueprintPure, Category="Inventory")
17: 	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
18: };
```

## File: Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTInventoryFunctionLibrary.generated.h"
 6: 
 7: class UWitchPTInventoryItemDefinition;
 8: class UWitchPTInventoryItemFragment;
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
14: {
15: 	GENERATED_BODY()
16: 	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
17: 	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
18: };
```

## File: Source/WitchPT/Public/Item/Item.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 5: #include "GameFramework/Actor.h"
 6: #include "Item.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AItem : public AActor, public IInteractableTarget
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AItem();
16: 
17: protected:
18: 
19: 	virtual void BeginPlay() override;
20: 	UPROPERTY(EditAnywhere)
21: 	FInteractionOption Option;
22: 
23: public:
24: 
25: 	virtual void Tick(float DeltaTime) override;
26: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
27: };
```

## File: Source/WitchPT/Public/Item/PositionInterface.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Interface.h"
 5: #include "PositionInterface.generated.h"
 6: 
 7: class ARitualAltar;
 8: 
 9: UINTERFACE(MinimalAPI)
10: class UPositionInterface : public UInterface
11: {
12: 	GENERATED_BODY()
13: };
14: 
15: 
16: 
17: 
18: class WITCHPT_API IPositionInterface
19: {
20: 	GENERATED_BODY()
21: 
22: 
23: public:
24: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
25: 	ARitualAltar* GetRitualAltarActor() const;
26: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
27: 	bool IsOccupied();
28: };
```

## File: Source/WitchPT/Public/Systems/GameplayTagStack.cpp
```cpp
  1: #include "Systems/GameplayTagStack.h"
  2: 
  3: #include "UObject/Stack.h"
  4: 
  5: #include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)
  6: 
  7: 
  8: 
  9: 
 10: FString FGameplayTagStack::GetDebugString() const
 11: {
 12: 	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
 13: }
 14: 
 15: 
 16: 
 17: 
 18: void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
 19: {
 20: 	if (!Tag.IsValid())
 21: 	{
 22: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
 23: 		return;
 24: 	}
 25: 
 26: 	if (StackCount > 0)
 27: 	{
 28: 		for (FGameplayTagStack& Stack : Stacks)
 29: 		{
 30: 			if (Stack.Tag == Tag)
 31: 			{
 32: 				const int32 NewCount = Stack.StackCount + StackCount;
 33: 				Stack.StackCount = NewCount;
 34: 				TagToCountMap[Tag] = NewCount;
 35: 				MarkItemDirty(Stack);
 36: 				return;
 37: 			}
 38: 		}
 39: 
 40: 		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
 41: 		MarkItemDirty(NewStack);
 42: 		TagToCountMap.Add(Tag, StackCount);
 43: 	}
 44: }
 45: 
 46: void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
 47: {
 48: 	if (!Tag.IsValid())
 49: 	{
 50: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
 51: 		return;
 52: 	}
 53: 
 54: 
 55: 	if (StackCount > 0)
 56: 	{
 57: 		for (auto It = Stacks.CreateIterator(); It; ++It)
 58: 		{
 59: 			FGameplayTagStack& Stack = *It;
 60: 			if (Stack.Tag == Tag)
 61: 			{
 62: 				if (Stack.StackCount <= StackCount)
 63: 				{
 64: 					It.RemoveCurrent();
 65: 					TagToCountMap.Remove(Tag);
 66: 					MarkArrayDirty();
 67: 				}
 68: 				else
 69: 				{
 70: 					const int32 NewCount = Stack.StackCount - StackCount;
 71: 					Stack.StackCount = NewCount;
 72: 					TagToCountMap[Tag] = NewCount;
 73: 					MarkItemDirty(Stack);
 74: 				}
 75: 				return;
 76: 			}
 77: 		}
 78: 	}
 79: }
 80: 
 81: void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 82: {
 83: 	for (int32 Index : RemovedIndices)
 84: 	{
 85: 		const FGameplayTag Tag = Stacks[Index].Tag;
 86: 		TagToCountMap.Remove(Tag);
 87: 	}
 88: }
 89: 
 90: void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 91: {
 92: 	for (int32 Index : AddedIndices)
 93: 	{
 94: 		const FGameplayTagStack& Stack = Stacks[Index];
 95: 		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
 96: 	}
 97: }
 98: 
 99: void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
100: {
101: 	for (int32 Index : ChangedIndices)
102: 	{
103: 		const FGameplayTagStack& Stack = Stacks[Index];
104: 		TagToCountMap[Stack.Tag] = Stack.StackCount;
105: 	}
106: }
```

## File: Source/WitchPT/Public/Systems/GameplayTagStack.h
```
 1: #pragma once
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Net/Serialization/FastArraySerializer.h"
 5: 
 6: #include "GameplayTagStack.generated.h"
 7: 
 8: struct FGameplayTagStackContainer;
 9: struct FNetDeltaSerializeInfo;
10: 
11: 
12: 
13: 
14: USTRUCT(BlueprintType)
15: struct FGameplayTagStack : public FFastArraySerializerItem
16: {
17: 	GENERATED_BODY()
18: 
19: 	FGameplayTagStack()
20: 	{}
21: 
22: 	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
23: 		: Tag(InTag)
24: 		, StackCount(InStackCount)
25: 	{
26: 	}
27: 
28: 	FString GetDebugString() const;
29: 
30: private:
31: 	friend FGameplayTagStackContainer;
32: 
33: 	UPROPERTY()
34: 	FGameplayTag Tag;
35: 
36: 	UPROPERTY()
37: 	int32 StackCount = 0;
38: };
39: 
40: 
41: USTRUCT(BlueprintType)
42: struct FGameplayTagStackContainer : public FFastArraySerializer
43: {
44: 	GENERATED_BODY()
45: 
46: 	FGameplayTagStackContainer()
47: 
48: 	{
49: 	}
50: 
51: public:
52: 
53: 	void AddStack(FGameplayTag Tag, int32 StackCount);
54: 
55: 
56: 	void RemoveStack(FGameplayTag Tag, int32 StackCount);
57: 
58: 
59: 	int32 GetStackCount(FGameplayTag Tag) const
60: 	{
61: 		return TagToCountMap.FindRef(Tag);
62: 	}
63: 
64: 
65: 	bool ContainsTag(FGameplayTag Tag) const
66: 	{
67: 		return TagToCountMap.Contains(Tag);
68: 	}
69: 
70: 
71: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
72: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
73: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
74: 
75: 
76: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
77: 	{
78: 		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
79: 	}
80: 
81: private:
82: 
83: 	UPROPERTY()
84: 	TArray<FGameplayTagStack> Stacks;
85: 
86: 
87: 	TMap<FGameplayTag, int32> TagToCountMap;
88: };
89: 
90: template<>
91: struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
92: {
93: 	enum
94: 	{
95: 		WithNetDeltaSerializer = true,
96: 	};
97: };
```

## File: Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTWidgetController.h"
 6: #include "OverlayWidgetController.generated.h"
 7: class UWitchPTUserWidget;
 8: 
 9: USTRUCT()
10: struct FUIWidgetRow: public FTableRowBase
11: {
12: 	GENERATED_BODY()
13: 
14: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
15: 	FGameplayTag MessageGameplayTag = FGameplayTag();
16: 
17: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
18: 	FText Message = FText();
19: 
20: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
21: 	TSubclassOf<UWitchPTUserWidget> MessageWidget;
22: 
23: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
24: 	UTexture2D* Image = nullptr;
25: 
26: };
27: 
28: 
29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);
30: 
31: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);
32: 
33: UCLASS(BlueprintType, Blueprintable)
34: class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
35: {
36: 	GENERATED_BODY()
37: public:
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
48: 	virtual void BroadcastInitialValues() override;
49: 
50: 	virtual void BindCallbacksToDependencies() override;
51: 
52: 
53: 
54: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
55: 	FOnAttributeChangedSignature OnHealthChanged;
56: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
57: 	FOnAttributeChangedSignature OnMaxHealthChanged;
58: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
59: 	FOnAttributeChangedSignature OnStaminaChanged;
60: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
61: 	FOnAttributeChangedSignature OnMaxStaminaChanged;
62: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
63: 	FOnAttributeChangedSignature OnAgeChanged;
64: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
65: 	FOnAttributeChangedSignature OnMaxAgeChanged;
66: 
67: 	UPROPERTY(BlueprintAssignable, Category="Widget Data")
68: 	FOnMessageWidgetRowSignature OnMessageWidgetRow;
69: protected:
70: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
71: 	TObjectPtr<UDataTable> MessageWidgetDataTable;
72: 
73: 	template<typename T>
74: T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
75: };
76: 
77: template <typename T>
78: T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
79: {
80: 	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));
81: 
82: }
```

## File: Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "WitchPTWidgetController.generated.h"
 6: 
 7: class UAbilitySystemComponent;
 8: class UAttributeSet;
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: USTRUCT(BlueprintType)
24: struct FWidgetControllerParams
25: {
26: 	GENERATED_BODY()
27: 	FWidgetControllerParams() {};
28: 	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
29: 	:
30: 	PlayerController(PC),
31: 	PlayerState(PS),
32: 	AbilitySystemComponent(ASC),
33: 	AttributeSet(AS)
34: 	{}
35: 
36: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
37: 	TObjectPtr<APlayerController> PlayerController = nullptr;
38: 
39: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
40: 	TObjectPtr<APlayerState> PlayerState = nullptr;
41: 
42: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
43: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
44: 
45: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
46: 	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
47: 
48: };
49: UCLASS()
50: class WITCHPT_API UWitchPTWidgetController : public UObject
51: {
52: 	GENERATED_BODY()
53: public:
54: 	UFUNCTION(BlueprintCallable)
55: 	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
56: 
57: 	UFUNCTION(BlueprintCallable)
58: 	virtual void BroadcastInitialValues();
59: 	virtual void BindCallbacksToDependencies();
60: protected:
61: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
62: 	TObjectPtr<APlayerController> PlayerController;
63: 
64: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
65: 	TObjectPtr<APlayerState> PlayerState;
66: 
67: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
68: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
69: 
70: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
71: 	TObjectPtr<UAttributeSet> AttributeSet;
72: };
```

## File: Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "RitualUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: };
```

## File: Source/WitchPT/Public/UI/Widgets/PointerWidget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "PointerWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UPointerWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
17: 	void ShowPickupMessage(const FString& Message);
18: 
19: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
20: 	void HidePickupMessage();
21: };
```

## File: Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "WitchPTUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTUserWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 	UFUNCTION(BlueprintCallable)
16: 	void SetWidgetController(UObject* InWidgetController);
17: 	UPROPERTY(BlueprintReadOnly)
18: 	TObjectPtr<UObject> WidgetController;
19: 
20: 	UFUNCTION(BlueprintImplementableEvent)
21: 	void OnWidgetControllerSet();
22: };
```

## File: Source/WitchPT/Public/WitchPTAssetManager.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Engine/AssetManager.h"
 5: #include "WitchPTAssetManager.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAssetManager : public UAssetManager
12: {
13: 	GENERATED_BODY()
14: public:
15: 	static UWitchPTAssetManager& Get();
16: protected:
17: 	virtual void StartInitialLoading() override;
18: 
19: 
20: };
```

## File: Source/WitchPT/WitchPT.cpp
```cpp
1: #include "WitchPT.h"
2: #include "Modules/ModuleManager.h"
3: 
4: IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );
```

## File: Source/WitchPTEditor.Target.cs
```csharp
 1: using UnrealBuildTool;
 2: using System.Collections.Generic;
 3: 
 4: public class WitchPTEditorTarget : TargetRules
 5: {
 6: 	public WitchPTEditorTarget(TargetInfo Target) : base(Target)
 7: 	{
 8: 		Type = TargetType.Editor;
 9: 		DefaultBuildSettings = BuildSettingsVersion.V5;
10: 
11: 		ExtraModuleNames.AddRange( new string[] { "WitchPT" } );
12: 	}
13: }
```

## File: Config/DefaultInput.ini
```
 1: [/Script/Engine.InputSettings]
 2: -AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 3: -AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 4: -AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 5: -AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
 6: -AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 7: -AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 8: -AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
 9: +AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
10: +AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
11: +AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
12: +AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
13: +AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
14: +AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
15: +AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
16: +AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
17: +AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
18: +AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
19: +AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
20: +AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
21: +AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
22: +AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
23: +AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
24: +AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
25: +AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
26: +AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
27: +AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
28: +AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
29: +AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
30: +AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
31: +AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
32: +AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
33: +AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
34: +AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
35: +AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
36: +AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
37: +AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
38: +AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
39: +AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
40: +AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
41: +AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
42: +AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
43: +AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
44: +AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
45: +AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
46: +AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
47: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
48: +AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
49: +AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
50: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
51: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
52: +AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
53: +AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
54: +AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
55: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
56: +AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
57: +AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
58: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
59: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
60: +AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
61: bAltEnterTogglesFullscreen=True
62: bF11TogglesFullscreen=True
63: bUseMouseForTouch=False
64: bEnableMouseSmoothing=True
65: bEnableFOVScaling=True
66: bCaptureMouseOnLaunch=True
67: bEnableLegacyInputScales=True
68: bEnableMotionControls=True
69: bFilterInputByPlatformUser=False
70: bEnableInputDeviceSubsystem=True
71: bShouldFlushPressedKeysOnViewportFocusLost=True
72: bEnableDynamicComponentInputBinding=True
73: bAlwaysShowTouchInterface=False
74: bShowConsoleOnFourFingerTap=True
75: bEnableGestureRecognizer=False
76: bUseAutocorrect=False
77: DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
78: DefaultViewportMouseLockMode=LockOnCapture
79: FOVScale=0.011110
80: DoubleClickTime=0.200000
81: +ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Bottom)
82: +ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
83: +AxisMappings=(AxisName="Look Up / Down Gamepad",Scale=1.000000,Key=Gamepad_RightY)
84: +AxisMappings=(AxisName="Look Up / Down Mouse",Scale=-1.000000,Key=MouseY)
85: +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=Gamepad_LeftY)
86: +AxisMappings=(AxisName="Move Forward / Backward",Scale=-1.000000,Key=S)
87: +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=W)
88: +AxisMappings=(AxisName="Move Right / Left",Scale=-1.000000,Key=A)
89: +AxisMappings=(AxisName="Move Right / Left",Scale=1.000000,Key=D)
90: +AxisMappings=(AxisName="Move Right / Left",Scale=1.000000,Key=Gamepad_LeftX)
91: +AxisMappings=(AxisName="Turn Right / Left Gamepad",Scale=1.000000,Key=Gamepad_RightX)
92: +AxisMappings=(AxisName="Turn Right / Left Mouse",Scale=1.000000,Key=MouseX)
93: DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
94: DefaultInputComponentClass=/Script/WitchPT.WitchPTInputComponent
95: DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
96: -ConsoleKeys=Tilde
97: +ConsoleKeys=Tilde
```

## File: Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
```cpp
 1: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: 
 5: UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
 6: 	:Super(ObjectInitializer)
 7: {
 8: 	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
 9: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
10: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
11: 	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
12: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
13: }
14: 
15: void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
16:                                             const FGameplayAbilitySpec& Spec)
17: {
18: 	Super::OnGiveAbility(ActorInfo, Spec);
19: 	TryActivateAbilityOnSpawn(ActorInfo, Spec);
20: }
21: 
22: void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
23: 	const FGameplayAbilitySpec& Spec) const
24: {
25: 	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
26: 	{
27: 		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
28: 		AbilitySystem->TryActivateAbility(Spec.Handle);
29: 	}
30: }
```

## File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
```cpp
  1: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "Engine/OverlapResult.h"
  5: #include "Engine/World.h"
  6: #include "GameFramework/Controller.h"
  7: 
  8: #include "TimerManager.h"
  9: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 10: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 11: #include "AbilitySystem/Interaction/InteractionQuery.h"
 12: #include "AbilitySystem/Interaction/InteractionStatics.h"
 13: #include "WitchPT/WitchPT.h"
 14: 
 15: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
 16: UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
 17: 	: Super(ObjectInitializer)
 18: {
 19: }
 20: void UAbilityTask_GrantNearbyInteraction::Activate()
 21: {
 22: 
 23: 	SetWaitingOnAvatar();
 24: 	UWorld* World = GetWorld();
 25: 	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
 26: 
 27: }
 28: 
 29: void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
 30: {
 31: 	Super::OnGameplayTaskActivated(Task);
 32: 
 33: }
 34: 
 35: UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
 36:                                                                                                              float InteractionScanRange, float InteractionScanRate)
 37: {
 38: 
 39: 	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
 40: 	MyObj->InteractionScanRange = InteractionScanRange;
 41: 	MyObj->InteractionScanRate = InteractionScanRate;
 42: 	return MyObj;
 43: }
 44: 
 45: void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
 46: {
 47: 
 48: 	UWorld* World = GetWorld();
 49: 	if (World)
 50: 	{
 51: 		World->GetTimerManager().ClearTimer(QueryTimerHandle);
 52: 	}
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 	Super::OnDestroy(AbilityEnded);
 74: }
 75: 
 76: void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
 77: {
 78: 	UWorld* World = GetWorld();
 79: 	AActor* ActorOwner = GetAvatarActor();
 80: 
 81: 	if (World && ActorOwner)
 82: 	{
 83: 		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);
 84: 
 85: 		TArray<FOverlapResult> OverlapResults;
 86: 		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);
 87: 
 88: 		if (OverlapResults.Num() > 0)
 89: 		{
 90: 			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 91: 			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
 92: 
 93: 			FInteractionQuery InteractionQuery;
 94: 			InteractionQuery.RequestingAvatar = ActorOwner;
 95: 			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());
 96: 
 97: 			TArray<FInteractionOption> Options;
 98: 			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
 99: 			{
100: 				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
101: 				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
102: 			}
103: 
104: 
105: 			for (FInteractionOption& Option : Options)
106: 			{
107: 
108: 				if (Option.InteractionAbilityToGrant)
109: 				{
110: 
111: 					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
112: 					if (!InteractionAbilityCache.Find(ObjectKey))
113: 					{
114: 						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
115: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
116: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
117: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
118: 						InteractionAbilityCache.Add(ObjectKey, Handle);
119: 					}
120: 				}
121: 
122: 
123: 				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
124: 				{
125: 					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
126: 					if (!HoldInteractionAbilityCache.Find(ObjectKey))
127: 					{
128: 						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
129: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
130: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
131: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
132: 						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
133: 					}
134: 				}
135: 			}
136: 		}
137: 	}
138: }
```

## File: Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
```cpp
 1: #include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"
 2: 
 3: #include "AbilitySystem/Interaction/InteractionStatics.h"
 4: #include "Kismet/GameplayStatics.h"
 5: 
 6: UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
 7: 	: Super(ObjectInitializer)
 8: {
 9: }
10: 
11: UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
12: 	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
13: 	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
14: 	bool bShowDebug)
15: {
16: 	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
17: 	MyObj->InteractionScanRange = InteractionScanRange;
18: 	MyObj->InteractionScanRate = InteractionScanRate;
19: 	MyObj->StartLocation = StartLocation;
20: 	MyObj->InteractionQuery = InteractionQuery;
21: 	MyObj->TraceProfile = TraceProfile;
22: 	MyObj->bShowDebug = bShowDebug;
23: 
24: 	return MyObj;
25: }
26: void UAT_WaitForInteractable_SLT::Activate()
27: {
28: 	SetWaitingOnAvatar();
29: 
30: 	UWorld* World = GetWorld();
31: 	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
32: }
33: 
34: void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
35: {
36: 	if (UWorld* World = GetWorld())
37: 	{
38: 		World->GetTimerManager().ClearTimer(TimerHandle);
39: 	}
40: 
41: 	Super::OnDestroy(AbilityEnded);
42: }
43: 
44: void UAT_WaitForInteractable_SLT::PerformTrace()
45: {
46: 	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
47: 
48: 	if (!AvatarActor)
49: 	{
50: 		return;
51: 	}
52: 
53: 	UWorld* World = GetWorld();
54: 
55: 	TArray<AActor*> ActorsToIgnore;
56: 	ActorsToIgnore.Add(AvatarActor);
57: 
58: 	const bool bTraceComplex = false;
59: 	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
60: 	Params.AddIgnoredActors(ActorsToIgnore);
61: 	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
62: 	FVector2D ViewportSize;
63: 	GEngine->GameViewport->GetViewportSize(ViewportSize);
64: 	const FVector2D ViewportCenter = ViewportSize / 2.f;
65: 	FVector TraceStart;
66: 	FVector Forward;
67: 	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;
68: 
69: 
70: 	FVector TraceEnd;
71: 	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);
72: 
73: 	FHitResult OutHitResult;
74: 	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);
75: 
76: 	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
77: 	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);
78: 
79: 	UpdateInteractableOptions(InteractionQuery, InteractableTargets);
80: 
81: #if ENABLE_DRAW_DEBUG
82: 	if (bShowDebug)
83: 	{
84: 		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
85: 		if (OutHitResult.bBlockingHit)
86: 		{
87: 			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
88: 			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
89: 		}
90: 		else
91: 		{
92: 			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
93: 		}
94: 	}
95: #endif
96: }
```

## File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
```cpp
 1: #include "AbilitySystem/WitchPTAbilitySystemLibrary.h"
 2: 
 3: #include "Item/MechanicsInterface.h"
 4: 
 5: TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
 6: {
 7: 	if (!Actor)
 8: 	{
 9: 		return TScriptInterface<IMechanicsInterface>();
10: 
11: 	}
12: 	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
13: 	if (ComponentsImplementingInterface.Num() > 0)
14: 	{
15: 		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
16: 	}
17: 	return TScriptInterface<IMechanicsInterface>();
18: }
```

## File: Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
```cpp
  1: #include "Character/WitchPTCharacterBase.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  5: #include "AbilitySystem/WitchPTAttributeSet.h"
  6: #include "Character/Components/WitchPTCharacterMovementComponent.h"
  7: #include "Components/CapsuleComponent.h"
  8: 
  9: 
 10: AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
 12: {
 13: 
 14: 	PrimaryActorTick.bCanEverTick = true;
 15: 	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 16: 	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 17: 
 18: }
 19: 
 20: UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
 21: {
 22: 	return AbilitySystemComponent;
 23: }
 24: 
 25: 
 26: 
 27: 
 28: void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 29: {
 30: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 31: 
 32: }
 33: 
 34: void AWitchPTCharacterBase::InitializeDefaultAttributes()
 35: {
 36: 	ApplyGameplayEffectToSelf(DefaultAttributes);
 37: 
 38: 
 39: }
 40: 
 41: void AWitchPTCharacterBase::GrantStartupAbilities()
 42: {
 43: 	if (!HasAuthority()) return;
 44: 
 45: 	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 46: 
 47: 	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
 48: }
 49: 
 50: void AWitchPTCharacterBase::AddStartupEffects()
 51: {
 52: 	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
 53: 	{
 54: 		return;
 55: 	}
 56: 
 57: 	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
 58: 	EffectContext.AddSourceObject(this);
 59: 
 60: 	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
 61: 	{
 62: 		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
 63: 		if (NewHandle.IsValid())
 64: 		{
 65: 			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
 66: 		}
 67: 	}
 68: 
 69: 	AbilitySystemComponent->bStartupEffectsApplied = true;
 70: }
 71: 
 72: void AWitchPTCharacterBase::InitAbilityActorInfo()
 73: {
 74: }
 75: 
 76: void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
 77: {
 78: 	check(IsValid(GetAbilitySystemComponent()));
 79: 	check(GameplayEffectClass);
 80: 	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
 81: 	EffectContextHandle.AddSourceObject(this);
 82: 	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
 83: 	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
 84: 
 85: }
 86: 
 87: float AWitchPTCharacterBase::GetHealth() const
 88: {
 89: 	if (IsValid(AttributeSet))
 90: 	{
 91: 		return AttributeSet->GetHealth();
 92: 	}
 93: 	return 0.f;
 94: }
 95: 
 96: float AWitchPTCharacterBase::GetMaxHealth() const
 97: {
 98: 	if (IsValid(AttributeSet))
 99: 	{
100: 		return AttributeSet->GetMaxHealth();
101: 	}
102: 	return 0.f;
103: }
104: 
105: float AWitchPTCharacterBase::GetStamina() const
106: {
107: 	if (IsValid(AttributeSet))
108: 	{
109: 		return AttributeSet->GetStamina();
110: 	}
111: 	return 0.f;
112: }
113: 
114: float AWitchPTCharacterBase::GetMaxStamina() const
115: {
116: 	if (IsValid(AttributeSet))
117: 	{
118: 		return AttributeSet->GetMaxStamina();
119: 	}
120: 	return 0.f;
121: }
122: 
123: float AWitchPTCharacterBase::GetAge() const
124: {
125: 	if (IsValid(AttributeSet))
126: 	{
127: 		return AttributeSet->GetAge();
128: 	}
129: 	return 0.f;
130: }
131: 
132: float AWitchPTCharacterBase::GetMaxAge() const
133: {
134: 	if (IsValid(AttributeSet))
135: 	{
136: 		return AttributeSet->GetMaxAge();
137: 	}
138: 	return 0.f;
139: }
140: 
141: float AWitchPTCharacterBase::GetMana() const
142: {
143: 	if (IsValid(AttributeSet))
144: 	{
145: 		return AttributeSet->GetMana();
146: 	}
147: 	return 0.f;
148: }
149: 
150: float AWitchPTCharacterBase::GetMaxMana() const
151: {
152: 	if (IsValid(AttributeSet))
153: 	{
154: 		return AttributeSet->GetMaxMana();
155: 	}
156: 	return 0.f;
157: }
158: 
159: float AWitchPTCharacterBase::GetSpeedMultiplier() const
160: {
161: 	if (IsValid(AttributeSet))
162: 	{
163: 		return AttributeSet->GetSpeedMultiplier();
164: 	}
165: 	return 0.f;
166: }
167: 
168: float AWitchPTCharacterBase::GetMoveSpeed() const
169: {
170: 	if (IsValid(AttributeSet))
171: 	{
172: 		return AttributeSet->GetMoveSpeed();
173: 	}
174: 	return 0.f;
175: }
176: 
177: float AWitchPTCharacterBase::GetMaxMoveSpeed() const
178: {
179: 	if (IsValid(AttributeSet))
180: 	{
181: 		return AttributeSet->GetMaxMoveSpeed();
182: 	}
183: 	return 0.f;
184: }
```

## File: Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
```cpp
 1: #include "Inventory/WitchPTInventoryFunctionLibrary.h"
 2: 
 3: #include "Inventory/WitchPTInventoryItemDefinition.h"
 4: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5: 
 6: const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
 7: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
 8: {
 9: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
10: 	{
11: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
12: 	}
13: 	return nullptr;
14: }
```

## File: Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
```cpp
 1: #include "Item/Ingredient/IngredientBase.h"
 2: 
 3: 
 4: 
 5: AIngredientBase::AIngredientBase()
 6: {
 7: 
 8: }
 9: 
10: void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
11: 	FInteractionOptionBuilder& OptionBuilder)
12: {
13: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
14: }
15: 
16: FItemManifest AIngredientBase::GetPickupInventory() const
17: {
18: 	return StaticInventory;
19: }
```

## File: Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
```cpp
 1: #include "UI/Widgets/CauldronUserWidget.h"
 2: 
 3: void UCauldronUserWidget::NativeConstruct()
 4: {
 5: 	Super::NativeConstruct();
 6: 	FInputModeGameAndUI InputMode;
 7: 
 8: 
 9: 	if (APlayerController* OwningController = GetOwningPlayer())
10: 	{
11: 		OwningController->SetInputMode(InputMode);
12: 		OwningController->SetShowMouseCursor(true);
13: 	}
14: 
15: }
16: 
17: FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
18: {
19: 	return FReply::Handled();
20: }
```

## File: Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
```cpp
1: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
2: 
3: FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
4: {
5: 
6: 	return FReply::Handled();
7: }
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AbilityTask_GrantNearbyInteraction.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
12: {
13: 	GENERATED_UCLASS_BODY()
14: 
15: 
16: 	virtual void Activate() override;
17: 	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;
18: 
19: 
20: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
21: 	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);
22: 
23: private:
24: 	virtual void OnDestroy(bool AbilityEnded) override;
25: 
26: 	void QueryInteractables();
27: 	float InteractionScanRange = 100;
28: 	float InteractionScanRate = 0.100;
29: 	FTimerHandle QueryTimerHandle;
30: 
31: 
32: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
33: 
34: 
35: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;
36: 
37: };
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "Engine/CollisionProfile.h"
 6: #include "InteractionOption.h"
 7: #include "AbilityTask_WaitForInteractable.generated.h"
 8: 
 9: 
10: 
11: 
12: class AActor;
13: class IInteractableTarget;
14: class UObject;
15: class UWorld;
16: struct FCollisionQueryParams;
17: struct FHitResult;
18: struct FInteractionQuery;
19: template <typename InterfaceType> class TScriptInterface;
20: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);
21: 
22: UCLASS(Abstract)
23: class UAbilityTask_WaitForInteractable : public UAbilityTask
24: {
25: 	GENERATED_UCLASS_BODY()
26: 
27: public:
28: 	UPROPERTY(BlueprintAssignable)
29: 	FInteractableObjectsChangedEvent InteractableObjectsChanged;
30: 
31: protected:
32: 
33: 	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);
34: 
35: 	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;
36: 
37: 	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);
38: 
39: 	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);
40: 
41: 	ECollisionChannel TraceProfile;
42: 
43: 
44: 	bool bTraceAffectsAimPitch = true;
45: 
46: 	TArray<FInteractionOption> CurrentOptions;
47: 
48: };
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "InteractionQuery.h"
 5: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 6: #include "AT_WaitForInteractable_SLT.generated.h"
 7: struct FCollisionProfileName;
 8: 
 9: class UGameplayAbility;
10: class UObject;
11: struct FFrame;
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
17: {
18: 	GENERATED_UCLASS_BODY()
19: 
20: 	virtual void Activate() override;
21: 
22: 
23: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
24: 	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);
25: 
26: private:
27: 
28: 	virtual void OnDestroy(bool AbilityEnded) override;
29: 
30: 	void PerformTrace();
31: 
32: 	UPROPERTY()
33: 	FInteractionQuery InteractionQuery;
34: 
35: 	UPROPERTY()
36: 	FGameplayAbilityTargetingLocationInfo StartLocation;
37: 
38: 	float InteractionScanRange = 100;
39: 	float InteractionScanRate = 0.100;
40: 	bool bShowDebug = false;
41: 
42: 	FTimerHandle TimerHandle;
43: 
44: };
```

## File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTAbilitySystemLibrary.generated.h"
 6: 
 7: class IMechanicsInterface;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
13: {
14: 	GENERATED_BODY()
15: 	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
16: 	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
17: };
```

## File: Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/CharacterMovementComponent.h"
 5: #include "WitchPTCharacterMovementComponent.generated.h"
 6: 
 7: 
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	UWitchPTCharacterMovementComponent();
15: 	uint8 RequestToStartSprinting : 1;
16: 	uint8 RequestToStartADS : 1;
17: 	virtual float GetMaxSpeed() const override;
18: 	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
19: 	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
20: 
21: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
22: 	void StartSprinting();
23: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
24: 	void StopSprinting();
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
29: 	void StartAimDownSights();
30: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
31: 	void StopAimDownSights();
32: };
```

## File: Source/WitchPT/Public/Character/WitchPTCharacterBase.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/Character.h"
 6: #include "WitchPTCharacterBase.generated.h"
 7: 
 8: class UWitchPTAbilitySystemComponent;
 9: class UWitchPTAttributeSet;
10: class UGameplayAbility;
11: class UGameplayEffect;
12: class UAttributeSet;
13: 
14: UCLASS(Abstract)
15: class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
25: 	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }
26: 
27: protected:
28: 	UPROPERTY()
29: 	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
30: 	UPROPERTY()
31: 	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
32: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
33: 
34: 	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
35: 	TSubclassOf<UGameplayEffect> DefaultAttributes;
36: 	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
37: 	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
38: 
39: 
40: 	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
41: 	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;
42: 
43: 	virtual void InitializeDefaultAttributes();
44: 
45: 	virtual void GrantStartupAbilities();
46: 
47: 	virtual void AddStartupEffects();
48: 
49: 	virtual void InitAbilityActorInfo();
50: private:
51: 	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);
52: 
53: 
54: 
55: public:
56: 
57: 
58: 
59: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
60: 	float GetHealth() const;
61: 
62: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
63: 	float GetMaxHealth() const;
64: 
65: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
66: 	float GetStamina() const;
67: 
68: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
69: 	float GetMaxStamina() const;
70: 
71: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
72: 	float GetAge() const;
73: 
74: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
75: 	float GetMaxAge() const;
76: 
77: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
78: 	float GetMana() const;
79: 
80: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
81: 	float GetMaxMana() const;
82: 
83: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
84: 	float GetSpeedMultiplier() const;
85: 
86: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
87: 	float GetMoveSpeed() const;
88: 
89: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
90: 	float GetMaxMoveSpeed() const;
91: 
92: 
93: 
94: 
95: 
96: 
97: 
98: };
```

## File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/NoExportTypes.h"
 5: #include "Kismet/BlueprintFunctionLibrary.h"
 6: #include "WitchPTInventoryItemDefinition.generated.h"
 7: 
 8: class UWitchPTInventoryItemFragment;
 9: struct FFrame;
10: 
11: 
12: 
13: UCLASS(Blueprintable, Const, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
19: 
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
21: 	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;
22: 
23: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
24: };
```

## File: Source/WitchPT/Public/Item/CauldronPosition.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "CauldronPosition.generated.h"
 7: 
 8: 
 9: class ACauldronAltar;
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: 
17: 
18: 
19: 
20: UCLASS()
21: class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
22: {
23:     GENERATED_BODY()
24: 
25: public:
26: 
27:     ACauldronPosition();
28: 
29: 
30:     virtual void BeginPlay() override;
31: 
32: 
33: 
34:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38:     UFUNCTION(BlueprintPure, Category = "Cauldron")
39:     ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
40: 
41: 
42: 
43:     UFUNCTION(BlueprintCallable)
44:     void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: protected:
78: 
79:     UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
80:     TObjectPtr<ACauldronAltar> CauldronAltar;
81: 
82: 
83:     virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
84: 
85: private:
86: 
87:     void FindCauldronAltar();
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: };
```

## File: Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Collectable.h"
 5: #include "Item/Item.h"
 6: #include "IngredientBase.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AIngredientBase : public AItem, public ICollectable
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AIngredientBase();
16: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
17: 	virtual FItemManifest GetPickupInventory() const override;
18: 
19: protected:
20: 
21: 	UPROPERTY(EditAnywhere)
22: 	FItemManifest StaticInventory;
23: 
24: };
```

## File: Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTUserWidget.h"
 5: #include "CauldronUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: private:
15: 	virtual void NativeConstruct() override;
16: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
17: };
```

## File: Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "InventoryUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
15: 
16: };
```

## File: Config/DefaultEditor.ini
```
1: [/Script/AdvancedPreviewScene.SharedProfiles]
2: +Profiles=(ProfileName="Epic Headquarters",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=False,bShowGrid=False,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=True,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=True,bShowMeshEdges=False)
3: +Profiles=(ProfileName="Grey Wireframe",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=False,bShowFloor=False,bShowGrid=True,EnvironmentColor=(R=0.039216,G=0.039216,B=0.039216,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=True)
```

## File: Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
```cpp
  1: #include "AbilitySystem/WitchPTAttributeSet.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "GameplayEffectExtension.h"
  5: #include "GameFramework/Character.h"
  6: #include "Net/UnrealNetwork.h"
  7: #include "WitchPT/WitchPT.h"
  8: 
  9: void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 10: {
 11: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 12: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
 13: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)
 14: 
 15: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
 16: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)
 17: 
 18: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
 19: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
 20: 
 21: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
 22: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
 23: 
 24: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
 25: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
 26: 
 27: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
 28: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)
 29: 
 30: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
 31: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
 32: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)
 33: 
 34: 
 35: }
 36: 
 37: UWitchPTAttributeSet::UWitchPTAttributeSet()
 38: {
 39: }
 40: 
 41: void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
 42: {
 43: 	Super::PreAttributeChange(Attribute, NewValue);
 44: }
 45: 
 46: void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 47: {
 48: 	Super::PostGameplayEffectExecute(Data);
 49: 	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
 50: 	{
 51: 
 52: 	}
 53: 	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
 54: 	{
 55: 		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
 56: 	}
 57: }
 58: 
 59: void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 60: {
 61: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
 62: }
 63: 
 64: void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
 65: {
 66: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
 67: }
 68: void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
 69: {
 70: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
 71: }
 72: 
 73: void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
 74: {
 75: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
 76: }
 77: 
 78: void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
 79: {
 80: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
 81: }
 82: 
 83: void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
 84: {
 85: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
 86: }
 87: 
 88: void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
 89: {
 90: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
 91: }
 92: 
 93: void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
 94: {
 95: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
 96: }
 97: 
 98: void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
 99: {
100: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
101: }
102: 
103: void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
104: {
105: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
106: }
107: 
108: void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
109: {
110: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
111: }
112: 
113: void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
114: {
115: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
116: }
117: 
118: void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
119: {
120: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
121: }
122: 
123: void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
124: {
125: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
126: }
127: 
128: void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
129: {
130: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
131: }
```

## File: Source/WitchPT/Private/Inventory/Collectable.cpp
```cpp
 1: #include "Inventory/Collectable.h"
 2: 
 3: #include "Inventory/WitchPTInventoryManagerComponent.h"
 4: 
 5: UCollectableStatics::UCollectableStatics()
 6: : Super(FObjectInitializer::Get())
 7: {
 8: }
 9: 
10: TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
11: {
12: 	TScriptInterface<ICollectable> PickupableActor(Actor);
13: 	if (PickupableActor)
14: 	{
15: 		return PickupableActor;
16: 	}
17: 
18: 	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
19: 	if (PickupableComponents.Num() > 0)
20: 	{
21: 		return TScriptInterface<ICollectable>(PickupableComponents[0]);
22: 	}
23: 
24: 	return TScriptInterface<ICollectable>();
25: }
26: 
27: 
28: void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
29: 	TScriptInterface<ICollectable> Collectable)
30: {
31: 	if (InventoryComponent && Collectable)
32: 	{
33: 		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
34: 		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
35: 	}
36: }
```

## File: Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
```cpp
  1: #pragma once
  2: 
  3: #include "Inventory/FastArray/FastArrayList.h"
  4: 
  5: #include "CoreMinimal.h"
  6: #include "Inventory/WitchPTInventoryItemDefinition.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  8: #include "Inventory/WitchPTInventoryItemInstance.h"
  9: #include "Inventory/WitchPTInventoryManagerComponent.h"
 10: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 11: 
 12: 
 13: class FLifetimeProperty;
 14: struct FReplicationFlags;
 15: 
 16: 
 17: FString FWitchPTInventoryEntry::GetDebugString() const
 18: {
 19: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 20: 	if (Instance != nullptr)
 21: 	{
 22: 		ItemDef = Instance->GetItemDef();
 23: 	}
 24: 
 25: 	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 33: {
 34: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 35: 	if (!IsValid(IMC)) return;
 36: 	for (int32 Index : RemovedIndices)
 37: 	{
 38: 		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
 39: 	}
 40: }
 41: 
 42: void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 43: {
 44: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 45: 	if (!IsValid(IMC)) return;
 46: 	for (int32 Index : AddedIndices)
 47: 	{
 48: 		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
 49: 	}
 50: }
 51: 
 52: void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 53: {
 54: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 55: 	if (!IsValid(IMC)) return;
 56: 
 57: 	for (int32 Index : ChangedIndices)
 58: 	{
 59: 		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
 60: 	}
 61: }
 62: 
 63: UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 64: {
 65: 	UWitchPTInventoryItemInstance* Result = nullptr;
 66: 
 67: 	check(ItemDef != nullptr);
 68: 	check(OwnerComponent);
 69: 
 70: 	AActor* OwningActor = OwnerComponent->GetOwner();
 71: 	check(OwningActor->HasAuthority());
 72: 
 73: 
 74: 	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
 75: 	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
 76: 	NewEntry.Instance->SetItemDef(ItemDef);
 77: 
 78: 	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 79: 	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 80: 	if (IsValid(StackableFragment))
 81: 	{
 82: 		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
 83: 	}
 84: 	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
 85: 	{
 86: 		if (Fragment != nullptr)
 87: 		{
 88: 			Fragment->OnInstanceCreated(NewEntry.Instance);
 89: 		}
 90: 	}
 91: 
 92: 	Result = NewEntry.Instance;
 93: 
 94: 
 95: 	MarkItemDirty(NewEntry);
 96: 
 97: 	return Result;
 98: }
 99: 
100: void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
101: {
102: 	unimplemented();
103: }
104: 
105: void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
106: {
107: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
108: 	{
109: 		FWitchPTInventoryEntry& Entry = *EntryIt;
110: 		if (Entry.Instance == Instance)
111: 		{
112: 			EntryIt.RemoveCurrent();
113: 			MarkArrayDirty();
114: 		}
115: 	}
116: }
117: TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
118: {
119: 	TArray<UWitchPTInventoryItemInstance*> Results;
120: 	Results.Reserve(Entries.Num());
121: 	for (const FWitchPTInventoryEntry& Entry : Entries)
122: 	{
123: 		if (Entry.Instance != nullptr)
124: 		{
125: 			Results.Add(Entry.Instance);
126: 		}
127: 	}
128: 	return Results;
129: }
```

## File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
```cpp
 1: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2: 
 3: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 4: 
 5: UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
 6: : Super(ObjectInitializer)
 7: 
 8: {
 9: }
10: 
11: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
12: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
13: {
14: 	if (FragmentClass != nullptr)
15: 	{
16: 		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
17: 		{
18: 			if (Fragment && Fragment->IsA(FragmentClass))
19: 			{
20: 				return Fragment;
21: 			}
22: 		}
23: 	}
24: 
25: 	return nullptr;
26: }
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.h"
 6: #include "IInteractableTarget.generated.h"
 7: 
 8: struct FInteractionQuery;
 9: 
10: 
11: class FInteractionOptionBuilder
12: {
13: public:
14: 	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
15: 		: Scope(InterfaceTargetScope)
16: 		, Options(InteractOptions)
17: 	{
18: 	}
19: 
20: 	void AddInteractionOption(const FInteractionOption& Option)
21: 	{
22: 		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
23: 		OptionEntry.InteractableTarget = Scope;
24: 	}
25: 
26: private:
27: 	TScriptInterface<IInteractableTarget> Scope;
28: 	TArray<FInteractionOption>& Options;
29: };
30: 
31: 
32: UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
33: class UInteractableTarget : public UInterface
34: {
35: 	GENERATED_BODY()
36: };
37: 
38: 
39: class IInteractableTarget
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;
46: 
47: 
48: 	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
49: 
50: 
51: 
52: 
53: 
54: 	virtual bool SupportsHoldInteraction() const { return false; }
55: 
56: 
57: 
58: 
59: 
60: 	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
61: };
```

## File: Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "AbilitySystemComponent.h"
  5: #include "AttributeSet.h"
  6: #include "WitchPTAttributeSet.generated.h"
  7: 
  8: 
  9: 
 10: 
 11: 
 12: 
 13: #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 14: GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 15: GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 16: GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 17: GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 18: 
 19: 
 20: UCLASS()
 21: class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
 22: {
 23: 	GENERATED_BODY()
 24: public:
 25: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 26: 	UWitchPTAttributeSet();
 27: 	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
 28: 	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
 35: 	FGameplayAttributeData Age;
 36: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
 37: 
 38: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
 39: 	FGameplayAttributeData MaxAge;
 40: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
 41: 
 42: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
 43: 	FGameplayAttributeData Health;
 44: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
 45: 
 46: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
 47: 	FGameplayAttributeData MaxHealth;
 48: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
 49: 
 50: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
 51: 	FGameplayAttributeData Strength;
 52: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
 53: 
 54: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
 55: 	FGameplayAttributeData MaxStrength;
 56: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
 57: 
 58: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
 59: 	FGameplayAttributeData Mana;
 60: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
 61: 
 62: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
 63: 	FGameplayAttributeData MaxMana;
 64: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
 65: 
 66: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
 67: 	FGameplayAttributeData Stamina;
 68: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
 69: 
 70: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
 71: 	FGameplayAttributeData MaxStamina;
 72: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);
 73: 
 74: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
 75: 	FGameplayAttributeData SpeedMultiplier;
 76: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);
 77: 
 78: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
 79: 	FGameplayAttributeData MaxSpeedMultiplier;
 80: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);
 81: 
 82: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
 83: 	FGameplayAttributeData MoveSpeed;
 84: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);
 85: 
 86: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
 87: 	FGameplayAttributeData MaxMoveSpeed;
 88: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);
 89: 
 90: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
 91: 	FGameplayAttributeData MinMoveSpeed;
 92: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 	UFUNCTION()
 99: 	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
100: 	UFUNCTION()
101: 	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
102: 	UFUNCTION()
103: 	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
104: 	UFUNCTION()
105: 	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
106: 	UFUNCTION()
107: 	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
108: 	UFUNCTION()
109: 	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
110: 	UFUNCTION()
111: 	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
112: 	UFUNCTION()
113: 	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
114: 	UFUNCTION()
115: 	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
116: 	UFUNCTION()
117: 	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
118: 	UFUNCTION()
119: 	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
120: 	UFUNCTION()
121: 	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
122: 	UFUNCTION()
123: 	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
124: 	UFUNCTION()
125: 	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
126: 	UFUNCTION()
127: 	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
128: };
```

## File: Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Net/Serialization/FastArraySerializer.h"
  5: 
  6: #include "FastArrayList.generated.h"
  7: 
  8: class UWitchPTInventoryItemDefinition;
  9: class UWitchPTInventoryItemInstance;
 10: class UWitchPTInventoryManagerComponent;
 11: struct FWitchPTInventoryList;
 12: 
 13: 
 14: 
 15: 
 16: 
 17: 
 18: 
 19: USTRUCT(BlueprintType)
 20: struct FWitchPTInventoryEntry : public FFastArraySerializerItem
 21: {
 22: 	GENERATED_BODY()
 23: 
 24: 	FWitchPTInventoryEntry()
 25: 	{}
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 	FString GetDebugString() const;
 32: 
 33: private:
 34: 	friend FWitchPTInventoryList;
 35: 	friend UWitchPTInventoryManagerComponent;
 36: 
 37: 
 38: 	UPROPERTY()
 39: 	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
 40: 
 41: };
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: USTRUCT(BlueprintType)
 51: struct FWitchPTInventoryList : public FFastArraySerializer
 52: {
 53: 	GENERATED_BODY()
 54: 
 55: 
 56: 	FWitchPTInventoryList()
 57: 		: OwnerComponent(nullptr)
 58: 	{
 59: 	}
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
 66: 		: OwnerComponent(InOwnerComponent)
 67: 	{
 68: 	}
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 75: 
 76: public:
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
102: 	{
103: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
104: 	}
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
114: 
115: 
116: 
117: 
118: 
119: 
120: 	void AddEntry(UWitchPTInventoryItemInstance* Instance);
121: 
122: 
123: 
124: 
125: 
126: 
127: 	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);
128: 
129: private:
130: 	friend UWitchPTInventoryManagerComponent;
131: 
132: private:
133: 
134: 	UPROPERTY()
135: 	TArray<FWitchPTInventoryEntry> Entries;
136: 
137: 
138: 	UPROPERTY(NotReplicated)
139: 	TObjectPtr<UActorComponent> OwnerComponent;
140: };
141: 
142: 
143: 
144: 
145: 
146: template<>
147: struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
148: {
149: 	enum { WithNetDeltaSerializer = true };
150: };
```

## File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Templates/SubclassOf.h"
 5: #include "WitchPTInventoryItemFragment.generated.h"
 6: 
 7: template <typename T> class TSubclassOf;
 8: 
 9: class UWitchPTInventoryItemInstance;
10: 
11: 
12: 
13: UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
20: 
21: };
```

## File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
```cpp
  1: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "Engine/World.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  6: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
  7: struct FInteractionQuery;
  8: 
  9: UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
 10: 	: Super(ObjectInitializer)
 11: {
 12: }
 13: void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
 14: {
 15: 	check(World);
 16: 
 17: 	OutHitResult = FHitResult();
 18: 	FHitResult HitResult;
 19: 
 20: 	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
 21: 	OutHitResult.TraceStart = Start;
 22: 	OutHitResult.TraceEnd = End;
 23: 
 24: 	OutHitResult = HitResult;
 25: }
 26: 
 27: void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
 28: {
 29: 	if (!Ability)
 30: 	{
 31: 		return;
 32: 	}
 33: 
 34: 
 35: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 36: 	check(PC);
 37: 
 38: 	FVector ViewStart;
 39: 	FRotator ViewRot;
 40: 	PC->GetPlayerViewPoint(ViewStart, ViewRot);
 41: 
 42: 	const FVector ViewDir = ViewRot.Vector();
 43: 	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);
 44: 
 45: 	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);
 46: 
 47: 	FHitResult HitResult;
 48: 	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);
 49: 
 50: 	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));
 51: 
 52: 	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;
 53: 
 54: 	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
 55: 	if (AdjustedAimDir.IsZero())
 56: 	{
 57: 		AdjustedAimDir = ViewDir;
 58: 	}
 59: 
 60: 	if (!bTraceAffectsAimPitch && bUseTraceResult)
 61: 	{
 62: 		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();
 63: 
 64: 		if (!OriginalAimDir.IsZero())
 65: 		{
 66: 
 67: 			const FRotator OriginalAimRot = OriginalAimDir.Rotation();
 68: 
 69: 			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
 70: 			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;
 71: 
 72: 			AdjustedAimDir = AdjustedAimRot.Vector();
 73: 		}
 74: 	}
 75: 
 76: 	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
 77: }
 78: 
 79: bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
 80: {
 81: 	FVector CameraToCenter = AbilityCenter - CameraLocation;
 82: 	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
 83: 	if (DotToCenter >= 0)
 84: 	{
 85: 		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
 86: 		float RadiusSquared = (AbilityRange * AbilityRange);
 87: 		if (DistanceSquared <= RadiusSquared)
 88: 		{
 89: 			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
 90: 			float DistanceAlongRay = DotToCenter + DistanceFromCamera;
 91: 			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);
 92: 			return true;
 93: 		}
 94: 	}
 95: 	return false;
 96: }
 97: 
 98: void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
 99: {
100: 	TArray<FInteractionOption> NewOptions;
101: 
102: 	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
103: 	{
104: 		TArray<FInteractionOption> TempOptions;
105: 		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
106: 		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);
107: 
108: 		for (FInteractionOption& Option : TempOptions)
109: 		{
110: 			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;
111: 
112: 
113: 			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
114: 			{
115: 
116: 				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
117: 			}
118: 
119: 			else if (Option.InteractionAbilityToGrant)
120: 			{
121: 
122: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);
123: 
124: 				if (InteractionAbilitySpec)
125: 				{
126: 
127: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
128: 					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
129: 				}
130: 			}
131: 			if (Option.HoldInteractionAbilityToGrant)
132: 			{
133: 
134: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);
135: 
136: 				if (InteractionAbilitySpec)
137: 				{
138: 
139: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
140: 					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
141: 				}
142: 			}
143: 			if (InteractionAbilitySpec)
144: 			{
145: 
146: 				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
147: 				{
148: 					NewOptions.Add(Option);
149: 				}
150: 			}
151: 		}
152: 	}
153: 
154: 	bool bOptionsChanged = false;
155: 	if (NewOptions.Num() == CurrentOptions.Num())
156: 	{
157: 		NewOptions.Sort();
158: 
159: 		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
160: 		{
161: 			const FInteractionOption& NewOption = NewOptions[OptionIndex];
162: 			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];
163: 
164: 			if (NewOption != CurrentOption)
165: 			{
166: 				bOptionsChanged = true;
167: 				break;
168: 			}
169: 		}
170: 	}
171: 	else
172: 	{
173: 		bOptionsChanged = true;
174: 	}
175: 
176: 	if (bOptionsChanged)
177: 	{
178: 		CurrentOptions = NewOptions;
179: 		InteractableObjectsChanged.Broadcast(CurrentOptions);
180: 	}
181: }
```

## File: Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
```cpp
 1: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Character/WitchPTCharacterBase.h"
 6: 
 7: 
 8: 
 9: UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
10: {
11: 
12: 	PrimaryComponentTick.bCanEverTick = true;
13: 
14: 
15: }
16: 
17: float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
18: {
19: 
20: 	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());
21: 
22: 	if (!Owner)
23: 	{
24: 
25: 		return Super::GetMaxSpeed();
26: 	}
27: 
28: 
29: 
30: 	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
31: 	{
32: 
33: 		return 0.0f;
34: 	}
35: 
36: 	float FinalSpeed = Owner->GetMoveSpeed();
37: 	if (RequestToStartSprinting)
38: 	{
39: 		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
40: 
41: 	}
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 	return FinalSpeed;
50: }
51: 
52: void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
53: {
54: 	Super::UpdateFromCompressedFlags(Flags);
55: }
56: 
57: class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
58: {
59: 	return Super::GetPredictionData_Client();
60: }
61: 
62: 
63: void UWitchPTCharacterMovementComponent::StartSprinting()
64: {
65: 	RequestToStartSprinting = true;
66: }
67: 
68: void UWitchPTCharacterMovementComponent::StopSprinting()
69: {
70: 	RequestToStartSprinting = false;
71: }
72: 
73: void UWitchPTCharacterMovementComponent::StartAimDownSights()
74: {
75: 	RequestToStartADS = true;
76: }
77: 
78: void UWitchPTCharacterMovementComponent::StopAimDownSights()
79: {
80: 	RequestToStartADS = false;
81: 
82: }
```

## File: Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
```cpp
 1: #include "Item/BaseInteractionPosition.h"
 2: #include "Net/UnrealNetwork.h"
 3: #include "Engine/ActorChannel.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "Components/BoxComponent.h"
 6: #include "GameFramework/Character.h"
 7: 
 8: ABaseInteractionPosition::ABaseInteractionPosition()
 9: {
10: 
11:     PrimaryActorTick.bCanEverTick = true;
12: 
13: 
14:     bReplicates = true;
15:     bAlwaysRelevant = true;
16: }
17: 
18: void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
19: {
20:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
21: 
22: 
23:     DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
24:     DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
25:     DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
26: 
27: 
28: }
29: 
30: void ABaseInteractionPosition::BeginPlay()
31: {
32:     Super::BeginPlay();
33: 
34: 
35: }
36: 
37: void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
38: {
39: 
40:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
41: }
42: 
43: bool ABaseInteractionPosition::IsOccupied() const
44: {
45:     return bIsOccupied;
46: }
47: 
48: void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
49: {
50:     if (GetLocalRole() != ROLE_Authority)
51:     {
52:         return;
53:     }
54: 
55:     OccupyingCharacter = Character;
56:     bIsOccupied = (Character != nullptr);
57: }
58: 
59: void ABaseInteractionPosition::SetUnoccupied()
60: {
61:     if (GetLocalRole() != ROLE_Authority)
62:     {
63:         return;
64:     }
65: 
66:     RemoveCharacterFromPosition();
67: }
68: 
69: void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
70: {
71:     PositionTag = NewTag;
72: }
73: 
74: void ABaseInteractionPosition::OnRep_IsOccupied()
75: {
76: 
77: }
78: 
79: void ABaseInteractionPosition::OnRep_OccupyingCharacter()
80: {
81: 
82: }
83: 
84: void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
85: {
86: 
87:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
88:         *GetName(), *InteractingCharacter->GetName());
89: }
90: 
91: void ABaseInteractionPosition::RemoveCharacterFromPosition()
92: {
93:     OccupyingCharacter = nullptr;
94:     bIsOccupied = false;
95: }
```

## File: Source/WitchPT/Private/Item/CauldronPosition.cpp
```cpp
  1: #include "Item/CauldronPosition.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/CauldronAltar.h"
  5: #include "Kismet/GameplayStatics.h"
  6: 
  7: ACauldronPosition::ACauldronPosition()
  8: {
  9: 
 10:     bIsOccupied = false;
 11:     OccupyingCharacter = nullptr;
 12: }
 13: 
 14: void ACauldronPosition::BeginPlay()
 15: {
 16:     Super::BeginPlay();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 
 23: }
 24: 
 25: void ACauldronPosition::FindCauldronAltar()
 26: {
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: 
 38: 
 39: 
 40: 
 41: 
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: }
 56: 
 57: void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 58: {
 59:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 
138: 
139: 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: 
177: 
178: 
179: 
180: 
181: }
182: 
183: void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
184: {
185:     Super::HandleInteraction(InteractingCharacter);
186: 
187:     if (!InteractingCharacter || !CauldronAltar)
188:     {
189:         return;
190:     }
191: 
192: 
193: 
194: }
```

## File: Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
```cpp
 1: #include "Item/Ritual/RitualFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/CauldronWidgetController.h"
 7: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 8: 
 9: URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
10: {
11: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
12: 	{
13: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
14: 		{
15: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
16: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
17: 			UAttributeSet* AS = PS->GetAttributeSet();
18: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
19: 
20: 			return WitchPTHUD->SetRitualWidgetController(WCParams);
21: 		}
22: 	}
23: 	return nullptr;
24: }
25: 
26: UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
27: {
28: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
29: 	{
30: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
31: 		{
32: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
33: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
34: 			UAttributeSet* AS = PS->GetAttributeSet();
35: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
36: 			return WitchPTHUD->SetCauldronWidgetController(WCParams);
37: 		}
38: 	}
39: 	return nullptr;
40: }
```

## File: Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "WitchPTGameplayAbility.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UENUM(BlueprintType)
11: enum class EPrototypeAbilityActivationPolicy: uint8
12: {
13: 
14: 	OnInputTriggered,
15: 
16: 
17: 	WhileInputActive,
18: 
19: 
20: 	OnSpawn,
21: 
22: 	OnTriggeredEvent
23: };
24: UCLASS()
25: class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
26: {
27: 	GENERATED_BODY()
28: public:
29: 	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
30: 	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
31: 	UPROPERTY(EditDefaultsOnly, Category="Input")
32: 	FGameplayTag StartupInputTag;
33: 	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
34: protected:
35: 
36: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
37: 	EPrototypeAbilityActivationPolicy ActivationPolicy;
38: 
39: 	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
40: };
```

## File: Source/WitchPT/Public/Inventory/Collectable.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "UObject/Interface.h"
 7: #include "UObject/ObjectPtr.h"
 8: #include "Collectable.generated.h"
 9: template <typename InterfaceType> class TScriptInterface;
10: 
11: 
12: class AActor;
13: class UWitchPTInventoryItemDefinition;
14: class UWitchPTInventoryItemInstance;
15: class UWitchPTInventoryManagerComponent;
16: class UObject;
17: struct FFrame;
18: 
19: USTRUCT(BlueprintType)
20: struct FItemManifest
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 	UPROPERTY(EditAnywhere)
26: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
27: };
28: 
29: 
30: UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
31: class UCollectable : public UInterface
32: {
33: 	GENERATED_BODY()
34: };
35: 
36: 
37: 
38: 
39: class WITCHPT_API ICollectable
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 
46: 
47: 	UFUNCTION(BlueprintCallable)
48: 	virtual FItemManifest GetPickupInventory() const = 0;
49: };
50: 
51: UCLASS()
52: class UCollectableStatics : public UBlueprintFunctionLibrary
53: {
54: 	GENERATED_BODY()
55: 
56: public:
57: 	UCollectableStatics();
58: 
59: 	UFUNCTION(BlueprintPure)
60: 	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);
61: 
62: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
63: 	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
64: };
```

## File: Source/WitchPT/Public/Item/BaseInteractionPosition.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/Item.h"
 5: #include "AbilitySystem/Interaction/InteractionOption.h"
 6: #include "GameplayTagContainer.h"
 7: #include "MechanicsInterface.h"
 8: #include "BaseInteractionPosition.generated.h"
 9: 
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: class ABaseInteractableAltar;
17: 
18: 
19: 
20: 
21: UCLASS(Abstract)
22: class WITCHPT_API ABaseInteractionPosition : public AItem
23: {
24:     GENERATED_BODY()
25: 
26: public:
27: 
28:     ABaseInteractionPosition();
29: 
30: 
31:     virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
32:     virtual void BeginPlay() override;
33: 
34: 
35: 
36:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
37: 
38: 
39: 
40: 
41:     UFUNCTION(BlueprintPure, Category = "Interaction")
42:     ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
43: 
44:     UFUNCTION(BlueprintPure, Category = "Interaction")
45:     FGameplayTag GetPositionTag() const { return PositionTag; }
46: 
47:     virtual bool IsOccupied() const;
48: 
49: 
50:     UFUNCTION()
51:     void SetOccupied(ACharacter* Character);
52: 
53:     UFUNCTION()
54:     void SetUnoccupied();
55: 
56:     UFUNCTION()
57:     void SetPositionTag(const FGameplayTag& NewTag);
58: 
59: protected:
60: 
61:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
62:     FGameplayTag PositionTag;
63: 
64: 
65:     UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
66:     bool bIsOccupied = false;
67: 
68: 
69:     UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
70:     TObjectPtr<ACharacter> OccupyingCharacter = nullptr;
71: 
72: 
73:     UPROPERTY()
74:     TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;
75: 
76:     UPROPERTY()
77:     TWeakObjectPtr<AController> InteractingController;
78: 
79: 
80:     UFUNCTION()
81:     void OnRep_IsOccupied();
82: 
83:     UFUNCTION()
84:     void OnRep_OccupyingCharacter();
85: 
86: 
87: 
88:     virtual void HandleInteraction(ACharacter* InteractingCharacter);
89: 
90: private:
91:     void RemoveCharacterFromPosition();
92: };
```

## File: Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6: #include "RitualFunctionLibrary.generated.h"
 7: 
 8: class UWitchPTWidgetController;
 9: class URitualWidgetController;
10: 
11: 
12: 
13: UCLASS()
14: class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UFUNCTION(Category="Ritual")
19: 	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
20: 	UFUNCTION(Category="Cauldron")
21: 	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
22: };
```

## File: Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/HUD.h"
 5: #include "WitchPTHUD.generated.h"
 6: 
 7: class UCauldronWidgetController;
 8: class UWitchPTWidgetController;
 9: class URitualWidgetController;
10: class UAbilitySystemComponent;
11: class UAttributeSet;
12: class UWitchPTUserWidget;
13: class UInventoryWidgetController;
14: struct FWidgetControllerParams;
15: class UOverlayWidgetController;
16: 
17: 
18: 
19: UCLASS()
20: class WITCHPT_API AWitchPTHUD : public AHUD
21: {
22: 	GENERATED_BODY()
23: public:
24: 	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
25: 	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
26: 	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
27: 	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
28: 
29: 	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
30: 
31: 
32: 
33: private:
34: 	UPROPERTY()
35: 	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
36: 	UPROPERTY(EditAnywhere)
37: 	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;
38: 
39: 
40: 	UPROPERTY()
41: 	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
42: 	UPROPERTY(EditAnywhere)
43: 	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;
44: 
45: 	UPROPERTY()
46: 	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
47: 	UPROPERTY(EditAnywhere)
48: 	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;
49: 
50: 	UPROPERTY()
51: 	TObjectPtr<URitualWidgetController> RitualWidgetController;
52: 	UPROPERTY(EditAnywhere)
53: 	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;
54: 
55: 	UPROPERTY()
56: 	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
57: 	UPROPERTY(EditAnywhere)
58: 	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
59: };
```

## File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
```cpp
  1: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  2: 
  3: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  4: 
  5: 
  6: void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
  7: 	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
  8: {
  9: 	if (!AbilitiesToGrant.IsEmpty())
 10: 	{
 11: 		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
 12: 		{
 13: 			if (!AbilityClass)
 14: 			{
 15: 				continue;
 16: 			}
 17: 
 18: 
 19: 			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
 20: 			if (!AbilityCDO)
 21: 			{
 22: 				continue;
 23: 			}
 24: 
 25: 			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
 26: 
 27: 			AbilitySpec.SourceObject = this;
 28: 
 29: 			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
 30: 
 31: 			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
 32: 
 33: 			GrantedAbilities.Add(AbilitySpecHandle);
 34: 		}
 35: 	}
 36: }
 37: 
 38: void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
 39: {
 40: 	if (InputTag.IsValid())
 41: 	{
 42: 
 43: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 44: 		{
 45: 
 46: 
 47: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 48: 			{
 49: 
 50: 				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
 51: 				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
 52: 			}
 53: 		}
 54: 	}
 55: }
 56: 
 57: void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
 58: {
 59: 	if (!InputTag.IsValid()) return;
 60: 	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
 61: 	{
 62: 		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
 63: 		{
 64: 			AbilitySpecInputPressed(AbilitySpec);
 65: 			if (!AbilitySpec.IsActive())
 66: 			{
 67: 				TryActivateAbility(AbilitySpec.Handle);
 68: 			}
 69: 		}
 70: 	}
 71: }
 72: 
 73: void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
 74: {
 75: 	if (InputTag.IsValid())
 76: 	{
 77: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 78: 		{
 79: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 80: 			{
 81: 				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
 82: 				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
 83: 			}
 84: 		}
 85: 	}
 86: }
 87: 
 88: void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
 89: {
 90: 	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
 91: }
 92: 
 93: void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
 94: {
 95: 		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
 96: 	AbilitiesToActivate.Reset();
 97: 
 98: 
 99: 
100: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
101: 	{
102: 
103: 
104: 		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
105: 		{
106: 			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
107: 			{
108: 				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
109: 				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
110: 				{
111: 
112: 
113: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
114: 					{
115: 						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
116: 					}
117: 				}
118: 			}
119: 		}
120: 	}
121: 
122: 
123: 
124: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
125: 	{
126: 
127: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
128: 		{
129: 			if (AbilitySpec->Ability)
130: 			{
131: 				AbilitySpec->InputPressed = true;
132: 
133: 				if (AbilitySpec->IsActive())
134: 				{
135: 
136: 
137: 
138: 					AbilitySpecInputPressed(*AbilitySpec);
139: 				}
140: 				else
141: 				{
142: 					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
143: 
144: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
145: 					{
146: 						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
147: 						{
148: 							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
149: 						}
150: 					}
151: 				}
152: 			}
153: 		}
154: 	}
155: 
156: 
157: 
158: 
159: 
160: 	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
161: 	{
162: 		TryActivateAbility(AbilitySpecHandle);
163: 	}
164: 
165: 
166: 
167: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
168: 	{
169: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
170: 		{
171: 			if (AbilitySpec->Ability)
172: 			{
173: 				AbilitySpec->InputPressed = false;
174: 
175: 				if (AbilitySpec->IsActive())
176: 				{
177: 
178: 					AbilitySpecInputReleased(*AbilitySpec);
179: 				}
180: 			}
181: 		}
182: 	}
183: 
184: 
185: 
186: 
187: 	InputPressedSpecHandles.Reset();
188: 	InputReleasedSpecHandles.Reset();
189: 
190: }
191: 
192: void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
193: {
194: 	Super::AbilitySpecInputPressed(Spec);
195: 
196: 
197: 	if (Spec.IsActive())
198: 	{
199: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
200: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
201: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
202: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
203: 
204: 
205: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
206: 	}
207: 
208: }
209: 
210: void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
211: {
212: 	Super::AbilitySpecInputReleased(Spec);
213: 
214: 
215: 	if (Spec.IsActive())
216: 	{
217: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
218: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
219: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
220: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
221: 
222: 
223: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
224: 	}
225: }
226: 
227: void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
228: 	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
229: {
230: 	FGameplayTagContainer TagContainer;
231: 	EffectSpec.GetAllAssetTags(TagContainer);
232: 
233: 	OnEffectAssetTags.Broadcast(TagContainer);
234: }
```

## File: Source/WitchPT/Private/Character/WitchPTEnemy.cpp
```cpp
 1: #include "Character/WitchPTEnemy.h"
 2: 
 3: 
 4: 
 5: AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AWitchPTEnemy::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AWitchPTEnemy::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: 
25: void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
26: {
27: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
28: 
29: }
```

## File: Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
```cpp
 1: #include "Player/WitchPTPlayerState.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Item/RitualPosition.h"
 7: 
 8: AWitchPTPlayerState::AWitchPTPlayerState()
 9: {
10: 	SetNetUpdateFrequency(100.f);
11: 
12: 	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
13: 	AbilitySystemComponent->SetIsReplicated(true);
14: 	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
15: 
16: 	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");
17: 
18: 
19: }
20: 
21: UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
22: {
23: 	return AbilitySystemComponent;
24: }
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.generated.h"
 6: 
 7: class IInteractableTarget;
 8: 
 9: 
10: 
11: USTRUCT(BlueprintType)
12: struct FInteractionOption
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UPROPERTY(BlueprintReadWrite)
19: 	TScriptInterface<IInteractableTarget> InteractableTarget;
20: 
21: 
22: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
23: 	FText Text;
24: 
25: 
26: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
27: 	FText SubText;
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
36: 	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;
37: 
38: 
39: 
40: 
41: 
42: 
43: 	UPROPERTY(BlueprintReadOnly)
44: 	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;
45: 
46: 
47: 	UPROPERTY(BlueprintReadOnly)
48: 	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
49: 
50: 
51: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
52: 	bool bSupportsHoldInteraction = false;
53: 
54: 
55: 	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
56: 	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
57: 
58: 
59: 	UPROPERTY(BlueprintReadOnly)
60: 	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;
61: 
62: 
63: 
64: 
65: 
66: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
67: 	TSoftClassPtr<UUserWidget> InteractionWidgetClass;
68: 
69: 
70: 
71: public:
72: 	FORCEINLINE bool operator==(const FInteractionOption& Other) const
73: 	{
74: 		return InteractableTarget == Other.InteractableTarget &&
75: 			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
76: 			TargetAbilitySystem == Other.TargetAbilitySystem &&
77: 			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
78: 			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
79: 			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
80: 			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
81: 
82: 			Text.IdenticalTo(Other.Text) &&
83: 			SubText.IdenticalTo(Other.SubText);
84: 	}
85: 
86: 	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
87: 	{
88: 		return !operator==(Other);
89: 	}
90: 
91: 	FORCEINLINE bool operator<(const FInteractionOption& Other) const
92: 	{
93: 		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
94: 	}
95: };
```

## File: Source/WitchPT/Public/Player/WitchPTPlayerState.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/PlayerState.h"
 6: #include "WitchPTPlayerState.generated.h"
 7: class ARitualPosition;
 8: class ARitualAltar;
 9: class UAbilitySystemComponent;
10: class UAttributeSet;
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 	AWitchPTPlayerState();
19: public:
20: 
21: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
22: 	UAttributeSet* GetAttributeSet() const { return AttributeSet; }
23: 
24: protected:
25: 	UPROPERTY(VisibleAnywhere)
26: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
27: 	UPROPERTY(VisibleAnywhere)
28: 	TObjectPtr<UAttributeSet> AttributeSet;
29: 
30: 
31: };
```

## File: Source/WitchPT/WitchPT.h
```
1: #pragma once
2: 
3: #include "CoreMinimal.h"
4: #define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
5: #define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
6: #define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)
```

## File: WitchPT.uproject
```
 1: {
 2: 	"FileVersion": 3,
 3: 	"EngineAssociation": "5.5",
 4: 	"Category": "",
 5: 	"Description": "",
 6: 	"Modules": [
 7: 		{
 8: 			"Name": "WitchPT",
 9: 			"Type": "Runtime",
10: 			"LoadingPhase": "Default",
11: 			"AdditionalDependencies": [
12: 				"Engine",
13: 				"CoreUObject"
14: 			]
15: 		}
16: 	],
17: 	"Plugins": [
18: 		{
19: 			"Name": "ModelingToolsEditorMode",
20: 			"Enabled": true,
21: 			"TargetAllowList": [
22: 				"Editor"
23: 			]
24: 		},
25: 		{
26: 			"Name": "GameplayAbilities",
27: 			"Enabled": true
28: 		},
29: 		{
30: 			"Name": "ElectronicNodes",
31: 			"Enabled": true,
32: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/5cb2a394d0c04e73891762be4cbd7216"
33: 		},
34: 		{
35: 			"Name": "FlatNodes",
36: 			"Enabled": true,
37: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/b719437f3fb54c259b34227363df8cab"
38: 		},
39: 		{
40: 			"Name": "BlueprintAssist",
41: 			"Enabled": true,
42: 			"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/9e895371fa3a471c87337860d6f341ff"
43: 		},
44: 		{
45: 			"Name": "ActorPalette",
46: 			"Enabled": true
47: 		}
48: 	]
49: }
```

## File: Config/DefaultGameplayTags.ini
```
 1: ;METADATA=(Diff=true, UseCommands=true)
 2: [/Script/GameplayTags.GameplayTagsSettings]
 3: ImportTagsFromConfig=True
 4: WarnOnInvalidTags=True
 5: ClearInvalidTags=False
 6: AllowEditorTagUnloading=True
 7: AllowGameTagUnloading=False
 8: FastReplication=False
 9: bDynamicReplication=False
10: InvalidTagCharacters="\"\',"
11: NumBitsForContainerSize=6
12: NetIndexFirstBitSegment=16
13: +GameplayTagList=(Tag="Ability.Altar.Participating",DevComment="")
14: +GameplayTagList=(Tag="Ability.Altar.Start",DevComment="")
15: +GameplayTagList=(Tag="Character.State.Cauldron.Brewing",DevComment="")
16: +GameplayTagList=(Tag="InputTag.F",DevComment="")
17: +GameplayTagList=(Tag="InputTag.Interact",DevComment="")
18: +GameplayTagList=(Tag="State.Ritual.Blocked",DevComment="")
19: +GameplayTagList=(Tag="State.Ritual.Moving",DevComment="")
```

## File: Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
```cpp
 1: #include "UI/HUD/WitchPTHUD.h"
 2: 
 3: #include "UI/WidgetControllers/CauldronWidgetController.h"
 4: #include "UI/WidgetControllers/InventoryWidgetController.h"
 5: #include "UI/WidgetControllers/OverlayWidgetController.h"
 6: #include "UI/WidgetControllers/RitualWidgetController.h"
 7: #include "UI/Widgets/WitchPTUserWidget.h"
 8: 
 9: UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
10: {
11: 	if (OverlayWidgetController == nullptr)
12: 	{
13: 		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
14: 		OverlayWidgetController->SetWidgetControllerParams(WCParams);
15: 		OverlayWidgetController->BindCallbacksToDependencies();
16: 	}
17: 	return OverlayWidgetController;
18: }
19: 
20: UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
21: {
22: 	if (CauldronWidgetController == nullptr)
23: 	{
24: 		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
25: 		CauldronWidgetController->SetWidgetControllerParams(WCParams);
26: 
27: 	}
28: 	return CauldronWidgetController;
29: }
30: 
31: UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
32: {
33: 	if (InventoryWidgetController == nullptr)
34: 	{
35: 		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
36: 		InventoryWidgetController->SetWidgetControllerParams(WCParams);
37: 		InventoryWidgetController->BindCallbacksToDependencies();
38: 	}
39: 	return InventoryWidgetController;
40: }
41: 
42: URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
43: {
44: 	if (RitualWidgetController == nullptr)
45: 	{
46: 		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
47: 		RitualWidgetController->SetWidgetControllerParams(WCParams);
48: 	}
49: 	return RitualWidgetController;
50: }
51: 
52: void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
53: {
54: 	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
55: 	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));
56: 
57: 
58: 	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
59: 	OverlayWidget = Cast<UWitchPTUserWidget>(Widget);
60: 
61: 	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
62: 	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);
63: 
64: 	OverlayWidget->SetWidgetController(WidgetController);
65: 	WidgetController->BroadcastInitialValues();
66: 	Widget->AddToViewport();
67: }
```

## File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "WitchPTAbilitySystemComponent.generated.h"
 6: 
 7: DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& )
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
15: 
16: 	void AbilityInputTagPressed(const FGameplayTag& InputTag);
17: 	void AbilityInputTagHeld(const FGameplayTag& InputTag);
18: 	void AbilityInputTagReleased(const FGameplayTag& InputTag);
19: 	void AbilityActorInfoHaveBeenSet();
20: 
21: 	FEffectAssetTags OnEffectAssetTags;
22: 
23: 	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
24: 
25: 	bool bCharacterAbilitiesGiven = false;
26: 	bool bStartupEffectsApplied = false;
27: 
28: 	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;
29: 
30: 
31: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
32: 	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;
33: 
34: 
35: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
36: 	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;
37: 
38: 
39: 
40: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
41: 	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
42: 
43: protected:
44: 	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
45: 	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
46: 	UFUNCTION(Client, Reliable)
47: 	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
48: 
49: };
```

## File: Source/WitchPT/WitchPT.Build.cs
```csharp
 1: using UnrealBuildTool;
 2: 
 3: public class WitchPT : ModuleRules
 4: {
 5: 	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
 6: 	{
 7: 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
 8: 
 9: 		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });
10: 
11: 		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 	}
21: }
```

## File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
```cpp
 1: #include "Inventory/WitchPTInventoryItemInstance.h"
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Inventory/WitchPTInventoryItemDefinition.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "Net/UnrealNetwork.h"
 7: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
 8: class FLifetimeProperty;
 9: UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
10: 	:Super(ObjectInitializer)
11: {
12: }
13: 
14: void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
15: {
16: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
17: 
18: 	DOREPLIFETIME(ThisClass, ItemDef);
19: 	DOREPLIFETIME(ThisClass, TotalStackCount);
20: }
21: 
22: 
23: 
24: void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
25: {
26: 	ItemDef = InDef;
27: }
28: 
29: 
30: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
31: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
32: {
33: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
34: 	{
35: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
36: 	}
37: 
38: 	return nullptr;
39: }
```

## File: Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
```cpp
 1: #include "UI/WidgetControllers/CauldronWidgetController.h"
 2: 
 3: #include "Item/CauldronAltar.h"
 4: 
 5: UCauldronWidgetController::UCauldronWidgetController()
 6: {
 7: }
 8: 
 9: void UCauldronWidgetController::BroadcastInitialValues()
10: {
11: 	if(CauldronAltar)
12: 	{
13: 		OnBaseIngredientSet.Broadcast(CauldronAltar->GetBaseIngredient());
14: 
15: 	}
16: 
17: }
18: 
19: void UCauldronWidgetController::BindCallbacksToDependencies()
20: {
21: 	Super::BindCallbacksToDependencies();
22: 	if(CauldronAltar)
23: 	{
24: 		CauldronAltar->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
25: 		CauldronAltar->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
26: 		CauldronAltar->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
27: 		CauldronAltar->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
28: 		CauldronAltar->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
29: 		CauldronAltar->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
30: 	}
31: }
32: 
33: void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
34: {
35: 	if (InCauldronAltar != nullptr)
36: 	{
37: 		CauldronAltar = InCauldronAltar;
38: 	}
39: 
40: }
41: 
42: void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
43: {
44: 	OnBaseIngredientSet.Broadcast(IngredientInstance);
45: }
46: 
47: void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
48: {
49: 	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
50: }
51: 
52: void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
53: {
54: 	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
55: }
56: 
57: void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
58: {
59: 	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
60: }
61: 
62: void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
63: {
64: 	OnModifierIngredientSet.Broadcast(IngredientInstance);
65: }
66: 
67: void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
68: {
69: 	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
70: }
```

## File: Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
```cpp
 1: #include "UI/WidgetControllers/InventoryWidgetController.h"
 2: 
 3: #include "Inventory/WitchPTInventoryItemInstance.h"
 4: #include "Inventory/WitchPTInventoryManagerComponent.h"
 5: #include "Player/WitchPTPlayerController.h"
 6: 
 7: void UInventoryWidgetController::BindCallbacksToDependencies()
 8: {
 9: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
10: 	if (WitchPtPlayerController)
11: 	{
12: 		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
13: 		if (InventoryManager)
14: 		{
15: 			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
16: 			{
17: 				OnItemAddedDelegate.Broadcast(ItemAdded);
18: 			});
19: 			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
20: 			{
21: 				OnItemStackChangedDelegate.Broadcast(ItemAdded);
22: 			});
23: 			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
24: 			{
25: 				OnItemRemovedDelegate.Broadcast(ItemRemoved);
26: 			});
27: 		}
28: 	}
29: }
30: 
31: void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
32: {
33: 	if (!ItemInstance)
34: 	{
35: 		return;
36: 	}
37: 
38: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
39: 	if (!WitchPtPlayerController)
40: 	{
41: 		return;
42: 	}
43: 
44: 	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
45: 	if (!InventoryManager)
46: 	{
47: 		return;
48: 	}
49: 
50: 	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
51: 
52: 
53: 	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
54: 	{
55: 		InventoryManager->Server_RemoveItemInstance(ItemInstance);
56: 	}
57: 	else
58: 	{
59: 
60: 		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
61: 	}
62: }
```

## File: Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "CauldronWidgetController.generated.h"
 6: 
 7: class ACauldronAltar;
 8: class UWitchPTInventoryItemInstance;
 9: 
10: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
13: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
14: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
16: 
17: 
18: 
19: UCLASS(BlueprintType, Blueprintable)
20: class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
21: {
22: 	GENERATED_BODY()
23: public:
24: 	UCauldronWidgetController();
25: 	virtual void BroadcastInitialValues() override;
26: 	virtual void BindCallbacksToDependencies() override;
27: 
28: 
29: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
30: 	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
31: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
32: 	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
33: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
34: 	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
35: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
36: 	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
37: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
38: 	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
39: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
40: 	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;
41: 
42: 	UFUNCTION(Category = "Cauldron")
43: 	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);
44: 
45: 
46: 	UFUNCTION(BlueprintPure, Category = "Cauldron")
47: 	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
48: 
49: 
50: protected:
51: 
52: 	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
53: 	TObjectPtr<ACauldronAltar> CauldronAltar;
54: 
55: 	UFUNCTION(Category = "Cauldron")
56: 	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
57: 	UFUNCTION(Category = "Cauldron")
58: 	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
59: 	UFUNCTION(Category = "Cauldron")
60: 	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
61: 	UFUNCTION(Category = "Cauldron")
62: 	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
63: 	UFUNCTION(Category = "Cauldron")
64: 	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
65: 	UFUNCTION(Category = "Cauldron")
66: 	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
67: };
```

## File: Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "InventoryWidgetController.generated.h"
 6: 
 7: 
 8: 
 9: 
10: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);
12: 
13: UCLASS(BlueprintType, Blueprintable)
14: class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 	UFUNCTION(BlueprintCallable)
20: 	virtual void BindCallbacksToDependencies() override;
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable, Category = "Inventory")
29: 	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);
30: 
31: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
32: 	FOnItemAddedSignature OnItemAddedDelegate;
33: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
34: 	FOnItemAddedSignature OnItemStackChangedDelegate;
35: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
36: 	FOnItemRemovedSignature OnItemRemovedDelegate;
37: };
```

## File: Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "InteractionOption.h"
  5: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  6: #include "GameplayAbility_Interact.generated.h"
  7: 
  8: class UObject;
  9: struct FFrame;
 10: struct FGameplayAbilityActorInfo;
 11: struct FGameplayEventData;
 12: 
 13: 
 14: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);
 15: 
 16: 
 17: 
 18: 
 19: UCLASS(Abstract)
 20: class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
 21: {
 22: 	GENERATED_BODY()
 23: 	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 24: 	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 25: 
 26: 	UFUNCTION(BlueprintCallable)
 27: 	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
 28: 
 29: 
 30: 	UFUNCTION(BlueprintCallable)
 31: 	void TriggerInteraction();
 32: 
 33: 
 34: 	UFUNCTION(BlueprintCallable)
 35: 	void TriggerHoldInteraction();
 36: 
 37: 
 38: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 39: 	void OnInteractionButtonPressed();
 40: 
 41: 
 42: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 43: 	void OnInteractionButtonReleased();
 44: 
 45: 
 46: 	UFUNCTION()
 47: 	void OnHoldInteractionTimeElapsed();
 48: 
 49: 
 50:     UFUNCTION()
 51:     void CheckInteractionValidity();
 52: 
 53: 
 54:     UFUNCTION(BlueprintCallable, Category = "Interaction")
 55:     void CancelCurrentInteraction();
 56: 
 57: 
 58:     UFUNCTION()
 59:     void OnMaxInteractionTimeElapsed();
 60: 
 61: 
 62: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 63: 	FOnInteractionComplete OnInteractionComplete;
 64: 
 65: 
 66: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 67: 	FOnInteractionComplete OnHoldInteractionComplete;
 68: 
 69: 
 70:     UPROPERTY(BlueprintAssignable, Category = "Interaction")
 71:     FOnInteractionComplete OnInteractionCancelled;
 72: 
 73: protected:
 74: 
 75: 	UPROPERTY(BlueprintReadWrite)
 76: 	TArray<FInteractionOption> CurrentOptions;
 77: 
 78: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
 79: 	float InteractionScanRate = 0.1f;
 80: 
 81: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
 82: 	float InteractionScanRange = 500;
 83: 
 84: 
 85: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
 86: 	float HoldInteractionTime = 1.0f;
 87: 
 88: 
 89:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
 90:     float ValidityCheckRate = 0.1f;
 91: 
 92: 
 93:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
 94:     float MaxInteractionTime = 10.0f;
 95: 
 96: 
 97: 	FTimerHandle HoldInteractionTimerHandle;
 98: 
 99: 
100:     FTimerHandle ValidityCheckTimerHandle;
101: 
102: 
103:     FTimerHandle MaxInteractionTimeTimerHandle;
104: 
105: 
106: 	bool bIsInteractionButtonHeld = false;
107: 
108: 
109: 	float InteractionStartTime = 0.0f;
110: 
111: 
112: 	bool bHoldInteractionFired = false;
113: 
114: 
115:     TScriptInterface<IInteractableTarget> InitialInteractableTarget;
116: 
117: 	UPROPERTY(EditDefaultsOnly)
118: 	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
119: 
120: 
121: };
```

## File: .gitignore
```
 1: Binaries
 2: DerivedDataCache
 3: Intermediate
 4: Saved
 5: Build
 6: Plugins
 7: Content/WitchHag
 8: Content/BattleWitch
 9: Content/UltraDynamicSky
10: Content/MagicCircleVFX
11: Content/PIP_Herbals_Potions
12: Content/fullscreen_flat_gui
13: Content/Village
14: Content/LootDrop_VFX
15: 
16: .vscode
17: .vs
18: *.VC.db
19: *.opensdf
20: *.opendb
21: *.sdf
22: *.sln
23: *.suo
24: *.xcodeproj
25: *.xcworkspace
26: # ignore all related to .idea
27: .idea
28: 
29: .codebuddy/.gitignore
30: .idea/.idea.Aura.dir/.idea/workspace.xml
31: 
32: Source/WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.h
33: 
34: Source/WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlace.cpp
35: 
36: Source/WitchPT/Private/AbilitySystem/Cauldron/GA_CauldronPlacementPreview.cpp
37: 
38: Source/WitchPT/Public/AbilitySystem/Cauldron/GA_CauldronPlace.h
```

## File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Systems/GameplayTagStack.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "WitchPTInventoryItemInstance.generated.h"
 7: class UWitchPTInventoryItemFragment;
 8: class UWitchPTInventoryItemDefinition;
 9: struct FFrame;
10: struct FGameplayTag;
11: 
12: 
13: 
14: 
15: UCLASS(BlueprintType)
16: class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
21: 	friend struct FWitchPTInventoryList;
22: 
23: 
24: 	virtual bool IsSupportedForNetworking() const override { return true; }
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable)
29: 	int32 GetTotalStackCount() const { return TotalStackCount; }
30: 
31: 	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
32: 	UFUNCTION(BlueprintCallable)
33: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
34: 	{
35: 		return ItemDef;
36: 	}
37: 
38: 	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
39: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
40: 
41: 	template <typename ResultClass>
42: 	const ResultClass* FindFragmentByClass() const
43: 	{
44: 		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
45: 	}
46: 
47: 	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);
48: 
49: 
50: private:
51: 	UPROPERTY(Replicated)
52: 	int32 TotalStackCount{0};
53: 
54: 	UPROPERTY(Replicated)
55: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
56: 
57: };
```

## File: Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
```cpp
  1: #include "AbilitySystem/Interaction/GameplayAbility_Interact.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  5: #include "AbilitySystem/Interaction/InteractionStatics.h"
  6: #include "NativeGameplayTags.h"
  7: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  8: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  9: #include "Engine/World.h"
 10: #include "Player/WitchPTPlayerController.h"
 11: 
 12: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
 13: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");
 14: 
 15: UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
 16: 	: Super(ObjectInitializer)
 17: {
 18: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
 19: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 20: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 21: }
 22: 
 23: void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
 24: 	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
 25: 	const FGameplayEventData* TriggerEventData)
 26: {
 27: 	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
 28: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 29: 	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
 30: 	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
 31: 	{
 32: 
 33: 		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
 34: 		Task->ReadyForActivation();
 35: 
 36: 	}
 37: }
 38: 
 39: void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
 40: {
 41: 
 42: 	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
 43: 	{
 44: 
 45: 
 46: 		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
 47: 
 48: 		CurrentOptions = InteractiveOptions;
 49: 
 50: 		for (const FInteractionOption& InteractionOption : InteractiveOptions)
 51: 		{
 52: 			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 53: 
 54: 			if (InteractableTargetActor)
 55: 			{
 56: 				FString ActorName = InteractableTargetActor->GetName();
 57: 				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
 58: 			}
 59: 
 60: 
 61: 		}
 62: 		if (InteractiveOptions.Num() == 0)
 63: 		{
 64: 			WitchPt->HUDWidget->HidePickupMessage();
 65: 		}
 66: 
 67: 	}
 68: 
 69: 	CurrentOptions = InteractiveOptions;
 70: }
 71: 
 72: void UGameplayAbility_Interact::TriggerInteraction()
 73: {
 74: 	if (CurrentOptions.Num() == 0)
 75: 	{
 76: 		return;
 77: 	}
 78: 
 79: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 80: 	if (AbilitySystem)
 81: 	{
 82: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 83: 
 84: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 85: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 86: 
 87: 
 88: 
 89: 		FGameplayEventData Payload;
 90: 		Payload.EventTag = TAG_Ability_Interaction_Activate;
 91: 		Payload.Instigator = Instigator;
 92: 		Payload.Target = InteractableTargetActor;
 93: 
 94: 
 95: 
 96: 
 97: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
 98: 
 99: 
100: 
101: 
102: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
103: 
104: 
105: 		FGameplayAbilityActorInfo ActorInfo;
106: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
107: 
108: 
109: 
110: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
111: 			InteractionOption.TargetInteractionAbilityHandle,
112: 			&ActorInfo,
113: 			TAG_Ability_Interaction_Activate,
114: 			&Payload,
115: 			*InteractionOption.TargetAbilitySystem
116: 		);
117: 
118: 
119: 		OnInteractionComplete.Broadcast();
120: 	}
121: }
122: 
123: void UGameplayAbility_Interact::TriggerHoldInteraction()
124: {
125: 	if (CurrentOptions.Num() == 0)
126: 	{
127: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
128: 		OnInteractionCancelled.Broadcast();
129: 		return;
130: 	}
131: 
132: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
133: 	if (AbilitySystem)
134: 	{
135: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
136: 
137: 
138: 		if (!InteractionOption.bSupportsHoldInteraction)
139: 		{
140: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
141: 
142: 			TriggerInteraction();
143: 			return;
144: 		}
145: 
146: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
147: 
148: 		AActor* Instigator = GetAvatarActorFromActorInfo();
149: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
150: 
151: 
152: 		FGameplayEventData Payload;
153: 		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
154: 		Payload.Instigator = Instigator;
155: 		Payload.Target = InteractableTargetActor;
156: 
157: 
158: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);
159: 
160: 
161: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
162: 
163: 
164: 		FGameplayAbilityActorInfo ActorInfo;
165: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
166: 
167: 
168: 		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
169: 
170: 
171: 		if (!AbilityHandle.IsValid())
172: 		{
173: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
174: 			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
175: 		}
176: 		else
177: 		{
178: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
179: 		}
180: 
181: 
182: 
183: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
184: 			AbilityHandle,
185: 			&ActorInfo,
186: 			TAG_Ability_Interaction_Hold_Activate,
187: 			&Payload,
188: 			*InteractionOption.TargetAbilitySystem
189: 		);
190: 
191: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
192: 
193: 
194: 		OnHoldInteractionComplete.Broadcast();
195: 	}
196: }
197: 
198: void UGameplayAbility_Interact::OnInteractionButtonPressed()
199: {
200: 	if (CurrentOptions.Num() == 0)
201: 	{
202: 
203: 		OnInteractionCancelled.Broadcast();
204: 		return;
205: 	}
206: 
207: 
208: 	bIsInteractionButtonHeld = true;
209: 	bHoldInteractionFired = false;
210: 	InteractionStartTime = GetWorld()->GetTimeSeconds();
211: 
212: 
213: 	if (CurrentOptions.Num() > 0)
214: 	{
215: 		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
216: 
217: 	}
218: 
219: 
220: 	GetWorld()->GetTimerManager().SetTimer(
221: 		HoldInteractionTimerHandle,
222: 		this,
223: 		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
224: 		HoldInteractionTime,
225: 		false
226: 	);
227: 
228: 
229: 	GetWorld()->GetTimerManager().SetTimer(
230: 		ValidityCheckTimerHandle,
231: 		this,
232: 		&UGameplayAbility_Interact::CheckInteractionValidity,
233: 		ValidityCheckRate,
234: 		true
235: 	);
236: 
237: 
238: 	GetWorld()->GetTimerManager().SetTimer(
239: 		MaxInteractionTimeTimerHandle,
240: 		this,
241: 		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
242: 		MaxInteractionTime,
243: 		false
244: 	);
245: 
246: 
247: 
248: }
249: 
250: void UGameplayAbility_Interact::OnInteractionButtonReleased()
251: {
252: 
253: 
254: 	if (!bIsInteractionButtonHeld)
255: 	{
256: 
257: 		return;
258: 	}
259: 
260: 	bIsInteractionButtonHeld = false;
261: 
262: 
263: 	if (GetWorld())
264: 	{
265: 
266: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
267: 		{
268: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
269: 		}
270: 
271: 
272: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
273: 		{
274: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
275: 		}
276: 
277: 
278: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
279: 		{
280: 
281: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
282: 
283: 
284: 			if (bHoldInteractionFired)
285: 			{
286: 
287: 				return;
288: 			}
289: 
290: 
291: 			float CurrentTime = GetWorld()->GetTimeSeconds();
292: 			float HoldTime = CurrentTime - InteractionStartTime;
293: 
294: 
295: 
296: 			if (HoldTime < HoldInteractionTime)
297: 			{
298: 
299: 
300: 				TriggerInteraction();
301: 
302: 
303: 
304: 
305: 
306: 			}
307: 		}
308: 		else
309: 		{
310: 
311: 		}
312: 	}
313: 
314: 
315: 	InitialInteractableTarget = nullptr;
316: }
317: 
318: void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
319: {
320: 
321: 
322: 	if (bIsInteractionButtonHeld)
323: 	{
324: 
325: 
326: 		bHoldInteractionFired = true;
327: 
328: 
329: 
330: 		TriggerHoldInteraction();
331: 
332: 
333: 
334: 
335: 
336: 	}
337: 	else
338: 	{
339: 
340: 	}
341: }
342: 
343: void UGameplayAbility_Interact::CheckInteractionValidity()
344: {
345: 
346: 	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
347: 	{
348: 		return;
349: 	}
350: 
351: 
352: 	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
353: 
354: 
355: 	bool bHasValidInteraction = false;
356: 
357: 	if (CurrentOptions.Num() > 0)
358: 	{
359: 
360: 		for (const FInteractionOption& Option : CurrentOptions)
361: 		{
362: 			if (Option.InteractableTarget == InitialInteractableTarget)
363: 			{
364: 				bHasValidInteraction = true;
365: 				break;
366: 			}
367: 		}
368: 
369: 
370: 		if (bHasValidInteraction)
371: 		{
372: 			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
373: 		}
374: 		else
375: 		{
376: 
377: 			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
378: 			AActor* CurrentActor = CurrentOptions.Num() > 0 ?
379: 				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
380: 
381: 			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"),
382: 				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
383: 				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
384: 		}
385: 	}
386: 	else
387: 	{
388: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
389: 	}
390: 
391: 
392: 	if (!bHasValidInteraction)
393: 	{
394: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
395: 		CancelCurrentInteraction();
396: 	}
397: }
398: 
399: void UGameplayAbility_Interact::CancelCurrentInteraction()
400: {
401: 
402: 	if (!bIsInteractionButtonHeld)
403: 	{
404: 		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
405: 		return;
406: 	}
407: 
408: 
409: 	FString InitialObjectName = TEXT("Desconocido");
410: 	if (InitialInteractableTarget.GetInterface())
411: 	{
412: 		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
413: 		if (InitialActor)
414: 		{
415: 			InitialObjectName = InitialActor->GetName();
416: 		}
417: 	}
418: 
419: 	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
420: 
421: 
422: 	if (GetWorld())
423: 	{
424: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
425: 		{
426: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
427: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
428: 		}
429: 
430: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
431: 		{
432: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
433: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
434: 		}
435: 
436: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
437: 		{
438: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
439: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
440: 		}
441: 	}
442: 
443: 
444: 	bIsInteractionButtonHeld = false;
445: 	bHoldInteractionFired = false;
446: 
447: 
448: 	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
449: 	InitialInteractableTarget = nullptr;
450: 
451: 
452: 	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
453: 
454: 
455: 	OnInteractionCancelled.Broadcast();
456: }
457: 
458: void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
459: {
460: 
461: 	if (bIsInteractionButtonHeld)
462: 	{
463: 		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
464: 		CancelCurrentInteraction();
465: 
466: 
467: 		OnInteractionCancelled.Broadcast();
468: 	}
469: }
```

## File: Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Components/ActorComponent.h"
 5: #include "Item/MechanicsInterface.h"
 6: #include "WitchPTMechanicComponent.generated.h"
 7: 
 8: class ACauldronAltar;
 9: 
10: UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
11: class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 
17: 	UWitchPTMechanicComponent();
18: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
19: 
20: 
21: 	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
22: 	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
23: 	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
24: 	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
25: 	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
26: 	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
27: 	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
28: 
29: 	virtual void RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
30: 
31: 	UFUNCTION(Server, Reliable)
32: 	void Server_RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
33: 
34: 
35: 
36: 
37: 
38: 	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
39: 	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
40: 	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
41: 	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
42: 
43: 
44: 
45: 
46: protected:
47: 
48: 
49: 	virtual void BeginPlay() override;
50: 
51: public:
52: 
53: 	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
54: };
```

## File: Source/WitchPT/Public/Character/WitchPTCharacter.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "Item/CauldronAltar.h"
 6: #include "Item/MechanicsInterface.h"
 7: #include "Blueprint/UserWidget.h"
 8: #include "Components/WidgetComponent.h"
 9: #include "UObject/ConstructorHelpers.h"
10: #include "WitchPTCharacter.generated.h"
11: 
12: class UWitchPTMechanicComponent;
13: class ACauldronAltar;
14: class ARitualPosition;
15: 
16: UCLASS()
17: class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
18: {
19: 	GENERATED_BODY()
20: 
21: public:
22: 
23: 	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
24: 	virtual void PossessedBy(AController* NewController) override;
25: 	virtual void OnRep_PlayerState() override;
26: 
27: 	virtual void InitAbilityActorInfo() override;
28: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
29: 	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: };
```

## File: WitchPT.uproject.DotSettings.user
```
 1: <wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
 2: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AAndroidTargetPlatform_002EBuild_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FProgram_0020Files_003FEpic_0020Games_003FUE_005F5_002E5_003FEngine_003FSource_003FDeveloper_003FAndroid_003FAndroidTargetPlatform_003FAndroidTargetPlatform_002EBuild_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
 3: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ADuqasom_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FByfowyz_003FDuqasom_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 4: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AFonijyx_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FQukibov_003FFonijyx_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 5: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AHojanux_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FPolafon_003FHojanux_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 6: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AKalevut_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FTivupeq_003FKalevut_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 7: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ALekocyf_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FPuqyhac_003FLekocyf_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 8: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AMeganim_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FBilanag_003FMeganim_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
 9: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003Amimalloc_002Dinternal_002Eh_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FProgram_0020Files_003FEpic_0020Games_003FUE_005F5_002E5_003FEngine_003FSource_003FThirdParty_003Fmimalloc_003F2_002E0_002E0_003Finclude_003Fmimalloc_002Dinternal_002Eh/@EntryIndexedValue">ForceIncluded</s:String>
10: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ASegivyw_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FFyxodat_003FSegivyw_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
11: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AWyrataj_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FKilamyk_003FWyrataj_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
12: 	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AZowixan_002Easm_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003FAppData_003FLocal_003FTemp_003FSandboxFiles_003FMufytyw_003FZowixan_002Easm/@EntryIndexedValue">ForceIncluded</s:String>
13: 	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=c037d507_002Dd9ad_002D4d6b_002Db7d1_002D94b80280b02c/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" IsActive="True" Name="All tests from Solution" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
14:   &lt;Solution /&gt;&#xD;
15: &lt;/SessionState&gt;</s:String></wpf:ResourceDictionary>
```

## File: Source/WitchPT/Private/Item/RitualPosition.cpp
```cpp
  1: #include "Item/RitualPosition.h"
  2: #include "Net/UnrealNetwork.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/RitualAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "AbilitySystemComponent.h"
  7: #include "AbilitySystemBlueprintLibrary.h"
  8: #include "FWitchPTGameplayTags.h"
  9: #include "GameplayEffect.h"
 10: #include "GameFramework/CharacterMovementComponent.h"
 11: #include "Components/CapsuleComponent.h"
 12: #include "Kismet/GameplayStatics.h"
 13: #include "Character/Components/WitchPTMechanicComponent.h"
 14: 
 15: 
 16: ARitualPosition::ARitualPosition()
 17: {
 18: 
 19: }
 20: 
 21: void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 22: {
 23: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 24: 
 25: 	DOREPLIFETIME(ARitualPosition, RitualAltar);
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: void ARitualPosition::BeginPlay()
 38: {
 39: 	Super::BeginPlay();
 40: 
 41: 
 42: 
 43: }
 44: 
 45: 
 46: void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 47: {
 48: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: }
 86: 
 87: ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
 88: {
 89: 	if (RitualAltar)
 90: 	{
 91: 		return RitualAltar;
 92: 	}
 93: 	return nullptr;
 94: }
 95: 
 96: bool ARitualPosition::IsOccupied_Implementation()
 97: {
 98: 	return bIsOccupied;
 99: }
100: 
101: 
102: void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
103: {
104: 	Super::HandleInteraction(InteractingCharacter);
105: 
106: 	if (!InteractingCharacter || !RitualAltar)
107: 	{
108: 		return;
109: 	}
110: 
111: }
```

## File: Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Components/ActorComponent.h"
  5: #include "FastArray/FastArrayList.h"
  6: #include "Net/Serialization/FastArraySerializer.h"
  7: #include "WitchPTInventoryManagerComponent.generated.h"
  8: 
  9: class UInventoryUserWidget;
 10: class UWitchPTInventoryItemDefinition;
 11: class UWitchPTInventoryItemInstance;
 12: class UWitchPTInventoryManagerComponent;
 13: class UObject;
 14: struct FFrame;
 15: struct FNetDeltaSerializeInfo;
 16: struct FWitchPTInventoryList;
 17: struct FReplicationFlags;
 18: 
 19: 
 20: 
 21: 
 22: 
 23: 
 24: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);
 25: 
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: UCLASS(BlueprintType)
 34: class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
 35: {
 36: 	GENERATED_BODY()
 37: protected:
 38: 	virtual void BeginPlay() override;
 39: 
 40: public:
 41: 	UFUNCTION(BlueprintCallable)
 42: 	UInventoryUserWidget* GetInventoryMenuWidget() const { return InventoryMenu; }
 43: 
 44: 	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 45: 
 46: 
 47: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
 48: 	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 49: 
 50: 
 51: 	UFUNCTION(Server, Reliable)
 52: 	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 53: 
 54: 
 55: 	UFUNCTION(Server, Reliable)
 56: 	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 57: 
 58: 
 59: 	UFUNCTION(Server, Reliable)
 60: 	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);
 61: 
 62: 
 63: 	UFUNCTION(Server, Reliable)
 64: 	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);
 65: 
 66: 
 67: 	UFUNCTION(Server, Reliable)
 68: 	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);
 69: 
 70: 
 71: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
 72: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 73: 
 74: 
 75: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
 76: 	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 77: 
 78: 
 79: 	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 80: 
 81: 
 82: 	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);
 83: 
 84: 
 85: 
 86: 
 87: 	FOnItemChanged OnItemAdded;
 88: 
 89: 
 90: 	FOnItemChanged OnItemStackChanged;
 91: 
 92: 
 93: 	FOnItemChanged OnItemRemoved;
 94: 
 95: 
 96: 
 97: 
 98: 
 99: 
100: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
101: 
102: 
103: 
104: 
105: 
106: 	virtual void ReadyForReplication() override;
107: 
108: 
109: private:
110: 
111: 
112: 
113: 
114: 	UPROPERTY(Replicated)
115: 	FWitchPTInventoryList InventoryList;
116: 	UPROPERTY()
117: 	TObjectPtr<UInventoryUserWidget> InventoryMenu;
118: 
119: 
120: 	UPROPERTY(EditAnywhere, Category = "Inventory")
121: 	TSubclassOf<UInventoryUserWidget> InventoryMenuClass;
122: 
123: 	TWeakObjectPtr<APlayerController> OwningController;
124: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
125: 	void ToggleInventoryMenu();
126: 	void ConstructInventory();
127: 	bool bInventoryMenuOpen;
128: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
129: 	void OpenInventoryMenu();
130: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
131: 	void CloseInventoryMenu();
132: };
```

## File: Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
```cpp
  1: #include "Character/Components/WitchPTMechanicComponent.h"
  2: #include "Item/CauldronAltar.h"
  3: #include "Net/UnrealNetwork.h"
  4: #include "GameFramework/Character.h"
  5: #include "Item/RitualAltar.h"
  6: 
  7: 
  8: UWitchPTMechanicComponent::UWitchPTMechanicComponent()
  9: {
 10: 
 11: 	PrimaryComponentTick.bCanEverTick = true;
 12: 	SetIsReplicatedByDefault(true);
 13: }
 14: 
 15: void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 16: {
 17: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 18: 
 19: 
 20: }
 21: 
 22: 
 23: void UWitchPTMechanicComponent::BeginPlay()
 24: {
 25: 	Super::BeginPlay();
 26: 
 27: }
 28: 
 29: 
 30: void UWitchPTMechanicComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
 31: {
 32: 	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
 33: }
 34: 
 35: 
 36: void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
 37: {
 38: 	if (!TargetAltar)
 39: 	{
 40: 		return;
 41: 	}
 42: 
 43: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 44: 	if (!Character)
 45: 	{
 46: 		return;
 47: 	}
 48: 
 49: 	if (Character->HasAuthority())
 50: 	{
 51: 		TargetAltar->StartBrewingPotion(Character);
 52: 	}
 53: }
 54: 
 55: void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
 56: {
 57: 	if (!TargetAltar)
 58: 	{
 59: 		return;
 60: 	}
 61: 
 62: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 63: 	if (!Character)
 64: 	{
 65: 		return;
 66: 	}
 67: 
 68: 	if (GetOwnerRole() == ROLE_Authority)
 69: 	{
 70: 
 71: 		TargetAltar->StartCarryCauldron(Character);
 72: 	}
 73: 
 74: }
 75: 
 76: void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 77: {
 78: 	if (!TargetAltar)
 79: 	{
 80: 		return;
 81: 	}
 82: 
 83: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 84: 	if (!Character)
 85: 	{
 86: 		return;
 87: 	}
 88: 
 89: 	if (GetOwnerRole() == ROLE_Authority)
 90: 	{
 91: 
 92: 		TargetAltar->StartPlacementPreview(Character);
 93: 	}
 94: }
 95: 
 96: void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
 97: {
 98: 	if (!TargetAltar)
 99: 	{
100: 		return;
101: 	}
102: 
103: 	if (GetOwnerRole() == ROLE_Authority)
104: 	{
105: 
106: 		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
107: 	}
108: }
109: 
110: void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
111: {
112: 	if (!TargetAltar)
113: 	{
114: 		return;
115: 	}
116: 
117: 	if (GetOwnerRole() == ROLE_Authority)
118: 	{
119: 
120: 		TargetAltar->CancelPlacement();
121: 	}
122: 
123: }
124: 
125: void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
126: {
127: 	if (!TargetAltar)
128: 	{
129: 		return;
130: 	}
131: 
132: 	if (GetOwnerRole() == ROLE_Authority)
133: 	{
134: 
135: 		TargetAltar->FinalizePlacement();
136: 	}
137: 
138: }
139: 
140: void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
141: {
142: 	if (!TargetCauldron) return;
143: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
144: 	if (GetOwnerRole() == ROLE_Authority)
145: 	{
146: 		TargetCauldron->UnoccupyPosition(Character, nullptr);
147: 	}
148: }
149: 
150: void UWitchPTMechanicComponent::RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
151: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
152: {
153: 	if (!TargetAltar) return;
154: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
155: 
156: 
157: 	if(GetOwnerRole() == ROLE_Authority)
158: 	{
159: 		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
160: 	}
161: 	else
162: 	{
163: 		Server_RequestSetBaseIngredient(TargetAltar, IngredientItemDef);
164: 	}
165: 
166: 
167: 
168: }
169: 
170: void UWitchPTMechanicComponent::Server_RequestSetBaseIngredient_Implementation(ACauldronAltar* TargetAltar,
171: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
172: {
173: 	if (!TargetAltar) return;
174: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
175: 
176: 	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
177: 
178: }
179: 
180: void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
181: {
182: 
183: 	if (!TargetAltar) return;
184: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
185: 
186: 	if (GetOwnerRole() == ROLE_Authority)
187: 	{
188: 		TargetAltar->OccupyPosition(Character, Position);
189: 	}
190: 
191: }
192: 
193: void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
194: 	ABaseInteractionPosition* Position)
195: {
196: 	if (!TargetAltar) return;
197: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
198: 	if (GetOwnerRole() == ROLE_Authority)
199: 	{
200: 		TargetAltar->UnoccupyPosition(Character, Position);
201: 	}
202: 
203: }
204: 
205: void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
206: {
207: 	if (!TargetAltar) return;
208: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
209: 	if (GetOwnerRole() == ROLE_Authority)
210: 	{
211: 		TargetAltar->StartRitual(Character);
212: 	}
213: }
214: 
215: void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
216: {
217: 	if (!TargetAltar) return;
218: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
219: 	if (GetOwnerRole() == ROLE_Authority)
220: 	{
221: 		TargetAltar->HandlePlayerInput(Character, InputTag);
222: 	}
223: }
```

## File: Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
```cpp
  1: #include "Item/BaseInteractableAltar.h"
  2: 
  3: #include "FWitchPTGameplayTags.h"
  4: #include "Item/BaseInteractionPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Item/RitualAltar.h"
  8: #include "Item/RitualPosition.h"
  9: 
 10: 
 11: ABaseInteractableAltar::ABaseInteractableAltar()
 12: {
 13: 
 14:     PrimaryActorTick.bCanEverTick = true;
 15: 
 16: 
 17:     bReplicates = true;
 18:     bAlwaysRelevant = true;
 19: 
 20:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
 21:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
 22:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
 23:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);
 24: 
 25: }
 26: 
 27: void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 28: {
 29:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 30: 
 31:     DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
 32:     DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
 33:     DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
 34:     DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
 35: 
 36: }
 37: 
 38: 
 39: void ABaseInteractableAltar::BeginPlay()
 40: {
 41:     Super::BeginPlay();
 42: 
 43: 
 44:     CreateAltarPositions();
 45: }
 46: 
 47: 
 48: void ABaseInteractableAltar::Tick(float DeltaTime)
 49: {
 50:     Super::Tick(DeltaTime);
 51: 
 52: 
 53: }
 54: 
 55: 
 56: 
 57: void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 58: {
 59:     if (!Player || !Position || !HasAuthority())
 60:     {
 61:         return;
 62:     }
 63: 
 64:     Position->SetOccupied(nullptr);
 65: 
 66: 
 67:     ParticipatingPlayers.Remove(Player);
 68: 
 69: }
 70: void ABaseInteractableAltar::CreateAltarPositions()
 71: {
 72:     if (!HasAuthority() || !PositionClass)
 73:     {
 74:         return;
 75:     }
 76: 
 77: 
 78:     DestroyAltarPositions();
 79: 
 80:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
 81:     int positionIndex = 0;
 82: 
 83:     for (const FTransform& PosTransform : PositionTransforms)
 84:     {
 85: 
 86:         FTransform WorldTransform = PosTransform * GetActorTransform();
 87: 
 88: 
 89:         FVector Location = WorldTransform.GetLocation();
 90:         FRotator Rotation = WorldTransform.Rotator();
 91: 
 92: 
 93:         FActorSpawnParameters SpawnParams;
 94:         SpawnParams.Owner = this;
 95:         SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 96: 
 97: 
 98:         ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
 99:             PositionClass,
100:             Location,
101:             Rotation,
102:             SpawnParams);
103: 
104:         if (NewPosition)
105:         {
106: 
107: 
108: 
109:             NewPosition->SetPositionTag(TagsPositions[positionIndex]);
110:             ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
111:             if (RitualPosition)
112:             {
113:                 RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
114:             }
115:             positionIndex++;
116: 
117: 
118: 
119:             InteractionPositions.Add(NewPosition);
120: 
121:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
122:         }
123:     }
124: }
125: 
126: 
127: 
128: void ABaseInteractableAltar::DestroyAltarPositions()
129: {
130: 
131:     if (!HasAuthority())
132:     {
133:         return;
134:     }
135: 
136: 
137:     for (ABaseInteractionPosition* Position : InteractionPositions)
138:     {
139:         if (Position)
140:         {
141:             Position->Destroy();
142:         }
143:     }
144: 
145: 
146:     InteractionPositions.Empty();
147: 
148:     UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
149: }
150: 
151: 
152: void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
153: {
154: 
155:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
156: }
157: 
158: void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
159: {
160: 
161:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
162: }
163: 
164: void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
165: {
166: 
167:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
168: }
169: 
170: 
171: 
172: void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
173: {
174: 
175: }
176: 
177: 
178: void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
179: {
180: 
181:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
182: }
183: 
184: void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
185: {
186: 
187: }
188: 
189: void ABaseInteractableAltar::CheckState()
190: {
191: 
192: 
193: }
194: 
195: void ABaseInteractableAltar::CleanupInteraction()
196: {
197: 
198: }
199: 
200: void ABaseInteractableAltar::SpawnReward()
201: {
202: 
203: }
204: 
205: void ABaseInteractableAltar::SpawnDemon()
206: {
207: 
208: }
209: 
210: bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
211: {
212: 
213: 
214:     return Player && ParticipatingPlayers.Contains(Player);
215: }
```

## File: Source/WitchPT/Public/Item/BaseInteractableAltar.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/Actor.h"
  5: #include "GameplayTagContainer.h"
  6: #include "BaseInteractableAltar.generated.h"
  7: 
  8: class UWitchPTUserWidget;
  9: class ABaseInteractionPosition;
 10: class ACharacter;
 11: 
 12: 
 13: 
 14: 
 15: UENUM(BlueprintType)
 16: enum class EInteractionState : uint8
 17: {
 18:     Inactive    UMETA(DisplayName = "Inactive"),
 19:     WaitingForPlayers UMETA(DisplayName = "Waiting For Players"),
 20:     Preparing   UMETA(DisplayName = "Preparing"),
 21:     Active      UMETA(DisplayName = "Active"),
 22:     Succeeded   UMETA(DisplayName = "Succeeded"),
 23:     Failed      UMETA(DisplayName = "Failed"),
 24:     FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
 25: };
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
 28: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);
 29: 
 30: 
 31: USTRUCT(BlueprintType)
 32: struct FPlayerPositionTagEntry
 33: {
 34:     GENERATED_BODY();
 35: 
 36:     UPROPERTY(BlueprintReadWrite)
 37:     TObjectPtr<ACharacter> Player = nullptr;
 38: 
 39:     UPROPERTY(BlueprintReadWrite)
 40:     FGameplayTag PositionTag;
 41: };
 42: 
 43: 
 44: 
 45: 
 46: UCLASS(Abstract)
 47: class WITCHPT_API ABaseInteractableAltar : public AActor
 48: {
 49:     GENERATED_BODY()
 50: 
 51: public:
 52: 
 53:     ABaseInteractableAltar();
 54:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 55: 
 56: 
 57:     UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
 58:     EInteractionState CurrentState = EInteractionState::Inactive;
 59: 
 60: 
 61:     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
 62:     TArray<FTransform> PositionTransforms;
 63: 
 64: 
 65:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
 66:     TSubclassOf<ABaseInteractionPosition> PositionClass;
 67: 
 68:     UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
 69:     TArray<FGameplayTag> TagsPositions;
 70: 
 71: 
 72:     UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
 73:     TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
 74: 
 75: 
 76: 
 77:     UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 78:     TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;
 79: 
 80:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 81:     TArray<FPlayerPositionTagEntry> PlayerPositionTags;
 82: 
 83: 
 84: 
 85:     virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
 86: 
 87: 
 88:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 89:     virtual void CreateAltarPositions();
 90: 
 91: 
 92:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 93:     virtual void DestroyAltarPositions();
 94: 
 95: 
 96: 
 97: 
 98:     UFUNCTION(NetMulticast, Reliable)
 99:     void Multicast_OnStateChanged(EInteractionState NewState);
100: 
101:     UFUNCTION(NetMulticast, Reliable)
102:     virtual void Multicast_OnInputSuccess(ACharacter* Character);
103: 
104:     UFUNCTION(NetMulticast, Reliable)
105:     virtual void Multicast_OnInputFailed(ACharacter* Character);
106: 
107: 
108: 
109:     UFUNCTION(BlueprintPure, Category = "Interaction")
110:     EInteractionState GetCurrentState() const { return CurrentState; }
111: 
112:     UPROPERTY(EditDefaultsOnly)
113:     TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;
114: 
115: protected:
116:     virtual void BeginPlay() override;
117:     virtual void Tick(float DeltaTime) override;
118: 
119: 
120: 
121:     UFUNCTION()
122:     virtual void OnRep_ParticipatingPlayers();
123: 
124: 
125: 
126:     virtual void HandleInputSuccess(ACharacter* Player);
127:     virtual void HandleInputFailure(ACharacter* Player);
128:     virtual void CheckState();
129:     virtual void CleanupInteraction();
130:     virtual void SpawnReward();
131:     virtual void SpawnDemon();
132:     virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
133: 
134: };
```

## File: Source/WitchPT/Public/Item/RitualPosition.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "MechanicsInterface.h"
 7: #include "PositionInterface.h"
 8: #include "RitualPosition.generated.h"
 9: 
10: 
11: class ARitualAltar;
12: class UAbilitySystemComponent;
13: struct FGameplayAbilitySpec;
14: class AController;
15: class UGameplayAbility;
16: class UBoxComponent;
17: class ACharacter;
18: 
19: UCLASS()
20: class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 
26: 	ARitualPosition();
27: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
28: 
29: 
30: 	virtual void BeginPlay() override;
31: 
32: 
33: 
34: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38: 	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
39: 
40: 
41: 	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
42: 	virtual bool IsOccupied_Implementation() override;
43: 
44: protected:
45: 
46: 	UPROPERTY(EditInstanceOnly, Replicated)
47: 	TObjectPtr<ARitualAltar> RitualAltar;
48: 
49: 
50: 	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
51: 
52: private:
53: 
54: 
55: };
```

## File: Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
```cpp
  1: #include "Inventory/WitchPTInventoryManagerComponent.h"
  2: 
  3: #include "Blueprint/UserWidget.h"
  4: #include "Engine/ActorChannel.h"
  5: #include "Inventory/WitchPTInventoryItemDefinition.h"
  6: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  7: #include "Inventory/WitchPTInventoryItemInstance.h"
  8: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
  9: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 10: #include "Net/UnrealNetwork.h"
 11: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 12: 
 13: 
 14: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)
 15: 
 16: 
 17: void UWitchPTInventoryManagerComponent::BeginPlay()
 18: {
 19: 	Super::BeginPlay();
 20: 	ConstructInventory();
 21: }
 22: 
 23: UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
 24: : Super(ObjectInitializer)
 25: 	, InventoryList(this)
 26: {
 27: 	PrimaryComponentTick.bCanEverTick = false;
 28: 	SetIsReplicatedByDefault(true);
 29: 	bReplicateUsingRegisteredSubObjectList = true;
 30: }
 31: void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
 32: {
 33: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 34: 
 35: 	DOREPLIFETIME(ThisClass, InventoryList);
 36: }
 37: 
 38: 
 39: 
 40: void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 41: {
 42: 	if(IsValid(ItemDef))
 43: 	{
 44: 		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 45: 		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 46: 		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 47: 
 48: 		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
 49: 		Server_UpdateItemStackCount(FoundItem, NewStackCount);
 50: 	}
 51: }
 52: 
 53: void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
 54: {
 55: 	if (IsValid(ItemInstance))
 56: 	{
 57: 		ItemInstance->SetTotalStackCount(NewCount);
 58: 
 59: 
 60: 		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 61: 		{
 62: 			if (Entry.Instance == ItemInstance)
 63: 			{
 64: 				InventoryList.MarkItemDirty(Entry);
 65: 				break;
 66: 			}
 67: 		}
 68: 
 69: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 70: 		{
 71: 			OnItemStackChanged.Broadcast(ItemInstance);
 72: 		}
 73: 	}
 74: }
 75: 
 76: void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
 77: {
 78: 	if (IsValid(ItemInstance))
 79: 	{
 80: 
 81: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 82: 		{
 83: 			OnItemRemoved.Broadcast(ItemInstance);
 84: 		}
 85: 
 86: 
 87: 		InventoryList.RemoveEntry(ItemInstance);
 88: 
 89: 
 90: 		if (IsUsingRegisteredSubObjectList())
 91: 		{
 92: 			RemoveReplicatedSubObject(ItemInstance);
 93: 		}
 94: 	}
 95: }
 96: 
 97: void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 98: {
 99: 	if (IsValid(ItemInstance))
100: 	{
101: 		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
102: 		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
103: 
104: 
105: 		if (NewCount <= 0)
106: 		{
107: 			Server_RemoveItemInstance(ItemInstance);
108: 		}
109: 		else
110: 		{
111: 
112: 			Server_UpdateItemStackCount(ItemInstance, NewCount);
113: 		}
114: 	}
115: }
116: 
117: TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
118: {
119: 	return InventoryList.GetAllItems();
120: }
121: 
122: bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
123: {
124: 	if (!ItemDef)
125: 	{
126: 		return false;
127: 	}
128: 
129: 	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
130: 	if (FoundItem)
131: 	{
132: 		Server_AddStacksToItem(ItemDef);
133: 		return false;
134: 	}
135: 	else
136: 	{
137: 		Server_AddItem(ItemDef);
138: 		return true;
139: 	}
140: }
141: 
142: 
143: 
144: void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
145: {
146: 	UWitchPTInventoryItemInstance* NewItem = nullptr;
147: 	if (ItemDef != nullptr)
148: 	{
149: 		NewItem = InventoryList.AddEntry(ItemDef);
150: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
151: 		{
152: 			OnItemAdded.Broadcast(NewItem);
153: 		}
154: 
155: 		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
156: 		{
157: 			AddReplicatedSubObject(NewItem);
158: 		}
159: 	}
160: 
161: }
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
177: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
178: {
179: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
180: 	{
181: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
182: 
183: 		if (IsValid(Instance))
184: 		{
185: 			if (Instance->GetItemDef() == ItemDef)
186: 			{
187: 				return Instance;
188: 			}
189: 		}
190: 	}
191: 
192: 	return nullptr;
193: }
194: 
195: int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
196: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
197: {
198: 	int32 TotalCount = 0;
199: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
200: 	{
201: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
202: 
203: 		if (IsValid(Instance))
204: 		{
205: 			if (Instance->GetItemDef() == ItemDef)
206: 			{
207: 				++TotalCount;
208: 			}
209: 		}
210: 	}
211: 
212: 	return TotalCount;
213: }
214: 
215: bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
216: 	int32 NumToConsume)
217: {
218: 	AActor* OwningActor = GetOwner();
219: 	if (!OwningActor || !OwningActor->HasAuthority())
220: 	{
221: 		return false;
222: 	}
223: 
224: 
225: 	int32 TotalConsumed = 0;
226: 	while (TotalConsumed < NumToConsume)
227: 	{
228: 		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
229: 		{
230: 			InventoryList.RemoveEntry(Instance);
231: 			++TotalConsumed;
232: 		}
233: 		else
234: 		{
235: 			return false;
236: 		}
237: 	}
238: 
239: 	return TotalConsumed == NumToConsume;
240: }
241: 
242: 
243: bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
244:                                                             FReplicationFlags* RepFlags)
245: {
246: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
247: 
248: 	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
249: 	{
250: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
251: 
252: 		if (Instance && IsValid(Instance))
253: 		{
254: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
255: 		}
256: 	}
257: 
258: 	return WroteSomething;
259: }
260: 
261: void UWitchPTInventoryManagerComponent::ReadyForReplication()
262: {
263: 	Super::ReadyForReplication();
264: 
265: 	if (IsUsingRegisteredSubObjectList())
266: 	{
267: 		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
268: 		{
269: 			UWitchPTInventoryItemInstance* Instance = Entry.Instance;
270: 
271: 			if (IsValid(Instance))
272: 			{
273: 				AddReplicatedSubObject(Instance);
274: 			}
275: 		}
276: 	}
277: }
278: 
279: void UWitchPTInventoryManagerComponent::ToggleInventoryMenu()
280: {
281: 	if (bInventoryMenuOpen)
282: 	{
283: 		CloseInventoryMenu();
284: 	}
285: 	else
286: 	{
287: 		OpenInventoryMenu();
288: 	}
289: }
290: 
291: void UWitchPTInventoryManagerComponent::ConstructInventory()
292: {
293: 	OwningController = Cast<APlayerController>(GetOwner());
294: 	checkf(OwningController.IsValid(), TEXT("Inventory Component should have a Player Controller as Owner."))
295: 	if (!OwningController->IsLocalController()) return;
296: 	InventoryMenu = CreateWidget<UInventoryUserWidget>(OwningController.Get(), InventoryMenuClass);
297: 	InventoryMenu->AddToViewport();
298: 	CloseInventoryMenu();
299: }
300: 
301: void UWitchPTInventoryManagerComponent::OpenInventoryMenu()
302: {
303: 	if (!IsValid(InventoryMenu)) return;
304: 
305: 	InventoryMenu->SetVisibility(ESlateVisibility::Visible);
306: 	bInventoryMenuOpen = true;
307: 
308: 	if (!OwningController.IsValid()) return;
309: 
310: 	FInputModeGameAndUI InputMode;
311: 
312: 	OwningController->SetInputMode(InputMode);
313: 	OwningController->SetShowMouseCursor(true);
314: }
315: 
316: void UWitchPTInventoryManagerComponent::CloseInventoryMenu()
317: {
318: 	if (!IsValid(InventoryMenu)) return;
319: 
320: 	InventoryMenu->SetVisibility(ESlateVisibility::Collapsed);
321: 	bInventoryMenuOpen = false;
322: 
323: 	if (!OwningController.IsValid()) return;
324: 
325: 	FInputModeGameOnly InputMode;
326: 	OwningController->SetInputMode(InputMode);
327: 	OwningController->SetShowMouseCursor(false);
328: }
```

## File: Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: #include "WitchPTWidgetController.h"
  6: #include "Item/RitualAltar.h"
  7: #include "RitualWidgetController.generated.h"
  8: 
  9: enum class ERitualInput : uint8;
 10: class ARitualAltar;
 11: class ACharacter;
 12: enum class EInteractionState : uint8;
 13: 
 14: 
 15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
 16: 
 17: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
 18: 
 19: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
 20: 
 21: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
 22: 
 23: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
 24: 
 25: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
 28: 
 29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);
 30: 
 31: 
 32: 
 33: 
 34: UCLASS(BlueprintType, Blueprintable)
 35: class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
 36: {
 37: 	GENERATED_BODY()
 38: 
 39: public:
 40: 	URitualWidgetController();
 41: 
 42: 	virtual void BroadcastInitialValues() override;
 43: 	virtual void BindCallbacksToDependencies() override;
 44: 
 45: 
 46: 	UFUNCTION(Category = "Ritual")
 47: 	void SetRitualAltar(ARitualAltar* InRitualAltar);
 48: 
 49: 
 50: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 51: 	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
 52: 
 53: 
 54: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 55: 	bool IsLocalPlayerActive() const;
 56: 
 57: 
 58: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 59: 	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;
 60: 
 61: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 62: 	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;
 63: 
 64: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 65: 	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
 66: 
 67: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 68: 	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
 69: 
 70: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 71: 	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
 72: 
 73: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 74: 	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
 75: 
 76: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 77: 	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
 78: 
 79: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 80: 	FOnRitualCompletedSignature_WC OnRitualCompleted;
 81: 
 82: protected:
 83: 
 84: 	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
 85: 	TObjectPtr<ARitualAltar> RitualAltar;
 86: 
 87: 
 88: 	UFUNCTION()
 89: 	void HandleRitualStateChanged(EInteractionState NewState);
 90: 
 91: 	UFUNCTION()
 92: 	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
 93: 
 94: 	UFUNCTION()
 95: 	void HandleCountdownTick(int32 CountdownValue);
 96: 
 97: 	UFUNCTION()
 98: 	void HandleTurnDataChanged(FUIRitualData TurnData);
 99: 
100: 	UFUNCTION()
101: 	void HandleCorruptionChanged(float CorruptionPercentage);
102: 
103: 	UFUNCTION()
104: 	void HandleSequenceProgressChanged(float ProgressPercentage);
105: 
106: 	UFUNCTION()
107: 	void HandleRitualCompleted(bool bWasSuccessful);
108: 
109: private:
110: 
111: 	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
112: };
```

## File: Source/WitchPT/Private/Character/WitchPTCharacter.cpp
```cpp
 1: #include "Character/WitchPTCharacter.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Character/Components/WitchPTMechanicComponent.h"
 7: #include "Item/RitualAltar.h"
 8: #include "Item/RitualPosition.h"
 9: #include "Player/WitchPTPlayerController.h"
10: #include "Player/WitchPTPlayerState.h"
11: #include "UI/HUD/WitchPTHUD.h"
12: #include "WitchPT/WitchPT.h"
13: 
14: 
15: 
16: AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
17: {
18: 
19: 	PrimaryActorTick.bCanEverTick = true;
20: 
21: 	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
22: 
23: }
24: 
25: void AWitchPTCharacter::PossessedBy(AController* NewController)
26: {
27: 	Super::PossessedBy(NewController);
28: 
29: 
30: 	InitAbilityActorInfo();
31: 
32: 
33: 
34: 	if (AbilitySystemComponent)
35: 	{
36: 		GrantStartupAbilities();
37: 		AddStartupEffects();
38: 	}
39: }
40: 
41: void AWitchPTCharacter::OnRep_PlayerState()
42: {
43: 	Super::OnRep_PlayerState();
44: 
45: 	InitAbilityActorInfo();
46: 	AddStartupEffects();
47: }
48: 
49: void AWitchPTCharacter::InitAbilityActorInfo()
50: {
51: 	Super::InitAbilityActorInfo();
52: 	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
53: 
54: 	if (!WitchPtPlayerState)
55: 	{
56: 		return;
57: 	}
58: 
59: 	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);
60: 
61: 	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
62: 	if (!AbilitySystemComponent)
63: 	{
64: 		return;
65: 	}
66: 
67: 	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
68: 	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
77: 	{
78: 		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
79: 		{
80: 			WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
81: 		}
82: 	}
83: 	InitializeDefaultAttributes();
84: }
```

## File: Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
```cpp
  1: #include "UI/WidgetControllers/RitualWidgetController.h"
  2: #include "Item/RitualAltar.h"
  3: #include "GameFramework/Character.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystemComponent.h"
  6: #include "AbilitySystemBlueprintLibrary.h"
  7: #include "FWitchPTGameplayTags.h"
  8: 
  9: URitualWidgetController::URitualWidgetController()
 10: {
 11: 
 12: }
 13: 
 14: void URitualWidgetController::BroadcastInitialValues()
 15: {
 16: 
 17:     if (RitualAltar)
 18:     {
 19: 
 20:         OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
 21: 
 22: 
 23:         FRitualReadyPlayersData ReadyPlayersData;
 24:         ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
 25:         ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
 26:         OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 27: 
 28: 
 29:         FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
 30:         FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
 31:         OnTurnDataChanged.Broadcast(ProcessedTurnData);
 32: 
 33: 
 34:         OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
 35: 
 36: 
 37:         OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
 38:     }
 39: }
 40: 
 41: void URitualWidgetController::BindCallbacksToDependencies()
 42: {
 43: 
 44:     if (RitualAltar)
 45:     {
 46: 
 47:         RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
 48:         RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
 49:         RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
 50:         RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
 51:         RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
 52:         RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
 53:         RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
 54:     }
 55: }
 56: 
 57: void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
 58: {
 59: 
 60:     if (RitualAltar != nullptr)
 61:     {
 62:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 63:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 64:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 65:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 66:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 67:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 68:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 69:     }
 70: 
 71: 
 72:     RitualAltar = InRitualAltar;
 73: 
 74: 
 75:     if (RitualAltar)
 76:     {
 77:         BindCallbacksToDependencies();
 78:         BroadcastInitialValues();
 79:     }
 80: }
 81: 
 82: bool URitualWidgetController::IsLocalPlayerActive() const
 83: {
 84:     if (!RitualAltar || !PlayerController)
 85:     {
 86:         return false;
 87:     }
 88: 
 89: 
 90:     ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
 91:     if (!LocalCharacter)
 92:     {
 93:         return false;
 94:     }
 95: 
 96: 
 97:     return RitualAltar->GetCurrentActivePlayer() == LocalCharacter;
 98: }
 99: 
100: FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
101: {
102:     FUIRitualData ProcessedData = InTurnData;
103: 
104: 
105:     ProcessedData.bIsMyTurn = IsLocalPlayerActive();
106: 
107: 
108:     if (!ProcessedData.bIsMyTurn)
109:     {
110:         ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
111:         ProcessedData.CurrentInputTimeRemaining = 0.0f;
112:     }
113: 
114:     return ProcessedData;
115: }
116: 
117: 
118: 
119: void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
120: {
121:     OnRitualStateChanged.Broadcast(NewState);
122: }
123: 
124: void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
125: {
126:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
127: }
128: 
129: void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
130: {
131:     OnRitualCountdownTick.Broadcast(CountdownValue);
132: }
133: 
134: void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
135: {
136: 
137:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
138:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
139: 
140: 
141:     if (ProcessedTurnData.bIsMyTurn)
142:     {
143:         OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
144:     }
145:     else
146:     {
147:         OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
148:     }
149: }
150: 
151: void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
152: {
153:     OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
154: }
155: 
156: void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
157: {
158:     OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
159: }
160: 
161: void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
162: {
163:     OnRitualCompleted.Broadcast(bWasSuccessful);
164: 
165: 
166:     if (RitualAltar)
167:     {
168:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
169:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
170:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
171:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
172:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
173:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
174:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
175:     }
176: }
```

## File: Source/WitchPT/Public/FWitchPTGameplayTags.cpp
```cpp
  1: #include "FWitchPTGameplayTags.h"
  2: 
  3: #include "GameplayTagsManager.h"
  4: 
  5: FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;
  6: 
  7: void FWitchPTGameplayTags::InitializeGameplayTags()
  8: {
  9: 	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
 10: 	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
 11: 	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
 12: 	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
 13: 	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
 14: 	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
 15: 	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
 16: 	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
 17: 	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
 18: 	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
 19: 	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
 20: 	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
 21: 	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
 22: 	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
 23: 	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
 24: 	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
 25: 	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));
 26: 
 27: 	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
 28: 	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
 29: 	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
 30: 	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
 31: 
 32: 	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
 33: 	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
 34: 	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
 35: 	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
 36: 	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
 37: 
 38: 	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
 39: 	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
 40: 	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
 41: 	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
 42: 	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
 43: 	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
 44: 	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));
 45: 
 46: 
 47: 
 48: 
 49: 	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
 50: 	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
 51: 	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
 52: 	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
 53: 	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
 54: 	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
 55: 	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
 56: 	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
 57: 	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
 58: 	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
 59: 	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
 60: 	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
 61: 	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
 62: 	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
 63: 	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
 64: 	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
 65: 
 66: 	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
 67: 	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
 68: 	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
 69: 	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));
 70: 
 71: 	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
 72: 	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
 73: 	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
 74: 	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));
 75: 
 76: 
 77: 	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
 78: 	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
 79: 	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
 80: 	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
 81: 	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
 82: 	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
 83: 	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));
 84: 
 85: 
 86: 
 87: 	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
 88: 	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
 89: 	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
 90: 
 91: 
 92: 
 93: 	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));
 94: 
 95: 
 96: 	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
 97: 	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
 98: 	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
 99: 	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
100: 	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
101: 	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
102: 	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));
103: 
104: 	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
105: 	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
106: 	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
107: 	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
108: 	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));
109: 
110: 
111: 
112: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
113: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
114: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
115: 
116: 
117: 	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
118: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
119: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
120: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));
121: 
122: 
123: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
124: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
125: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
126: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));
127: 
128: 
129: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
130: 
131: 
132: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
133: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
134: 
135: 
136: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
137: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
138: 
139: 
140: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
141: 
142: 
143: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
144: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
145: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));
146: 
147: }
```

## File: Source/WitchPT/Public/FWitchPTGameplayTags.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: 
  6: 
  7: 
  8: 
  9: 
 10: 
 11: 
 12: struct FWitchPTGameplayTags
 13: {
 14: public:
 15: 	static FWitchPTGameplayTags& Get() { return GameplayTags; }
 16: 	static void InitializeGameplayTags();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 	FGameplayTag Attributes_Primary_Health;
 23: 	FGameplayTag Attributes_Primary_Age;
 24: 	FGameplayTag Attributes_Secondary_Mana;
 25: 	FGameplayTag Attributes_Secondary_Stamina;
 26: 
 27: 	FGameplayTag Character_State_Movement_Sprinting;
 28: 	FGameplayTag Character_State_Movement_Crouching;
 29: 	FGameplayTag Character_State_Movement_MovingToPosition;
 30: 	FGameplayTag Character_State_Dead;
 31: 	FGameplayTag Character_State_Aim;
 32: 	FGameplayTag Character_State_Blocked;
 33: 
 34: 	FGameplayTag Character_State_Cauldron_InPosition;
 35: 	FGameplayTag Character_State_Cauldron_Carrying;
 36: 	FGameplayTag Character_State_Cauldron_Placing;
 37: 	FGameplayTag Character_State_Cauldron_InGame;
 38: 	FGameplayTag Character_State_Cauldron_BrewingPotion;
 39: 
 40: 	FGameplayTag Character_State_Ritual_InPosition;
 41: 	FGameplayTag Character_State_Ritual_InGame;
 42: 
 43: 
 44: 	FGameplayTag Ability_Interact;
 45: 	FGameplayTag Ability_Sprint;
 46: 	FGameplayTag Ability_Jump;
 47: 	FGameplayTag Ability_Crouch;
 48: 	FGameplayTag Ability_Ritual_GoToPosition;
 49: 	FGameplayTag Ability_Ritual_ParticipatingInRitual;
 50: 	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
 51: 	FGameplayTag Ability_Ritual_Start;
 52: 	FGameplayTag Ability_Ritual_SendInput;
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
 60: 	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
 61: 	FGameplayTag Ability_Cauldron_CarryingCauldron;
 62: 	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
 63: 	FGameplayTag Ability_Cauldron_SetInPlace;
 64: 	FGameplayTag Ability_Cauldron_CancelSetInPlace;
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 	FGameplayTag InputTag_LMB;
 73: 	FGameplayTag InputTag_RMB;
 74: 	FGameplayTag InputTag_1;
 75: 	FGameplayTag InputTag_2;
 76: 	FGameplayTag InputTag_3;
 77: 	FGameplayTag InputTag_4;
 78: 	FGameplayTag InputTag_5;
 79: 	FGameplayTag InputTag_6;
 80: 	FGameplayTag InputTag_7;
 81: 	FGameplayTag InputTag_8;
 82: 	FGameplayTag InputTag_9;
 83: 	FGameplayTag InputTag_0;
 84: 	FGameplayTag InputTag_Ctrl;
 85: 	FGameplayTag InputTag_Alt;
 86: 	FGameplayTag InputTag_Shift;
 87: 	FGameplayTag InputTag_Tab;
 88: 
 89: 
 90: 
 91: 	FGameplayTag Ritual_Position_1;
 92: 	FGameplayTag Ritual_Position_2;
 93: 	FGameplayTag Ritual_Position_3;
 94: 	FGameplayTag Ritual_Position_4;
 95: 
 96: 	FGameplayTag Ritual_Input_Up;
 97: 	FGameplayTag Ritual_Input_Down;
 98: 	FGameplayTag Ritual_Input_Left;
 99: 	FGameplayTag Ritual_Input_Right;
100: 
101: 
102: 	FGameplayTag Event_Ritual_InputSuccess;
103: 	FGameplayTag Event_Ritual_InputFailure;
104: 	FGameplayTag Event_Ritual_SequenceSuccess;
105: 	FGameplayTag Event_Ritual_SequenceFailure;
106: 	FGameplayTag Event_Ritual_CatastrophicFailure;
107: 
108: 
109: 
110: 
111: 	FGameplayTag Event_Ritual_InputReceived;
112: 	FGameplayTag Event_Ritual_TurnAdvanced;
113: 	FGameplayTag Event_Ritual_SequenceFail;
114: 	FGameplayTag Event_Ritual_CatastrophicFail;
115: 
116: 
117: 	FGameplayTag Cauldron_State_Empty;
118: 	FGameplayTag Cauldron_State_Full;
119: 	FGameplayTag Cauldron_State_PotionReady;
120: 	FGameplayTag Event_Cauldron_CharacterPositioned;
121: 
122: 
123: 
124: 	FGameplayTag Communication_Message;
125: 
126: 
127: 	FGameplayTag Item;
128: 	FGameplayTag Item_Consumable;
129: 	FGameplayTag Item_Consumable_Potion;
130: 	FGameplayTag Item_Consumable_Potion_Tier_0;
131: 	FGameplayTag Item_Consumable_Potion_Tier_1;
132: 	FGameplayTag Item_Consumable_Potion_Tier_2;
133: 	FGameplayTag Item_Consumable_Potion_Tier_3;
134: 
135: 	FGameplayTag Item_Consumable_Ingredient;
136: 	FGameplayTag Item_Consumable_Ingredient_Tier_0;
137: 	FGameplayTag Item_Consumable_Ingredient_Tier_1;
138: 	FGameplayTag Item_Consumable_Ingredient_Tier_2;
139: 	FGameplayTag Item_Consumable_Ingredient_Tier_3;
140: 
141: 
142: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
143: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
144: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;
145: 
146: 	FGameplayTag Item_Consumable_Ingredient_Category_Base;
147: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
148: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
149: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
150: 
151: 
152: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
153: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
154: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
155: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
164: 
165: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
166: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
167: 
168: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
169: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
170: 
171: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
172: 
173: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
174: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
175: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
176: 
177: 
178: 
179: 
180: 
181: private:
182: 	static FWitchPTGameplayTags GameplayTags;
183: 
184: 
185: };
```

## File: Source/WitchPT/Public/Item/MechanicsInterface.h
```
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "UObject/Interface.h"
 6: #include "MechanicsInterface.generated.h"
 7: 
 8: class UWitchPTInventoryItemDefinition;
 9: class UWitchPTInventoryItemInstance;
10: class ABaseInteractionPosition;
11: class ACauldronAltar;
12: class ARitualPosition;
13: class ARitualAltar;
14: class ACharacter;
15: 
16: 
17: UINTERFACE(MinimalAPI)
18: class UMechanicsInterface : public UInterface
19: {
20: 	GENERATED_BODY()
21: };
22: 
23: 
24: 
25: 
26: class WITCHPT_API IMechanicsInterface
27: {
28: 	GENERATED_BODY()
29: 
30: 
31: 
32: public:
33: 
34: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
35: 	void RequestStartRitual(ARitualAltar* TargetAltar);
36: 
37: 
38: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
39: 	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);
40: 
41: 
42: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
43: 	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
44: 
45: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
46: 	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
47: 
48: 
49: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
50: 	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);
51: 
52: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
53: 	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);
54: 
55: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
56: 	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);
57: 
58: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
59: 	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);
60: 
61: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
62: 	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);
63: 
64: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
65: 	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);
66: 
67: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
68: 	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);
69: 
70: 
71: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
72: 	void RequestSetBaseIngredient(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
73: 
74: 
75: 
76: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
77: 	ARitualAltar* GetRitualAltarActor() const;
78: 
79: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
80: 	bool IsOccuppied() const;
81: 
82: };
```

## File: Source/WitchPT/Public/Player/WitchPTPlayerController.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "UI/Widgets/PointerWidget.h"
  6: #include "WitchPTPlayerController.generated.h"
  7: 
  8: class UCauldronUserWidget;
  9: class ABaseInteractableAltar;
 10: class ACauldronAltar;
 11: class ARitualAltar;
 12: class UWitchPTInventoryManagerComponent;
 13: struct FGameplayTag;
 14: class UWitchPTAbilitySystemComponent;
 15: class UWitchPTInputConfig;
 16: struct FInputActionValue;
 17: class UInputAction;
 18: class UInputMappingContext;
 19: 
 20: 
 21: 
 22: UCLASS()
 23: class WITCHPT_API AWitchPTPlayerController : public APlayerController
 24: {
 25: 	GENERATED_BODY()
 26: public:
 27: 	AWitchPTPlayerController();
 28: 	virtual void PlayerTick(float DeltaTime) override;
 29: 	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
 30: 	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
 31: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 32: 
 33: 	void LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar);
 34: 	bool HasRitualWidgetInitialized(ABaseInteractableAltar* Altar);
 35: 	void LocalToggleCauldronMenu();
 36: 
 37: 
 38: 
 39: 
 40: 	UFUNCTION(Client, Reliable)
 41: 	void Client_InitializeRitualUserWidget(ABaseInteractableAltar* Altar);
 42: 
 43: 	UFUNCTION(Client, Reliable)
 44: 	void Client_ToggleCauldronMenu();
 45: 
 46: 
 47: 	UPROPERTY(Replicated, VisibleAnywhere)
 48: 	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
 49: 	UPROPERTY()
 50: 	TObjectPtr<UPointerWidget> HUDWidget;
 51: 	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
 52: protected:
 53: 	virtual void BeginPlay() override;
 54: 	virtual void SetupInputComponent() override;
 55: 
 56: 
 57: 	UPROPERTY(EditAnywhere, Category="Input")
 58: 	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
 59: 	UPROPERTY(EditAnywhere, Category="Input")
 60: 	TObjectPtr<UInputAction> MoveAction;
 61: 	UPROPERTY(EditAnywhere, Category= "Input")
 62: 	TObjectPtr<UInputAction> LookAction;
 63: 
 64: 	UPROPERTY(EditDefaultsOnly, Category= "Input")
 65: 	TObjectPtr<UWitchPTInputConfig> InputConfig;
 66: 
 67: 
 68: 	UPROPERTY()
 69: 	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;
 70: 
 71: 	UWitchPTAbilitySystemComponent* GetASC();
 72: 
 73: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 74: 	TSubclassOf<UPointerWidget> HUDWidgetClass;
 75: 
 76: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 77: 	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;
 78: 
 79: 
 80: 
 81: private:
 82: 
 83: 	void Move(const FInputActionValue& InputActionValue);
 84: 
 85: 	void Look(const FInputActionValue& Value);
 86: 
 87: 	void AbilityInputTagPressed(FGameplayTag InputTag);
 88: 	void AbilityInputTagReleased(FGameplayTag InputTag);
 89: 	void AbilityInputTagHeld(FGameplayTag InputTag);
 90: 
 91: 	void ConstructCauldronWidget();
 92: 
 93: 	void CreateHUDWidget();
 94: 	void OpenCauldronMenu();
 95: 	void CloseCauldronMenu();
 96: 	bool bCauldronMenuOpen = false;
 97: 
 98: 
 99: 	UPROPERTY()
100: 	TObjectPtr<ARitualAltar> ThisRitualAltarHasWidget;
101: 	UPROPERTY()
102: 	TObjectPtr<UCauldronUserWidget> CauldronAltarMenu;
103: 
104: };
```

## File: Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
```cpp
  1: #include "Player/WitchPTPlayerController.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "EnhancedInputSubsystems.h"
  5: #include "InputActionValue.h"
  6: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  7: #include "Blueprint/UserWidget.h"
  8: #include "Input/WitchPTInputComponent.h"
  9: #include "Inventory/WitchPTInventoryManagerComponent.h"
 10: #include "Item/CauldronAltar.h"
 11: #include "Item/RitualAltar.h"
 12: #include "Item/Ritual/RitualFunctionLibrary.h"
 13: #include "Kismet/GameplayStatics.h"
 14: #include "Net/UnrealNetwork.h"
 15: #include "UI/HUD/WitchPTHUD.h"
 16: #include "UI/WidgetControllers/CauldronWidgetController.h"
 17: #include "UI/WidgetControllers/RitualWidgetController.h"
 18: #include "UI/Widgets/CauldronUserWidget.h"
 19: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 20: #include "WitchPT/WitchPT.h"
 21: 
 22: AWitchPTPlayerController::AWitchPTPlayerController()
 23: {
 24: 	bReplicates = true;
 25: 	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
 26: 	InventoryManager->SetIsReplicated(true);
 27: 
 28: 
 29: }
 30: 
 31: void AWitchPTPlayerController::PlayerTick(float DeltaTime)
 32: {
 33: 	Super::PlayerTick(DeltaTime);
 34: }
 35: 
 36: void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
 37: {
 38: 	Super::PreProcessInput(DeltaTime, bGamePaused);
 39: }
 40: 
 41: void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
 42: {
 43: 	if (WitchPtAbilitySystemComponent)
 44: 	{
 45: 		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
 46: 	}
 47: 	Super::PostProcessInput(DeltaTime, bGamePaused);
 48: }
 49: 
 50: void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 51: {
 52: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 53: 	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
 54: }
 55: void AWitchPTPlayerController::LocalToggleCauldronMenu()
 56: {
 57: 
 58: 	if (bCauldronMenuOpen)
 59: 	{
 60: 		CloseCauldronMenu();
 61: 	}
 62: 	else
 63: 	{
 64: 		OpenCauldronMenu();
 65: 	}
 66: }
 67: 
 68: void AWitchPTPlayerController::LocalInitializeRitualUserWidget(ABaseInteractableAltar* Altar)
 69: {
 70: 	if (!Altar || !Altar->AltarUserWidgetClass || !IsLocalController())
 71: 	{
 72: 		UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Invalid altar or widget class!"));
 73: 		return;
 74: 	}
 75: 
 76: 	if (Altar->IsA<ARitualAltar>())
 77: 	{
 78: 
 79: 		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
 80: 
 81: 		if (!ThisRitualAltarHasWidget || ThisRitualAltarHasWidget != RitualAltar)
 82: 		{
 83: 			ThisRitualAltarHasWidget = RitualAltar;
 84: 		}
 85: 
 86: 		URitualUserWidget* RitualUserWidget = CreateWidget<URitualUserWidget>(this, Altar->AltarUserWidgetClass);
 87: 
 88: 		if (IsValid(RitualUserWidget))
 89: 		{
 90: 
 91: 			URitualWidgetController* RitualWidgetController = URitualFunctionLibrary::SetRitualWidgetController(this);
 92: 
 93: 			if (!RitualWidgetController)
 94: 			{
 95: 				UE_LOG(LogTemp, Error, TEXT("InitializeRitualUserWidget: Failed to get or create RitualWidgetController!"));
 96: 				return;
 97: 			}
 98: 
 99: 			RitualWidgetController->SetRitualAltar(RitualAltar);
100: 
101: 			RitualUserWidget->SetWidgetController(RitualWidgetController);
102: 
103: 
104: 
105: 			RitualUserWidget->AddToViewport();
106: 		}
107: 
108: 	}
109: 
110: 
111: }
112: 
113: bool AWitchPTPlayerController::HasRitualWidgetInitialized(ABaseInteractableAltar* Altar)
114: {
115: 	if (Altar->IsA<ARitualAltar>())
116: 	{
117: 		return ThisRitualAltarHasWidget == Altar;
118: 	}
119: 	return false;
120: }
121: 
122: void AWitchPTPlayerController::OpenCauldronMenu()
123: {
124: 	if (!IsValid(CauldronAltarMenu)) return;
125: 
126: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Visible);
127: 	bCauldronMenuOpen = true;
128: 
129: 	FInputModeGameAndUI InputMode;
130: 
131: 	SetInputMode(InputMode);
132: 	SetShowMouseCursor(true);
133: }
134: 
135: void AWitchPTPlayerController::CloseCauldronMenu()
136: {
137: 	if (!IsValid(CauldronAltarMenu)) return;
138: 
139: 	CauldronAltarMenu->SetVisibility(ESlateVisibility::Collapsed);
140: 	bCauldronMenuOpen = false;
141: 
142: 
143: 
144: 	FInputModeGameOnly InputMode;
145: 	SetInputMode(InputMode);
146: 	SetShowMouseCursor(false);
147: }
148: 
149: void AWitchPTPlayerController::Client_InitializeRitualUserWidget_Implementation(ABaseInteractableAltar* Altar)
150: {
151: 	if (!HasRitualWidgetInitialized(Altar))
152: 	{
153: 		LocalInitializeRitualUserWidget(Altar);
154: 	}
155: }
156: 
157: void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
158: {
159: 	LocalToggleCauldronMenu();
160: }
161: void AWitchPTPlayerController::BeginPlay()
162: {
163: 	Super::BeginPlay();
164: 	check(WitchPtiInputMappingContext)
165: 	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
166: 	if (Subsystem)
167: 	{
168: 		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
169: 	}
170: 	CreateHUDWidget();
171: 	ConstructCauldronWidget();
172: }
173: 
174: void AWitchPTPlayerController::SetupInputComponent()
175: {
176: 	Super::SetupInputComponent();
177: 	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
178: 	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
179: 	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
180: 	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
181: 
182: }
183: 
184: void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
185: {
186: 	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
187: 	const FRotator Rotation = GetControlRotation();
188: 	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);
189: 
190: 	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
191: 	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
192: 
193: 	if (APawn* ControlledPawn = GetPawn<APawn>())
194: 	{
195: 		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
196: 		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
197: 	}
198: 
199: }
200: 
201: void AWitchPTPlayerController::Look(const FInputActionValue& Value)
202: {
203: 
204: 	FVector2D LookAxisVector = Value.Get<FVector2D>();
205: 
206: 	if (APawn* ControlledPawn = GetPawn<APawn>())
207: 	{
208: 
209: 		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
210: 		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
211: 	}
212: }
213: 
214: void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
215: {
216: 	if (GetASC())
217: 	{
218: 		GetASC()->AbilityInputTagPressed(InputTag);
219: 	}
220: }
221: 
222: void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
223: {
224: 	if (GetASC())
225: 	{
226: 		GetASC()->AbilityInputTagReleased(InputTag);
227: 	}
228: }
229: 
230: void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
231: {
232: 	if (GetASC())
233: 	{
234: 		GetASC()->AbilityInputTagHeld(InputTag);
235: 	}
236: }
237: 
238: void AWitchPTPlayerController::ConstructCauldronWidget()
239: {
240: 	if (!this->IsLocalController()) return;
241: 	CauldronAltarMenu = CreateWidget<UCauldronUserWidget>(this, CauldronAltarWidgetClass);
242: 	UCauldronWidgetController* CauldronWidgetController = URitualFunctionLibrary::SetCauldronWidgetController(this);
243: 	CauldronAltarMenu->SetWidgetController(CauldronWidgetController);
244: 
245: 	ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass()));
246: 	if (CauldronAltar)
247: 	{
248: 		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
249: 	}
250: 	CauldronWidgetController->BindCallbacksToDependencies();
251: 	CauldronAltarMenu->AddToViewport();
252: 	CloseCauldronMenu();
253: }
254: 
255: void AWitchPTPlayerController::CreateHUDWidget()
256: {
257: 	if (!IsLocalController()) return;
258: 	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
259: 	if (IsValid(HUDWidget))
260: 	{
261: 		HUDWidget->AddToViewport();
262: 	}
263: }
264: 
265: 
266: UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
267: {
268: 	if (WitchPtAbilitySystemComponent == nullptr)
269: 	{
270: 		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
271: 	}
272: 	return WitchPtAbilitySystemComponent;
273: }
```

## File: Config/DefaultEngine.ini
```
  1: [/Script/EngineSettings.GameMapsSettings]
  2: GameDefaultMap=/Game/Blueprints/Maps/Default.Default
  3: EditorStartupMap=/Game/Blueprints/Maps/Default.Default
  4: 
  5: [/Script/Engine.RendererSettings]
  6: r.AllowStaticLighting=False
  7: 
  8: r.GenerateMeshDistanceFields=True
  9: 
 10: r.DynamicGlobalIlluminationMethod=0
 11: 
 12: r.ReflectionMethod=0
 13: 
 14: r.SkinCache.CompileShaders=True
 15: 
 16: r.RayTracing=True
 17: 
 18: r.Shadow.Virtual.Enable=1
 19: 
 20: r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True
 21: 
 22: r.DefaultFeature.LocalExposure.HighlightContrastScale=0.8
 23: 
 24: r.DefaultFeature.LocalExposure.ShadowContrastScale=0.8
 25: 
 26: [/Script/WindowsTargetPlatform.WindowsTargetSettings]
 27: DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
 28: DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
 29: -D3D12TargetedShaderFormats=PCD3D_SM5
 30: +D3D12TargetedShaderFormats=PCD3D_SM6
 31: -D3D11TargetedShaderFormats=PCD3D_SM5
 32: +D3D11TargetedShaderFormats=PCD3D_SM5
 33: Compiler=Default
 34: AudioSampleRate=48000
 35: AudioCallbackBufferFrameSize=1024
 36: AudioNumBuffersToEnqueue=1
 37: AudioMaxChannels=0
 38: AudioNumSourceWorkers=4
 39: SpatializationPlugin=
 40: SourceDataOverridePlugin=
 41: ReverbPlugin=
 42: OcclusionPlugin=
 43: CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
 44: CacheSizeKB=65536
 45: MaxChunkSizeOverrideKB=0
 46: bResampleForDevice=False
 47: MaxSampleRate=48000.000000
 48: HighSampleRate=32000.000000
 49: MedSampleRate=24000.000000
 50: LowSampleRate=12000.000000
 51: MinSampleRate=8000.000000
 52: CompressionQualityModifier=1.000000
 53: AutoStreamingThreshold=0.000000
 54: SoundCueCookQualityIndex=-1
 55: 
 56: [/Script/LinuxTargetPlatform.LinuxTargetSettings]
 57: -TargetedRHIs=SF_VULKAN_SM5
 58: +TargetedRHIs=SF_VULKAN_SM6
 59: 
 60: [/Script/HardwareTargeting.HardwareTargetingSettings]
 61: TargetedHardwareClass=Desktop
 62: AppliedTargetedHardwareClass=Desktop
 63: DefaultGraphicsPerformance=Maximum
 64: AppliedDefaultGraphicsPerformance=Maximum
 65: 
 66: [/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
 67: CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'
 68: 
 69: [/Script/Engine.UserInterfaceSettings]
 70: bAuthorizeAutomaticWidgetVariableCreation=False
 71: FontDPIPreset=Standard
 72: FontDPI=72
 73: 
 74: [/Script/Engine.Engine]
 75: +ActiveGameNameRedirects=(OldGameName="TP_BlankBP",NewGameName="/Script/WitchPT")
 76: +ActiveGameNameRedirects=(OldGameName="/Script/TP_BlankBP",NewGameName="/Script/WitchPT")
 77: AssetManagerClassName=/Script/WitchPT.WitchPTAssetManager
 78: 
 79: [/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
 80: bEnablePlugin=True
 81: bAllowNetworkConnection=True
 82: SecurityToken=E3BD176F4C42D74EBD24B5984F1936CC
 83: bIncludeInShipping=False
 84: bAllowExternalStartInShipping=False
 85: bCompileAFSProject=False
 86: bUseCompression=False
 87: bLogFiles=False
 88: bReportStats=False
 89: ConnectionType=USBOnly
 90: bUseManualIPAddress=False
 91: ManualIPAddress=
 92: 
 93: 
 94: [CoreRedirects]
 95: +ClassRedirects=(OldName="/Script/WitchPT.WitchPT",NewName="/Script/WitchPT.WitchPTPlayerState")
 96: +EnumRedirects=(OldName="/Script/WitchPT.ERitualState",NewName="/Script/WitchPT.EInteractionState")
 97: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.OnPressInteraction",NewName="/Script/WitchPT.CauldronAltar.StartBrewingPotions")
 98: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.OnHoldInteraction",NewName="/Script/WitchPT.CauldronAltar.StartCarryCauldron")
 99: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.StartBrewingPotions",NewName="/Script/WitchPT.CauldronAltar.StartBrewingPotion")
100: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.BrewingPositionTransforms",NewName="/Script/WitchPT.CauldronAltar.PositionTransforms")
101: +PropertyRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.CauldronPositionClass",NewName="/Script/WitchPT.BaseInteractableAltar.PositionClass")
102: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.CreateBrewingPositions",NewName="/Script/WitchPT.BaseInteractableAltar.CreateAltarPositions")
103: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.DestroyBrewingPositions",NewName="/Script/WitchPT.BaseInteractableAltar.DestroyAltarPositions")
104: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputFailed",NewName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputFailed")
105: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputSuccess",NewName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputSuccess")
106: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputSuccess",NewName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputSuccess")
107: +FunctionRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.Client_OnInputFailed",NewName="/Script/WitchPT.BaseInteractableAltar.Multicast_OnInputFailed")
108: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.AttachToCharacter",NewName="/Script/WitchPT.CauldronAltar.Server_AttachToCharacter")
109: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.DetachFromCharacter",NewName="/Script/WitchPT.CauldronAltar.Server_DetachFromCharacter")
110: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.StartPlacementPreview",NewName="/Script/WitchPT.CauldronAltar.Server_StartPlacementPreview")
111: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.FinalizePlacement",NewName="/Script/WitchPT.CauldronAltar.Server_FinalizePlacement")
112: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.CancelPlacement",NewName="/Script/WitchPT.CauldronAltar.Server_CancelPlacement")
113: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.PositionCharacterForBrewing",NewName="/Script/WitchPT.CauldronAltar.Server_PositionCharacterForBrewing")
114: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Server_AttachToCharacter",NewName="/Script/WitchPT.CauldronAltar.AttachToCharacter")
115: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Server_PositionCharacterForBrewing",NewName="/Script/WitchPT.CauldronAltar.PositionCharacterForBrewing")
116: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronAltar.Multicas_StartBrewingPotion",NewName="/Script/WitchPT.CauldronAltar.Multicast_StartBrewingPotion")
117: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTUserWidget.WidgetControllerSet",NewName="/Script/WitchPT.WitchPTUserWidget.OnWidgetControllerSet")
118: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTOverlayWidgetController",NewName="/Script/WitchPT.OverlayWidgetController")
119: +ClassRedirects=(OldName="/Script/WitchPT.OverlayWidgetController",NewName="/Script/WitchPT.OverlayWidgetController")
120: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTInventoryFragment_Details",NewName="/Script/WitchPT.WitchPTInventoryFragment_UIDetails")
121: +StructRedirects=(OldName="/Script/WitchPT.PickupTemplate",NewName="/Script/WitchPT.ItemManifest")
122: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTInventoryManagerComponent.CanAddItemDefinition",NewName="/Script/WitchPT.WitchPTInventoryManagerComponent.TryAddItemDefinition")
123: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTInventoryManagerComponent.AddItemDefinition",NewName="/Script/WitchPT.WitchPTInventoryManagerComponent.Server_AddItem")
124: +PropertyRedirects=(OldName="/Script/WitchPT.InventoryWidgetController.OnItemStackChanged",NewName="/Script/WitchPT.InventoryWidgetController.OnItemStackChangedDelegate")
125: +PropertyRedirects=(OldName="/Script/WitchPT.InventoryWidgetController.OnItemAdded",NewName="/Script/WitchPT.InventoryWidgetController.OnItemAddedDelegate")
126: +FunctionRedirects=(OldName="/Script/WitchPT.RitualFunctionLibrary.SetInventoryWidgetController",NewName="/Script/WitchPT.RitualFunctionLibrary.SetRitualWidgetController")
127: +FunctionRedirects=(OldName="/Script/WitchPT.RitualAltar.Multicast_PlayersReadyNumberChanged",NewName="/Script/WitchPT.RitualAltar.Multicast_NumberOfPlayersReadyHasChanged")
128: +PropertyRedirects=(OldName="/Script/WitchPT.RitualWidgetController.OnRitualActivePlayerChanged",NewName="/Script/WitchPT.RitualWidgetController.OnIsMyTurnChangedDelegate")
129: +PropertyRedirects=(OldName="/Script/WitchPT.RitualWidgetController.OnRitualActivePlayerChangedDelegate",NewName="/Script/WitchPT.RitualWidgetController.OnIsMyTurnChangedDelegate")
130: +PropertyRedirects=(OldName="/Script/WitchPT.BaseInteractableAltar.RitualUserWidgetClass",NewName="/Script/WitchPT.BaseInteractableAltar.AltarUserWidgetClass")
131: +PropertyRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.RitualAltarWidget",NewName="/Script/WitchPT.WitchPTPlayerController.ThisRitualAltarHasWidget")
132: +PropertyRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.CauldronAltarWidget",NewName="/Script/WitchPT.WitchPTPlayerController.CauldronAltarMenu")
133: +FunctionRedirects=(OldName="/Script/WitchPT.WitchPTPlayerController.Client_OpenCauldronMenu",NewName="/Script/WitchPT.WitchPTPlayerController.Client_ToggleCauldronMenu")
134: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronWidgetController.OnBaseIngredientDropped",NewName="/Script/WitchPT.CauldronWidgetController.OnBaseIngredientSet")
135: +FunctionRedirects=(OldName="/Script/WitchPT.CauldronWidgetController.HandleBaseIngredientDropped",NewName="/Script/WitchPT.CauldronWidgetController.HandleBaseIngredientSet")
136: +ClassRedirects=(OldName="/Script/WitchPT.WitchPTInventoryItemFragment_IngredientDetails",NewName="/Script/WitchPT.WitchPTInventoryItemFragment_IngredientCraftingProperties")
137: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.PotentiatorIngredient",NewName="/Script/WitchPT.CauldronAltar.ModifierIngredient")
138: +PropertyRedirects=(OldName="/Script/WitchPT.CauldronAltar.PotentiatorIngredientIcon",NewName="/Script/WitchPT.CauldronAltar.ModifierIngredientIcon")
139: 
140: [/Script/Engine.CollisionProfile]
141: -Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
142: -Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
143: -Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
144: -Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
145: -Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
146: -Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
147: -Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
148: -Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
149: -Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
150: -Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
151: -Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
152: -Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
153: -Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
154: -Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
155: -Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
156: -Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
157: -Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
158: -Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
159: +Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
160: +Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
161: +Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
162: +Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
163: +Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
164: +Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
165: +Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
166: +Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
167: +Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
168: +Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
169: +Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
170: +Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
171: +Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
172: +Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
173: +Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
174: +Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
175: +Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
176: +Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
177: +Profiles=(Name="Interactable_BlockDynamic",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WitchPT_TraceChannel_Interaction",Response=ECR_Overlap)),HelpMessage="Needs description")
178: +Profiles=(Name="Interactable_OverlapDynamic",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="WitchPT_TraceChannel_Interaction",Response=ECR_Overlap)),HelpMessage="Needs description")
179: +Profiles=(Name="Item",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="WitchPT_TraceChannel_Interaction")),HelpMessage="Needs description")
180: +DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Ignore,bTraceType=True,bStaticObject=False,Name="WitchPT_TraceChannel_Interaction")
181: -ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
182: -ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
183: -ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
184: -ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
185: -ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
186: +ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
187: +ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
188: +ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
189: +ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
190: +ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
191: -CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
192: -CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
193: -CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
194: -CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
195: +CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
196: +CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
197: +CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
198: +CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
```

## File: Source/WitchPT/Private/Item/CauldronAltar.cpp
```cpp
  1: #include "Item/CauldronAltar.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "Item/CauldronPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Kismet/GameplayStatics.h"
  8: #include "TimerManager.h"
  9: #include "Components/SkeletalMeshComponent.h"
 10: #include "Components/CapsuleComponent.h"
 11: #include "Components/StaticMeshComponent.h"
 12: #include "Engine/World.h"
 13: #include "DrawDebugHelpers.h"
 14: #include "FWitchPTGameplayTags.h"
 15: #include "Engine/ActorChannel.h"
 16: #include "Inventory/WitchPTInventoryItemDefinition.h"
 17: #include "Inventory/WitchPTInventoryItemInstance.h"
 18: #include "Inventory/WitchPTInventoryManagerComponent.h"
 19: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 20: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 21: #include "Player/WitchPTPlayerController.h"
 22: 
 23: 
 24: ACauldronAltar::ACauldronAltar()
 25: {
 26: 
 27:     PrimaryActorTick.bCanEverTick = true;
 28: 
 29: 
 30:     bReplicates = true;
 31:     bAlwaysRelevant = true;
 32:     CauldronPhysicState = ECauldronPhysicState::Static;
 33:     CarryingCharacter = nullptr;
 34:     CurrentPlacementState = ECauldronPlacementState::None;
 35:     bReplicateUsingRegisteredSubObjectList = true;
 36: 
 37: }
 38: 
 39: void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 40: {
 41: 
 42:     FInteractionOption InteractionOption = Option;
 43: 
 44: 
 45:     InteractionOption.bSupportsHoldInteraction = true;
 46: 
 47: 
 48:     OptionBuilder.AddInteractionOption(InteractionOption);
 49: }
 50: 
 51: void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 52: {
 53:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 54: 
 55:     DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
 56:     DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
 57:     DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
 58:     DOREPLIFETIME(ACauldronAltar, BaseIngredientIcon);
 59:     DOREPLIFETIME(ACauldronAltar, PrincipalIngredientIcon);
 60:     DOREPLIFETIME(ACauldronAltar, ModifierIngredientIcon);
 61: 
 62: }
 63: 
 64: 
 65: void ACauldronAltar::OnRep_CauldronPhysicState()
 66: {
 67: 
 68:     if (CauldronPhysicState == ECauldronPhysicState::Moving)
 69:     {
 70: 
 71:         SetActorEnableCollision(false);
 72:     }
 73:     else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
 74:     {
 75: 
 76:         SetActorEnableCollision(false);
 77: 
 78: 
 79:     }
 80: 
 81: }
 82: 
 83: 
 84: 
 85: void ACauldronAltar::OnRep_BaseIngredientIcon()
 86: {
 87:     BroadcastBaseIngredientIconSet();
 88: }
 89: 
 90: void ACauldronAltar::OnRep_PrincipalIngredientIcon()
 91: {
 92:     BroadcastPrincipalIngredientIconSet();
 93: }
 94: 
 95: void ACauldronAltar::OnRep_PotentiatorIngredientIcon()
 96: {
 97:     BroadcastModifierIngredientIconSet();
 98: }
 99: 
100: 
101: 
102: void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
103: {
104:     if (!InteractingCharacter)
105:     {
106:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
107:         return;
108:     }
109: 
110: 
111:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
112:     {
113:         FinalizePlacement();
114:         return;
115:     }
116: 
117: 
118:     PositionCharacterForBrewing(InteractingCharacter);
119: }
120: 
121: void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
122: {
123:     if (!HasAuthority())
124:     {
125:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Not authority"));
126:         return;
127:     }
128: 
129:     if (CauldronPhysicState != ECauldronPhysicState::Static)
130:     {
131:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
132:         return;
133:     }
134: 
135:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
136:     if (!PC)
137:     {
138:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
139:         return;
140:     }
141: 
142:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
143:     if (!InventoryManager)
144:     {
145:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
146:         return;
147:     }
148: 
149:     UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);
150: 
151:     if (!InstanceFromInventory)
152:     {
153:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
154:         return;
155:     }
156: 
157:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
158:     if (!IngredientCraftingDetails)
159:     {
160:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
161:         return;
162:     }
163: 
164: 
165:     const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
166:     bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
167:     bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
168:     bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);
169: 
170: 
171:     if (bIsBaseIngredient && BaseIngredient != nullptr)
172:     {
173:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
174:         return;
175:     }
176: 
177:     if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
178:     {
179:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
180:         return;
181:     }
182: 
183:     if (bIsModifierIngredient && ModifierIngredient != nullptr)
184:     {
185:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
186:         return;
187:     }
188: 
189: 
190:     if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
191:     {
192:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
193:         return;
194:     }
195: 
196:     bool bConsumedSuccessfully = false;
197:     int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
198: 
199:     if (CurrentStackCount > 0)
200:     {
201:         UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
202: 
203:         if (CurrentStackCount == 1)
204:         {
205:             IngredientToSet = InstanceFromInventory;
206:             InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
207:             bConsumedSuccessfully = true;
208:         }
209:         else
210:         {
211:             InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
212:             IngredientToSet = InstanceFromInventory;
213:             bConsumedSuccessfully = true;
214:         }
215: 
216: 
217:         const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
218:         TSubclassOf<UUserWidget> IngredientIcon = nullptr;
219:         if (IsValid(UIFragment))
220:         {
221:             IngredientIcon = UIFragment->IconWidget;
222:         }
223: 
224: 
225:         if (bIsBaseIngredient)
226:         {
227:             BaseIngredient = IngredientToSet;
228:             BaseIngredientIcon = IngredientIcon;
229:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Base ingredient set successfully"));
230: 
231:             if (HasAuthority())
232:             {
233:                 BroadcastBaseIngredientIconSet();
234:             }
235:         }
236:         else if (bIsPrincipalIngredient)
237:         {
238:             PrincipalIngredient = IngredientToSet;
239:             PrincipalIngredientIcon = IngredientIcon;
240:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Principal ingredient set successfully"));
241: 
242:             if (HasAuthority())
243:             {
244:                 BroadcastPrincipalIngredientIconSet();
245:             }
246:         }
247:         else if (bIsModifierIngredient)
248:         {
249:             ModifierIngredient = IngredientToSet;
250:             ModifierIngredientIcon = IngredientIcon;
251:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::TrySetIngredientInSlot: Modifier ingredient set successfully"));
252: 
253:             if (HasAuthority())
254:             {
255:                 BroadcastModifierIngredientIconSet();
256:             }
257:         }
258:     }
259: }
260: 
261: 
262: void ACauldronAltar::BeginPlay()
263: {
264:     Super::BeginPlay();
265:     SetReplicateMovement(true);
266: }
267: 
268: bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
269:     FReplicationFlags* RepFlags)
270: {
271:     return Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
272: }
273: 
274: 
275: void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
276: {
277:     if (!InteractingCharacter)
278:     {
279:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
280:         return;
281:     }
282: 
283: 
284:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
285:     {
286:         CancelPlacement();
287:         return;
288:     }
289: 
290: 
291:     if (!CanBePickedUp())
292:     {
293:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
294:         return;
295:     }
296: 
297: 
298:     AttachToCharacter(InteractingCharacter);
299: }
300: 
301: bool ACauldronAltar::CanBePickedUp() const
302: {
303: 
304:     if (IsBeingCarried() || IsInPlacementPreview())
305:     {
306:         return false;
307:     }
308: 
309: 
310: 
311:     return true;
312: }
313: 
314: bool ACauldronAltar::IsBeingCarried() const
315: {
316:     return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
317: }
318: 
319: bool ACauldronAltar::IsInPlacementPreview() const
320: {
321:     return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
322: }
323: 
324: 
325: ACharacter* ACauldronAltar::GetCarryingCharacter() const
326: {
327:     return CarryingCharacter;
328: }
329: 
330: void ACauldronAltar::AttachToCharacter(ACharacter* Character)
331: {
332:     if (!Character || !HasAuthority())
333:     {
334:         return;
335:     }
336: 
337: 
338:     DestroyAltarPositions();
339: 
340: 
341:     CauldronPhysicState = ECauldronPhysicState::Moving;
342:     CarryingCharacter = Character;
343: 
344: 
345:     FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget,
346:                                           EAttachmentRule::KeepWorld, true);
347: 
348: 
349:     USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
350:     if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
351:     {
352: 
353:         AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
354: 
355: 
356:         SetActorEnableCollision(false);
357: 
358: 
359:         SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
360: 
361:         UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
362:     }
363: 
364: 
365: }
366: 
367: void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
368: {
369:     if (!Character || !HasAuthority() || Character != CarryingCharacter)
370:     {
371:         return;
372:     }
373: 
374: 
375:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
376: 
377: 
378:     FVector CharacterLocation = Character->GetActorLocation();
379:     FRotator CharacterRotation = Character->GetActorRotation();
380:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
381: 
382: 
383:     SetActorLocation(CharacterLocation + PlacementOffset);
384: 
385: 
386:     CauldronPhysicState = ECauldronPhysicState::Static;
387:     CarryingCharacter = nullptr;
388: 
389: 
390:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
391: 
392: 
393:     SetActorEnableCollision(true);
394: 
395: 
396:     CreateAltarPositions();
397: 
398:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
399: 
400: 
401: 
402: }
403: 
404: void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
405: {
406:     if (!Character || !HasAuthority())
407:     {
408:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
409:         return;
410:     }
411: 
412: 
413:     ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
414: 
415:     if (BrewingPosition)
416:     {
417:         Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
418:         ParticipatingPlayers.Add(Character);
419: 
420:         if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
421:         {
422: 
423:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
424:             {
425:                 PC->LocalToggleCauldronMenu();
426:             }
427:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
428:         {
429: 
430:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
431:             {
432:                 PC->Client_ToggleCauldronMenu();
433:             }
434:         }
435:         FGameplayEventData Payload;
436:         Payload.OptionalObject = Character;
437:         FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
438:         UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
439:         return BrewingPosition->SetOccupied(Character);
440: 
441: 
442: 
443: 
444:     }
445: 
446: 
447: 
448: 
449: 
450: 
451: }
452: 
453: 
454: ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
455: {
456: 
457:     if (InteractionPositions.Num() == 0)
458:     {
459:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
460:         return nullptr;
461:     }
462: 
463: 
464:     for (ABaseInteractionPosition* Position : InteractionPositions)
465:     {
466:         if (Position && !Position->IsOccupied())
467:         {
468:             return Position;
469:         }
470:     }
471: 
472: 
473:     UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
474: 
475:     return nullptr;
476: }
477: 
478: 
479: 
480: void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
481: {
482:     if (!Character || Character != CarryingCharacter || !HasAuthority())
483:     {
484:         return;
485:     }
486: 
487: 
488:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
489: 
490: 
491:     CauldronPhysicState = ECauldronPhysicState::Previewing;
492: 
493: 
494:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
495:     if (MeshComponent)
496:     {
497:         OriginalMaterials.Empty();
498:         for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
499:         {
500:             OriginalMaterials.Add(MeshComponent->GetMaterial(i));
501:         }
502:     }
503: 
504: 
505:     CurrentPlacementState = ECauldronPlacementState::Invalid;
506: 
507: 
508: 
509:     SetActorEnableCollision(false);
510: 
511: 
512:     FVector CharacterLocation = Character->GetActorLocation();
513:     FRotator CharacterRotation = Character->GetActorRotation();
514:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
515: 
516: 
517:     PreviewLocation = CharacterLocation + PlacementOffset;
518: 
519: 
520:     PreviewRotation.Pitch = 0;
521:     PreviewRotation.Roll = 0;
522:     PreviewRotation.Yaw = 0;
523: 
524:     SetActorLocation(PreviewLocation);
525:     SetActorRotation(PreviewRotation);
526: 
527: 
528:     Multicast_FinalizePlacement();
529: 
530: 
531: }
532: 
533: void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
534: {
535: 
536: 
537: 
538: 
539: }
540: 
541: void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
542: {
543: 
544: 
545:     if (!IsInPlacementPreview())
546:     {
547:         return;
548:     }
549: 
550: 
551:     PreviewLocation = HitLocation;
552: 
553: 
554:     FRotator SurfaceAlignedRotation = HitNormal.Rotation();
555: 
556: 
557: 
558:     FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
559: 
560: 
561:     if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
562:     {
563:         AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
564:     }
565: 
566:     if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
567:     {
568:         AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
569:     }
570: 
571:     PreviewRotation = AdjustedRotation;
572:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
573:     SetActorLocation(PreviewLocation);
574: 
575: 
576: 
577:     CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
578: }
579: 
580: 
581: 
582: void ACauldronAltar::FinalizePlacement()
583: {
584:     if (!IsInPlacementPreview() || !HasAuthority())
585:     {
586:         return;
587:     }
588: 
589: 
590:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
591:     SetActorLocation(PreviewLocation);
592:     SetActorRotation(PreviewRotation);
593: 
594: 
595:     RestoreOriginalMaterials();
596: 
597: 
598:     SetActorEnableCollision(true);
599: 
600: 
601:     CauldronPhysicState = ECauldronPhysicState::Static;
602:     CarryingCharacter = nullptr;
603:     CurrentPlacementState = ECauldronPlacementState::None;
604: 
605:     OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
606: 
607: 
608:     CreateAltarPositions();
609: 
610: 
611:     Multicast_FinalizePlacement();
612: 
613:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
614: }
615: 
616: void ACauldronAltar::CancelPlacement()
617: {
618:     if (!IsInPlacementPreview() || !HasAuthority())
619:     {
620:         return;
621:     }
622: 
623: 
624:     RestoreOriginalMaterials();
625: 
626: 
627:     ACharacter* Character = CarryingCharacter;
628: 
629: 
630:     CauldronPhysicState = ECauldronPhysicState::Moving;
631:     CarryingCharacter = nullptr;
632:     CurrentPlacementState = ECauldronPlacementState::None;
633: 
634: 
635:     if (Character)
636:     {
637:         AttachToCharacter(Character);
638:     }
639: 
640:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
641: }
642: 
643: void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
644: {
645: 
646:     for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
647:     {
648:         if(PositionOccupied->GetOccupyingCharacter() == Character)
649:         {
650: 
651:              if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
652:         {
653: 
654:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
655:             {
656:                 PC->LocalToggleCauldronMenu();
657: 
658:             }
659:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
660:         {
661: 
662:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
663:             {
664:                 PC->Client_ToggleCauldronMenu();
665: 
666:             }
667:         }
668:             PositionOccupied->SetOccupied(nullptr);
669:             break;
670:         }
671:     }
672: 
673: }
674: 
675: 
676: 
677: 
678: void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
679: {
680: 
681:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
682:     SetActorEnableCollision(true);
683: }
684: 
685: ECauldronPlacementState ACauldronAltar::GetPlacementState() const
686: {
687:     return CurrentPlacementState;
688: }
689: 
690: void ACauldronAltar::ApplyPlacementPreviewMaterial()
691: {
692:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
693:     if (!MeshComponent)
694:     {
695:         return;
696:     }
697: 
698: 
699:     UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ?
700:         ValidPlacementMaterial : InvalidPlacementMaterial;
701: 
702: 
703:     if (!MaterialToApply)
704:     {
705:         return;
706:     }
707: 
708: 
709:     for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
710:     {
711:         MeshComponent->SetMaterial(i, MaterialToApply);
712:     }
713: }
714: 
715: void ACauldronAltar::RestoreOriginalMaterials()
716: {
717: 
718:     if (CauldronPhysicState != ECauldronPhysicState::Previewing)
719:     {
720:         UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
721:         if (MeshComponent && OriginalMaterials.Num() > 0)
722:         {
723:             for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
724:             {
725:                 if (OriginalMaterials[i])
726:                 {
727:                     MeshComponent->SetMaterial(i, OriginalMaterials[i]);
728:                 }
729:             }
730:         }
731:     }
732: }
733: 
734: bool ACauldronAltar::IsPlacementValid() const
735: {
736:     if (!GetWorld())
737:     {
738:         return false;
739:     }
740: 
741: 
742:     TArray<FOverlapResult> Overlaps;
743:     FCollisionQueryParams QueryParams;
744:     QueryParams.AddIgnoredActor(this);
745: 
746:     if (CarryingCharacter)
747:     {
748:         QueryParams.AddIgnoredActor(CarryingCharacter);
749:     }
750: 
751:     bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
752:         Overlaps,
753:         PreviewLocation,
754:         FQuat::Identity,
755:         FCollisionObjectQueryParams::AllObjects,
756:         FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
757:         QueryParams
758:     );
759: 
760:     if (bHasOverlaps)
761:     {
762: 
763:         for (const FOverlapResult& Overlap : Overlaps)
764:         {
765: 
766:             if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
767:             {
768: 
769:                 return false;
770:             }
771:         }
772:     }
773: 
774: 
775: 
776:     FHitResult HitResult;
777:     FVector TraceStart = PreviewLocation;
778:     FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
779: 
780:     bool bHitGround = GetWorld()->LineTraceSingleByChannel(
781:         HitResult,
782:         TraceStart,
783:         TraceEnd,
784:         ECC_Visibility,
785:         QueryParams
786:     );
787: 
788:     if (!bHitGround)
789:     {
790: 
791:         return false;
792:     }
793: 
794: 
795:     float DistanceToGround = (HitResult.Location - TraceStart).Size();
796:     if (DistanceToGround > MaxGroundAlignmentHeight)
797:     {
798: 
799:         return false;
800:     }
801: 
802: 
803:     return true;
804: }
805: 
806: void ACauldronAltar::BroadcastBaseIngredientDropped() const
807: {
808:     OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
809: }
810: 
811: void ACauldronAltar::BroadcastBaseIngredientIconSet() const
812: {
813:     OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
814: }
815: 
816: void ACauldronAltar::BroadcastPrincipalIngredientDropped() const
817: {
818:     OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
819: }
820: 
821: void ACauldronAltar::BroadcastPrincipalIngredientIconSet() const
822: {
823:     OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
824: }
825: 
826: void ACauldronAltar::BroadcastModifierIngredientDropped() const
827: {
828:     OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
829: }
830: 
831: void ACauldronAltar::BroadcastModifierIngredientIconSet() const
832: {
833:     OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
834: }
835: 
836: UWitchPTInventoryItemInstance* ACauldronAltar::GetBaseIngredient() const
837: {
838:     return BaseIngredient;
839: }
840: 
841: UWitchPTInventoryItemInstance* ACauldronAltar::GetPrincipalIngredient() const
842: {
843:     return PrincipalIngredient;
844: }
845: 
846: UWitchPTInventoryItemInstance* ACauldronAltar::GetModifierIngredient() const
847: {
848:     return ModifierIngredient;
849: }
```

## File: Source/WitchPT/Public/Item/CauldronAltar.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "MechanicsInterface.h"
  7: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  8: #include "CauldronAltar.generated.h"
  9: 
 10: class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
 11: class UWitchPTInventoryItemFragment;
 12: class UCauldronUserWidget;
 13: class ACauldronPosition;
 14: class ACharacter;
 15: 
 16: 
 17: USTRUCT(BlueprintType)
 18: struct FIngredientSequence
 19: {
 20:     GENERATED_BODY()
 21: 
 22:     UPROPERTY(BlueprintReadOnly)
 23:     TArray<FGameplayTag> Ingredients;
 24: };
 25: 
 26: 
 27: UENUM(BlueprintType)
 28: enum class ECauldronInput : uint8
 29: {
 30:     Ingredient1 UMETA(DisplayName = "Ingredient 1"),
 31:     Ingredient2 UMETA(DisplayName = "Ingredient 2"),
 32:     Ingredient3 UMETA(DisplayName = "Ingredient 3"),
 33:     Ingredient4 UMETA(DisplayName = "Ingredient 4"),
 34:     Ingredient5 UMETA(DisplayName = "Ingredient 5"),
 35:     None        UMETA(DisplayName = "None")
 36: };
 37: 
 38: UENUM(BlueprintType)
 39: enum ECauldronPhysicState
 40: {
 41:     Static UMETA(DisplayName = "InPlace"),
 42:     Moving UMETA(DisplayName = "Moving"),
 43:     Previewing UMETA(DisplayName = "Previewing")
 44: };
 45: 
 46: 
 47: UENUM(BlueprintType)
 48: enum class ECauldronPlacementState : uint8
 49: {
 50:     Valid UMETA(DisplayName = "Valid"),
 51:     Invalid UMETA(DisplayName = "Invalid"),
 52:     None UMETA(DisplayName = "None")
 53: };
 54: 
 55: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
 56: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
 57: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 58: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
 59: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 60: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
 61: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 62: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
 63: 
 64: 
 65: 
 66: 
 67: UCLASS()
 68: class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
 69: {
 70:     GENERATED_BODY()
 71: 
 72: public:
 73: 
 74:     ACauldronAltar();
 75: 
 76: 
 77:     virtual void BeginPlay() override;
 78:     virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 79:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 80:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 81:     virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
 82: 
 83: 
 84:     UPROPERTY(EditAnywhere)
 85:     FInteractionOption Option;
 86: 
 87:     UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
 88:     TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;
 89: 
 90: 
 91:     UPROPERTY(VisibleAnywhere)
 92:     UWitchPTInventoryItemInstance* BaseIngredient;
 93:     UPROPERTY(VisibleAnywhere)
 94:     UWitchPTInventoryItemInstance* PrincipalIngredient;
 95:     UPROPERTY(VisibleAnywhere)
 96:     UWitchPTInventoryItemInstance* ModifierIngredient;
 97: 
 98:     UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
 99:     TSubclassOf<UUserWidget> BaseIngredientIcon;
100: 
101:     UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
102:     TSubclassOf<UUserWidget> PrincipalIngredientIcon;
103: 
104:     UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon,Category= "Cauldron|Ingredients", VisibleAnywhere)
105:     TSubclassOf<UUserWidget> ModifierIngredientIcon;
106: 
107: 
108: 
109:     FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
110:     FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
111:     FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
112:     FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
113:     FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
114:     FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
115:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
116:     FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
117: 
118:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
119:     FOnCharacterPositioned OnCharacterPositioned;
120: 
121: 
122:     UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
123:     TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
124: 
125: 
126:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
127:     UMaterialInterface* ValidPlacementMaterial;
128: 
129:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
130:     UMaterialInterface* InvalidPlacementMaterial;
131: 
132:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
133:     float PlacementCollisionCheckRadius = 50.0f;
134: 
135:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
136:     float MaxGroundAlignmentHeight = 20.0f;
137: 
138: 
139: 
140:     void StartBrewingPotion(ACharacter* InteractingCharacter);
141: 
142:     void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
143: 
144: 
145: 
146:     UFUNCTION()
147:     void OnRep_CauldronPhysicState();
148:     UFUNCTION()
149:     void OnRep_BaseIngredientIcon();
150:     UFUNCTION()
151:     void OnRep_PrincipalIngredientIcon();
152:     UFUNCTION()
153:     void OnRep_PotentiatorIngredientIcon();
154: 
155:     UFUNCTION()
156:     void PositionCharacterForBrewing(ACharacter* Character);
157: 
158:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
159:     ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
160: 
161: 
162: 
163:     void StartCarryCauldron(ACharacter* InteractingCharacter);
164: 
165:     UFUNCTION()
166:     void AttachToCharacter(ACharacter* Character);
167: 
168:     UFUNCTION()
169:     void DetachFromCharacter(ACharacter* Character);
170: 
171: 
172:     void StartPlacementPreview(ACharacter* Character);
173:     void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
174:     void FinalizePlacement();
175:     void CancelPlacement();
176:     void ApplyPlacementPreviewMaterial();
177: 
178:     UFUNCTION(Client, Unreliable)
179:     void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
180: 
181:     UFUNCTION(NetMulticast, Reliable)
182:     void Multicast_FinalizePlacement();
183: 
184: 
185:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
186:     bool CanBePickedUp() const;
187: 
188:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
189:     bool IsBeingCarried() const;
190: 
191:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
192:     ACharacter* GetCarryingCharacter() const;
193: 
194:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
195:     ECauldronPlacementState GetPlacementState() const;
196: 
197:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
198:     bool IsInPlacementPreview() const;
199: 
200: 
201:     UWitchPTInventoryItemInstance* GetBaseIngredient() const;
202:     UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
203:     UWitchPTInventoryItemInstance* GetModifierIngredient() const;
204: 
205: protected:
206: 
207: 
208:     void BroadcastBaseIngredientDropped() const;
209:     void BroadcastBaseIngredientIconSet() const;
210:     void BroadcastPrincipalIngredientDropped() const;
211:     void BroadcastPrincipalIngredientIconSet() const;
212:     void BroadcastModifierIngredientDropped() const;
213:     void BroadcastModifierIngredientIconSet() const;
214: 
215: 
216: private:
217:     UPROPERTY(Replicated)
218:     TObjectPtr<ACharacter> CarryingCharacter;
219: 
220:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
221:     FName BackAttachSocketName = "BackpackSocket";
222: 
223:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
224:     FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
225: 
226: 
227:     UPROPERTY(Replicated)
228:     ECauldronPlacementState CurrentPlacementState;
229: 
230:     UPROPERTY()
231:     TArray<UMaterialInterface*> OriginalMaterials;
232: 
233:     FVector PreviewLocation;
234:     FRotator PreviewRotation;
235: 
236: 
237:     void RestoreOriginalMaterials();
238:     bool IsPlacementValid() const;
239: };
```

## File: Source/WitchPT/Public/Item/RitualAltar.h
```
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "RitualAltar.generated.h"
  7: 
  8: class URitualUserWidget;
  9: class ARitualPosition;
 10: 
 11: 
 12: UENUM(BlueprintType)
 13: enum class ERitualInput : uint8
 14: {
 15: 	Up		UMETA(DisplayName = "Up"),
 16: 	Down	UMETA(DisplayName = "Down"),
 17: 	Left	UMETA(DisplayName = "Left"),
 18: 	Right	UMETA(DisplayName = "Right"),
 19: 	None	UMETA(DisplayName = "None")
 20: };
 21: 
 22: USTRUCT(BlueprintType)
 23: struct FUIRitualData
 24: {
 25: 	GENERATED_BODY()
 26: 	UPROPERTY(BlueprintReadOnly)
 27: 	bool bIsMyTurn = false;
 28: 	UPROPERTY(BlueprintReadOnly)
 29: 	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
 30: 	UPROPERTY(BlueprintReadOnly)
 31: 	float RitualPercentageCompleted = 0.0f;
 32: 	UPROPERTY(BlueprintReadOnly)
 33: 	float CorruptionPercentage = 0.0f;
 34: 	UPROPERTY(BlueprintReadOnly)
 35: 	float CurrentInputTimeRemaining = 0.0f;
 36: };
 37: 
 38: 
 39: USTRUCT(BlueprintType)
 40: struct FRitualReadyPlayersData
 41: {
 42: 	GENERATED_BODY()
 43: 
 44: 	UPROPERTY(BlueprintReadOnly)
 45: 	int32 TotalPlayers = 0;
 46: 
 47: 	UPROPERTY(BlueprintReadOnly)
 48: 	int32 ReadyPlayers = 0;
 49: 
 50: 	bool operator==(const FRitualReadyPlayersData& Other) const
 51: 	{
 52: 		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
 53: 	}
 54: 
 55: 	bool operator!=(const FRitualReadyPlayersData& Other) const
 56: 	{
 57: 		return !(*this == Other);
 58: 	}
 59: };
 60: 
 61: 
 62: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
 63: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
 64: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
 65: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
 66: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
 67: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
 68: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);
 69: 
 70: UCLASS()
 71: class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
 72: {
 73: 	GENERATED_BODY()
 74: 
 75: public:
 76: 
 77: 	ARitualAltar();
 78: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 79: 
 80: 
 81: 
 82: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
 83: 	EInteractionState CurrentRitualState = EInteractionState::Inactive;
 84: 
 85: 
 86: 	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
 87: 	TArray<FGameplayTag> InputSequence;
 88: 
 89: 
 90: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
 91: 	int32 CurrentSequenceIndex = -1;
 92: 
 93: 
 94: 	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
 95: 	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
 96: 
 97: 
 98: 	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
 99: 	FRitualReadyPlayersData ReadyPlayersData;
100: 
101: 
102: 	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
103: 	int32 StartCountdown = 3;
104: 
105: 
106: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
107: 	TObjectPtr<ACharacter> CurrentActivePlayer;
108: 
109: 
110: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
111: 	float CurrentInputTimer;
112: 
113: 
114: 	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
115: 	FUIRitualData CurrentTurnData;
116: 
117: 
118: 	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
119: 	float CorruptionAmount = 0.0f;
120: 
121: 
122: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
123: 	float MaxCorruption = 100.0f;
124: 
125: 
126: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
127: 	float CorruptionIncreasePerFail = 10.0f;
128: 
129: 
130: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
131: 	float BaseInputTimeWindow = 10.0f;
132: 
133: 
134: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
135: 	float DifficultyScalingMultiplier = 1.0f;
136: 
137: 
138: 	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
139: 	bool bRitualCompleted = false;
140: 
141: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
142: 	bool bRitualWasSuccessful = false;
143: 
144: 
145: 	FOnRitualStateChanged OnRitualStateChangedEvent;
146: 
147: 	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
148: 
149: 	FOnCountdownTick OnCountdownTickEvent;
150: 
151: 	FOnTurnDataChanged OnTurnDataChangedEvent;
152: 
153: 	FOnCorruptionChanged OnCorruptionChangedEvent;
154: 
155: 	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
156: 	UPROPERTY(BlueprintAssignable)
157: 	FOnRitualCompleted OnRitualCompletedEvent;
158: 
159: 
160: 	UFUNCTION()
161: 	void OnRep_CurrentRitualState();
162: 
163: 	UFUNCTION()
164: 	void OnRep_CurrentSequenceIndex();
165: 
166: 	UFUNCTION()
167: 	void OnRep_ReadyPlayersData();
168: 
169: 	UFUNCTION()
170: 	void OnRep_StartCountdown();
171: 
172: 	UFUNCTION()
173: 	void OnRep_CurrentActivePlayer();
174: 
175: 	UFUNCTION()
176: 	void OnRep_TurnData();
177: 
178: 	UFUNCTION()
179: 	void OnRep_CorruptionAmount();
180: 
181: 	UFUNCTION()
182: 	void OnRep_RitualCompleted();
183: 
184: 
185: 	UFUNCTION(NetMulticast, Reliable)
186: 	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
187: 
188: 	void StartRitual(ACharacter* RequestingCharacter);
189: 	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
190: 
191: 
192: 	UFUNCTION(BlueprintPure, Category = "Ritual")
193: 	bool IsPlayerReady(ACharacter* Player) const;
194: 
195: 
196: 	UFUNCTION(BlueprintPure, Category = "Ritual")
197: 	bool AreAllPlayersReady() const;
198: 
199: 	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
200: 	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
201: 
202: 
203: 	UFUNCTION(NetMulticast, Reliable)
204: 	void Multicast_OnRitualSucceeded();
205: 
206: 	UFUNCTION(NetMulticast, Reliable)
207: 	void Multicast_OnRitualCatastrophicFail();
208: 
209: 
210: 	UFUNCTION(NetMulticast, Reliable)
211: 	void Multicast_OnCountdownTick(int32 CountdownValue);
212: 
213: 	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
214: 
215: 
216: 	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
217: 	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
218: 	float GetCorruptionPercentage() const;
219: 	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
220: 	float GetCurrentSequenceProgress() const;
221: 	FGameplayTag GetCurrentExpectedInput() const;
222: 	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
223: 	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
224: 	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }
225: 
226: 
227: protected:
228: 	virtual void BeginPlay() override;
229: 	virtual void Tick(float DeltaTime) override;
230: 
231: 
232: 	FTimerHandle RitualStartCountdownHandle;
233: 
234: 
235: 	FTimerHandle InputTimerHandle;
236: 
237: 
238: 	void GenerateInputSequence();
239: 	void AdvanceToNextPlayer();
240: 	virtual void HandleInputSuccess(ACharacter* Player) override;
241: 	virtual void HandleInputFailure(ACharacter* Player) override;
242: 	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
243: 	void StartInputTimer();
244: 	void OnInputTimerExpired();
245: 	void CheckRitualState();
246: 	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
247: 	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
248: 	void CleanupRitual();
249: 	void SpawnReward();
250: 	void SpawnDemon();
251: 	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
252: 	void UpdateTurnData();
253: 	void UpdateReadyPlayersData();
254: 
255: 
256: 	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
257: 	void StartRitualCountdown();
258: 	void ProcessCountdownTick();
259: 	void ActivateRitual();
260: 
261: 
262: 
263: 	void BroadcastRitualStateChanged();
264: 	void BroadcastReadyPlayersChanged();
265: 	void BroadcastCountdownTick();
266: 	void BroadcastTurnDataChanged();
267: 	void BroadcastCorruptionChanged();
268: 	void BroadcastSequenceProgressChanged();
269: 	void BroadcastRitualCompleted();
270: 
271: 	UPROPERTY(EditDefaultsOnly)
272: 	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
273: 	UPROPERTY(EditDefaultsOnly)
274: 	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
275: 	UPROPERTY(EditDefaultsOnly)
276: 	TObjectPtr<UAnimMontage> FailedAnimMontage;
277: 	UPROPERTY(EditDefaultsOnly)
278: 	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
279: 
280: 
281: 	UPROPERTY(EditDefaultsOnly)
282: 	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
283: 	UPROPERTY(EditDefaultsOnly)
284: 	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
285: };
```

## File: Source/WitchPT/Private/Item/RitualAltar.cpp
```cpp
   1: #include "Item/RitualAltar.h"
   2: #include "Net/UnrealNetwork.h"
   3: #include "Item/RitualPosition.h"
   4: #include "GameFramework/Character.h"
   5: #include "AbilitySystemComponent.h"
   6: #include "AbilitySystemBlueprintLibrary.h"
   7: #include "FWitchPTGameplayTags.h"
   8: #include "Player/WitchPTPlayerController.h"
   9: 
  10: 
  11: ARitualAltar::ARitualAltar()
  12: {
  13: 
  14: 	PrimaryActorTick.bCanEverTick = true;
  15: 
  16: 	bReplicates = true;
  17: 
  18: 
  19: 	CurrentRitualState = EInteractionState::Inactive;
  20: 	CurrentSequenceIndex = -1;
  21: 	CurrentInputTimer = 0.0f;
  22: 	CorruptionAmount = 0.0f;
  23: 	MaxCorruption = 100.0f;
  24: 	StartCountdown = 3;
  25: 	bRitualCompleted = false;
  26: 	bRitualWasSuccessful = false;
  27: }
  28: 
  29: void ARitualAltar::BeginPlay()
  30: {
  31: 	Super::BeginPlay();
  32: 
  33: 
  34: 
  35: 
  36: 
  37: 
  38: 
  39: 
  40: 
  41: 
  42: 
  43: 
  44: 
  45: 
  46: 
  47: 
  48: 
  49: }
  50: 
  51: void ARitualAltar::Tick(float DeltaTime)
  52: {
  53: 	Super::Tick(DeltaTime);
  54: }
  55: 
  56: void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
  57: {
  58: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  59: 
  60: 	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
  61: 	DOREPLIFETIME(ARitualAltar, InputSequence);
  62: 	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
  63: 	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
  64: 	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
  65: 	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
  66: 	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
  67: 	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
  68: 	DOREPLIFETIME(ARitualAltar, MaxCorruption);
  69: 	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
  70: 	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
  71: 	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
  72: 	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
  73: 	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
  74: 	DOREPLIFETIME(ARitualAltar, StartCountdown);
  75: 	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
  76: 	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
  77: }
  78: 
  79: 
  80: 
  81: void ARitualAltar::OnRep_CurrentRitualState()
  82: {
  83: 	BroadcastRitualStateChanged();
  84: }
  85: 
  86: void ARitualAltar::OnRep_CurrentSequenceIndex()
  87: {
  88: 
  89: 	BroadcastSequenceProgressChanged();
  90: }
  91: 
  92: void ARitualAltar::OnRep_ReadyPlayersData()
  93: {
  94: 	BroadcastReadyPlayersChanged();
  95: }
  96: 
  97: void ARitualAltar::OnRep_StartCountdown()
  98: {
  99: 	BroadcastCountdownTick();
 100: }
 101: 
 102: void ARitualAltar::OnRep_CurrentActivePlayer()
 103: {
 104: 
 105: 
 106: }
 107: 
 108: void ARitualAltar::OnRep_TurnData()
 109: {
 110: 	BroadcastTurnDataChanged();
 111: }
 112: 
 113: void ARitualAltar::OnRep_CorruptionAmount()
 114: {
 115: 	BroadcastCorruptionChanged();
 116: }
 117: 
 118: void ARitualAltar::OnRep_RitualCompleted()
 119: {
 120: 	if (bRitualCompleted)
 121: 	{
 122: 		BroadcastRitualCompleted();
 123: 	}
 124: }
 125: 
 126: 
 127: 
 128: void ARitualAltar::BroadcastRitualStateChanged()
 129: {
 130: 	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
 131: }
 132: 
 133: void ARitualAltar::BroadcastReadyPlayersChanged()
 134: {
 135: 	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
 136: }
 137: 
 138: void ARitualAltar::BroadcastCountdownTick()
 139: {
 140: 	OnCountdownTickEvent.Broadcast(StartCountdown);
 141: }
 142: 
 143: void ARitualAltar::BroadcastTurnDataChanged()
 144: {
 145: 	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
 146: }
 147: 
 148: void ARitualAltar::BroadcastCorruptionChanged()
 149: {
 150: 	float CorruptionPercentage = GetCorruptionPercentage();
 151: 	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
 152: }
 153: 
 154: void ARitualAltar::BroadcastSequenceProgressChanged()
 155: {
 156: 	float Progress = GetCurrentSequenceProgress();
 157: 	OnSequenceProgressChangedEvent.Broadcast(Progress);
 158: }
 159: 
 160: void ARitualAltar::BroadcastRitualCompleted()
 161: {
 162: 	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
 163: }
 164: 
 165: 
 166: 
 167: void ARitualAltar::UpdateTurnData()
 168: {
 169: 
 170: 
 171: 
 172: 
 173: 	FUIRitualData NewTurnData;
 174: 	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
 175: 	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
 176: 	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
 177: 
 178: 
 179: 	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
 180: 	{
 181: 		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
 182: 	}
 183: 	else
 184: 	{
 185: 		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
 186: 	}
 187: 
 188: 
 189: 	NewTurnData.bIsMyTurn = false;
 190: 
 191: 
 192: 	if (HasAuthority())
 193: 	{
 194: 
 195: 		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
 196: 			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
 197: 			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
 198: 			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
 199: 			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
 200: 		{
 201: 			CurrentTurnData = NewTurnData;
 202: 
 203: 			BroadcastTurnDataChanged();
 204: 		}
 205: 	}
 206: 	else
 207: 	{
 208: 
 209: 		CurrentTurnData = NewTurnData;
 210: 		BroadcastTurnDataChanged();
 211: 	}
 212: }
 213: 
 214: void ARitualAltar::UpdateReadyPlayersData()
 215: {
 216: 	if (!HasAuthority())
 217: 	{
 218: 		return;
 219: 	}
 220: 
 221: 	FRitualReadyPlayersData NewData;
 222: 	NewData.TotalPlayers = ParticipatingPlayers.Num();
 223: 	NewData.ReadyPlayers = ReadyPlayers.Num();
 224: 
 225: 	if (ReadyPlayersData != NewData)
 226: 	{
 227: 		ReadyPlayersData = NewData;
 228: 
 229: 		BroadcastReadyPlayersChanged();
 230: 	}
 231: }
 232: 
 233: 
 234: 
 235: void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
 236: {
 237: 
 238: 	UpdateReadyPlayersData();
 239: }
 240: 
 241: void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
 242: {
 243: 	if (!HasAuthority() || !RequestingCharacter)
 244: 	{
 245: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
 246: 		return;
 247: 	}
 248: 
 249: 
 250: 	if (CurrentRitualState != EInteractionState::Inactive &&
 251: 	    CurrentRitualState != EInteractionState::WaitingForPlayers)
 252: 	{
 253: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
 254: 		return;
 255: 	}
 256: 
 257: 
 258: 	ProcessRitualReadyRequest(RequestingCharacter);
 259: }
 260: 
 261: void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
 262: {
 263: 	if (!HasAuthority() || !RequestingCharacter)
 264: 	{
 265: 		return;
 266: 	}
 267: 
 268: 
 269: 	if (ReadyPlayers.Contains(RequestingCharacter))
 270: 	{
 271: 
 272: 		ReadyPlayers.Remove(RequestingCharacter);
 273: 		UpdateReadyPlayersData();
 274: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
 275: 		return;
 276: 	}
 277: 
 278: 
 279: 	ReadyPlayers.Add(RequestingCharacter);
 280: 	UpdateReadyPlayersData();
 281: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
 282: 
 283: 
 284: 	if (AreAllPlayersReady())
 285: 	{
 286: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
 287: 		StartRitualCountdown();
 288: 	}
 289: }
 290: 
 291: bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
 292: {
 293: 	return ReadyPlayers.Contains(Player);
 294: }
 295: 
 296: bool ARitualAltar::AreAllPlayersReady() const
 297: {
 298: 
 299: 	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
 300: 	{
 301: 		return false;
 302: 	}
 303: 
 304: 	for (ACharacter* Player : ParticipatingPlayers)
 305: 	{
 306: 		if (!ReadyPlayers.Contains(Player))
 307: 		{
 308: 			return false;
 309: 		}
 310: 	}
 311: 
 312: 	return true;
 313: }
 314: 
 315: void ARitualAltar::StartRitualCountdown()
 316: {
 317: 	if (!HasAuthority())
 318: 	{
 319: 		return;
 320: 	}
 321: 
 322: 
 323: 	CurrentRitualState = EInteractionState::Preparing;
 324: 
 325: 	BroadcastRitualStateChanged();
 326: 
 327: 
 328: 	GenerateInputSequence();
 329: 
 330: 
 331: 	StartCountdown = 3;
 332: 
 333: 	BroadcastCountdownTick();
 334: 
 335: 
 336: 	GetWorldTimerManager().SetTimer(
 337: 		RitualStartCountdownHandle,
 338: 		this,
 339: 		&ARitualAltar::ProcessCountdownTick,
 340: 		1.0f,
 341: 		true
 342: 	);
 343: }
 344: 
 345: void ARitualAltar::ProcessCountdownTick()
 346: {
 347: 	if (!HasAuthority())
 348: 	{
 349: 		return;
 350: 	}
 351: 
 352: 
 353: 	StartCountdown--;
 354: 
 355: 	BroadcastCountdownTick();
 356: 
 357: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
 358: 
 359: 	if (StartCountdown <= 0)
 360: 	{
 361: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 362: 		ActivateRitual();
 363: 	}
 364: }
 365: 
 366: void ARitualAltar::ActivateRitual()
 367: {
 368: 	if (!HasAuthority())
 369: 	{
 370: 		return;
 371: 	}
 372: 
 373: 
 374: 	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
 375: 
 376: 
 377: 	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
 378: 	CurrentSequenceIndex = 0;
 379: 	CurrentRitualState = EInteractionState::Active;
 380: 
 381: 
 382: 	StartInputTimer();
 383: 
 384: 
 385: 	UpdateTurnData();
 386: 
 387: 
 388: 	BroadcastRitualStateChanged();
 389: }
 390: 
 391: void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
 392: {
 393: 
 394: 	StartCountdown = CountdownValue;
 395: }
 396: 
 397: void ARitualAltar::GenerateInputSequence()
 398: {
 399: 	if (!HasAuthority())
 400: 	{
 401: 		return;
 402: 	}
 403: 
 404: 	InputSequence.Empty();
 405: 
 406: 
 407: 	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
 408: 
 409: 
 410: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 411: 
 412: 	TArray<FGameplayTag> PossibleInputs;
 413: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
 414: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
 415: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
 416: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
 417: 
 418: 
 419: 	for (int32 i = 0; i < SequenceLength; ++i)
 420: 	{
 421: 		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
 422: 		InputSequence.Add(PossibleInputs[RandomIndex]);
 423: 	}
 424: 
 425: 
 426: 
 427: 
 428: }
 429: 
 430: void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
 431: {
 432: 	if (!Character || !HasAuthority())
 433: 	{
 434: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
 435: 		return;
 436: 	}
 437: 
 438: 
 439: 	if (CurrentRitualState != EInteractionState::Active)
 440: 	{
 441: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"),
 442: 			*Character->GetName(), static_cast<int32>(CurrentRitualState));
 443: 		return;
 444: 	}
 445: 
 446: 
 447: 	if (Character != CurrentActivePlayer)
 448: 	{
 449: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"),
 450: 			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
 451: 		return;
 452: 	}
 453: 
 454: 
 455: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 456: 	{
 457: 		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"),
 458: 			CurrentSequenceIndex, InputSequence.Num());
 459: 		return;
 460: 	}
 461: 
 462: 
 463: 	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
 464: 
 465: 
 466: 
 467: 	if (InputTag == ExpectedInput)
 468: 	{
 469: 		HandleInputSuccess(Character);
 470: 	}
 471: 	else
 472: 	{
 473: 		HandleInputFailure(Character);
 474: 	}
 475: }
 476: 
 477: void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 478: {
 479: 
 480: 	if (Character)
 481: 	{
 482: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 483: 		if (ASC)
 484: 		{
 485: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 486: 			FGameplayEventData EventData;
 487: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 488: 			EventData.Instigator = this;
 489: 			EventData.Target = Character;
 490: 
 491: 
 492: 			FGameplayTag* PositionTag = nullptr;
 493: 			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 494: 			{
 495: 				if (Entry.Player == Character)
 496: 				{
 497: 					PositionTag = &Entry.PositionTag;
 498: 					break;
 499: 				}
 500: 			}
 501: 			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
 502: 			{
 503: 				EventData.OptionalObject = PrimaryAnimMontage;
 504: 			} else
 505: 			{
 506: 				EventData.OptionalObject = SecondaryAnimMontage;
 507: 			}
 508: 
 509: 
 510: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
 511: 		}
 512: 
 513: 
 514: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 515: 	}
 516: }
 517: 
 518: void ARitualAltar::HandleInputSuccess(ACharacter* Player)
 519: {
 520: 	if (!HasAuthority() || !Player)
 521: 	{
 522: 		return;
 523: 	}
 524: 
 525: 
 526: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 527: 
 528: 
 529: 	CurrentSequenceIndex++;
 530: 
 531: 
 532: 	Multicast_OnInputSuccess(Player);
 533: 
 534: 
 535: 	if (CurrentSequenceIndex >= InputSequence.Num())
 536: 	{
 537: 
 538: 		CurrentRitualState = EInteractionState::Succeeded;
 539: 		bRitualCompleted = true;
 540: 		bRitualWasSuccessful = true;
 541: 
 542: 
 543: 		UpdateTurnData();
 544: 
 545: 
 546: 		BroadcastRitualStateChanged();
 547: 		BroadcastRitualCompleted();
 548: 
 549: 
 550: 		SpawnReward();
 551: 		Multicast_OnRitualSucceeded();
 552: 
 553: 
 554: 		CleanupRitual();
 555: 	}
 556: 	else
 557: 	{
 558: 
 559: 		AdvanceToNextPlayer();
 560: 
 561: 
 562: 		StartInputTimer();
 563: 
 564: 
 565: 		UpdateTurnData();
 566: 	}
 567: }
 568: 
 569: void ARitualAltar::HandleInputFailure(ACharacter* Player)
 570: {
 571: 	if (!HasAuthority() || !Player)
 572: 	{
 573: 		return;
 574: 	}
 575: 
 576: 
 577: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 578: 
 579: 
 580: 	CorruptionAmount += CorruptionIncreasePerFail;
 581: 
 582: 	BroadcastCorruptionChanged();
 583: 
 584: 
 585: 
 586: 
 587: 
 588: 	ApplyAgePenalty(Player);
 589: 
 590: 
 591: 	Multicast_OnInputFailed(Player);
 592: 
 593: 
 594: 	if (CorruptionAmount >= MaxCorruption)
 595: 	{
 596: 
 597: 		CurrentRitualState = EInteractionState::FailedCatastrophically;
 598: 		bRitualCompleted = true;
 599: 		bRitualWasSuccessful = false;
 600: 
 601: 
 602: 		UpdateTurnData();
 603: 
 604: 
 605: 		BroadcastRitualStateChanged();
 606: 		BroadcastRitualCompleted();
 607: 
 608: 
 609: 		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
 610: 		{
 611: 			if (ParticipatingPlayer)
 612: 			{
 613: 				ApplyAgePenalty(ParticipatingPlayer, true);
 614: 			}
 615: 		}
 616: 
 617: 
 618: 		SpawnDemon();
 619: 		Multicast_OnRitualCatastrophicFail();
 620: 
 621: 
 622: 		CleanupRitual();
 623: 	}
 624: 	else
 625: 	{
 626: 
 627: 		AdvanceToNextPlayer();
 628: 
 629: 
 630: 		StartInputTimer();
 631: 
 632: 
 633: 		UpdateTurnData();
 634: 	}
 635: }
 636: 
 637: void ARitualAltar::StartInputTimer()
 638: {
 639: 	if (!HasAuthority())
 640: 	{
 641: 		return;
 642: 	}
 643: 
 644: 
 645: 	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
 646: 	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f));
 647: 
 648: 
 649: 	CurrentInputTimer = ScaledTimeWindow;
 650: 
 651: 
 652: 
 653: 	GetWorldTimerManager().SetTimer(
 654: 		InputTimerHandle,
 655: 		this,
 656: 		&ARitualAltar::OnInputTimerExpired,
 657: 		ScaledTimeWindow,
 658: 		false
 659: 	);
 660: 
 661: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"),
 662: 		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"),
 663: 		CurrentSequenceIndex, InputSequence.Num()-1);
 664: 
 665: 
 666: 	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
 667: 	{
 668: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"),
 669: 			*InputSequence[CurrentSequenceIndex].ToString());
 670: 	}
 671: }
 672: 
 673: void ARitualAltar::OnInputTimerExpired()
 674: {
 675: 	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
 676: 	{
 677: 		return;
 678: 	}
 679: 
 680: 
 681: 	if (CurrentActivePlayer)
 682: 	{
 683: 		HandleInputFailure(CurrentActivePlayer);
 684: 	}
 685: 	else
 686: 	{
 687: 
 688: 		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
 689: 		AdvanceToNextPlayer();
 690: 		StartInputTimer();
 691: 	}
 692: }
 693: 
 694: void ARitualAltar::AdvanceToNextPlayer()
 695: {
 696: 	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
 697: 	{
 698: 		return;
 699: 	}
 700: 
 701: 
 702: 
 703: 	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
 704: 
 705: 
 706: 	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
 707: 	{
 708: 		CurrentPlayerIndex = 0;
 709: 	}
 710: 	else
 711: 	{
 712: 		CurrentPlayerIndex++;
 713: 	}
 714: 
 715: 
 716: 	int32 StartIndex = CurrentPlayerIndex;
 717: 	bool bFoundEligiblePlayer = false;
 718: 
 719: 
 720: 	do
 721: 	{
 722: 		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
 723: 		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
 724: 		{
 725: 			CurrentActivePlayer = NextPlayer;
 726: 			bFoundEligiblePlayer = true;
 727: 			break;
 728: 		}
 729: 
 730: 
 731: 		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
 732: 	}
 733: 	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
 734: 
 735: 
 736: 	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
 737: 	{
 738: 		CurrentActivePlayer = ParticipatingPlayers[0];
 739: 	}
 740: }
 741: 
 742: bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
 743: {
 744: 	if (!Player)
 745: 	{
 746: 		return false;
 747: 	}
 748: 
 749: 
 750: 	bool bIsInPosition = false;
 751: 	for (const ABaseInteractionPosition* Position : InteractionPositions)
 752: 	{
 753: 		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
 754: 		{
 755: 			bIsInPosition = true;
 756: 			break;
 757: 		}
 758: 	}
 759: 
 760: 
 761: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 762: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 763: 	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
 764: 
 765: 	return bIsInPosition && bHasPositionTag;
 766: }
 767: 
 768: 
 769: void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
 770: {
 771: 	if (!HasAuthority() || !Player)
 772: 	{
 773: 		return;
 774: 	}
 775: 
 776: 
 777: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 778: 	if (!ASC)
 779: 	{
 780: 		return;
 781: 	}
 782: 
 783: 
 784: 
 785: 
 786: 
 787: 
 788: 
 789: 
 790: 
 791: 
 792: 
 793: 
 794: 
 795: 
 796: 
 797: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"),
 798: 		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
 799: }
 800: 
 801: void ARitualAltar::SpawnReward()
 802: {
 803: 	if (!HasAuthority())
 804: 	{
 805: 		return;
 806: 	}
 807: 
 808: 
 809: 
 810: 
 811: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
 812: }
 813: 
 814: void ARitualAltar::SpawnDemon()
 815: {
 816: 	if (!HasAuthority())
 817: 	{
 818: 		return;
 819: 	}
 820: 
 821: 
 822: 
 823: 
 824: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
 825: }
 826: 
 827: void ARitualAltar::CleanupRitual()
 828: {
 829: 	if (!HasAuthority())
 830: 	{
 831: 		return;
 832: 	}
 833: 
 834: 
 835: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 836: 
 837: 
 838: 	CurrentSequenceIndex = 0;
 839: 	InputSequence.Empty();
 840: 	CurrentActivePlayer = nullptr;
 841: 
 842: 
 843: 
 844: 
 845: 
 846: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up"));
 847: }
 848: 
 849: float ARitualAltar::GetCurrentSequenceProgress() const
 850: {
 851: 	if (InputSequence.Num() == 0)
 852: 	{
 853: 		return 0.0f;
 854: 	}
 855: 
 856: 	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
 857: }
 858: 
 859: FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
 860: {
 861: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 862: 	{
 863: 
 864: 		return FGameplayTag();
 865: 	}
 866: 
 867: 	return InputSequence[CurrentSequenceIndex];
 868: }
 869: 
 870: 
 871: 
 872: FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
 873: {
 874: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 875: 
 876: 	switch (Input)
 877: 	{
 878: 	case ERitualInput::Up:
 879: 		return WitchPtGameplayTags.Ritual_Input_Up;
 880: 	case ERitualInput::Down:
 881: 		return WitchPtGameplayTags.Ritual_Input_Down;
 882: 	case ERitualInput::Left:
 883: 		return WitchPtGameplayTags.Ritual_Input_Left;
 884: 	case ERitualInput::Right:
 885: 		return WitchPtGameplayTags.Ritual_Input_Right;
 886: 	default:
 887: 		return FGameplayTag();
 888: 	}
 889: }
 890: 
 891: ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
 892: {
 893: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 894: 
 895: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
 896: 		return ERitualInput::Up;
 897: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
 898: 		return ERitualInput::Down;
 899: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
 900: 		return ERitualInput::Left;
 901: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
 902: 		return ERitualInput::Right;
 903: 
 904: 	return ERitualInput::None;
 905: }
 906: 
 907: void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 908: {
 909: 	if (Character)
 910: 	{
 911: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 912: 		if (ASC)
 913: 		{
 914: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 915: 			FGameplayEventData EventData;
 916: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 917: 			EventData.Instigator = this;
 918: 			EventData.Target = Character;
 919: 
 920: 			EventData.OptionalObject = FailedAnimMontage;
 921: 
 922: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
 923: 
 924: 		}
 925: 
 926: 
 927: 
 928: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 929: 	}
 930: 
 931: 
 932: }
 933: 
 934: 
 935: 
 936: void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 937: {
 938: 
 939: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
 940: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
 941: 	if (Player->IsLocallyControlled())
 942: 	{
 943: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
 944: 	}
 945: 	else
 946: 	{
 947: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
 948: 	}
 949: 
 950: 	if (!Player || !Position || !HasAuthority())
 951: 	{
 952: 		return;
 953: 	}
 954: 
 955: 
 956: 	if (Position->IsOccupied())
 957: 	{
 958: 
 959: 		return;
 960: 	}
 961: 	Position->SetOccupied(Player);
 962: 
 963: 	bool bFound = false;
 964: 	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 965: 	{
 966: 		if (Entry.Player == Player)
 967: 		{
 968: 			Entry.PositionTag = Position->GetPositionTag();
 969: 			bFound = true;
 970: 			break;
 971: 		}
 972: 	}
 973: 	if (!bFound)
 974: 	{
 975: 		FPlayerPositionTagEntry NewEntry;
 976: 		NewEntry.Player = Player;
 977: 		NewEntry.PositionTag = Position->GetPositionTag();
 978: 		PlayerPositionTags.Add(NewEntry);
 979: 	}
 980: 
 981: 
 982: 	if (!ParticipatingPlayers.Contains(Player))
 983: 	{
 984: 		ParticipatingPlayers.Add(Player);
 985: 	}
 986: 	CurrentRitualState = EInteractionState::WaitingForPlayers;
 987: 
 988: 
 989: 	if (HasAuthority())
 990: 	{
 991: 		BroadcastRitualStateChanged();
 992: 	}
 993: 
 994: 
 995: 	UpdateReadyPlayersData();
 996: 
 997: 
 998: 	if (Player->GetLocalRole() == ROLE_Authority && Player->IsLocallyControlled())
 999: 	{
1000: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
1001: 		if (!PC->HasRitualWidgetInitialized(this))
1002: 		{
1003: 			PC->LocalInitializeRitualUserWidget(this);
1004: 		}
1005: 	} else if (Player->HasAuthority() && !Player->IsLocallyControlled())
1006: 	{
1007: 		AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetOwner());
1008: 		if (!PC->HasRitualWidgetInitialized(this))
1009: 		{
1010: 			PC->Client_InitializeRitualUserWidget(this);
1011: 		}
1012: 	}
1013: }
1014: 
1015: void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
1016: {
1017: 
1018: 
1019: 
1020: 
1021: 
1022: 
1023: 
1024: 
1025: 	bRitualCompleted = true;
1026: 	bRitualWasSuccessful = true;
1027: 
1028: 	DestroyAltarPositions();
1029: 
1030: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback"));
1031: }
1032: 
1033: void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
1034: {
1035: 
1036: 
1037: 
1038: 
1039: 
1040: 
1041: 
1042: 
1043: 	bRitualCompleted = true;
1044: 	bRitualWasSuccessful = false;
1045: 
1046: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback"));
1047: }
1048: 
1049: float ARitualAltar::GetCorruptionPercentage() const
1050: {
1051: 	if (MaxCorruption == 0.0f)
1052: 	{
1053: 		return 0.0f;
1054: 	}
1055: 
1056: 	return CorruptionAmount / MaxCorruption;
1057: }
```
