This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Source/WitchPT, GDD.txt
- Files matching these patterns are excluded: *.test.ts, docs/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
GDD.txt
Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
Source/WitchPT/Private/Character/WitchPTCharacter.cpp
Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
Source/WitchPT/Private/Character/WitchPTEnemy.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp
Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
Source/WitchPT/Private/Inventory/Collectable.cpp
Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
Source/WitchPT/Private/Item/CauldronAltar.cpp
Source/WitchPT/Private/Item/CauldronPosition.cpp
Source/WitchPT/Private/Item/Components/CauldronCraftComponent.cpp
Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
Source/WitchPT/Private/Item/Item.cpp
Source/WitchPT/Private/Item/MechanicsInterface.cpp
Source/WitchPT/Private/Item/PositionInterface.cpp
Source/WitchPT/Private/Item/Potion/PotionBase.cpp
Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
Source/WitchPT/Private/Item/RitualAltar.cpp
Source/WitchPT/Private/Item/RitualPosition.cpp
Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
Source/WitchPT/Private/WitchPTAssetManager.cpp
Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
Source/WitchPT/Public/Character/WitchPTCharacter.h
Source/WitchPT/Public/Character/WitchPTCharacterBase.h
Source/WitchPT/Public/Character/WitchPTEnemy.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentInstance.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h
Source/WitchPT/Public/FWitchPTGameplayTags.cpp
Source/WitchPT/Public/FWitchPTGameplayTags.h
Source/WitchPT/Public/Game/WitchPTGameModeBase.h
Source/WitchPT/Public/Input/WitchPTInputComponent.h
Source/WitchPT/Public/Input/WitchPTInputConfig.h
Source/WitchPT/Public/Inventory/Collectable.h
Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
Source/WitchPT/Public/Item/BaseInteractableAltar.h
Source/WitchPT/Public/Item/BaseInteractionPosition.h
Source/WitchPT/Public/Item/CauldronAltar.h
Source/WitchPT/Public/Item/CauldronPosition.h
Source/WitchPT/Public/Item/Components/CauldronCraftComponent.h
Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
Source/WitchPT/Public/Item/Item.h
Source/WitchPT/Public/Item/MechanicsInterface.h
Source/WitchPT/Public/Item/PositionInterface.h
Source/WitchPT/Public/Item/Potion/PotionBase.h
Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
Source/WitchPT/Public/Item/RitualAltar.h
Source/WitchPT/Public/Item/RitualPosition.h
Source/WitchPT/Public/Player/WitchPTPlayerController.h
Source/WitchPT/Public/Player/WitchPTPlayerState.h
Source/WitchPT/Public/Systems/GameplayTagStack.cpp
Source/WitchPT/Public/Systems/GameplayTagStack.h
Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
Source/WitchPT/Public/UI/Widgets/PointerWidget.h
Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
Source/WitchPT/Public/WitchPTAssetManager.h
Source/WitchPT/WitchPT.Build.cs
Source/WitchPT/WitchPT.cpp
Source/WitchPT/WitchPT.h

================================================================
Files
================================================================

================
File: GDD.txt
================
  1: Game Design Document (GDD) - Witches' Descent
  2: 1. Resumen General
  3: Título: Witches' Descent
  4: Género: Cooperativo PvE, Roguelite, Sigilo y Supervivencia
  5: Plataforma: PC (con opción de expansión a consolas)
  6: Motor: Unreal Engine 5
  7: Número de jugadores: 1-4 jugadores online
  8: Estilo visual: Medieval
  9: Narrativa y Ambientación
 10: Las brujas están bajo una maldición de envejecimiento acelerado. Necesitan crear y usar la Poción de Juventud en cada misión para sobrevivir y continuar su viaje. El fracaso en una misión significa el fin de la partida (la "run"), perdiendo todo el progreso acumulado dentro de esa run.
 11: Inspiración
 12: Este juego está fuertemente inspirado por Lethal Company, Helldivers 2 y R.E.P.O.
 13: 
 14: 2. Gameplay Loop
 15: Preparación (Carroza): Las brujas ven su edad actual y el objetivo de la misión (cuántos rituales humanos se necesitan). Deciden quién lleva el Caldero Portátil.
 16: Entrar al Pueblo: La misión comienza. La Maldición del Envejecimiento se activa, haciendo que las brujas se vuelvan más lentas y débiles con el tiempo.
 17: Explorar y Recolectar: Se mueven sigilosamente por el pueblo para:
 18: Encontrar NPCs humanos (su "pureza" afecta la recompensa y dificultad).
 19: Localizar Altares de Ritual.
 20: Recolectar ingredientes secundarios para pociones de buff.
 21: Evitar Cazadores de Brujas y otras amenazas.
 22: Capturar Humano: Usan el Hechizo de Sueño en un NPC (la efectividad depende de la edad de la bruja y la pureza del NPC).
 23: Transportar al Altar: Llevan el cuerpo dormido hasta un Altar (la facilidad depende de la fuerza/edad de la bruja). Es una fase vulnerable.
 24: Realizar Ritual: Ejecutan un mini-juego cooperativo en el Altar.
 25: Éxito: Obtienen 1 Ingrediente Esencial para la Poción de Juventud.
 26: Fallo: Sufren penalizaciones graves (más edad, invocación de demonio).
 27: 
 28: 
 29: Repetir si es Necesario: Si la misión requiere más ingredientes, repiten los pasos 3 a 6.
 30: Fabricar Pociones (Caldero):
 31: Con los Ingredientes Esenciales, fabrican la Poción de Juventud (mini-juego cooperativo rápido). ¡Este es el objetivo principal!
 32: Opcionalmente, usan ingredientes secundarios para crear pociones de buff (interacción simple).
 33: Escapar: Una vez hecha la Poción de Juventud, deben regresar a la Carroza. La tensión aumenta (más enemigos, tiempo corriendo).
 34: Resultado de Misión:
 35: Victoria: Escapan con éxito. La Poción de Juventud reduce su edad para la siguiente misión. Conservan pociones de buff no usadas. Avanzan al siguiente mapa.
 36: Derrota: Si todas son capturadas, se acaba el tiempo antes de hacer la poción, o el ritual falla catastróficamente -> La "run" termina. Se pierde todo el progreso de esa partida.
 37: 
 38: Moment to Moment
 39: Minute to Minute
 40: Hour to Hour
 41: Day to Day
 42: Explorar nivel.
 43: Localizar recursos
 44: Evitar amenazas
 45: (↻ repeat)
 46: 
 47: 
 48: Localizar NPC
 49: Lanzar hechizo de sueño
 50: Transportar al altar
 51: Iniciar ritual
 52: Elaborar pociones secundarias
 53: (↻ repeat)
 54: Elaborar poción de juventud
 55: Volver a la carroza
 56: Reducir la edad de la bruja.
 57: (↻ repeat)
 58: 
 59: 
 60: 
 61: (↻ repeat)
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 3. Mecánicas
 68: 
 69: 3.1 Core Mechanics
 70: 3.1.1 Movimiento básico
 71: Objetivo de Diseño: Caminar, correr, agacharse y saltar conforman el set de movimientos del personaje.
 72: TODO: Introducir imagen de lyra
 73: 3.1.2 Interacción contextual
 74: Objetivo de Diseño: Activar objetos, recoger ítems, iniciar rituales, iniciar crafteo de pociones.
 75: 3.1.3 Sistema de envejecimiento
 76: Objetivo de Diseño: Crear una presión constante y creciente sobre los jugadores, afectando directamente sus capacidades físicas y sirviendo como el motor principal del gameplay loop (la necesidad de crear la Poción de Juventud). 
 77: Descripción Jugable Paso a Paso (Experiencia del Jugador)
 78: Impacto Progresivo: A medida que la Edad aumenta, la bruja experimenta efectos negativos:
 79: 
 80: Reducción de Velocidad de Movimiento: Caminar, correr y moverse agachada se vuelve notablemente más lento. Una bruja muy anciana será significativamente más lenta que una joven.
 81: Reducción de Fuerza: La capacidad para realizar acciones que requieren esfuerzo físico disminuye. El ejemplo principal es la habilidad "Levitar Cuerpo":
 82: Una bruja joven levita/arrastra cuerpos a una velocidad decente.
 83: Una bruja de mediana edad lo hace más lentamente.
 84: Una bruja muy anciana puede que levite cuerpos extremadamente lento
 85: 
 86: 
 87: 
 88: Bruja anciana:				Bruja joven:
 89: Walk						Walk
 90: Run
 91: 
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 3.2 Primary Mechanics
 99: 3.2.1 Hechizo de sueño
100: 
101: Objetivo de Diseño: Hechizo para adormecer al NPC humano.
102: 
103: 
104: Ejecución: El hechizo requiere un tiempo de canalización hasta conseguir incapacitar al humano. El tiempo de canalización depende de la edad de la bruja y la pureza del humano.
105: Posibles maneras de canalización:
106: Canalización inmovil: La bruja no puede moverse durante la canalización. Tiempo reducido
107: Canalización con movimiento: La bruja puede moverse durante la canalización del hechizo. Tiempo de canalización mayor.
108: Percepción de la Pureza: Al observar a un NPC humano, las brujas pueden percibir su Nivel de Pureza.
109: El nivel de pureza se representa mediante un aura de distintos tiers:
110: NPC Baja Pureza (ej: 30%): Canalización muy rápida (ej: 1.5 segundos). Aura azul.
111: NPC Pureza Media (ej: 60%): Canalización moderada (ej: 3 segundos). Aura amarilla.
112: NPC Alta Pureza (ej: 95%): Canalización significativamente larga (ej: 5-6 segundos). Aura roja.
113: El nivel de pureza es directamente proporcional al tiempo que tardará la bruja en poder dormir al humano mediante el hechizo del sueño.
114: Representación: Esto podría mostrarse en la UI como un porcentaje (ej: 30% - Corrupto, 60% - Común, 95% - Puro), un aura de color sutil visible solo para las brujas, o un icono sobre la cabeza del NPC.
115: Distribución: La mayoría de los NPCs tendrán una pureza media. Los NPCs muy puros o muy corruptos serán más raros.
116: 
117: 
118: Impacto de la Pureza (Información para el Jugador): Las brujas saben (por la UI o tutoriales) que:
119: Mayor Pureza = Poción de Juventud Más Potente: El Ingrediente Ritual Esencial obtenido de un NPC más puro permitirá crear una Poción de Juventud que reduce más años de edad (ej: un NPC 90% puro da una poción que resta 250 años, mientras uno 40% puro da una que resta solo 150). Esto crea un incentivo directo para buscar NPCs puros.
120: Mayor Pureza = Mayor Resistencia al Hechizo de Sueño: Dormir a un NPC puro requiere más tiempo de canalizaciónl.
121: 3.2.2 Hechizo de levitación
122: Objetivo de Diseño: Permitir a las brujas transportar a los NPCs dormidos hasta los altares, introduciendo un elemento de habilidad física simulada y riesgo asociado al movimiento descuidado, además de un coste de recurso.
123: 1. Activación y Uso Básico
124: Requisito: Un NPC humano debe estar dormido (tras usar el Hechizo de Sueño) y una bruja debe estar cerca del cuerpo.
125: Habilidad por Defecto: Todas las brujas poseen la habilidad "Levitar Cuerpo".
126: Activación: La bruja interactúa con el cuerpo dormido o pulsa y mantiene presionado el botón/tecla asignado a la habilidad de levitación.
127: Efecto Inicial: El cuerpo del NPC se eleva del suelo y flota a una distancia corta frente a la bruja (o ligeramente a un lado para no bloquear completamente la visión).
128: Coste de Recurso: Mientras la habilidad está activa, consume Maná (o el recurso mágico principal) a una tasa constante.
129: 2. Física Ligera: Inercia y Balance
130: Sensación de Peso: El cuerpo levitado no está rígidamente fijado a la bruja. Posee una inercia simulada:
131: Al Empezar a Moverse: El cuerpo tarda una fracción de segundo en "seguir" a la bruja, como si tuviera un ligero retraso.
132: Al Girar: Si la bruja gira rápidamente, el cuerpo "derrapa" ligeramente hacia el exterior de la curva.
133: Al Detenerse: Si la bruja se detiene bruscamente, el cuerpo continúa su movimiento un instante y luego oscila hacia adelante y atrás un par de veces antes de estabilizarse.
134: Control del Jugador: La jugadora debe moverse de forma más suave y deliberada para minimizar estos efectos:
135: Tomar las curvas de forma más amplia.
136: Consecuencias del Movimiento Brusco:
137: Colisiones Ruidosas: Si la inercia o la oscilación hacen que el cuerpo golpee contra paredes, muebles u otros objetos del entorno, se genera un ruido significativo que puede alertar a los enemigos cercanos o despertar al NPC.
138: Si el humano despierta, grita alertando a los enemigos cercanos y huye.
139: 3. Conexión Sutil con la Edad
140: Control de la Inercia: Se puede añadir una ligera variación basada en la edad:
141: Brujas Jóvenes: Tienen un control ligeramente mejor sobre la inercia. El cuerpo sigue sus movimientos de forma más precisa y las oscilaciones son menores.
142: Brujas Viejas: Tienen un control ligeramente peor. El cuerpo tiende a tener más retraso, derrapar más en las curvas y oscilar de forma más pronunciada al detenerse, requiriendo aún más cuidado en el movimiento.
143: Importante: Esta diferencia debe ser sutil, afectando la facilidad de control, pero no impidiendo que ninguna bruja pueda transportar el cuerpo si es cuidadosa.
144: 4. Finalización o Interrupción
145: Soltar el Cuerpo: La bruja puede soltar el botón/tecla de levitación en cualquier momento para dejar caer suavemente el cuerpo al suelo.
146: Llegada al Altar: Al llegar al área designada del altar, una interacción o soltar el cuerpo en el lugar correcto lo deposita para iniciar el ritual.
147: Agotar Maná: Si la bruja se queda sin Maná, la levitación falla y el cuerpo cae al suelo (posiblemente haciendo ruido).
148: Ser Atacada: Recibir daño puede interrumpir la concentración y hacer que la bruja suelte el cuerpo.
149: El NPC Despierta: Si se agota el temporizador del Hechizo de Sueño antes de llegar al altar, el NPC despierta, la levitación se rompe, y el NPC alertará a los enemigos.
150: 
151: 
152: 
153: 
154: 3.2.3 Ritual Humano
155: Objetivo de Diseño: Crear un momento de tensión y cooperación obligatoria, donde el éxito proporciona el ingrediente clave para la supervivencia (Poción de Juventud) y el fallo tiene consecuencias graves y progresivas, ligadas a un sistema de "Corrupción".
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 1. Inicio del Ritual
173: Requisitos Previos:
174: Un NPC humano válido ha sido dormido con el Hechizo de Sueño.
175: El cuerpo del NPC ha sido transportado y colocado sobre un Altar de Ritual activo.
176: Al menos una bruja (idealmente todas las participantes) está presente en el área designada del altar.
177: Activación: Una bruja interactúa con el altar para iniciar formalmente el ritual. Una animación de preparación comienza, y la interfaz del mini-juego aparece para todas las brujas participantes.
178: 2. El Mini-juego de Inputs Sincronizados por Turnos
179: Secuencia y Dificultad:
180: El ritual requiere completar una secuencia de inputs específica. La longitud de esta secuencia depende de la dificultad del mapa/misión (ej: Nivel 1 = 8 inputs; Nivel 5 = 15 inputs).
181: Los inputs son típicamente direccionales (Arriba, Abajo, Izquierda, Derecha), similares a las estratagemas de Helldivers 2.
182: Sistema de Turnos:
183: Las brujas participantes toman turnos para introducir los inputs. El orden podría ser fijo (Jugador 1 -> Jugador 2 -> Jugador 3 -> Jugador 1...) o determinado por la posición alrededor del altar.
184: La interfaz indica claramente a qué bruja le toca actuar y qué input específico debe introducir.
185: Ejecución del Input:
186: A la bruja activa se le muestra el input requerido y una barra de tiempo o indicador visual que representa la ventana para introducirlo (ej: 1.5 - 2 segundos. Este tiempo también escala con la dificultad del juego).
187: Debe presionar el botón/tecla correcta dentro de esa ventana de tiempo.
188: Feedback Inmediato:
189: Éxito: Sonido de confirmación positivo, la animación del ritual progresa ligeramente (ej: la bruja realiza una animación acorde con el ritual).
190: Fallo (Input Incorrecto o Tiempo Agotado): Sonido de error disonante (animación que representa un hit). Se aplican consecuencias inmediatas (ver punto 4). Importante: El turno aún así pasa a la siguiente bruja para continuar la secuencia (a menos que se alcance un fallo catastrófico).
191: 3. La Corrupción del Ritual (Sistema de Riesgo Progresivo)
192: Indicador de Corrupción: Una barra o porcentaje visible en la UI (ej: 0% a 100%) representa el nivel de Corrupción acumulada en el ritual actual. Empieza en 0%.
193: Acumulación por Fallos: Cada vez que una bruja falla un input (sea incorrecto o fuera de tiempo):
194: El porcentaje de Corrupción del ritual aumenta en una cantidad fija (ej: +25% por fallo) Esta cantidad escala con la dificultad del nivel.
195: Umbrales de Corrupción: A medida que la Corrupción aumenta, se pueden activar efectos negativos pasivos o eventos discretos al cruzar ciertos umbrales:
196: Umbral Bajo (ej: 25%): Ligera perturbación mágica. Aumenta temporalmente la probabilidad de que enemigos cercanos investiguen el área del altar. Sonidos ambientales más inquietantes.
197: Umbral Medio (ej: 50%): El ritual se vuelve inestable. Podrían aparecer efectos visuales erráticos (chispas, humo oscuro). La ventana de tiempo para los siguientes inputs podría reducirse ligeramente.
198: Umbral Alto (ej: 75%): Gran inestabilidad. Posible aparición de amenazas menores cerca del altar (ej: sombras débiles, espíritus hostiles de bajo nivel). El entorno cercano podría oscurecerse o distorsionarse visualmente.
199: Corrupción Máxima (100% - Fallo Catastrófico): Ver punto 5.
200: 4. Penalizaciones por Fallo Individual
201: Penalización Inmediata: Además de aumentar la Corrupción general, la bruja específica que falló su input sufre una penalización personal:
202: Pico de Envejecimiento: Recibe una pequeña cantidad de Edad instantánea (ej: +5 o +10 años.  Esta cantidad escala con la dificultad del nivel). Esto es un coste directo y personal por el error.
203: (Opcional) Breve aturdimiento o interrupción de la animación, dejándola vulnerable por un instante.
204: 5. Resultados Finales del Ritual
205: Éxito Completo:
206: Toda la secuencia de inputs se completa sin alcanzar el 100% de Corrupción.
207: Se obtiene un Ingrediente Ritual Esencial  de la calidad correspondiente a la Pureza del NPC sacrificado.
208: El altar se consume (se desactiva)
209: (Opcional) Una pequeña recompensa adicional si se completa con 0% de corrupción (ej: un buff temporal menor, un ingrediente secundario raro).
210: Fallo Catastrófico (Corrupción al 100%):
211: El ritual explota o implosiona violentamente.
212: El humano se consume.
213: No se obtiene el Ingrediente Ritual Esencial.
214: Todas las brujas participantes sufren un pico de envejecimiento significativo (ej: +25 años cada una).
215: Se invoca inmediatamente al Demonio del Pacto Roto (Tier 3) cerca del altar, una amenaza poderosa que comenzará a cazar a las brujas.
216: El altar no se consume.
217: Interrupción Externa: Que hacer si las brujas son interrumpidas?
218: 
219: 
220: 
221: 3.2.4 Elaboración de la Poción de Juventud
222: 
223: Objetivo de Diseño: Crear un mini-juego cooperativo para la fabricación de la poción más importante que sea distinto al ritual, requiriendo concentración individual sincronizada y éxito colectivo para completar la poción.
224: 
225: 1. Inicio de la Elaboración
226: Requisitos Previos:
227: Todas las brujas participantes deben estar cerca del Caldero Portátil  y este está situado en el suelo.
228: Las brujas deben tener todos los ingredientes necesarios para la poción. Tanto principales como secundarios.
229: Activación: Una bruja interactúa con el caldero y selecciona la receta "Poción de Juventud". Esto inicia el mini-juego para todas las brujas cercanas que estén participando.
230: 2. Minijuego de inputs individual.
231: Interfaz: En la pantalla de cada bruja participante aparece una representación visual de un "sello" incompleto o un patrón específico que deben trazar. Este patrón es individual para cada bruja en ese momento (o podría ser el mismo para todas, a definir).
232: Tarea Individual: Cada bruja debe "trazar" o completar su patrón asignado utilizando una secuencia específica de inputs:
233: Opción A (Mando): Inputs arriba, abajo, izquierda, derecha.
234: Opción B (Secuencia WASD/Direccional): Introducir una secuencia rápida y precisa de teclas direccionales que correspondan al trazado del patrón (ej: Triángulo = W -> D+S -> A+S -> W). La UI mostraría la secuencia requerida.
235: Ejecución Simultánea: Todas las brujas realizan su trazado individual al mismo tiempo. No hay turnos.
236: Tiempo Límite: Hay una ventana de tiempo general (ej: 5-7 segundos) para que todas las brujas completen con éxito su respectivo sello/patrón. Un temporizador visible aumenta la presión.
237: Feedback Individual: Mientras trazan, las brujas reciben feedback visual:
238: Éxito Parcial: La línea del patrón se ilumina a medida que avanzan correctamente.
239: Error: Si se salen del camino (Opción A) o pulsan la tecla incorrecta (Opción B), hay un feedback negativo (sonido, vibración leve, el trazo parpadea en rojo) y deben corregir o reiniciar su input.
240: Indicador de Progreso Grupal: Podría haber un indicador central (el caldero brillando, un sello mayor formándose) que muestre cuántas brujas han completado su parte.
241: 3. Sistema de Fallo
242: Fallo Individual: Si una bruja comete demasiados errores o no logra completar su patrón dentro del tiempo límite, su contribución falla.
243: Consecuencia del Fallo: Aquí hay varias opciones de diseño, de menor a mayor penalización:
244: Opción Leve (Reintento con Coste): El mini-juego se reinicia inmediatamente. Se consume una pequeña cantidad de los ingredientes secundarios catalizadores (si los hay). Quizás añade una pequeña cantidad de Edad a todas las brujas por el esfuerzo fallido.
245: Opción Moderada (Reintento más Difícil): El mini-juego se reinicia, pero la ventana de tiempo es ligeramente más corta o los patrones un poco más complejos. Consume ingredientes secundarios.
246: Opción Grave (Pérdida de Ingredientes): El mini-juego falla. Se pierde UNO de los Ingrediente Ritual Esencial  (el recurso más valioso). Esto podría obligar a las brujas a realizar otro Ritual Humano completo para recuperarlo, aumentando drásticamente el riesgo y el tiempo.
247: Opción Catastrófica (Explosión Menor): El caldero suelta una pequeña explosión mágica. Todas las brujas sufren un pico de Edad moderado, se pierden los ingredientes secundarios, y deben volver a empezar la elaboración (pero conservan los Esenciales esta vez).
248: 4. Resultado Final de la Elaboración
249: Éxito Completo:
250: Todas las brujas participantes completan con éxito su sello/patrón individual dentro del tiempo límite general.
251: Se crea la poción de la juventud. Es solo un indicativo. Se consume automáticamente al completar el nivel.
252: El objetivo principal de la misión se cumple. Se activa la Fase de Escape.
253: Fallo (Según la opción elegida): Se aplican las consecuencias del fallo (reintento, pérdida de ingredientes, penalización de edad...). El equipo debe decidir si volver a intentarlo inmediatamente (si es posible) o si la situación requiere posponerlo.
254: 3.3 Secondary Mechanics
255: 3.3.1 Elaboración de pociones secundarias (Utilidad y Buffs)
256: Objetivo de Diseño: Proveer un sistema flexible y basado en el descubrimiento para que las brujas combinen ingredientes secundarios y creen pociones de utilidad y buff, fomentando la experimentación y la gestión de inventario.
257: 
258: 
259: Descripción Jugable Paso a Paso (Experiencia del Jugador)
260: 
261: 
262: Inicio de la Elaboración: Las brujas se acercan al Caldero Portátil colocado en el suelo. Una bruja interactúa con el caldero para abrir la interfaz de crafteo de pociones secundarias.
263: Interfaz de Slots: La interfaz del caldero muestra un número definido de "slots" (espacios) donde el jugador puede colocar ingredientes de su inventario arrastrándolos. No hay una lista de recetas conocidas al principio; el jugador descubre las recetas experimentando.
264: Roles de los Slots: Cada slot tiene un rol específico en la composición de la poción y solo acepta ingredientes que cumplen ciertos criterios basados en sus propiedades (Tier, Categoría, Tags de Crafteo):
265: Slot 1: Base/Cantidad (ej: 2-3 espacios apilables): Acepta ingredientes de Tier 0 de cualquier categoría. Proporciona la "base" de la poción. La cantidad de ingredientes colocados aquí (hasta el límite del slot) es importante.
266: Slot 2: Esencia Primaria (ej: 1 espacio): Acepta 1 ingrediente de un Tier > 0 que define el Tipo Principal de la poción (Curación, Maná, Fuerza, Sigilo, Ofensiva, etc.). La Categoría específica del ingrediente (Hierba Medicinal, Mineral Ácido, Parte Monstruo Veloz) determina el tipo de poción. El Tier del ingrediente determina la Potencia Base de la poción resultante (una Hierba Medicinal Tier 2 da una poción de curación más potente que una Tier 1).
267: Slot 3: Modificador/Catalizador (ej: 1 espacio): Acepta 1 ingrediente (generalmente Tier > 0, pudiendo ser del mismo o diferente tier que Slot 2) que añade un Efecto Secundario o Modifica el efecto primario. Este ingrediente debe tener tags de Propiedad o Crafteo específicas (ej: Modificador de Duración, Modificador de Área, Catalizador, Propiedad Eterea). Su Tier y tags determinan qué se modifica y la magnitud de la modificación. Este slot es a menudo opcional en las recetas básicas.
268: Colocación de Ingredientes: El jugador arrastra ingredientes de su inventario a los slots correspondientes. La UI puede dar feedback visual sobre si un ingrediente es válido para un slot.
269: Descubrimiento y Previsualización: Al colocar ingredientes en los slots, el sistema verifica si la combinación actual coincide con alguna receta oculta predefinida en los Data Assets del juego.
270: Si la combinación coincide con una receta ya descubierta, la UI muestra el nombre y la descripción de la poción resultante antes de craftear.
271: Si la combinación coincide con una receta aún no descubierta, la UI indica que es una "Combinación Desconocida" pero Potencialmente Válida.
272: Si la combinación no coincide con ninguna receta, la UI indica que la combinación es inválida.
273: Inicio del Crafteo: El jugador inicia el proceso de crafteo (interacción simple o mini-juego rápido, a definir) con los ingredientes colocados.
274: Resultado:
275: Éxito: Si la combinación era válida, los ingredientes se consumen de los inventarios de los jugadores participantes (o del inventario del jugador que inició el crafteo, si es individual) y se añade la poción resultante al inventario del jugador que inició el crafteo. Si la receta no estaba descubierta, ahora se añade a la lista de recetas descubiertas del jugador (persiste entre misiones, pero no entre runs).
276: Fallo: Si la combinación era inválida, el crafteo falla, los ingredientes no se consumen (o se consume una pequeña cantidad como penalización menor).
277: Gestión de Inventario y Decisiones: La limitación en el espacio del inventario obliga al jugador a elegir cuidadosamente qué ingredientes recoger. Llevar diferentes Categorías de ingredientes (Hierbas vs Minerales, etc.) del mismo Tier es crucial, ya que le da acceso a craftear diferentes tipos de pociones de ese Tier, generando decisiones significativas sobre qué capacidades (curación, utilidad, ofensa) quiere priorizar tener disponibles para craftear durante la misión.
278: 

================
File: Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
================
 1: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: 
 5: UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
 6: 	:Super(ObjectInitializer)
 7: {
 8: 	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
 9: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
10: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
11: 	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
12: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
13: }
14: 
15: void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
16:                                             const FGameplayAbilitySpec& Spec)
17: {
18: 	Super::OnGiveAbility(ActorInfo, Spec);
19: 	TryActivateAbilityOnSpawn(ActorInfo, Spec);
20: }
21: 
22: void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
23: 	const FGameplayAbilitySpec& Spec) const
24: {
25: 	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
26: 	{
27: 		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
28: 		AbilitySystem->TryActivateAbility(Spec.Handle);
29: 	}
30: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
================
 1: #include "AbilitySystem/Interaction/InteractionStatics.h"
 2: 
 3: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 4: #include "Engine/OverlapResult.h"
 5: 
 6: UInteractionStatics::UInteractionStatics()
 7: 	: Super(FObjectInitializer::Get())
 8: {
 9: }
10: 
11: AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
12: {
13: 	if (UObject* Object = InteractableTarget.GetObject())
14: 	{
15: 		if (AActor* Actor = Cast<AActor>(Object))
16: 		{
17: 			return Actor;
18: 		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
19: 		{
20: 			AActor* ActorToReturn = ActorComponent->GetOwner();
21: 			return ActorToReturn;
22: 		} else
23: 		{
24: 			unimplemented()
25: 		}
26: 	}
27: 	return nullptr;
28: }
29: 
30: void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
31: 	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
32: {
33: 
34: 	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
35: 	if (InteractableActor)
36: 	{
37: 		OutInteractableTargets.Add(InteractableActor);
38: 	}
39: 
40: 
41: 	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
42: 	for (UActorComponent* InteractableComponent : InteractableComponents)
43: 	{
44: 		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
45: 	}
46: }
47: 
48: void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
49: {
50: 	for (const FOverlapResult& Overlap : OverlapResults)
51: 	{
52: 		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
53: 		if (InteractableActor)
54: 		{
55: 			OutInteractableTargets.AddUnique(InteractableActor);
56: 		}
57: 
58: 		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
59: 		if (InteractableComponent)
60: 		{
61: 			OutInteractableTargets.AddUnique(InteractableComponent);
62: 		}
63: 	}
64: }
65: 
66: void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
67: {
68: 	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
69: 	if (InteractableActor)
70: 	{
71: 		OutInteractableTargets.AddUnique(InteractableActor);
72: 	}
73: 
74: 	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
75: 	if (InteractableComponent)
76: 	{
77: 		OutInteractableTargets.AddUnique(InteractableComponent);
78: 	}
79: }

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
================
1: #include "AbilitySystem/WitchPTAbilitySystemGlobals.h"

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
================
  1: #include "AbilitySystem/WitchPTAttributeSet.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "GameplayEffectExtension.h"
  5: #include "GameFramework/Character.h"
  6: #include "Net/UnrealNetwork.h"
  7: #include "WitchPT/WitchPT.h"
  8: 
  9: void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 10: {
 11: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 12: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
 13: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)
 14: 
 15: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
 16: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)
 17: 
 18: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
 19: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
 20: 
 21: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
 22: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
 23: 
 24: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
 25: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
 26: 
 27: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
 28: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)
 29: 
 30: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
 31: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
 32: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)
 33: 
 34: 
 35: }
 36: 
 37: UWitchPTAttributeSet::UWitchPTAttributeSet()
 38: {
 39: }
 40: 
 41: void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
 42: {
 43: 	Super::PreAttributeChange(Attribute, NewValue);
 44: }
 45: 
 46: void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 47: {
 48: 	Super::PostGameplayEffectExecute(Data);
 49: 	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
 50: 	{
 51: 
 52: 	}
 53: 	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
 54: 	{
 55: 		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
 56: 	}
 57: }
 58: 
 59: void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 60: {
 61: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
 62: }
 63: 
 64: void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
 65: {
 66: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
 67: }
 68: void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
 69: {
 70: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
 71: }
 72: 
 73: void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
 74: {
 75: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
 76: }
 77: 
 78: void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
 79: {
 80: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
 81: }
 82: 
 83: void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
 84: {
 85: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
 86: }
 87: 
 88: void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
 89: {
 90: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
 91: }
 92: 
 93: void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
 94: {
 95: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
 96: }
 97: 
 98: void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
 99: {
100: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
101: }
102: 
103: void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
104: {
105: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
106: }
107: 
108: void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
109: {
110: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
111: }
112: 
113: void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
114: {
115: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
116: }
117: 
118: void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
119: {
120: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
121: }
122: 
123: void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
124: {
125: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
126: }
127: 
128: void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
129: {
130: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
131: }

================
File: Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
================
  1: #include "Character/WitchPTCharacterBase.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  5: #include "AbilitySystem/WitchPTAttributeSet.h"
  6: #include "Character/Components/WitchPTCharacterMovementComponent.h"
  7: #include "Components/CapsuleComponent.h"
  8: 
  9: 
 10: AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
 12: {
 13: 
 14: 	PrimaryActorTick.bCanEverTick = true;
 15: 	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 16: 	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 17: 
 18: }
 19: 
 20: UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
 21: {
 22: 	return AbilitySystemComponent;
 23: }
 24: 
 25: 
 26: 
 27: 
 28: void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 29: {
 30: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 31: 
 32: }
 33: 
 34: void AWitchPTCharacterBase::InitializeDefaultAttributes()
 35: {
 36: 	ApplyGameplayEffectToSelf(DefaultAttributes);
 37: 
 38: 
 39: }
 40: 
 41: void AWitchPTCharacterBase::GrantStartupAbilities()
 42: {
 43: 	if (!HasAuthority()) return;
 44: 
 45: 	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 46: 
 47: 	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
 48: }
 49: 
 50: void AWitchPTCharacterBase::AddStartupEffects()
 51: {
 52: 	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
 53: 	{
 54: 		return;
 55: 	}
 56: 
 57: 	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
 58: 	EffectContext.AddSourceObject(this);
 59: 
 60: 	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
 61: 	{
 62: 		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
 63: 		if (NewHandle.IsValid())
 64: 		{
 65: 			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
 66: 		}
 67: 	}
 68: 
 69: 	AbilitySystemComponent->bStartupEffectsApplied = true;
 70: }
 71: 
 72: void AWitchPTCharacterBase::InitAbilityActorInfo()
 73: {
 74: }
 75: 
 76: void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
 77: {
 78: 	check(IsValid(GetAbilitySystemComponent()));
 79: 	check(GameplayEffectClass);
 80: 	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
 81: 	EffectContextHandle.AddSourceObject(this);
 82: 	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
 83: 	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
 84: 
 85: }
 86: 
 87: float AWitchPTCharacterBase::GetHealth() const
 88: {
 89: 	if (IsValid(AttributeSet))
 90: 	{
 91: 		return AttributeSet->GetHealth();
 92: 	}
 93: 	return 0.f;
 94: }
 95: 
 96: float AWitchPTCharacterBase::GetMaxHealth() const
 97: {
 98: 	if (IsValid(AttributeSet))
 99: 	{
100: 		return AttributeSet->GetMaxHealth();
101: 	}
102: 	return 0.f;
103: }
104: 
105: float AWitchPTCharacterBase::GetStamina() const
106: {
107: 	if (IsValid(AttributeSet))
108: 	{
109: 		return AttributeSet->GetStamina();
110: 	}
111: 	return 0.f;
112: }
113: 
114: float AWitchPTCharacterBase::GetMaxStamina() const
115: {
116: 	if (IsValid(AttributeSet))
117: 	{
118: 		return AttributeSet->GetMaxStamina();
119: 	}
120: 	return 0.f;
121: }
122: 
123: float AWitchPTCharacterBase::GetAge() const
124: {
125: 	if (IsValid(AttributeSet))
126: 	{
127: 		return AttributeSet->GetAge();
128: 	}
129: 	return 0.f;
130: }
131: 
132: float AWitchPTCharacterBase::GetMaxAge() const
133: {
134: 	if (IsValid(AttributeSet))
135: 	{
136: 		return AttributeSet->GetMaxAge();
137: 	}
138: 	return 0.f;
139: }
140: 
141: float AWitchPTCharacterBase::GetMana() const
142: {
143: 	if (IsValid(AttributeSet))
144: 	{
145: 		return AttributeSet->GetMana();
146: 	}
147: 	return 0.f;
148: }
149: 
150: float AWitchPTCharacterBase::GetMaxMana() const
151: {
152: 	if (IsValid(AttributeSet))
153: 	{
154: 		return AttributeSet->GetMaxMana();
155: 	}
156: 	return 0.f;
157: }
158: 
159: float AWitchPTCharacterBase::GetSpeedMultiplier() const
160: {
161: 	if (IsValid(AttributeSet))
162: 	{
163: 		return AttributeSet->GetSpeedMultiplier();
164: 	}
165: 	return 0.f;
166: }
167: 
168: float AWitchPTCharacterBase::GetMoveSpeed() const
169: {
170: 	if (IsValid(AttributeSet))
171: 	{
172: 		return AttributeSet->GetMoveSpeed();
173: 	}
174: 	return 0.f;
175: }
176: 
177: float AWitchPTCharacterBase::GetMaxMoveSpeed() const
178: {
179: 	if (IsValid(AttributeSet))
180: 	{
181: 		return AttributeSet->GetMaxMoveSpeed();
182: 	}
183: 	return 0.f;
184: }

================
File: Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
================
1: #include "Game/WitchPTGameModeBase.h"

================
File: Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
================
1: #include "Input/WitchPTInputComponent.h"

================
File: Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
================
 1: #include "Input/WitchPTInputConfig.h"
 2: 
 3: const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
 4: {
 5: 	for (const FWitchPTInputAction& Pair: AbilityInputActions)
 6: 	{
 7: 		if (InputTag == Pair.InputTag)
 8: 		{
 9: 			return Pair.InputAction;
10: 		}
11: 	}
12: 	if (bLogNotFound)
13: 	{
14: 		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
15: 	}
16: 	return nullptr;
17: 
18: }

================
File: Source/WitchPT/Private/Item/Item.cpp
================
 1: #include "Item/Item.h"
 2: 
 3: 
 4: 
 5: AItem::AItem()
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AItem::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AItem::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
25: {
26: 	OptionBuilder.AddInteractionOption(Option);
27: }

================
File: Source/WitchPT/Private/WitchPTAssetManager.cpp
================
 1: #include "WitchPTAssetManager.h"
 2: 
 3: #include "AbilitySystemGlobals.h"
 4: #include "FWitchPTGameplayTags.h"
 5: 
 6: UWitchPTAssetManager& UWitchPTAssetManager::Get()
 7: {
 8: 	check(GEngine)
 9: 	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
10: 	return *WitchPtAssetManager;
11: }
12: 
13: void UWitchPTAssetManager::StartInitialLoading()
14: {
15: 	Super::StartInitialLoading();
16: 	FWitchPTGameplayTags::InitializeGameplayTags();
17: 
18: 
19: 
20: 
21: 
22: 	UAbilitySystemGlobals::Get().InitGlobalData();
23: 
24: }

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionQuery.generated.h"
 6: 
 7: 
 8: 
 9: USTRUCT(BlueprintType)
10: struct FInteractionQuery
11: {
12: 	GENERATED_BODY()
13: 
14: public:
15: 
16: 	UPROPERTY(BlueprintReadWrite)
17: 	TWeakObjectPtr<AActor> RequestingAvatar;
18: 
19: 
20: 	UPROPERTY(BlueprintReadWrite)
21: 	TWeakObjectPtr<AController> RequestingController;
22: 
23: 
24: 	UPROPERTY(BlueprintReadWrite)
25: 	TWeakObjectPtr<UObject> OptionalObjectData;
26: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "InteractionStatics.generated.h"
 6: 
 7: template <typename InterfaceType> class TScriptInterface;
 8: class AActor;
 9: class IInteractableTarget;
10: class UObject;
11: 
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UInteractionStatics();
21: 
22: public:
23: 	UFUNCTION(BlueprintCallable)
24: 	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);
25: 
26: 	UFUNCTION(BlueprintCallable)
27: 	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
28: 	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
29: 	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
30: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemGlobals.h"
 5: #include "WitchPTAbilitySystemGlobals.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
12: {
13: 	GENERATED_BODY()
14: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "AbilitySystemComponent.h"
  5: #include "AttributeSet.h"
  6: #include "WitchPTAttributeSet.generated.h"
  7: 
  8: 
  9: 
 10: 
 11: 
 12: 
 13: #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 14: GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 15: GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 16: GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 17: GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 18: 
 19: 
 20: UCLASS()
 21: class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
 22: {
 23: 	GENERATED_BODY()
 24: public:
 25: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 26: 	UWitchPTAttributeSet();
 27: 	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
 28: 	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
 35: 	FGameplayAttributeData Age;
 36: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
 37: 
 38: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
 39: 	FGameplayAttributeData MaxAge;
 40: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
 41: 
 42: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
 43: 	FGameplayAttributeData Health;
 44: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
 45: 
 46: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
 47: 	FGameplayAttributeData MaxHealth;
 48: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
 49: 
 50: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
 51: 	FGameplayAttributeData Strength;
 52: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
 53: 
 54: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
 55: 	FGameplayAttributeData MaxStrength;
 56: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
 57: 
 58: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
 59: 	FGameplayAttributeData Mana;
 60: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
 61: 
 62: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
 63: 	FGameplayAttributeData MaxMana;
 64: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
 65: 
 66: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
 67: 	FGameplayAttributeData Stamina;
 68: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
 69: 
 70: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
 71: 	FGameplayAttributeData MaxStamina;
 72: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);
 73: 
 74: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
 75: 	FGameplayAttributeData SpeedMultiplier;
 76: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);
 77: 
 78: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
 79: 	FGameplayAttributeData MaxSpeedMultiplier;
 80: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);
 81: 
 82: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
 83: 	FGameplayAttributeData MoveSpeed;
 84: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);
 85: 
 86: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
 87: 	FGameplayAttributeData MaxMoveSpeed;
 88: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);
 89: 
 90: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
 91: 	FGameplayAttributeData MinMoveSpeed;
 92: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 	UFUNCTION()
 99: 	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
100: 	UFUNCTION()
101: 	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
102: 	UFUNCTION()
103: 	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
104: 	UFUNCTION()
105: 	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
106: 	UFUNCTION()
107: 	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
108: 	UFUNCTION()
109: 	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
110: 	UFUNCTION()
111: 	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
112: 	UFUNCTION()
113: 	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
114: 	UFUNCTION()
115: 	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
116: 	UFUNCTION()
117: 	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
118: 	UFUNCTION()
119: 	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
120: 	UFUNCTION()
121: 	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
122: 	UFUNCTION()
123: 	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
124: 	UFUNCTION()
125: 	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
126: 	UFUNCTION()
127: 	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
128: };

================
File: Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/CharacterMovementComponent.h"
 5: #include "WitchPTCharacterMovementComponent.generated.h"
 6: 
 7: 
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	UWitchPTCharacterMovementComponent();
15: 	uint8 RequestToStartSprinting : 1;
16: 	uint8 RequestToStartADS : 1;
17: 	virtual float GetMaxSpeed() const override;
18: 	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
19: 	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
20: 
21: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
22: 	void StartSprinting();
23: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
24: 	void StopSprinting();
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
29: 	void StartAimDownSights();
30: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
31: 	void StopAimDownSights();
32: };

================
File: Source/WitchPT/Public/Character/WitchPTCharacterBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/Character.h"
 6: #include "WitchPTCharacterBase.generated.h"
 7: 
 8: class UWitchPTAbilitySystemComponent;
 9: class UWitchPTAttributeSet;
10: class UGameplayAbility;
11: class UGameplayEffect;
12: class UAttributeSet;
13: 
14: UCLASS(Abstract)
15: class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
25: 	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }
26: 
27: protected:
28: 	UPROPERTY()
29: 	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
30: 	UPROPERTY()
31: 	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
32: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
33: 
34: 	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
35: 	TSubclassOf<UGameplayEffect> DefaultAttributes;
36: 	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
37: 	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
38: 
39: 
40: 	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
41: 	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;
42: 
43: 	virtual void InitializeDefaultAttributes();
44: 
45: 	virtual void GrantStartupAbilities();
46: 
47: 	virtual void AddStartupEffects();
48: 
49: 	virtual void InitAbilityActorInfo();
50: private:
51: 	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);
52: 
53: 
54: 
55: public:
56: 
57: 
58: 
59: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
60: 	float GetHealth() const;
61: 
62: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
63: 	float GetMaxHealth() const;
64: 
65: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
66: 	float GetStamina() const;
67: 
68: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
69: 	float GetMaxStamina() const;
70: 
71: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
72: 	float GetAge() const;
73: 
74: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
75: 	float GetMaxAge() const;
76: 
77: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
78: 	float GetMana() const;
79: 
80: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
81: 	float GetMaxMana() const;
82: 
83: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
84: 	float GetSpeedMultiplier() const;
85: 
86: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
87: 	float GetMoveSpeed() const;
88: 
89: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
90: 	float GetMaxMoveSpeed() const;
91: 
92: 
93: 
94: 
95: 
96: 
97: 
98: };

================
File: Source/WitchPT/Public/Character/WitchPTEnemy.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "WitchPTEnemy.generated.h"
 6: 
 7: UCLASS()
 8: class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
 9: {
10: 	GENERATED_BODY()
11: 
12: public:
13: 
14: 	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);
15: 
16: protected:
17: 
18: 	virtual void BeginPlay() override;
19: 
20: public:
21: 
22: 	virtual void Tick(float DeltaTime) override;
23: 
24: 
25: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
26: };

================
File: Source/WitchPT/Public/Game/WitchPTGameModeBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/GameModeBase.h"
 5: #include "WitchPTGameModeBase.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
12: {
13: 	GENERATED_BODY()
14: };

================
File: Source/WitchPT/Public/Input/WitchPTInputComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "EnhancedInputComponent.h"
 5: #include "WitchPTInputConfig.h"
 6: 
 7: #include "WitchPTInputComponent.generated.h"
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
17: 	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);
18: 
19: };
20: 
21: template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
22: void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
23: 	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
24: {
25: 	check(InputConfig);
26: 	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
27: 	{
28: 		if (Action.InputAction && Action.InputTag.IsValid())
29: 		{
30: 			if (PressedFunc)
31: 			{
32: 				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
33: 			}
34: 			if (ReleasedFunc)
35: 			{
36: 				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
37: 			}
38: 			if (HeldFunc)
39: 			{
40: 				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
41: 			}
42: 		}
43: 	}
44: 
45: }

================
File: Source/WitchPT/Public/Input/WitchPTInputConfig.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Engine/DataAsset.h"
 6: #include "WitchPTInputConfig.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FWitchPTInputAction
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly)
13: 	const class UInputAction* InputAction = nullptr;
14: 
15: 	UPROPERTY(EditDefaultsOnly)
16: 	FGameplayTag InputTag = FGameplayTag();
17: };
18: 
19: 
20: 
21: UCLASS()
22: class WITCHPT_API UWitchPTInputConfig : public UDataAsset
23: {
24: 	GENERATED_BODY()
25: 	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
26: public:
27: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
28: 	TArray<FWitchPTInputAction> AbilityInputActions;
29: 
30: };

================
File: Source/WitchPT/Public/Item/Item.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 5: #include "GameFramework/Actor.h"
 6: #include "Item.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AItem : public AActor, public IInteractableTarget
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AItem();
16: 
17: protected:
18: 
19: 	virtual void BeginPlay() override;
20: 	UPROPERTY(EditAnywhere)
21: 	FInteractionOption Option;
22: 
23: public:
24: 
25: 	virtual void Tick(float DeltaTime) override;
26: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
27: };

================
File: Source/WitchPT/Public/WitchPTAssetManager.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Engine/AssetManager.h"
 5: #include "WitchPTAssetManager.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAssetManager : public UAssetManager
12: {
13: 	GENERATED_BODY()
14: public:
15: 	static UWitchPTAssetManager& Get();
16: protected:
17: 	virtual void StartInitialLoading() override;
18: 
19: 
20: };

================
File: Source/WitchPT/WitchPT.cpp
================
1: #include "WitchPT.h"
2: #include "Modules/ModuleManager.h"
3: 
4: IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );

================
File: Source/WitchPT/WitchPT.h
================
1: #pragma once
2: 
3: #include "CoreMinimal.h"
4: #define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
5: #define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
6: #define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)

================
File: Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
================
  1: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/PlayerController.h"
  4: #include "Engine/World.h"
  5: #include "DrawDebugHelpers.h"
  6: #include "TimerManager.h"
  7: #include "GameFramework/Character.h"
  8: #include "Camera/CameraComponent.h"
  9: 
 10: UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer)
 12: {
 13: 	bTickingTask = true;
 14: 	TraceDistance = 500.0f;
 15: 	TraceRadius = 10.0f;
 16: 	bTraceComplex = false;
 17: 	bIgnoreBlockingHits = false;
 18: 	bShowDebug = false;
 19: 	LastHitLocation = FVector::ZeroVector;
 20: 	LastHitNormal = FVector::UpVector;
 21: }
 22: 
 23: UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
 24: 	UGameplayAbility* OwningAbility,
 25: 	float TraceDistance,
 26: 	float TraceRadius,
 27: 	bool TraceComplex,
 28: 	bool bIgnoreBlockingHits,
 29: 	bool bShowDebug)
 30: {
 31: 	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
 32: 
 33: 	MyObj->TraceDistance = TraceDistance;
 34: 	MyObj->TraceRadius = TraceRadius;
 35: 	MyObj->bTraceComplex = TraceComplex;
 36: 	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
 37: 	MyObj->bShowDebug = bShowDebug;
 38: 
 39: 	return MyObj;
 40: }
 41: 
 42: void UAT_WaitForPlacementLocation_SLT::Activate()
 43: {
 44: 	Super::Activate();
 45: 
 46: 
 47: 	SetWaitingOnAvatar();
 48: 
 49: 
 50: 	PerformTrace();
 51: }
 52: 
 53: void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
 54: {
 55: 
 56: 	UWorld* World = GetWorld();
 57: 	if (World)
 58: 	{
 59: 		World->GetTimerManager().ClearTimer(TraceTimerHandle);
 60: 	}
 61: 
 62: 	Super::OnDestroy(bInOwnerFinished);
 63: }
 64: 
 65: void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
 66: {
 67: 	Super::TickTask(DeltaTime);
 68: 
 69: 
 70: 	PerformTrace();
 71: }
 72: 
 73: void UAT_WaitForPlacementLocation_SLT::PerformTrace()
 74: {
 75: 	if (!Ability || !Ability->GetCurrentActorInfo())
 76: 	{
 77: 		return;
 78: 	}
 79: 
 80: 
 81: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 82: 	if (!PC)
 83: 	{
 84: 		return;
 85: 	}
 86: 
 87: 
 88: 	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
 89: 	if (!Character)
 90: 	{
 91: 		return;
 92: 	}
 93: 
 94: 
 95: 	FVector TraceStart;
 96: 	FVector TraceDirection;
 97: 
 98: 
 99: 	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
100: 	if (CameraComponent)
101: 	{
102: 
103: 		TraceStart = CameraComponent->GetComponentLocation();
104: 		TraceDirection = CameraComponent->GetForwardVector();
105: 	}
106: 	else
107: 	{
108: 
109: 		FRotator ControllerRotation = PC->GetControlRotation();
110: 		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
111: 		TraceDirection = ControllerRotation.Vector();
112: 	}
113: 
114: 	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
115: 
116: 
117: 	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
118: 	QueryParams.AddIgnoredActor(Character);
119: 
120: 
121: 	ECollisionChannel TraceChannel = ECC_Visibility;
122: 
123: 
124: 	FHitResult HitResult;
125: 	bool bHit = false;
126: 
127: 
128: 	if (TraceRadius > 0.0f)
129: 	{
130: 		bHit = GetWorld()->SweepSingleByChannel(
131: 			HitResult,
132: 			TraceStart,
133: 			TraceEnd,
134: 			FQuat::Identity,
135: 			TraceChannel,
136: 			FCollisionShape::MakeSphere(TraceRadius),
137: 			QueryParams
138: 		);
139: 	}
140: 	else
141: 	{
142: 		bHit = GetWorld()->LineTraceSingleByChannel(
143: 			HitResult,
144: 			TraceStart,
145: 			TraceEnd,
146: 			TraceChannel,
147: 			QueryParams
148: 		);
149: 	}
150: 
151: 
152: 	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
153: 	{
154: 
155: 		LastHitLocation = HitResult.ImpactPoint;
156: 		LastHitNormal = HitResult.ImpactNormal;
157: 
158: 
159: 		if (ShouldBroadcastAbilityTaskDelegates())
160: 		{
161: 			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
162: 		}
163: 	}
164: 
165: 
166: 	if (bShowDebug)
167: 	{
168: 		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
169: 
170: 		if (bHit)
171: 		{
172: 
173: 			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
174: 
175: 
176: 			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
177: 		}
178: 	}
179: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
================
  1: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "Engine/OverlapResult.h"
  5: #include "Engine/World.h"
  6: #include "GameFramework/Controller.h"
  7: 
  8: #include "TimerManager.h"
  9: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 10: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 11: #include "AbilitySystem/Interaction/InteractionQuery.h"
 12: #include "AbilitySystem/Interaction/InteractionStatics.h"
 13: #include "WitchPT/WitchPT.h"
 14: 
 15: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
 16: UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
 17: 	: Super(ObjectInitializer)
 18: {
 19: }
 20: void UAbilityTask_GrantNearbyInteraction::Activate()
 21: {
 22: 
 23: 	SetWaitingOnAvatar();
 24: 	UWorld* World = GetWorld();
 25: 	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
 26: 
 27: }
 28: 
 29: void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
 30: {
 31: 	Super::OnGameplayTaskActivated(Task);
 32: 
 33: }
 34: 
 35: UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
 36:                                                                                                              float InteractionScanRange, float InteractionScanRate)
 37: {
 38: 
 39: 	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
 40: 	MyObj->InteractionScanRange = InteractionScanRange;
 41: 	MyObj->InteractionScanRate = InteractionScanRate;
 42: 	return MyObj;
 43: }
 44: 
 45: void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
 46: {
 47: 
 48: 	UWorld* World = GetWorld();
 49: 	if (World)
 50: 	{
 51: 		World->GetTimerManager().ClearTimer(QueryTimerHandle);
 52: 	}
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 	Super::OnDestroy(AbilityEnded);
 74: }
 75: 
 76: void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
 77: {
 78: 	UWorld* World = GetWorld();
 79: 	AActor* ActorOwner = GetAvatarActor();
 80: 
 81: 	if (World && ActorOwner)
 82: 	{
 83: 		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);
 84: 
 85: 		TArray<FOverlapResult> OverlapResults;
 86: 		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);
 87: 
 88: 		if (OverlapResults.Num() > 0)
 89: 		{
 90: 			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 91: 			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
 92: 
 93: 			FInteractionQuery InteractionQuery;
 94: 			InteractionQuery.RequestingAvatar = ActorOwner;
 95: 			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());
 96: 
 97: 			TArray<FInteractionOption> Options;
 98: 			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
 99: 			{
100: 				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
101: 				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
102: 			}
103: 
104: 
105: 			for (FInteractionOption& Option : Options)
106: 			{
107: 
108: 				if (Option.InteractionAbilityToGrant)
109: 				{
110: 
111: 					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
112: 					if (!InteractionAbilityCache.Find(ObjectKey))
113: 					{
114: 						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
115: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
116: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
117: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
118: 						InteractionAbilityCache.Add(ObjectKey, Handle);
119: 					}
120: 				}
121: 
122: 
123: 				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
124: 				{
125: 					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
126: 					if (!HoldInteractionAbilityCache.Find(ObjectKey))
127: 					{
128: 						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
129: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
130: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
131: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
132: 						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
133: 					}
134: 				}
135: 			}
136: 		}
137: 	}
138: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
================
 1: #include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"
 2: 
 3: #include "AbilitySystem/Interaction/InteractionStatics.h"
 4: #include "Kismet/GameplayStatics.h"
 5: 
 6: UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
 7: 	: Super(ObjectInitializer)
 8: {
 9: }
10: 
11: UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
12: 	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
13: 	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
14: 	bool bShowDebug)
15: {
16: 	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
17: 	MyObj->InteractionScanRange = InteractionScanRange;
18: 	MyObj->InteractionScanRate = InteractionScanRate;
19: 	MyObj->StartLocation = StartLocation;
20: 	MyObj->InteractionQuery = InteractionQuery;
21: 	MyObj->TraceProfile = TraceProfile;
22: 	MyObj->bShowDebug = bShowDebug;
23: 
24: 	return MyObj;
25: }
26: void UAT_WaitForInteractable_SLT::Activate()
27: {
28: 	SetWaitingOnAvatar();
29: 
30: 	UWorld* World = GetWorld();
31: 	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
32: }
33: 
34: void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
35: {
36: 	if (UWorld* World = GetWorld())
37: 	{
38: 		World->GetTimerManager().ClearTimer(TimerHandle);
39: 	}
40: 
41: 	Super::OnDestroy(AbilityEnded);
42: }
43: 
44: void UAT_WaitForInteractable_SLT::PerformTrace()
45: {
46: 	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
47: 
48: 	if (!AvatarActor)
49: 	{
50: 		return;
51: 	}
52: 
53: 	UWorld* World = GetWorld();
54: 
55: 	TArray<AActor*> ActorsToIgnore;
56: 	ActorsToIgnore.Add(AvatarActor);
57: 
58: 	const bool bTraceComplex = false;
59: 	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
60: 	Params.AddIgnoredActors(ActorsToIgnore);
61: 	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
62: 	FVector2D ViewportSize;
63: 	GEngine->GameViewport->GetViewportSize(ViewportSize);
64: 	const FVector2D ViewportCenter = ViewportSize / 2.f;
65: 	FVector TraceStart;
66: 	FVector Forward;
67: 	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;
68: 
69: 
70: 	FVector TraceEnd;
71: 	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);
72: 
73: 	FHitResult OutHitResult;
74: 	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);
75: 
76: 	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
77: 	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);
78: 
79: 	UpdateInteractableOptions(InteractionQuery, InteractableTargets);
80: 
81: #if ENABLE_DRAW_DEBUG
82: 	if (bShowDebug)
83: 	{
84: 		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
85: 		if (OutHitResult.bBlockingHit)
86: 		{
87: 			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
88: 			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
89: 		}
90: 		else
91: 		{
92: 			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
93: 		}
94: 	}
95: #endif
96: }

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
================
 1: #include "AbilitySystem/WitchPTAbilitySystemLibrary.h"
 2: 
 3: #include "Item/MechanicsInterface.h"
 4: 
 5: TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
 6: {
 7: 	if (!Actor)
 8: 	{
 9: 		return TScriptInterface<IMechanicsInterface>();
10: 
11: 	}
12: 	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
13: 	if (ComponentsImplementingInterface.Num() > 0)
14: 	{
15: 		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
16: 	}
17: 	return TScriptInterface<IMechanicsInterface>();
18: }

================
File: Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
================
 1: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Character/WitchPTCharacterBase.h"
 6: 
 7: 
 8: 
 9: UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
10: {
11: 
12: 	PrimaryComponentTick.bCanEverTick = true;
13: 
14: 
15: }
16: 
17: float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
18: {
19: 
20: 	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());
21: 
22: 	if (!Owner)
23: 	{
24: 
25: 		return Super::GetMaxSpeed();
26: 	}
27: 
28: 
29: 
30: 	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
31: 	{
32: 
33: 		return 0.0f;
34: 	}
35: 
36: 	float FinalSpeed = Owner->GetMoveSpeed();
37: 	if (RequestToStartSprinting)
38: 	{
39: 		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
40: 
41: 	}
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 	return FinalSpeed;
50: }
51: 
52: void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
53: {
54: 	Super::UpdateFromCompressedFlags(Flags);
55: }
56: 
57: class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
58: {
59: 	return Super::GetPredictionData_Client();
60: }
61: 
62: 
63: void UWitchPTCharacterMovementComponent::StartSprinting()
64: {
65: 	RequestToStartSprinting = true;
66: }
67: 
68: void UWitchPTCharacterMovementComponent::StopSprinting()
69: {
70: 	RequestToStartSprinting = false;
71: }
72: 
73: void UWitchPTCharacterMovementComponent::StartAimDownSights()
74: {
75: 	RequestToStartADS = true;
76: }
77: 
78: void UWitchPTCharacterMovementComponent::StopAimDownSights()
79: {
80: 	RequestToStartADS = false;
81: 
82: }

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp
================
1: #include "Equipment/WitchPTEquipmentDefinition.h"
2: 
3: #include "Equipment/WitchPTEquipmentInstance.h"
4: 
5: UWitchPTEquipmentDefinition::UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer)
6: 	: Super(ObjectInitializer)
7: {
8: 	InstanceType = UWitchPTEquipmentInstance::StaticClass();
9: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
2: 
3: #include "Inventory/WitchPTInventoryItemInstance.h"
4: 
5: void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
6: {
7: 
8: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp
================
 1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
 2: #include "Inventory/WitchPTInventoryItemInstance.h"
 3: 
 4: void UWitchPTInventoryItemFragment_PotionProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
 5: {
 6: 
 7: 
 8: }
 9: 
10: bool UWitchPTInventoryItemFragment_PotionProperties::IsValidPotion() const
11: {
12: 
13: 	return PotionEssenceTag.IsValid() &&
14: 		   FinalPotency > 0.0f &&
15: 		   FinalDuration > 0.0f &&
16: 		   FinalCharges > 0;
17: }
18: 
19: FString UWitchPTInventoryItemFragment_PotionProperties::GetPotionDescription() const
20: {
21: 	if (!IsValidPotion())
22: 	{
23: 		return TEXT("Invalid Potion");
24: 	}
25: 
26: 
27: 	FString Description = FString::Printf(
28: 		TEXT("%s Potion\nPotency: %.1f\nDuration: %.1fs\nCharges: %d"),
29: 		*PotionEssenceTag.GetTagName().ToString(),
30: 		FinalPotency,
31: 		FinalDuration,
32: 		FinalCharges
33: 	);
34: 
35: 
36: 	if (PotionTierTag.IsValid())
37: 	{
38: 		Description += FString::Printf(TEXT("\nTier: %s"), *PotionTierTag.GetTagName().ToString());
39: 	}
40: 
41: 
42: 	if (BaseLiquidTypeTag.IsValid())
43: 	{
44: 		Description += FString::Printf(TEXT("\nBase: %s"), *BaseLiquidTypeTag.GetTagName().ToString());
45: 	}
46: 
47: 
48: 	if (GrantedEffectTags.Num() > 0)
49: 	{
50: 		Description += FString::Printf(TEXT("\nEffects: %d"), GrantedEffectTags.Num());
51: 	}
52: 
53: 
54: 	if (GrantedPropertyTags.Num() > 0)
55: 	{
56: 		Description += FString::Printf(TEXT("\nProperties: %d"), GrantedPropertyTags.Num());
57: 	}
58: 
59: 	return Description;
60: }
61: 
62: void UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties(
63: 	const FGameplayTag& InPotionEssence,
64: 	const FGameplayTag& InBaseLiquidType,
65: 	float InPotency,
66: 	float InDuration,
67: 	int32 InCharges,
68: 	const FGameplayTag& InTierTag,
69: 	const FGameplayTagContainer& InEffectTags,
70: 	const FGameplayTagContainer& InPropertyTags)
71: {
72: 	PotionEssenceTag = InPotionEssence;
73: 	BaseLiquidTypeTag = InBaseLiquidType;
74: 	FinalPotency = InPotency;
75: 	FinalDuration = InDuration;
76: 	FinalCharges = InCharges;
77: 	PotionTierTag = InTierTag;
78: 	GrantedEffectTags = InEffectTags;
79: 	GrantedPropertyTags = InPropertyTags;
80: 
81: 	UE_LOG(LogTemp, Log, TEXT("UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties: Potion properties set - %s, Potency: %.2f, Duration: %.2f, Charges: %d"),
82: 		   *PotionEssenceTag.ToString(),
83: 		   FinalPotency,
84: 		   FinalDuration,
85: 		   FinalCharges);
86: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp
================
 1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
 2: #include "Inventory/WitchPTInventoryItemInstance.h"
 3: 
 4: void UWitchPTInventoryItemFragment_WorldDetails::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
 5: {
 6: 
 7: 
 8: }
 9: 
10: bool UWitchPTInventoryItemFragment_WorldDetails::HasValidWorldMesh() const
11: {
12: 	return WorldStaticMesh != nullptr;
13: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

================
File: Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
================
 1: #include "Inventory/InventoryFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 7: 
 8: UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
 9: {
10: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
11: 	{
12: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
13: 		{
14: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
15: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
16: 			UAttributeSet* AS = PS->GetAttributeSet();
17: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
18: 
19: 			return WitchPTHUD->SetInventoryWidgetController(WCParams);
20: 		}
21: 	}
22: 	return nullptr;
23: }

================
File: Source/WitchPT/Private/Item/MechanicsInterface.cpp
================
1: #include "Item/MechanicsInterface.h"

================
File: Source/WitchPT/Private/Item/PositionInterface.cpp
================
1: #include "Item/PositionInterface.h"

================
File: Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
================
 1: #include "UI/WidgetControllers/OverlayWidgetController.h"
 2: 
 3: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAttributeSet.h"
 5: 
 6: void UOverlayWidgetController::BroadcastInitialValues()
 7: {
 8: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
 9: 
10: 	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
11: 	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
12: 	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
13: 	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
14: 	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
15: 	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
16: }
17: 
18: void UOverlayWidgetController::BindCallbacksToDependencies()
19: {
20: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
21: 
22: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
23: 	{
24: 		OnHealthChanged.Broadcast(Data.NewValue);
25: 	});
26: 
27: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
28: 	{
29: 		OnMaxHealthChanged.Broadcast(Data.NewValue);
30: 	});
31: 
32: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
33: 	{
34: 		OnStaminaChanged.Broadcast(Data.NewValue);
35: 	});
36: 
37: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
38: 	{
39: 		OnMaxStaminaChanged.Broadcast(Data.NewValue);
40: 	});
41: 
42: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
43: 	{
44: 		OnAgeChanged.Broadcast(Data.NewValue);
45: 	});
46: 
47: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
48: 	{
49: 		OnMaxAgeChanged.Broadcast(Data.NewValue);
50: 	});
51: 
52: 	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
53: 
54: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
55: 
56: 
57: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
58: 
59: 		[this](const FGameplayTagContainer& AssetTags)
60: 	{
61: 		for (const auto& Tag : AssetTags)
62: 		{
63: 
64: 			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
65: 			if (Tag.MatchesTag(ParentMessageGameplayTag))
66: 			{
67: 
68: 
69: 				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
70: 				OnMessageWidgetRow.Broadcast(*Row);
71: 
72: 			}
73: 
74: 		}
75: 	});
76: 
77: 
78: 
79: }
80: void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
81: {
82: 
83: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
================
 1: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 2: 
 3: void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
 4: {
 5: 	PlayerController = WCParams.PlayerController;
 6: 	PlayerState = WCParams.PlayerState;
 7: 	AbilitySystemComponent = WCParams.AbilitySystemComponent;
 8: 	AttributeSet = WCParams.AttributeSet;
 9: }
10: 
11: void UWitchPTWidgetController::BroadcastInitialValues()
12: {
13: }
14: 
15: void UWitchPTWidgetController::BindCallbacksToDependencies()
16: {
17: }

================
File: Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
================
1: #include "UI/Widgets/PointerWidget.h"

================
File: Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
================
1: #include "UI/Widgets/WitchPTUserWidget.h"
2: 
3: void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
4: {
5: 	WidgetController = InWidgetController;
6: 	OnWidgetControllerSet();
7: }

================
File: Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AT_WaitForPlacementLocation_SLT.generated.h"
 6: 
 7: 
 8: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);
 9: 
10: 
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
25: 	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
26: 		UGameplayAbility* OwningAbility,
27: 		float TraceDistance = 500.0f,
28: 		float TraceRadius = 10.0f,
29: 		bool TraceComplex = false,
30: 		bool bIgnoreBlockingHits = false,
31: 		bool bShowDebug = false);
32: 
33: 
34: 	UPROPERTY(BlueprintAssignable)
35: 	FPlacementLocationFound OnLocationFound;
36: 
37: 
38: 	virtual void Activate() override;
39: 
40: 
41: 	virtual void OnDestroy(bool bInOwnerFinished) override;
42: 
43: private:
44: 
45: 	void PerformTrace();
46: 
47: 
48: 	void TickTask(float DeltaTime);
49: 
50: 
51: 	FTimerHandle TraceTimerHandle;
52: 
53: 
54: 	float TraceDistance;
55: 
56: 
57: 	float TraceRadius;
58: 
59: 
60: 	bool bTraceComplex;
61: 
62: 
63: 	bool bIgnoreBlockingHits;
64: 
65: 
66: 	bool bShowDebug;
67: 
68: 
69: 	FVector LastHitLocation;
70: 
71: 
72: 	FVector LastHitNormal;
73: };

================
File: Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "WitchPTGameplayAbility.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UENUM(BlueprintType)
11: enum class EPrototypeAbilityActivationPolicy: uint8
12: {
13: 
14: 	OnInputTriggered,
15: 
16: 
17: 	WhileInputActive,
18: 
19: 
20: 	OnSpawn,
21: 
22: 	OnTriggeredEvent
23: };
24: UCLASS()
25: class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
26: {
27: 	GENERATED_BODY()
28: public:
29: 	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
30: 	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
31: 	UPROPERTY(EditDefaultsOnly, Category="Input")
32: 	FGameplayTag StartupInputTag;
33: 	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
34: protected:
35: 
36: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
37: 	EPrototypeAbilityActivationPolicy ActivationPolicy;
38: 
39: 	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
40: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AbilityTask_GrantNearbyInteraction.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
12: {
13: 	GENERATED_UCLASS_BODY()
14: 
15: 
16: 	virtual void Activate() override;
17: 	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;
18: 
19: 
20: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
21: 	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);
22: 
23: private:
24: 	virtual void OnDestroy(bool AbilityEnded) override;
25: 
26: 	void QueryInteractables();
27: 	float InteractionScanRange = 100;
28: 	float InteractionScanRate = 0.100;
29: 	FTimerHandle QueryTimerHandle;
30: 
31: 
32: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
33: 
34: 
35: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;
36: 
37: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "Engine/CollisionProfile.h"
 6: #include "InteractionOption.h"
 7: #include "AbilityTask_WaitForInteractable.generated.h"
 8: 
 9: 
10: 
11: 
12: class AActor;
13: class IInteractableTarget;
14: class UObject;
15: class UWorld;
16: struct FCollisionQueryParams;
17: struct FHitResult;
18: struct FInteractionQuery;
19: template <typename InterfaceType> class TScriptInterface;
20: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);
21: 
22: UCLASS(Abstract)
23: class UAbilityTask_WaitForInteractable : public UAbilityTask
24: {
25: 	GENERATED_UCLASS_BODY()
26: 
27: public:
28: 	UPROPERTY(BlueprintAssignable)
29: 	FInteractableObjectsChangedEvent InteractableObjectsChanged;
30: 
31: protected:
32: 
33: 	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);
34: 
35: 	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;
36: 
37: 	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);
38: 
39: 	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);
40: 
41: 	ECollisionChannel TraceProfile;
42: 
43: 
44: 	bool bTraceAffectsAimPitch = true;
45: 
46: 	TArray<FInteractionOption> CurrentOptions;
47: 
48: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "InteractionQuery.h"
 5: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 6: #include "AT_WaitForInteractable_SLT.generated.h"
 7: struct FCollisionProfileName;
 8: 
 9: class UGameplayAbility;
10: class UObject;
11: struct FFrame;
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
17: {
18: 	GENERATED_UCLASS_BODY()
19: 
20: 	virtual void Activate() override;
21: 
22: 
23: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
24: 	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);
25: 
26: private:
27: 
28: 	virtual void OnDestroy(bool AbilityEnded) override;
29: 
30: 	void PerformTrace();
31: 
32: 	UPROPERTY()
33: 	FInteractionQuery InteractionQuery;
34: 
35: 	UPROPERTY()
36: 	FGameplayAbilityTargetingLocationInfo StartLocation;
37: 
38: 	float InteractionScanRange = 100;
39: 	float InteractionScanRate = 0.100;
40: 	bool bShowDebug = false;
41: 
42: 	FTimerHandle TimerHandle;
43: 
44: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTAbilitySystemLibrary.generated.h"
 6: 
 7: class IMechanicsInterface;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
13: {
14: 	GENERATED_BODY()
15: 	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
16: 	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
17: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryFragment_Stackable.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	int32 GetMaxStackSize() const { return MaxStackSize; }
17: 	int32 GetStackCount() const { return StackCount; }
18: 	void SetStackCount(int32 Count) { StackCount = Count; }
19: 
20: private:
21: 
22: 	UPROPERTY(EditAnywhere, Category = "Inventory")
23: 	int32 MaxStackSize{1};
24: 
25: 	UPROPERTY(EditAnywhere, Category = "Inventory")
26: 	int32 StackCount{1};
27: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryFragment_UIDetails.generated.h"
 7: 
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	FText Title;
18: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
19: 	FText Description;
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
21: 	TSubclassOf<UUserWidget> IconWidget;
22: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
23: 	FGameplayTag TierTag;
24: 
25: 
26: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryItemFragment_EquippableItem.generated.h"
 6: 
 7: class UWitchPTEquipmentDefinition;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryItemFragment_EquippableItem : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UPROPERTY(EditAnywhere, Category=Equipment)
17: 	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;
18: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FBaseIngredientData
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
13: 	FGameplayTag BaseLiquidTypeTag;
14: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
15: 	int32 DefaultChargesProvided;
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	float StabilityModifier;
18: };
19: 
20: USTRUCT(BlueprintType)
21: struct FPrincipalIngredientData
22: {
23: 	GENERATED_BODY()
24: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
25: 	FGameplayTag PrincipalEssenceTag;
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
27: 	float BasePotency;
28: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
29: 	float BaseDuration;
30: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
31: 	bool bIsRitualEssence;
32: };
33: 
34: USTRUCT(BlueprintType)
35: struct FModifierIngredientData
36: {
37: 	GENERATED_BODY()
38: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
39: 	FGameplayTagContainer ModifierEffectTags;
40: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
41: 	float PotencyModificationValue;
42: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
43: 	float DurationModificationValue;
44: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
45: 	FGameplayTag GrantedPropertyTag;
46: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
47: 	FGameplayTag AddedEffectTag;
48: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
49: 	float StrengthOfModifier;
50: 
51: };
52: UCLASS()
53: class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
54: {
55: 	GENERATED_BODY()
56: public:
57: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
58: 	FGameplayTag SlotUsageTag;
59: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
60: 	FGameplayTag TierTag;
61: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
62: 	FGameplayTag CategoryTag;
63: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
64: 	FBaseIngredientData BaseIngredientData;
65: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
66: 	FPrincipalIngredientData PrincipalIngredientData;
67: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
68: 	FModifierIngredientData ModifierIngredientData;
69: 
70: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
71: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryItemFragment_WorldDetails.generated.h"
 6: 
 7: 
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryItemFragment_WorldDetails : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
19: 	UStaticMesh* WorldStaticMesh;
20: 
21: 
22: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
23: 	UMaterialInterface* WorldMaterial;
24: 
25: 
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
27: 	FVector WorldScale = FVector(1.0f, 1.0f, 1.0f);
28: 
29: 
30: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
31: 	FName CollisionProfileName = "Item";
32: 
33: 
34: 	UFUNCTION(BlueprintPure, Category = "World Details")
35: 	bool HasValidWorldMesh() const;
36: 
37: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
38: };

================
File: Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "InventoryFunctionLibrary.generated.h"
 6: 
 7: class UInventoryWidgetController;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UFUNCTION(BlueprintPure, Category="Inventory")
17: 	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
18: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTInventoryFunctionLibrary.generated.h"
 6: 
 7: class UWitchPTInventoryItemDefinition;
 8: class UWitchPTInventoryItemFragment;
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
14: {
15: 	GENERATED_BODY()
16: 	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
17: 	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
18: };

================
File: Source/WitchPT/Public/Item/PositionInterface.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Interface.h"
 5: #include "PositionInterface.generated.h"
 6: 
 7: class ARitualAltar;
 8: 
 9: UINTERFACE(MinimalAPI)
10: class UPositionInterface : public UInterface
11: {
12: 	GENERATED_BODY()
13: };
14: 
15: 
16: 
17: 
18: class WITCHPT_API IPositionInterface
19: {
20: 	GENERATED_BODY()
21: 
22: 
23: public:
24: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
25: 	ARitualAltar* GetRitualAltarActor() const;
26: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
27: 	bool IsOccupied();
28: };

================
File: Source/WitchPT/Public/Systems/GameplayTagStack.cpp
================
  1: #include "Systems/GameplayTagStack.h"
  2: 
  3: #include "UObject/Stack.h"
  4: 
  5: #include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)
  6: 
  7: 
  8: 
  9: 
 10: FString FGameplayTagStack::GetDebugString() const
 11: {
 12: 	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
 13: }
 14: 
 15: 
 16: 
 17: 
 18: void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
 19: {
 20: 	if (!Tag.IsValid())
 21: 	{
 22: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
 23: 		return;
 24: 	}
 25: 
 26: 	if (StackCount > 0)
 27: 	{
 28: 		for (FGameplayTagStack& Stack : Stacks)
 29: 		{
 30: 			if (Stack.Tag == Tag)
 31: 			{
 32: 				const int32 NewCount = Stack.StackCount + StackCount;
 33: 				Stack.StackCount = NewCount;
 34: 				TagToCountMap[Tag] = NewCount;
 35: 				MarkItemDirty(Stack);
 36: 				return;
 37: 			}
 38: 		}
 39: 
 40: 		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
 41: 		MarkItemDirty(NewStack);
 42: 		TagToCountMap.Add(Tag, StackCount);
 43: 	}
 44: }
 45: 
 46: void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
 47: {
 48: 	if (!Tag.IsValid())
 49: 	{
 50: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
 51: 		return;
 52: 	}
 53: 
 54: 
 55: 	if (StackCount > 0)
 56: 	{
 57: 		for (auto It = Stacks.CreateIterator(); It; ++It)
 58: 		{
 59: 			FGameplayTagStack& Stack = *It;
 60: 			if (Stack.Tag == Tag)
 61: 			{
 62: 				if (Stack.StackCount <= StackCount)
 63: 				{
 64: 					It.RemoveCurrent();
 65: 					TagToCountMap.Remove(Tag);
 66: 					MarkArrayDirty();
 67: 				}
 68: 				else
 69: 				{
 70: 					const int32 NewCount = Stack.StackCount - StackCount;
 71: 					Stack.StackCount = NewCount;
 72: 					TagToCountMap[Tag] = NewCount;
 73: 					MarkItemDirty(Stack);
 74: 				}
 75: 				return;
 76: 			}
 77: 		}
 78: 	}
 79: }
 80: 
 81: void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 82: {
 83: 	for (int32 Index : RemovedIndices)
 84: 	{
 85: 		const FGameplayTag Tag = Stacks[Index].Tag;
 86: 		TagToCountMap.Remove(Tag);
 87: 	}
 88: }
 89: 
 90: void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 91: {
 92: 	for (int32 Index : AddedIndices)
 93: 	{
 94: 		const FGameplayTagStack& Stack = Stacks[Index];
 95: 		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
 96: 	}
 97: }
 98: 
 99: void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
100: {
101: 	for (int32 Index : ChangedIndices)
102: 	{
103: 		const FGameplayTagStack& Stack = Stacks[Index];
104: 		TagToCountMap[Stack.Tag] = Stack.StackCount;
105: 	}
106: }

================
File: Source/WitchPT/Public/Systems/GameplayTagStack.h
================
 1: #pragma once
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Net/Serialization/FastArraySerializer.h"
 5: 
 6: #include "GameplayTagStack.generated.h"
 7: 
 8: struct FGameplayTagStackContainer;
 9: struct FNetDeltaSerializeInfo;
10: 
11: 
12: 
13: 
14: USTRUCT(BlueprintType)
15: struct FGameplayTagStack : public FFastArraySerializerItem
16: {
17: 	GENERATED_BODY()
18: 
19: 	FGameplayTagStack()
20: 	{}
21: 
22: 	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
23: 		: Tag(InTag)
24: 		, StackCount(InStackCount)
25: 	{
26: 	}
27: 
28: 	FString GetDebugString() const;
29: 
30: private:
31: 	friend FGameplayTagStackContainer;
32: 
33: 	UPROPERTY()
34: 	FGameplayTag Tag;
35: 
36: 	UPROPERTY()
37: 	int32 StackCount = 0;
38: };
39: 
40: 
41: USTRUCT(BlueprintType)
42: struct FGameplayTagStackContainer : public FFastArraySerializer
43: {
44: 	GENERATED_BODY()
45: 
46: 	FGameplayTagStackContainer()
47: 
48: 	{
49: 	}
50: 
51: public:
52: 
53: 	void AddStack(FGameplayTag Tag, int32 StackCount);
54: 
55: 
56: 	void RemoveStack(FGameplayTag Tag, int32 StackCount);
57: 
58: 
59: 	int32 GetStackCount(FGameplayTag Tag) const
60: 	{
61: 		return TagToCountMap.FindRef(Tag);
62: 	}
63: 
64: 
65: 	bool ContainsTag(FGameplayTag Tag) const
66: 	{
67: 		return TagToCountMap.Contains(Tag);
68: 	}
69: 
70: 
71: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
72: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
73: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
74: 
75: 
76: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
77: 	{
78: 		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
79: 	}
80: 
81: private:
82: 
83: 	UPROPERTY()
84: 	TArray<FGameplayTagStack> Stacks;
85: 
86: 
87: 	TMap<FGameplayTag, int32> TagToCountMap;
88: };
89: 
90: template<>
91: struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
92: {
93: 	enum
94: 	{
95: 		WithNetDeltaSerializer = true,
96: 	};
97: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTWidgetController.h"
 6: #include "OverlayWidgetController.generated.h"
 7: class UWitchPTUserWidget;
 8: 
 9: USTRUCT()
10: struct FUIWidgetRow: public FTableRowBase
11: {
12: 	GENERATED_BODY()
13: 
14: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
15: 	FGameplayTag MessageGameplayTag = FGameplayTag();
16: 
17: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
18: 	FText Message = FText();
19: 
20: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
21: 	TSubclassOf<UWitchPTUserWidget> MessageWidget;
22: 
23: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
24: 	UTexture2D* Image = nullptr;
25: 
26: };
27: 
28: 
29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);
30: 
31: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);
32: 
33: UCLASS(BlueprintType, Blueprintable)
34: class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
35: {
36: 	GENERATED_BODY()
37: public:
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
48: 	virtual void BroadcastInitialValues() override;
49: 
50: 	virtual void BindCallbacksToDependencies() override;
51: 
52: 
53: 
54: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
55: 	FOnAttributeChangedSignature OnHealthChanged;
56: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
57: 	FOnAttributeChangedSignature OnMaxHealthChanged;
58: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
59: 	FOnAttributeChangedSignature OnStaminaChanged;
60: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
61: 	FOnAttributeChangedSignature OnMaxStaminaChanged;
62: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
63: 	FOnAttributeChangedSignature OnAgeChanged;
64: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
65: 	FOnAttributeChangedSignature OnMaxAgeChanged;
66: 
67: 	UPROPERTY(BlueprintAssignable, Category="Widget Data")
68: 	FOnMessageWidgetRowSignature OnMessageWidgetRow;
69: protected:
70: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
71: 	TObjectPtr<UDataTable> MessageWidgetDataTable;
72: 
73: 	template<typename T>
74: T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
75: };
76: 
77: template <typename T>
78: T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
79: {
80: 	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));
81: 
82: }

================
File: Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "WitchPTWidgetController.generated.h"
 6: 
 7: class UAbilitySystemComponent;
 8: class UAttributeSet;
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: USTRUCT(BlueprintType)
24: struct FWidgetControllerParams
25: {
26: 	GENERATED_BODY()
27: 	FWidgetControllerParams() {};
28: 	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
29: 	:
30: 	PlayerController(PC),
31: 	PlayerState(PS),
32: 	AbilitySystemComponent(ASC),
33: 	AttributeSet(AS)
34: 	{}
35: 
36: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
37: 	TObjectPtr<APlayerController> PlayerController = nullptr;
38: 
39: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
40: 	TObjectPtr<APlayerState> PlayerState = nullptr;
41: 
42: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
43: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
44: 
45: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
46: 	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
47: 
48: };
49: UCLASS()
50: class WITCHPT_API UWitchPTWidgetController : public UObject
51: {
52: 	GENERATED_BODY()
53: public:
54: 	UFUNCTION(BlueprintCallable)
55: 	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
56: 
57: 	UFUNCTION(BlueprintCallable)
58: 	virtual void BroadcastInitialValues();
59: 	virtual void BindCallbacksToDependencies();
60: protected:
61: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
62: 	TObjectPtr<APlayerController> PlayerController;
63: 
64: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
65: 	TObjectPtr<APlayerState> PlayerState;
66: 
67: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
68: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
69: 
70: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
71: 	TObjectPtr<UAttributeSet> AttributeSet;
72: };

================
File: Source/WitchPT/Public/UI/Widgets/PointerWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "PointerWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UPointerWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
17: 	void ShowPickupMessage(const FString& Message);
18: 
19: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
20: 	void HidePickupMessage();
21: };

================
File: Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "WitchPTUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTUserWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 	UFUNCTION(BlueprintCallable)
16: 	void SetWidgetController(UObject* InWidgetController);
17: 	UPROPERTY(BlueprintReadOnly)
18: 	TObjectPtr<UObject> WidgetController;
19: 
20: 	UFUNCTION(BlueprintImplementableEvent)
21: 	void OnWidgetControllerSet();
22: };

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
================
  1: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  2: 
  3: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  4: 
  5: 
  6: void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
  7: 	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
  8: {
  9: 	if (!AbilitiesToGrant.IsEmpty())
 10: 	{
 11: 		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
 12: 		{
 13: 			if (!AbilityClass)
 14: 			{
 15: 				continue;
 16: 			}
 17: 
 18: 
 19: 			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
 20: 			if (!AbilityCDO)
 21: 			{
 22: 				continue;
 23: 			}
 24: 
 25: 			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
 26: 
 27: 			AbilitySpec.SourceObject = this;
 28: 
 29: 			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
 30: 
 31: 			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
 32: 
 33: 			GrantedAbilities.Add(AbilitySpecHandle);
 34: 		}
 35: 	}
 36: }
 37: 
 38: void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
 39: {
 40: 	if (InputTag.IsValid())
 41: 	{
 42: 
 43: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 44: 		{
 45: 
 46: 
 47: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 48: 			{
 49: 
 50: 				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
 51: 				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
 52: 			}
 53: 		}
 54: 	}
 55: }
 56: 
 57: void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
 58: {
 59: 	if (!InputTag.IsValid()) return;
 60: 	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
 61: 	{
 62: 		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
 63: 		{
 64: 			AbilitySpecInputPressed(AbilitySpec);
 65: 			if (!AbilitySpec.IsActive())
 66: 			{
 67: 				TryActivateAbility(AbilitySpec.Handle);
 68: 			}
 69: 		}
 70: 	}
 71: }
 72: 
 73: void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
 74: {
 75: 	if (InputTag.IsValid())
 76: 	{
 77: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 78: 		{
 79: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 80: 			{
 81: 				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
 82: 				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
 83: 			}
 84: 		}
 85: 	}
 86: }
 87: 
 88: void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
 89: {
 90: 	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
 91: }
 92: 
 93: void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
 94: {
 95: 		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
 96: 	AbilitiesToActivate.Reset();
 97: 
 98: 
 99: 
100: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
101: 	{
102: 
103: 
104: 		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
105: 		{
106: 			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
107: 			{
108: 				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
109: 				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
110: 				{
111: 
112: 
113: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
114: 					{
115: 						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
116: 					}
117: 				}
118: 			}
119: 		}
120: 	}
121: 
122: 
123: 
124: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
125: 	{
126: 
127: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
128: 		{
129: 			if (AbilitySpec->Ability)
130: 			{
131: 				AbilitySpec->InputPressed = true;
132: 
133: 				if (AbilitySpec->IsActive())
134: 				{
135: 
136: 
137: 
138: 					AbilitySpecInputPressed(*AbilitySpec);
139: 				}
140: 				else
141: 				{
142: 					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
143: 
144: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
145: 					{
146: 						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
147: 						{
148: 							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
149: 						}
150: 					}
151: 				}
152: 			}
153: 		}
154: 	}
155: 
156: 
157: 
158: 
159: 
160: 	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
161: 	{
162: 		TryActivateAbility(AbilitySpecHandle);
163: 	}
164: 
165: 
166: 
167: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
168: 	{
169: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
170: 		{
171: 			if (AbilitySpec->Ability)
172: 			{
173: 				AbilitySpec->InputPressed = false;
174: 
175: 				if (AbilitySpec->IsActive())
176: 				{
177: 
178: 					AbilitySpecInputReleased(*AbilitySpec);
179: 				}
180: 			}
181: 		}
182: 	}
183: 
184: 
185: 
186: 
187: 	InputPressedSpecHandles.Reset();
188: 	InputReleasedSpecHandles.Reset();
189: 
190: }
191: 
192: void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
193: {
194: 	Super::AbilitySpecInputPressed(Spec);
195: 
196: 
197: 	if (Spec.IsActive())
198: 	{
199: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
200: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
201: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
202: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
203: 
204: 
205: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
206: 	}
207: 
208: }
209: 
210: void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
211: {
212: 	Super::AbilitySpecInputReleased(Spec);
213: 
214: 
215: 	if (Spec.IsActive())
216: 	{
217: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
218: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
219: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
220: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
221: 
222: 
223: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
224: 	}
225: }
226: 
227: void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
228: 	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
229: {
230: 	FGameplayTagContainer TagContainer;
231: 	EffectSpec.GetAllAssetTags(TagContainer);
232: 
233: 	OnEffectAssetTags.Broadcast(TagContainer);
234: }

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp
================
 1: #include "Equipment/WitchPTEquipmentInstance.h"
 2: 
 3: #include "Equipment/WitchPTEquipmentDefinition.h"
 4: #include "GameFramework/Character.h"
 5: 
 6: UWitchPTEquipmentInstance::UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer)
 7: {
 8: }
 9: 
10: UWorld* UWitchPTEquipmentInstance::GetWorld() const
11: {
12: 	if (const APawn* OwningPawn = GetPawn())
13: 	{
14: 		return OwningPawn->GetWorld();
15: 	}
16: 	return nullptr;
17: }
18: 
19: void UWitchPTEquipmentInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
20: {
21: 	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);
22: 	DOREPLIFETIME(ThisClass, Instigator);
23: }
24: 
25: void UWitchPTEquipmentInstance::SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn)
26: {
27: 	if (APawn* OwningPawn = GetPawn())
28: 	{
29: 		USceneComponent* AttachTarget = OwningPawn->GetRootComponent();
30: 		if (ACharacter* Char = Cast<ACharacter>(OwningPawn))
31: 		{
32: 			AttachTarget = Char->GetMesh();
33: 		}
34: 
35: 		for (const FWitchPTEquipmentActorToSpawn& SpawnInfo : ActorsToSpawn)
36: 		{
37: 			AActor* NewActor = GetWorld()->SpawnActorDeferred<AActor>(SpawnInfo.ActorToSpawn, FTransform::Identity, OwningPawn);
38: 			NewActor->FinishSpawning(FTransform::Identity,  true);
39: 			NewActor->SetActorRelativeTransform(SpawnInfo.AttachTransform);
40: 			NewActor->AttachToComponent(AttachTarget, FAttachmentTransformRules::KeepRelativeTransform, SpawnInfo.AttachSocket);
41: 
42: 			SpawnedActors.Add(NewActor);
43: 		}
44: 	}
45: }
46: 
47: void UWitchPTEquipmentInstance::DestroyEquipmentActors()
48: {
49: 	for (AActor* Actor : SpawnedActors)
50: 	{
51: 		if (Actor)
52: 		{
53: 			Actor->Destroy();
54: 		}
55: 	}
56: }
57: 
58: void UWitchPTEquipmentInstance::OnEquipped()
59: {
60: 	UE_LOG(LogTemp, Warning, TEXT("✅ EQUIPPED: %s"), *GetClass()->GetName());
61: 	K2_OnEquipped();
62: }
63: 
64: void UWitchPTEquipmentInstance::OnUnequipped()
65: {
66: 	UE_LOG(LogTemp, Warning, TEXT("❌ UNEQUIPPED: %s"), *GetClass()->GetName());
67: 	K2_OnUnequipped();
68: }
69: 
70: APawn* UWitchPTEquipmentInstance::GetPawn() const
71: {
72: 	return Cast<APawn>(GetOuter());
73: }
74: 
75: void UWitchPTEquipmentInstance::OnRep_Instigator()
76: {
77: }

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp
================
  1: #include "Equipment/WitchPTEquipmentManagerComponent.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystemGlobals.h"
  5: #include "Engine/ActorChannel.h"
  6: #include "Equipment/WitchPTEquipmentDefinition.h"
  7: #include "Equipment/WitchPTEquipmentInstance.h"
  8: #include "Inventory/WitchPTInventoryItemDefinition.h"
  9: #include "Inventory/WitchPTInventoryItemInstance.h"
 10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
 11: #include "Net/UnrealNetwork.h"
 12: 
 13: 
 14: void FWitchPTEquipmentList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 15: {
 16: 	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
 17: 	if (!IsValid(EquipmentManager)) return;
 18: 
 19: 	for (int32 Index : RemovedIndices)
 20: 	{
 21: 		const FWitchPTEquipmentEntry& Entry = Entries[Index];
 22: 		if (Entry.Instance != nullptr)
 23: 		{
 24: 			Entry.Instance->OnUnequipped();
 25: 			EquipmentManager->OnItemUnequipped.Broadcast(Entry.Instance);
 26: 		}
 27: 	}
 28: }
 29: 
 30: void FWitchPTEquipmentList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 31: {
 32: 	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
 33: 	if (!IsValid(EquipmentManager)) return;
 34: 
 35: 	for (int32 Index : AddedIndices)
 36: 	{
 37: 		const FWitchPTEquipmentEntry& Entry = Entries[Index];
 38: 		if (Entry.Instance != nullptr)
 39: 		{
 40: 			Entry.Instance->OnEquipped();
 41: 			EquipmentManager->OnItemEquipped.Broadcast(Entry.Instance);
 42: 		}
 43: 	}
 44: }
 45: 
 46: void FWitchPTEquipmentList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 47: {
 48: }
 49: 
 50: UWitchPTEquipmentInstance* FWitchPTEquipmentList::AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
 51: {
 52: 	UWitchPTEquipmentInstance* Result = nullptr;
 53: 
 54: 	check(EquipmentDefinition != nullptr);
 55: 	check(OwnerComponent);
 56: 	check(OwnerComponent->GetOwner()->HasAuthority());
 57: 
 58: 	const UWitchPTEquipmentDefinition* EquipmentCDO = GetDefault<UWitchPTEquipmentDefinition>(EquipmentDefinition);
 59: 
 60: 	TSubclassOf<UWitchPTEquipmentInstance> InstanceType = EquipmentCDO->InstanceType;
 61: 	if (InstanceType == nullptr)
 62: 	{
 63: 		InstanceType = UWitchPTEquipmentInstance::StaticClass();
 64: 	}
 65: 
 66: 	FWitchPTEquipmentEntry& NewEntry = Entries.AddDefaulted_GetRef();
 67: 	NewEntry.EquipmentDefinition = EquipmentDefinition;
 68: 	NewEntry.Instance = NewObject<UWitchPTEquipmentInstance>(OwnerComponent->GetOwner(), InstanceType);
 69: 	Result = NewEntry.Instance;
 70: 
 71: 
 72: 	if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
 73: 	{
 74: 		for (TSubclassOf<UGameplayAbility> AbilityClass : EquipmentCDO->AbilitiesToGrant)
 75: 		{
 76: 			if (AbilityClass)
 77: 			{
 78: 				FGameplayAbilitySpec AbilitySpec(AbilityClass, 1, INDEX_NONE, Result);
 79: 				FGameplayAbilitySpecHandle Handle = ASC->GiveAbility(AbilitySpec);
 80: 				NewEntry.AbilityHandles.GrantedHandles.Add(Handle);
 81: 				UE_LOG(LogTemp, Warning, TEXT("🎯 Granted ability: %s"), *AbilityClass->GetName());
 82: 			}
 83: 		}
 84: 	}
 85: 	Result->SpawnEquipmentActors(EquipmentCDO->ActorsToSpawn);
 86: 
 87: 	MarkItemDirty(NewEntry);
 88: 	return Result;
 89: }
 90: 
 91: void FWitchPTEquipmentList::RemoveEntry(UWitchPTEquipmentInstance* Instance)
 92: {
 93: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
 94: 	{
 95: 		FWitchPTEquipmentEntry& Entry = *EntryIt;
 96: 		if (Entry.Instance == Instance)
 97: 		{
 98: 
 99: 			if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
100: 			{
101: 				for (const FGameplayAbilitySpecHandle& Handle : Entry.AbilityHandles.GrantedHandles)
102: 				{
103: 					if (Handle.IsValid())
104: 					{
105: 						ASC->ClearAbility(Handle);
106: 						UE_LOG(LogTemp, Warning, TEXT("🚫 Removed ability"));
107: 					}
108: 				}
109: 			}
110: 
111: 			EntryIt.RemoveCurrent();
112: 			Instance->DestroyEquipmentActors();
113: 			MarkArrayDirty();
114: 		}
115: 	}
116: }
117: 
118: UAbilitySystemComponent* FWitchPTEquipmentList::GetAbilitySystemComponent() const
119: {
120: 	check(OwnerComponent);
121: 	AActor* OwningActor = OwnerComponent->GetOwner();
122: 	return Cast<UAbilitySystemComponent>(UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor));
123: }
124: 
125: 
126: 
127: UWitchPTEquipmentManagerComponent::UWitchPTEquipmentManagerComponent(const FObjectInitializer& ObjectInitializer)
128: 	: Super(ObjectInitializer)
129: 	, EquipmentList(this)
130: {
131: 	SetIsReplicatedByDefault(true);
132: 	bReplicateUsingRegisteredSubObjectList = true;
133: }
134: 
135: void UWitchPTEquipmentManagerComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
136: {
137: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
138: 	DOREPLIFETIME(ThisClass, EquipmentList);
139: }
140: 
141: bool UWitchPTEquipmentManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
142: 	FReplicationFlags* RepFlags)
143: {
144: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
145: 
146: 	for (FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
147: 	{
148: 		UWitchPTEquipmentInstance* Instance = Entry.Instance;
149: 		if (IsValid(Instance))
150: 		{
151: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
152: 		}
153: 	}
154: 
155: 	return WroteSomething;
156: }
157: 
158: void UWitchPTEquipmentManagerComponent::InitializeComponent()
159: {
160: 	Super::InitializeComponent();
161: }
162: 
163: void UWitchPTEquipmentManagerComponent::UninitializeComponent()
164: {
165: 	TArray<UWitchPTEquipmentInstance*> AllEquipmentInstances;
166: 
167: 
168: 	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
169: 	{
170: 		AllEquipmentInstances.Add(Entry.Instance);
171: 	}
172: 
173: 	for (UWitchPTEquipmentInstance* EquipInstance : AllEquipmentInstances)
174: 	{
175: 		UnequipItem(EquipInstance);
176: 	}
177: 
178: 	Super::UninitializeComponent();
179: }
180: 
181: void UWitchPTEquipmentManagerComponent::ReadyForReplication()
182: {
183: 	Super::ReadyForReplication();
184: 
185: 	if (IsUsingRegisteredSubObjectList())
186: 	{
187: 		for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
188: 		{
189: 			UWitchPTEquipmentInstance* Instance = Entry.Instance;
190: 			if (IsValid(Instance))
191: 			{
192: 				AddReplicatedSubObject(Instance);
193: 			}
194: 		}
195: 	}
196: }
197: 
198: void UWitchPTEquipmentManagerComponent::EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
199: {
200: 	if (GetOwner()->GetLocalRole() < ROLE_Authority)
201: 	{
202: 		Server_EquipItem(EquipmentDefinition);
203: 	}
204: 	else
205: 	{
206: 		if (EquipmentDefinition != nullptr)
207: 		{
208: 			UWitchPTEquipmentInstance* NewInstance = EquipmentList.AddEntry(EquipmentDefinition);
209: 			if (NewInstance != nullptr)
210: 			{
211: 				NewInstance->OnEquipped();
212: 				OnItemEquipped.Broadcast(NewInstance);
213: 
214: 				if (IsUsingRegisteredSubObjectList())
215: 				{
216: 					AddReplicatedSubObject(NewInstance);
217: 				}
218: 			}
219: 		}
220: 	}
221: }
222: 
223: void UWitchPTEquipmentManagerComponent::Server_EquipItem_Implementation(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
224: {
225: 	EquipItem(EquipmentDefinition);
226: }
227: 
228: void UWitchPTEquipmentManagerComponent::UnequipItem(UWitchPTEquipmentInstance* ItemInstance)
229: {
230: 	if (GetOwner()->GetLocalRole() < ROLE_Authority)
231: 	{
232: 		Server_UnequipItem(ItemInstance);
233: 	}
234: 	else
235: 	{
236: 		if (ItemInstance != nullptr)
237: 		{
238: 			if (IsUsingRegisteredSubObjectList())
239: 			{
240: 				RemoveReplicatedSubObject(ItemInstance);
241: 			}
242: 
243: 			ItemInstance->OnUnequipped();
244: 			OnItemUnequipped.Broadcast(ItemInstance);
245: 			EquipmentList.RemoveEntry(ItemInstance);
246: 		}
247: 	}
248: }
249: 
250: void UWitchPTEquipmentManagerComponent::Server_UnequipItem_Implementation(UWitchPTEquipmentInstance* ItemInstance)
251: {
252: 	UnequipItem(ItemInstance);
253: }
254: 
255: 
256: bool UWitchPTEquipmentManagerComponent::IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const
257: {
258: 	return FindEquipmentByInventoryItem(InventoryItem) != nullptr;
259: }
260: 
261: UWitchPTEquipmentInstance* UWitchPTEquipmentManagerComponent::FindEquipmentByInventoryItem(
262: 	UWitchPTInventoryItemInstance* InventoryItem) const
263: {
264: 	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
265: 	{
266: 		if (UWitchPTEquipmentInstance* Equipment = Entry.Instance)
267: 		{
268: 			if (Equipment && Equipment->GetInstigator() == InventoryItem)
269: 			{
270: 				return Equipment;
271: 			}
272: 		}
273: 	}
274: 	return nullptr;
275: }
276: 
277: void UWitchPTEquipmentManagerComponent::PrintEquippedItems()
278: {
279: 	UE_LOG(LogTemp, Warning, TEXT("📦 EQUIPPED ITEMS: %d total"), EquipmentList.Entries.Num());
280: 	for (int32 i = 0; i < EquipmentList.Entries.Num(); i++)
281: 	{
282: 		const FWitchPTEquipmentEntry& Entry = EquipmentList.Entries[i];
283: 		UE_LOG(LogTemp, Warning, TEXT("  [%d]: %s"), i, Entry.Instance ? *Entry.Instance->GetClass()->GetName() : TEXT("NULL"));
284: 	}
285: }
286: 
287: UAbilitySystemComponent* UWitchPTEquipmentManagerComponent::GetAbilitySystemComponent() const
288: {
289: 	if (APawn* OwnerPawn = Cast<APawn>(GetOwner()))
290: 	{
291: 		return UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwnerPawn);
292: 	}
293: 	return nullptr;
294: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
================
 1: #include "Inventory/WitchPTInventoryFunctionLibrary.h"
 2: 
 3: #include "Inventory/WitchPTInventoryItemDefinition.h"
 4: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5: 
 6: const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
 7: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
 8: {
 9: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
10: 	{
11: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
12: 	}
13: 	return nullptr;
14: }

================
File: Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
================
 1: #include "Item/Ingredient/IngredientBase.h"
 2: 
 3: 
 4: 
 5: AIngredientBase::AIngredientBase()
 6: {
 7: 
 8: }
 9: 
10: void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
11: 	FInteractionOptionBuilder& OptionBuilder)
12: {
13: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
14: }
15: 
16: FItemManifest AIngredientBase::GetPickupInventory() const
17: {
18: 	return StaticInventory;
19: }

================
File: Source/WitchPT/Private/Item/Potion/PotionBase.cpp
================
 1: #include "Item/Potion/PotionBase.h"
 2: 
 3: 
 4: 
 5: APotionBase::APotionBase()
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: 
10: 	InteractionAbilityClass = TSoftClassPtr<UGameplayAbility>(FSoftObjectPath(TEXT("/Game/Blueprints/AbilitySystem/GameplayAbilities/Interact/GA_Interact_Collect.GA_Interact_Collect_C")));
11: }
12: 
13: void APotionBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
14: 	FInteractionOptionBuilder& OptionBuilder)
15: {
16: 
17: 	if (!LoadedInteractionAbility && !InteractionAbilityClass.IsNull())
18: 	{
19: 		LoadedInteractionAbility = InteractionAbilityClass.LoadSynchronous();
20: 	}
21: 
22: 
23: 	if (LoadedInteractionAbility)
24: 	{
25: 		Option.InteractionAbilityToGrant = LoadedInteractionAbility;
26: 		Option.Text = FText::FromString(TEXT("Pick up Potion"));
27: 
28: 	}
29: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
30: }
31: 
32: FItemManifest APotionBase::GetPickupInventory() const
33: {
34: 	return StaticInventory;
35: }

================
File: Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
================
 1: #include "Player/WitchPTPlayerState.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Item/RitualPosition.h"
 7: 
 8: AWitchPTPlayerState::AWitchPTPlayerState()
 9: {
10: 	SetNetUpdateFrequency(100.f);
11: 
12: 	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
13: 	AbilitySystemComponent->SetIsReplicated(true);
14: 	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
15: 
16: 	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");
17: 
18: 
19: }
20: 
21: UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
22: {
23: 	return AbilitySystemComponent;
24: }

================
File: Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
================
1: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
2: 
3: FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
4: {
5: 
6: 	return FReply::Handled();
7: }

================
File: Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
================
 1: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 2: #include "Item/RitualAltar.h"
 3: #include "Components/Widget.h"
 4: 
 5: URitualUserWidget::URitualUserWidget(const FObjectInitializer& ObjectInitializer)
 6:     : Super(ObjectInitializer)
 7:     , bIsActiveForRitual(false)
 8:     , CurrentRitualAltar(nullptr)
 9: {
10: 
11: }
12: 
13: void URitualUserWidget::NativeOnInitialized()
14: {
15:     Super::NativeOnInitialized();
16: 
17: 
18:     ResetWidgetState();
19: }
20: 
21: void URitualUserWidget::NativeDestruct()
22: {
23: 
24:     HideFromRitual();
25: 
26:     Super::NativeDestruct();
27: }
28: 
29: void URitualUserWidget::ShowForRitual(ARitualAltar* Altar)
30: {
31:     if (!Altar)
32:     {
33:         UE_LOG(LogTemp, Warning, TEXT("[RitualUserWidget] ShowForRitual called with null altar"));
34:         return;
35:     }
36: 
37: 
38:     if (bIsActiveForRitual && CurrentRitualAltar != Altar)
39:     {
40:         ResetWidgetState();
41:     }
42: 
43: 
44:     CurrentRitualAltar = Altar;
45:     bIsActiveForRitual = true;
46: 
47: 
48:     OnShownForRitual(Altar);
49: 
50:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Shown for ritual altar"));
51: }
52: 
53: void URitualUserWidget::HideFromRitual()
54: {
55:     if (!bIsActiveForRitual)
56:     {
57:         return;
58:     }
59: 
60: 
61:     bIsActiveForRitual = false;
62:     ARitualAltar* PreviousAltar = CurrentRitualAltar;
63:     CurrentRitualAltar = nullptr;
64: 
65: 
66:     OnHiddenFromRitual();
67: 
68: 
69:     ResetWidgetState();
70: 
71:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Hidden from ritual"));
72: }
73: 
74: void URitualUserWidget::ResetWidgetState()
75: {
76: 
77: 
78: 
79: 
80: 
81: 
82:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Widget state reset"));
83: }

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.h"
 6: #include "IInteractableTarget.generated.h"
 7: 
 8: struct FInteractionQuery;
 9: 
10: 
11: class FInteractionOptionBuilder
12: {
13: public:
14: 	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
15: 		: Scope(InterfaceTargetScope)
16: 		, Options(InteractOptions)
17: 	{
18: 	}
19: 
20: 	void AddInteractionOption(const FInteractionOption& Option)
21: 	{
22: 		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
23: 		OptionEntry.InteractableTarget = Scope;
24: 	}
25: 
26: private:
27: 	TScriptInterface<IInteractableTarget> Scope;
28: 	TArray<FInteractionOption>& Options;
29: };
30: 
31: 
32: UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
33: class UInteractableTarget : public UInterface
34: {
35: 	GENERATED_BODY()
36: };
37: 
38: 
39: class IInteractableTarget
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;
46: 
47: 
48: 	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
49: 
50: 
51: 
52: 
53: 
54: 	virtual bool SupportsHoldInteraction() const { return false; }
55: 
56: 
57: 
58: 
59: 
60: 	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
61: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "WitchPTAbilitySystemComponent.generated.h"
 6: 
 7: DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& )
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
15: 
16: 	void AbilityInputTagPressed(const FGameplayTag& InputTag);
17: 	void AbilityInputTagHeld(const FGameplayTag& InputTag);
18: 	void AbilityInputTagReleased(const FGameplayTag& InputTag);
19: 	void AbilityActorInfoHaveBeenSet();
20: 
21: 	FEffectAssetTags OnEffectAssetTags;
22: 
23: 	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
24: 
25: 	bool bCharacterAbilitiesGiven = false;
26: 	bool bStartupEffectsApplied = false;
27: 
28: 	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;
29: 
30: 
31: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
32: 	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;
33: 
34: 
35: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
36: 	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;
37: 
38: 
39: 
40: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
41: 	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
42: 
43: protected:
44: 	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
45: 	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
46: 	UFUNCTION(Client, Reliable)
47: 	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
48: 
49: };

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "WitchPTEquipmentDefinition.generated.h"
 6: 
 7: class UWitchPTEquipmentInstance;
 8: class UGameplayAbility;
 9: 
10: USTRUCT()
11: struct FWitchPTEquipmentActorToSpawn
12: {
13: 	GENERATED_BODY()
14: 	FWitchPTEquipmentActorToSpawn() {};
15: 
16: 	UPROPERTY(EditAnywhere, Category=Equipment)
17: 	TSubclassOf<AActor> ActorToSpawn;
18: 
19: 	UPROPERTY(EditAnywhere, Category=Equipment)
20: 	FName AttachSocket;
21: 
22: 	UPROPERTY(EditAnywhere, Category=Equipment)
23: 	FTransform AttachTransform;
24: };
25: 
26: 
27: 
28: 
29: 
30: 
31: UCLASS(Blueprintable, BlueprintType)
32: class WITCHPT_API UWitchPTEquipmentDefinition : public UObject
33: {
34: 	GENERATED_BODY()
35: public:
36: 	UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
37: 
38: 
39: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
40: 	TSubclassOf<UWitchPTEquipmentInstance> InstanceType;
41: 
42: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
43: 	TArray<TSubclassOf<UGameplayAbility>> AbilitiesToGrant;
44: 
45: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
46: 	TArray<FWitchPTEquipmentActorToSpawn> ActorsToSpawn;
47: };

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentInstance.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "Net/UnrealNetwork.h"
 6: #include "WitchPTEquipmentInstance.generated.h"
 7: 
 8: struct FWitchPTEquipmentActorToSpawn;
 9: 
10: 
11: 
12: UCLASS(BlueprintType, Blueprintable)
13: class WITCHPT_API UWitchPTEquipmentInstance : public UObject
14: {
15: 	GENERATED_BODY()
16: public:
17: 	UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
18: 
19: 
20: 
21: 
22: 	virtual bool IsSupportedForNetworking() const override { return true; }
23: 	virtual UWorld* GetWorld() const override final;
24: 	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
25: 
26: 	virtual void SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn);
27: 	virtual void DestroyEquipmentActors();
28: 	virtual void OnEquipped();
29: 	virtual void OnUnequipped();
30: 
31: 	UFUNCTION(BlueprintPure, Category=Equipment)
32: 	APawn* GetPawn() const;
33: 	UFUNCTION(BlueprintPure, Category=Equipment)
34: 	UObject* GetInstigator() const { return Instigator; }
35: 
36: 	void SetInstigator(UObject* InInstigator) { Instigator = InInstigator; }
37: protected:
38: 	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
39: 	void K2_OnEquipped();
40: 
41: 	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
42: 	void K2_OnUnequipped();
43: 
44: private:
45: 	UPROPERTY(ReplicatedUsing=OnRep_Instigator)
46: 	TObjectPtr<UObject> Instigator;
47: 
48: 	UPROPERTY(Replicated)
49: 	TArray<TObjectPtr<AActor>> SpawnedActors;
50: 
51: 
52: 	UFUNCTION()
53: 	void OnRep_Instigator();
54: 
55: };

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayAbilitySpecHandle.h"
  5: #include "Components/ActorComponent.h"
  6: #include "Net/Serialization/FastArraySerializer.h"
  7: #include "WitchPTEquipmentManagerComponent.generated.h"
  8: 
  9: 
 10: class UWitchPTEquipmentManagerComponent;
 11: class UWitchPTInventoryItemInstance;
 12: class UAbilitySystemComponent;
 13: class UWitchPTEquipmentDefinition;
 14: class UWitchPTEquipmentInstance;
 15: 
 16: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemEquipped, UWitchPTEquipmentInstance*);
 17: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemUnequipped, UWitchPTEquipmentInstance*);
 18: 
 19: USTRUCT()
 20: struct FEquipmentAbilityHandles
 21: {
 22: 	GENERATED_BODY()
 23: 	TArray<FGameplayAbilitySpecHandle> GrantedHandles;
 24: };
 25: 
 26: USTRUCT(BlueprintType)
 27: struct FWitchPTEquipmentEntry: public FFastArraySerializerItem
 28: {
 29: 	GENERATED_BODY()
 30: 	FWitchPTEquipmentEntry() {};
 31: 
 32: 	UPROPERTY()
 33: 	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;
 34: 
 35: 	UPROPERTY()
 36: 	TObjectPtr<UWitchPTEquipmentInstance> Instance = nullptr;
 37: 
 38: 	FEquipmentAbilityHandles AbilityHandles;
 39: };
 40: 
 41: USTRUCT(BlueprintType)
 42: struct FWitchPTEquipmentList : public FFastArraySerializer
 43: {
 44: 	GENERATED_BODY()
 45: 
 46: 	FWitchPTEquipmentList() : OwnerComponent(nullptr) {}
 47: 	FWitchPTEquipmentList(UActorComponent* InOwnerComponent) : OwnerComponent(InOwnerComponent) {}
 48: 
 49: 
 50: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 51: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 52: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 53: 
 54: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
 55: 	{
 56: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTEquipmentEntry, FWitchPTEquipmentList>(Entries, DeltaParms, *this);
 57: 	}
 58: 
 59: 
 60: 
 61: 	UWitchPTEquipmentInstance* AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
 62: 	void RemoveEntry(UWitchPTEquipmentInstance* Instance);
 63: 
 64: private:
 65: 	UAbilitySystemComponent* GetAbilitySystemComponent() const;
 66: 
 67: 	UPROPERTY()
 68: 	TArray<FWitchPTEquipmentEntry> Entries;
 69: 
 70: 	UPROPERTY(NotReplicated)
 71: 	TObjectPtr<UActorComponent> OwnerComponent;
 72: 
 73: 	friend UWitchPTEquipmentManagerComponent;
 74: };
 75: 
 76: 
 77: template<>
 78: struct TStructOpsTypeTraits<FWitchPTEquipmentList> : public TStructOpsTypeTraitsBase2<FWitchPTEquipmentList>
 79: {
 80: 	enum { WithNetDeltaSerializer = true };
 81: };
 82: 
 83: 
 84: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 85: class WITCHPT_API UWitchPTEquipmentManagerComponent : public UActorComponent
 86: {
 87: 	GENERATED_BODY()
 88: 
 89: public:
 90: 
 91: 	UWitchPTEquipmentManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 92: 
 93: 	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
 94: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 95: 
 96: 
 97: 	virtual void InitializeComponent() override;
 98: 	virtual void UninitializeComponent() override;
 99: 	virtual void ReadyForReplication() override;
100: 
101: 
102: 	UFUNCTION(BlueprintCallable, Category="Equipment")
103: 	void EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
104: 
105: 	UFUNCTION(BlueprintCallable, Category="Equipment")
106: 	void UnequipItem(UWitchPTEquipmentInstance* ItemInstance);
107: 
108: 	UFUNCTION(Server, Reliable)
109: 	void Server_EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
110: 
111: 	UFUNCTION(Server, Reliable)
112: 	void Server_UnequipItem(UWitchPTEquipmentInstance* ItemInstance);
113: 
114: 
115: 	UFUNCTION(BlueprintPure, Category="Equipment")
116: 	bool IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const;
117: 
118: 	UFUNCTION(BlueprintPure, Category="Equipment")
119: 	UWitchPTEquipmentInstance* FindEquipmentByInventoryItem(UWitchPTInventoryItemInstance* InventoryItem) const;
120: 
121: 
122: 	UFUNCTION(BlueprintCallable, Category="Equipment")
123: 	void PrintEquippedItems();
124: 
125: 	FOnItemEquipped OnItemEquipped;
126: 	FOnItemUnequipped OnItemUnequipped;
127: 
128: protected:
129: 	UPROPERTY(Replicated)
130: 	FWitchPTEquipmentList EquipmentList;
131: 
132: 
133: 	UPROPERTY()
134: 	TMap<TObjectPtr<UWitchPTEquipmentInstance>, FEquipmentAbilityHandles> EquipmentAbilities;
135: 
136: private:
137: 	UAbilitySystemComponent* GetAbilitySystemComponent() const;
138: 
139: 
140: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryItemFragment_PotionProperties.generated.h"
 7: 
 8: class UGameplayAbility;
 9: 
10: 
11: 
12: 
13: UCLASS()
14: class WITCHPT_API UWitchPTInventoryItemFragment_PotionProperties : public UWitchPTInventoryItemFragment
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
21: 	UGameplayAbility* CollectAbility;
22: 
23: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
24: 	FGameplayTag PotionEssenceTag;
25: 
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
27: 	FGameplayTag BaseLiquidTypeTag;
28: 
29: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
30: 	float FinalPotency = 0.0f;
31: 
32: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
33: 	float FinalDuration = 0.0f;
34: 
35: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
36: 	int32 FinalCharges = 1;
37: 
38: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
39: 	FGameplayTag PotionTierTag;
40: 
41: 
42: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
43: 	FGameplayTagContainer GrantedEffectTags;
44: 
45: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
46: 	FGameplayTagContainer GrantedPropertyTags;
47: 
48: 
49: 	UFUNCTION(BlueprintPure, Category = "Potion Properties")
50: 	bool IsValidPotion() const;
51: 
52: 	UFUNCTION(BlueprintPure, Category = "Potion Properties")
53: 	FString GetPotionDescription() const;
54: 
55: 
56: 	UFUNCTION(BlueprintCallable, Category = "Potion Properties")
57: 	void SetPotionProperties(const FGameplayTag& InPotionEssence,
58: 							const FGameplayTag& InBaseLiquidType,
59: 							float InPotency,
60: 							float InDuration,
61: 							int32 InCharges,
62: 							const FGameplayTag& InTierTag,
63: 							const FGameplayTagContainer& InEffectTags,
64: 							const FGameplayTagContainer& InPropertyTags);
65: 
66: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
67: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/NoExportTypes.h"
 5: #include "Kismet/BlueprintFunctionLibrary.h"
 6: #include "WitchPTInventoryItemDefinition.generated.h"
 7: 
 8: class UWitchPTInventoryItemFragment;
 9: struct FFrame;
10: 
11: 
12: 
13: UCLASS(Blueprintable, Const, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
19: 
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
21: 	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;
22: 
23: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
24: };

================
File: Source/WitchPT/Public/Item/CauldronPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "CauldronPosition.generated.h"
 7: 
 8: 
 9: class ACauldronAltar;
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: 
17: 
18: 
19: 
20: UCLASS()
21: class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
22: {
23:     GENERATED_BODY()
24: 
25: public:
26: 
27:     ACauldronPosition();
28: 
29: 
30:     virtual void BeginPlay() override;
31: 
32: 
33: 
34:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38:     UFUNCTION(BlueprintPure, Category = "Cauldron")
39:     ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
40: 
41: 
42: 
43:     UFUNCTION(BlueprintCallable)
44:     void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: protected:
78: 
79:     UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
80:     TObjectPtr<ACauldronAltar> CauldronAltar;
81: 
82: 
83:     virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
84: 
85: private:
86: 
87:     void FindCauldronAltar();
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: };

================
File: Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Collectable.h"
 5: #include "Item/Item.h"
 6: #include "IngredientBase.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AIngredientBase : public AItem, public ICollectable
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AIngredientBase();
16: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
17: 	virtual FItemManifest GetPickupInventory() const override;
18: 
19: protected:
20: 
21: 	UPROPERTY(EditAnywhere)
22: 	FItemManifest StaticInventory;
23: 
24: };

================
File: Source/WitchPT/Public/Item/Potion/PotionBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Collectable.h"
 5: #include "Item/Item.h"
 6: #include "PotionBase.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API APotionBase : public AItem, public ICollectable
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	APotionBase();
16: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
17: 	virtual FItemManifest GetPickupInventory() const override;
18: 
19: 	UPROPERTY(EditAnywhere)
20: 	FItemManifest StaticInventory;
21: protected:
22: 
23: 
24: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Interaction")
25: 	TSoftClassPtr<UGameplayAbility> InteractionAbilityClass;
26: 
27: 
28: 	UPROPERTY(Transient)
29: 	TSubclassOf<UGameplayAbility> LoadedInteractionAbility;
30: 
31: };

================
File: Source/WitchPT/Public/Player/WitchPTPlayerState.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/PlayerState.h"
 6: #include "WitchPTPlayerState.generated.h"
 7: class ARitualPosition;
 8: class ARitualAltar;
 9: class UAbilitySystemComponent;
10: class UAttributeSet;
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 	AWitchPTPlayerState();
19: public:
20: 
21: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
22: 	UAttributeSet* GetAttributeSet() const { return AttributeSet; }
23: 
24: protected:
25: 	UPROPERTY(VisibleAnywhere)
26: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
27: 	UPROPERTY(VisibleAnywhere)
28: 	TObjectPtr<UAttributeSet> AttributeSet;
29: 
30: 
31: };

================
File: Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTUserWidget.h"
 5: #include "CauldronUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: private:
15: 	virtual void NativeConstruct() override;
16: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
17: };

================
File: Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "InventoryUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
15: 
16: };

================
File: Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "RitualUserWidget.generated.h"
 6: 
 7: class ARitualAltar;
 8: 
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
14: {
15: 	GENERATED_BODY()
16: 
17: public:
18: 	URitualUserWidget(const FObjectInitializer& ObjectInitializer);
19: 
20: 
21: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
22: 	void ShowForRitual(ARitualAltar* Altar);
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
25: 	void HideFromRitual();
26: 
27: 
28: 	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
29: 	bool IsActiveForRitual() const { return bIsActiveForRitual; }
30: 
31: 
32: 	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
33: 	ARitualAltar* GetCurrentRitualAltar() const { return CurrentRitualAltar; }
34: 
35: protected:
36: 
37: 	virtual void NativeOnInitialized() override;
38: 	virtual void NativeDestruct() override;
39: 
40: 
41: 	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
42: 	void OnShownForRitual(ARitualAltar* Altar);
43: 
44: 
45: 	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
46: 	void OnHiddenFromRitual();
47: 
48: 
49: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
50: 	void ResetWidgetState();
51: 
52: private:
53: 
54: 	UPROPERTY()
55: 	bool bIsActiveForRitual = false;
56: 
57: 
58: 	UPROPERTY()
59: 	TObjectPtr<ARitualAltar> CurrentRitualAltar;
60: };

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
================
  1: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "Engine/World.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  6: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
  7: struct FInteractionQuery;
  8: 
  9: UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
 10: 	: Super(ObjectInitializer)
 11: {
 12: }
 13: void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
 14: {
 15: 	check(World);
 16: 
 17: 	OutHitResult = FHitResult();
 18: 	FHitResult HitResult;
 19: 
 20: 	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
 21: 	OutHitResult.TraceStart = Start;
 22: 	OutHitResult.TraceEnd = End;
 23: 
 24: 	OutHitResult = HitResult;
 25: }
 26: 
 27: void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
 28: {
 29: 	if (!Ability)
 30: 	{
 31: 		return;
 32: 	}
 33: 
 34: 
 35: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 36: 	check(PC);
 37: 
 38: 	FVector ViewStart;
 39: 	FRotator ViewRot;
 40: 	PC->GetPlayerViewPoint(ViewStart, ViewRot);
 41: 
 42: 	const FVector ViewDir = ViewRot.Vector();
 43: 	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);
 44: 
 45: 	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);
 46: 
 47: 	FHitResult HitResult;
 48: 	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);
 49: 
 50: 	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));
 51: 
 52: 	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;
 53: 
 54: 	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
 55: 	if (AdjustedAimDir.IsZero())
 56: 	{
 57: 		AdjustedAimDir = ViewDir;
 58: 	}
 59: 
 60: 	if (!bTraceAffectsAimPitch && bUseTraceResult)
 61: 	{
 62: 		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();
 63: 
 64: 		if (!OriginalAimDir.IsZero())
 65: 		{
 66: 
 67: 			const FRotator OriginalAimRot = OriginalAimDir.Rotation();
 68: 
 69: 			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
 70: 			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;
 71: 
 72: 			AdjustedAimDir = AdjustedAimRot.Vector();
 73: 		}
 74: 	}
 75: 
 76: 	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
 77: }
 78: 
 79: bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
 80: {
 81: 	FVector CameraToCenter = AbilityCenter - CameraLocation;
 82: 	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
 83: 	if (DotToCenter >= 0)
 84: 	{
 85: 		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
 86: 		float RadiusSquared = (AbilityRange * AbilityRange);
 87: 		if (DistanceSquared <= RadiusSquared)
 88: 		{
 89: 			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
 90: 			float DistanceAlongRay = DotToCenter + DistanceFromCamera;
 91: 			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);
 92: 			return true;
 93: 		}
 94: 	}
 95: 	return false;
 96: }
 97: 
 98: void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
 99: {
100: 	TArray<FInteractionOption> NewOptions;
101: 
102: 	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
103: 	{
104: 		TArray<FInteractionOption> TempOptions;
105: 		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
106: 		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);
107: 
108: 		for (FInteractionOption& Option : TempOptions)
109: 		{
110: 			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;
111: 
112: 
113: 			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
114: 			{
115: 
116: 				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
117: 			}
118: 
119: 			else if (Option.InteractionAbilityToGrant)
120: 			{
121: 
122: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);
123: 
124: 				if (InteractionAbilitySpec)
125: 				{
126: 
127: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
128: 					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
129: 				}
130: 			}
131: 			if (Option.HoldInteractionAbilityToGrant)
132: 			{
133: 
134: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);
135: 
136: 				if (InteractionAbilitySpec)
137: 				{
138: 
139: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
140: 					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
141: 				}
142: 			}
143: 			if (InteractionAbilitySpec)
144: 			{
145: 
146: 				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
147: 				{
148: 					NewOptions.Add(Option);
149: 				}
150: 			}
151: 		}
152: 	}
153: 
154: 	bool bOptionsChanged = false;
155: 	if (NewOptions.Num() == CurrentOptions.Num())
156: 	{
157: 		NewOptions.Sort();
158: 
159: 		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
160: 		{
161: 			const FInteractionOption& NewOption = NewOptions[OptionIndex];
162: 			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];
163: 
164: 			if (NewOption != CurrentOption)
165: 			{
166: 				bOptionsChanged = true;
167: 				break;
168: 			}
169: 		}
170: 	}
171: 	else
172: 	{
173: 		bOptionsChanged = true;
174: 	}
175: 
176: 	if (bOptionsChanged)
177: 	{
178: 		CurrentOptions = NewOptions;
179: 		InteractableObjectsChanged.Broadcast(CurrentOptions);
180: 	}
181: }

================
File: Source/WitchPT/Private/Inventory/Collectable.cpp
================
 1: #include "Inventory/Collectable.h"
 2: 
 3: #include "Inventory/WitchPTInventoryManagerComponent.h"
 4: 
 5: UCollectableStatics::UCollectableStatics()
 6: : Super(FObjectInitializer::Get())
 7: {
 8: }
 9: 
10: TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
11: {
12: 	TScriptInterface<ICollectable> PickupableActor(Actor);
13: 	if (PickupableActor)
14: 	{
15: 		return PickupableActor;
16: 	}
17: 
18: 	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
19: 	if (PickupableComponents.Num() > 0)
20: 	{
21: 		return TScriptInterface<ICollectable>(PickupableComponents[0]);
22: 	}
23: 
24: 	return TScriptInterface<ICollectable>();
25: }
26: 
27: 
28: void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
29: 	TScriptInterface<ICollectable> Collectable)
30: {
31: 	if (InventoryComponent && Collectable)
32: 	{
33: 		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
34: 		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
35: 	}
36: }

================
File: Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
================
  1: #pragma once
  2: 
  3: #include "Inventory/FastArray/FastArrayList.h"
  4: 
  5: #include "CoreMinimal.h"
  6: #include "Inventory/WitchPTInventoryItemDefinition.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  8: #include "Inventory/WitchPTInventoryItemInstance.h"
  9: #include "Inventory/WitchPTInventoryManagerComponent.h"
 10: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 11: 
 12: 
 13: class FLifetimeProperty;
 14: struct FReplicationFlags;
 15: 
 16: 
 17: FString FWitchPTInventoryEntry::GetDebugString() const
 18: {
 19: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 20: 	if (Instance != nullptr)
 21: 	{
 22: 		ItemDef = Instance->GetItemDef();
 23: 	}
 24: 
 25: 	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 33: {
 34: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 35: 	if (!IsValid(IMC)) return;
 36: 	for (int32 Index : RemovedIndices)
 37: 	{
 38: 		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
 39: 	}
 40: }
 41: 
 42: void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 43: {
 44: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 45: 	if (!IsValid(IMC)) return;
 46: 	for (int32 Index : AddedIndices)
 47: 	{
 48: 		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
 49: 	}
 50: }
 51: 
 52: void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 53: {
 54: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 55: 	if (!IsValid(IMC)) return;
 56: 
 57: 	for (int32 Index : ChangedIndices)
 58: 	{
 59: 		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
 60: 	}
 61: }
 62: 
 63: UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 64: {
 65: 	UWitchPTInventoryItemInstance* Result = nullptr;
 66: 
 67: 	check(ItemDef != nullptr);
 68: 	check(OwnerComponent);
 69: 
 70: 	AActor* OwningActor = OwnerComponent->GetOwner();
 71: 	check(OwningActor->HasAuthority());
 72: 
 73: 
 74: 	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
 75: 	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
 76: 	NewEntry.Instance->SetItemDef(ItemDef);
 77: 
 78: 	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 79: 	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 80: 	if (IsValid(StackableFragment))
 81: 	{
 82: 		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
 83: 	}
 84: 	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
 85: 	{
 86: 		if (Fragment != nullptr)
 87: 		{
 88: 			Fragment->OnInstanceCreated(NewEntry.Instance);
 89: 		}
 90: 	}
 91: 
 92: 	Result = NewEntry.Instance;
 93: 
 94: 
 95: 	MarkItemDirty(NewEntry);
 96: 
 97: 	return Result;
 98: }
 99: 
100: void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
101: {
102: 	unimplemented();
103: }
104: 
105: void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
106: {
107: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
108: 	{
109: 		FWitchPTInventoryEntry& Entry = *EntryIt;
110: 		if (Entry.Instance == Instance)
111: 		{
112: 			EntryIt.RemoveCurrent();
113: 			MarkArrayDirty();
114: 		}
115: 	}
116: }
117: TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
118: {
119: 	TArray<UWitchPTInventoryItemInstance*> Results;
120: 	Results.Reserve(Entries.Num());
121: 	for (const FWitchPTInventoryEntry& Entry : Entries)
122: 	{
123: 		if (Entry.Instance != nullptr)
124: 		{
125: 			Results.Add(Entry.Instance);
126: 		}
127: 	}
128: 	return Results;
129: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
================
 1: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2: 
 3: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 4: 
 5: UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
 6: : Super(ObjectInitializer)
 7: 
 8: {
 9: }
10: 
11: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
12: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
13: {
14: 	if (FragmentClass != nullptr)
15: 	{
16: 		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
17: 		{
18: 			if (Fragment && Fragment->IsA(FragmentClass))
19: 			{
20: 				return Fragment;
21: 			}
22: 		}
23: 	}
24: 
25: 	return nullptr;
26: }

================
File: Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
================
 1: #include "UI/Widgets/CauldronUserWidget.h"
 2: 
 3: void UCauldronUserWidget::NativeConstruct()
 4: {
 5: 	Super::NativeConstruct();
 6: 
 7: 
 8: }
 9: 
10: FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
11: {
12: 	return FReply::Handled();
13: }

================
File: Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Net/Serialization/FastArraySerializer.h"
  5: 
  6: #include "FastArrayList.generated.h"
  7: 
  8: class UWitchPTInventoryItemDefinition;
  9: class UWitchPTInventoryItemInstance;
 10: class UWitchPTInventoryManagerComponent;
 11: struct FWitchPTInventoryList;
 12: 
 13: 
 14: 
 15: 
 16: 
 17: 
 18: 
 19: USTRUCT(BlueprintType)
 20: struct FWitchPTInventoryEntry : public FFastArraySerializerItem
 21: {
 22: 	GENERATED_BODY()
 23: 
 24: 	FWitchPTInventoryEntry()
 25: 	{}
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 	FString GetDebugString() const;
 32: 
 33: private:
 34: 	friend FWitchPTInventoryList;
 35: 	friend UWitchPTInventoryManagerComponent;
 36: 
 37: 
 38: 	UPROPERTY()
 39: 	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
 40: 
 41: };
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: USTRUCT(BlueprintType)
 51: struct FWitchPTInventoryList : public FFastArraySerializer
 52: {
 53: 	GENERATED_BODY()
 54: 
 55: 
 56: 	FWitchPTInventoryList()
 57: 		: OwnerComponent(nullptr)
 58: 	{
 59: 	}
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
 66: 		: OwnerComponent(InOwnerComponent)
 67: 	{
 68: 	}
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 75: 
 76: public:
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
102: 	{
103: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
104: 	}
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
114: 
115: 
116: 
117: 
118: 
119: 
120: 	void AddEntry(UWitchPTInventoryItemInstance* Instance);
121: 
122: 
123: 
124: 
125: 
126: 
127: 	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);
128: 
129: private:
130: 	friend UWitchPTInventoryManagerComponent;
131: 
132: private:
133: 
134: 	UPROPERTY()
135: 	TArray<FWitchPTInventoryEntry> Entries;
136: 
137: 
138: 	UPROPERTY(NotReplicated)
139: 	TObjectPtr<UActorComponent> OwnerComponent;
140: };
141: 
142: 
143: 
144: 
145: 
146: template<>
147: struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
148: {
149: 	enum { WithNetDeltaSerializer = true };
150: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Templates/SubclassOf.h"
 5: #include "WitchPTInventoryItemFragment.generated.h"
 6: 
 7: template <typename T> class TSubclassOf;
 8: 
 9: class UWitchPTInventoryItemInstance;
10: 
11: 
12: 
13: UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
20: 
21: };

================
File: Source/WitchPT/Public/Item/Components/CauldronCraftComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Components/ActorComponent.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameplayTagContainer.h"
  7: #include "CauldronCraftComponent.generated.h"
  8: 
  9: class UWitchPTInventoryItemDefinition;
 10: class UWitchPTInventoryItemInstance;
 11: class ACharacter;
 12: 
 13: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 14: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
 15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 16: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
 17: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 18: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
 19: 
 20: 
 21: USTRUCT(BlueprintType)
 22: struct FPotionResult
 23: {
 24: 	GENERATED_BODY()
 25: 
 26: 	UPROPERTY(BlueprintReadOnly)
 27: 	FGameplayTag PotionEssenceTag;
 28: 
 29: 	UPROPERTY(BlueprintReadOnly)
 30: 	FGameplayTag BaseLiquidTypeTag;
 31: 
 32: 	UPROPERTY(BlueprintReadOnly)
 33: 	float FinalPotency = 0.0f;
 34: 
 35: 	UPROPERTY(BlueprintReadOnly)
 36: 	float FinalDuration = 0.0f;
 37: 
 38: 	UPROPERTY(BlueprintReadOnly)
 39: 	int32 FinalCharges = 0;
 40: 
 41: 	UPROPERTY(BlueprintReadOnly)
 42: 	FGameplayTag PotionTierTag;
 43: 
 44: 	UPROPERTY(BlueprintReadOnly)
 45: 	FGameplayTagContainer GrantedEffectTags;
 46: 
 47: 	UPROPERTY(BlueprintReadOnly)
 48: 	FGameplayTagContainer GrantedPropertyTags;
 49: 
 50: 	UPROPERTY(BlueprintReadOnly)
 51: 	bool bIsValid = false;
 52: 
 53: 	UPROPERTY(BlueprintReadOnly)
 54: 	TSubclassOf<UWitchPTInventoryItemDefinition> ResultPotionItemDef;
 55: };
 56: 
 57: USTRUCT(BlueprintType)
 58: struct FPotionCraftingRecipe
 59: {
 60: 	GENERATED_BODY()
 61: 
 62: 	UPROPERTY(BlueprintReadOnly)
 63: 	bool bRequiresBaseIngredient = true;
 64: 
 65: 	UPROPERTY(BlueprintReadOnly)
 66: 	bool bRequiresPrincipalIngredient = true;
 67: 
 68: 	UPROPERTY(BlueprintReadOnly)
 69: 	bool bRequiresModifierIngredient = false;
 70: 
 71: 	UPROPERTY(BlueprintReadOnly)
 72: 	FGameplayTagContainer AllowedBaseLiquidTypes;
 73: 
 74: 	UPROPERTY(BlueprintReadOnly)
 75: 	FGameplayTagContainer AllowedPrincipalEssences;
 76: 
 77: 	UPROPERTY(BlueprintReadOnly)
 78: 	FGameplayTagContainer IncompatibleCombinations;
 79: };
 80: 
 81: 
 82: USTRUCT(BlueprintType)
 83: struct FExtractedBaseIngredientData
 84: {
 85: 	GENERATED_BODY()
 86: 
 87: 	UPROPERTY(BlueprintReadOnly)
 88: 	FGameplayTag BaseLiquidTypeTag;
 89: 
 90: 	UPROPERTY(BlueprintReadOnly)
 91: 	int32 DefaultChargesProvided = 0;
 92: 
 93: 	UPROPERTY(BlueprintReadOnly)
 94: 	float StabilityModifier = 1.0f;
 95: 
 96: 	UPROPERTY(BlueprintReadOnly)
 97: 	FGameplayTag TierTag;
 98: 
 99: 	UPROPERTY(BlueprintReadOnly)
100: 	bool bIsValid = false;
101: };
102: 
103: USTRUCT(BlueprintType)
104: struct FExtractedPrincipalIngredientData
105: {
106: 	GENERATED_BODY()
107: 
108: 	UPROPERTY(BlueprintReadOnly)
109: 	FGameplayTag PrincipalEssenceTag;
110: 
111: 	UPROPERTY(BlueprintReadOnly)
112: 	float BasePotency = 0.0f;
113: 
114: 	UPROPERTY(BlueprintReadOnly)
115: 	float BaseDuration = 0.0f;
116: 
117: 	UPROPERTY(BlueprintReadOnly)
118: 	bool bIsRitualEssence = false;
119: 
120: 	UPROPERTY(BlueprintReadOnly)
121: 	FGameplayTag TierTag;
122: 
123: 	UPROPERTY(BlueprintReadOnly)
124: 	bool bIsValid = false;
125: };
126: 
127: USTRUCT(BlueprintType)
128: struct FExtractedModifierIngredientData
129: {
130: 	GENERATED_BODY()
131: 
132: 	UPROPERTY(BlueprintReadOnly)
133: 	FGameplayTagContainer ModifierEffectTags;
134: 
135: 	UPROPERTY(BlueprintReadOnly)
136: 	float PotencyModificationValue = 1.0f;
137: 
138: 	UPROPERTY(BlueprintReadOnly)
139: 	float DurationModificationValue = 0.0f;
140: 
141: 	UPROPERTY(BlueprintReadOnly)
142: 	FGameplayTag GrantedPropertyTag;
143: 
144: 	UPROPERTY(BlueprintReadOnly)
145: 	FGameplayTag AddedEffectTag;
146: 
147: 	UPROPERTY(BlueprintReadOnly)
148: 	float StrengthOfModifier = 1.0f;
149: 
150: 	UPROPERTY(BlueprintReadOnly)
151: 	FGameplayTag TierTag;
152: 
153: 	UPROPERTY(BlueprintReadOnly)
154: 	bool bIsValid = false;
155: };
156: 
157: UCLASS(Blueprintable)
158: class WITCHPT_API UCauldronCraftComponent : public UActorComponent
159: {
160: 	GENERATED_BODY()
161: 
162: public:
163: 
164: 	UCauldronCraftComponent();
165: 
166: protected:
167: 
168: 	virtual void BeginPlay() override;
169: 
170: public:
171: 
172: 	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
173: 	                           FActorComponentTickFunction* ThisTickFunction) override;
174: 
175: 
176: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
177: 
178: 
179: 	UPROPERTY(VisibleAnywhere)
180: 	UWitchPTInventoryItemInstance* BaseIngredient;
181: 	UPROPERTY(VisibleAnywhere)
182: 	UWitchPTInventoryItemInstance* PrincipalIngredient;
183: 	UPROPERTY(VisibleAnywhere)
184: 	UWitchPTInventoryItemInstance* ModifierIngredient;
185: 
186: 	UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
187: 	TSubclassOf<UUserWidget> BaseIngredientIcon;
188: 
189: 	UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
190: 	TSubclassOf<UUserWidget> PrincipalIngredientIcon;
191: 
192: 	UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
193: 	TSubclassOf<UUserWidget> ModifierIngredientIcon;
194: 
195: 
196: 	UPROPERTY(ReplicatedUsing = OnRep_CraftedPotion, BlueprintReadOnly, Category = "Potion Crafting")
197: 	FPotionResult CraftedPotion;
198: 
199: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
200: 	FPotionCraftingRecipe DefaultCraftingRecipe;
201: 
202: 
203: 	FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
204: 	FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
205: 	FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
206: 	FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
207: 	FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
208: 	FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
209: 
210: 
211: 	void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
212: 
213: 
214: 	UFUNCTION()
215: 	void OnRep_BaseIngredientIcon();
216: 	UFUNCTION()
217: 	void OnRep_PrincipalIngredientIcon();
218: 	UFUNCTION()
219: 	void OnRep_PotentiatorIngredientIcon();
220: 	UFUNCTION()
221: 	void OnRep_CraftedPotion();
222: 
223: 
224: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
225: 	bool CanCraftPotion() const;
226: 
227: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
228: 	FPotionCraftingRecipe GetRequiredIngredients() const;
229: 
230: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
231: 	bool ValidateIngredientCombination() const;
232: 
233: 
234: 	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
235: 	void PrintIngredientDebugData() const;
236: 
237: 	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
238: 	void PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const;
239: 
240: 
241: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
242: 	FExtractedBaseIngredientData ExtractBaseIngredientProperties() const;
243: 
244: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
245: 	FExtractedPrincipalIngredientData ExtractPrincipalIngredientProperties() const;
246: 
247: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
248: 	FExtractedModifierIngredientData ExtractModifierIngredientProperties() const;
249: 
250: 
251: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Calculation")
252: 	FPotionResult CalculatePotionProperties() const;
253: 
254: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Calculation")
255: 	FGameplayTag CalculatePotionTier(const FExtractedBaseIngredientData& BaseData,
256: 									 const FExtractedPrincipalIngredientData& PrincipalData,
257: 									 const FExtractedModifierIngredientData& ModifierData) const;
258: 
259: 
260: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
261: 	TSubclassOf<UWitchPTInventoryItemDefinition> GeneratePotionItemDefinition(const FPotionResult& PotionData) const;
262: 
263: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
264: 	UWitchPTInventoryItemDefinition* CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const;
265: 
266: 
267: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
268: 	bool SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const;
269: 
270: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
271: 	UWitchPTInventoryItemInstance* AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const;
272: 
273: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
274: 	UWitchPTInventoryItemInstance* CreatePotionInstance(const FPotionResult& PotionData) const;
275: 
276: 
277: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Main", CallInEditor, meta = (DisplayName = "Craft Potion"))
278: 	FPotionResult CraftPotion(bool bAddToInventory = true, ACharacter* TargetCharacter = nullptr, const FVector& WorldSpawnLocation = FVector::ZeroVector);
279: 
280: 
281: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
282: 	bool CanPerformCrafting() const;
283: 
284: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
285: 	void ClearIngredientSlots();
286: 
287: 
288: 	UFUNCTION(BlueprintCallable, Category = "Debug|Testing", CallInEditor, meta = (DisplayName = "Quick Test Craft"))
289: 	void DebugTestCrafting();
290: 
291: 
292: 	UWitchPTInventoryItemInstance* GetBaseIngredient() const;
293: 	UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
294: 	UWitchPTInventoryItemInstance* GetModifierIngredient() const;
295: 	TSubclassOf<UUserWidget> GetBaseIngredientIcon() const;
296: 	TSubclassOf<UUserWidget> GetPrincipalIngredientIcon() const;
297: 	TSubclassOf<UUserWidget> GetModifierIngredientIcon() const;
298: 
299: protected:
300: 
301: 	void BroadcastBaseIngredientDropped() const;
302: 	void BroadcastBaseIngredientIconSet() const;
303: 	void BroadcastPrincipalIngredientDropped() const;
304: 	void BroadcastPrincipalIngredientIconSet() const;
305: 	void BroadcastModifierIngredientDropped() const;
306: 	void BroadcastModifierIngredientIconSet() const;
307: 
308: private:
309: 
310: 	bool HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const;
311: 
312: 
313: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetBasePotionItemDefinition() const;
314: };

================
File: Source/WitchPT/Private/Character/WitchPTEnemy.cpp
================
 1: #include "Character/WitchPTEnemy.h"
 2: 
 3: 
 4: 
 5: AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AWitchPTEnemy::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AWitchPTEnemy::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: 
25: void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
26: {
27: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
28: 
29: }

================
File: Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
================
 1: #include "Item/BaseInteractionPosition.h"
 2: #include "Net/UnrealNetwork.h"
 3: #include "Engine/ActorChannel.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "Components/BoxComponent.h"
 6: #include "GameFramework/Character.h"
 7: 
 8: ABaseInteractionPosition::ABaseInteractionPosition()
 9: {
10: 
11:     PrimaryActorTick.bCanEverTick = true;
12: 
13: 
14:     bReplicates = true;
15:     bAlwaysRelevant = true;
16: }
17: 
18: void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
19: {
20:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
21: 
22: 
23:     DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
24:     DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
25:     DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
26: 
27: 
28: }
29: 
30: void ABaseInteractionPosition::BeginPlay()
31: {
32:     Super::BeginPlay();
33: 
34: 
35: }
36: 
37: void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
38: {
39: 
40:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
41: }
42: 
43: bool ABaseInteractionPosition::IsOccupied() const
44: {
45:     return bIsOccupied;
46: }
47: 
48: void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
49: {
50:     if (GetLocalRole() != ROLE_Authority)
51:     {
52:         return;
53:     }
54: 
55:     OccupyingCharacter = Character;
56:     bIsOccupied = (Character != nullptr);
57: }
58: 
59: void ABaseInteractionPosition::SetUnoccupied()
60: {
61:     if (GetLocalRole() != ROLE_Authority)
62:     {
63:         return;
64:     }
65: 
66:     RemoveCharacterFromPosition();
67: }
68: 
69: void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
70: {
71:     PositionTag = NewTag;
72: }
73: 
74: void ABaseInteractionPosition::OnRep_IsOccupied()
75: {
76: 
77: }
78: 
79: void ABaseInteractionPosition::OnRep_OccupyingCharacter()
80: {
81: 
82: }
83: 
84: void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
85: {
86: 
87:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
88:         *GetName(), *InteractingCharacter->GetName());
89: }
90: 
91: void ABaseInteractionPosition::RemoveCharacterFromPosition()
92: {
93:     OccupyingCharacter = nullptr;
94:     bIsOccupied = false;
95: }

================
File: Source/WitchPT/Private/Item/CauldronPosition.cpp
================
  1: #include "Item/CauldronPosition.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/CauldronAltar.h"
  5: #include "Kismet/GameplayStatics.h"
  6: 
  7: ACauldronPosition::ACauldronPosition()
  8: {
  9: 
 10:     bIsOccupied = false;
 11:     OccupyingCharacter = nullptr;
 12: }
 13: 
 14: void ACauldronPosition::BeginPlay()
 15: {
 16:     Super::BeginPlay();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 
 23: }
 24: 
 25: void ACauldronPosition::FindCauldronAltar()
 26: {
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: 
 38: 
 39: 
 40: 
 41: 
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: }
 56: 
 57: void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 58: {
 59:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 
138: 
139: 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: 
177: 
178: 
179: 
180: 
181: }
182: 
183: void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
184: {
185:     Super::HandleInteraction(InteractingCharacter);
186: 
187:     if (!InteractingCharacter || !CauldronAltar)
188:     {
189:         return;
190:     }
191: 
192: 
193: 
194: }

================
File: Source/WitchPT/Private/Item/Components/CauldronCraftComponent.cpp
================
   1: #include "Item/Components/CauldronCraftComponent.h"
   2: #include "Net/UnrealNetwork.h"
   3: #include "GameFramework/Character.h"
   4: #include "FWitchPTGameplayTags.h"
   5: #include "Inventory/WitchPTInventoryItemDefinition.h"
   6: #include "Inventory/WitchPTInventoryItemInstance.h"
   7: #include "Inventory/WitchPTInventoryManagerComponent.h"
   8: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
   9: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
  10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
  11: #include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
  12: #include "Player/WitchPTPlayerController.h"
  13: #include "Item/CauldronAltar.h"
  14: #include "Item/Potion/PotionBase.h"
  15: #include "Components/StaticMeshComponent.h"
  16: #include "Engine/World.h"
  17: 
  18: 
  19: UCauldronCraftComponent::UCauldronCraftComponent()
  20: {
  21: 
  22: 
  23: 	PrimaryComponentTick.bCanEverTick = true;
  24: 	SetIsReplicatedByDefault(true);
  25: 
  26: 	BaseIngredient = nullptr;
  27: 	PrincipalIngredient = nullptr;
  28: 	ModifierIngredient = nullptr;
  29: 
  30: 
  31: 	DefaultCraftingRecipe.bRequiresBaseIngredient = true;
  32: 	DefaultCraftingRecipe.bRequiresPrincipalIngredient = true;
  33: 	DefaultCraftingRecipe.bRequiresModifierIngredient = false;
  34: }
  35: 
  36: 
  37: void UCauldronCraftComponent::BeginPlay()
  38: {
  39: 	Super::BeginPlay();
  40: }
  41: 
  42: 
  43: void UCauldronCraftComponent::TickComponent(float DeltaTime, ELevelTick TickType,
  44:                                             FActorComponentTickFunction* ThisTickFunction)
  45: {
  46: 	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
  47: }
  48: 
  49: void UCauldronCraftComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
  50: {
  51:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  52: 
  53:     DOREPLIFETIME(UCauldronCraftComponent, BaseIngredientIcon);
  54:     DOREPLIFETIME(UCauldronCraftComponent, PrincipalIngredientIcon);
  55:     DOREPLIFETIME(UCauldronCraftComponent, ModifierIngredientIcon);
  56:     DOREPLIFETIME(UCauldronCraftComponent, CraftedPotion);
  57: }
  58: 
  59: void UCauldronCraftComponent::OnRep_BaseIngredientIcon()
  60: {
  61:     BroadcastBaseIngredientIconSet();
  62: }
  63: 
  64: void UCauldronCraftComponent::OnRep_PrincipalIngredientIcon()
  65: {
  66:     BroadcastPrincipalIngredientIconSet();
  67: }
  68: 
  69: void UCauldronCraftComponent::OnRep_PotentiatorIngredientIcon()
  70: {
  71:     BroadcastModifierIngredientIconSet();
  72: }
  73: 
  74: void UCauldronCraftComponent::OnRep_CraftedPotion()
  75: {
  76: 
  77:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::OnRep_CraftedPotion: Potion crafted with validity: %s"),
  78:            CraftedPotion.bIsValid ? TEXT("Valid") : TEXT("Invalid"));
  79: }
  80: 
  81: 
  82: 
  83: bool UCauldronCraftComponent::CanCraftPotion() const
  84: {
  85:     const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
  86: 
  87: 
  88:     if (Recipe.bRequiresBaseIngredient)
  89:     {
  90:         if (!BaseIngredient || !HasValidCraftingProperties(BaseIngredient))
  91:         {
  92:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Base ingredient missing or invalid"));
  93:             return false;
  94:         }
  95:     }
  96: 
  97: 
  98:     if (Recipe.bRequiresPrincipalIngredient)
  99:     {
 100:         if (!PrincipalIngredient || !HasValidCraftingProperties(PrincipalIngredient))
 101:         {
 102:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Principal ingredient missing or invalid"));
 103:             return false;
 104:         }
 105:     }
 106: 
 107: 
 108:     if (Recipe.bRequiresModifierIngredient)
 109:     {
 110:         if (!ModifierIngredient || !HasValidCraftingProperties(ModifierIngredient))
 111:         {
 112:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Modifier ingredient missing or invalid"));
 113:             return false;
 114:         }
 115:     }
 116: 
 117: 
 118:     if (!ValidateIngredientCombination())
 119:     {
 120:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Ingredient combination is not valid"));
 121:         return false;
 122:     }
 123: 
 124:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CanCraftPotion: All requirements met, can craft potion"));
 125:     return true;
 126: }
 127: 
 128: FPotionCraftingRecipe UCauldronCraftComponent::GetRequiredIngredients() const
 129: {
 130: 
 131: 
 132:     return DefaultCraftingRecipe;
 133: }
 134: 
 135: bool UCauldronCraftComponent::ValidateIngredientCombination() const
 136: {
 137:     const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
 138: 
 139: 
 140:     if (Recipe.bRequiresBaseIngredient && !BaseIngredient)
 141:     {
 142:         return false;
 143:     }
 144: 
 145:     if (Recipe.bRequiresPrincipalIngredient && !PrincipalIngredient)
 146:     {
 147:         return false;
 148:     }
 149: 
 150: 
 151:     if (BaseIngredient && Recipe.AllowedBaseLiquidTypes.Num() > 0)
 152:     {
 153:         const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps =
 154:             Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 155:                 BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 156: 
 157:         if (BaseProps && !Recipe.AllowedBaseLiquidTypes.HasTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag))
 158:         {
 159:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Base liquid type not allowed"));
 160:             return false;
 161:         }
 162:     }
 163: 
 164: 
 165:     if (PrincipalIngredient && Recipe.AllowedPrincipalEssences.Num() > 0)
 166:     {
 167:         const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps =
 168:             Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 169:                 PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 170: 
 171:         if (PrincipalProps && !Recipe.AllowedPrincipalEssences.HasTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag))
 172:         {
 173:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Principal essence not allowed"));
 174:             return false;
 175:         }
 176:     }
 177: 
 178: 
 179:     if (Recipe.IncompatibleCombinations.Num() > 0)
 180:     {
 181: 
 182:         FGameplayTagContainer CurrentCombination;
 183: 
 184:         if (BaseIngredient)
 185:         {
 186:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps =
 187:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 188:                     BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 189:             if (BaseProps)
 190:             {
 191:                 CurrentCombination.AddTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag);
 192:                 CurrentCombination.AddTag(BaseProps->CategoryTag);
 193:             }
 194:         }
 195: 
 196:         if (PrincipalIngredient)
 197:         {
 198:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps =
 199:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 200:                     PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 201:             if (PrincipalProps)
 202:             {
 203:                 CurrentCombination.AddTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag);
 204:                 CurrentCombination.AddTag(PrincipalProps->CategoryTag);
 205:             }
 206:         }
 207: 
 208:         if (ModifierIngredient)
 209:         {
 210:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* ModifierProps =
 211:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 212:                     ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 213:             if (ModifierProps)
 214:             {
 215:                 CurrentCombination.AppendTags(ModifierProps->ModifierIngredientData.ModifierEffectTags);
 216:                 CurrentCombination.AddTag(ModifierProps->CategoryTag);
 217:             }
 218:         }
 219: 
 220: 
 221:         for (const FGameplayTag& IncompatibleTag : Recipe.IncompatibleCombinations)
 222:         {
 223:             if (CurrentCombination.HasTag(IncompatibleTag))
 224:             {
 225:                 UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Found incompatible combination: %s"),
 226:                        *IncompatibleTag.ToString());
 227:                 return false;
 228:             }
 229:         }
 230:     }
 231: 
 232:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Ingredient combination is valid"));
 233:     return true;
 234: }
 235: 
 236: bool UCauldronCraftComponent::HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const
 237: {
 238:     if (!Ingredient)
 239:     {
 240:         return false;
 241:     }
 242: 
 243:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 244:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 245:             Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 246: 
 247:     return CraftingProps != nullptr;
 248: }
 249: 
 250: 
 251: 
 252: void UCauldronCraftComponent::PrintIngredientDebugData() const
 253: {
 254:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON CRAFT COMPONENT DEBUG DATA ==="));
 255:     UE_LOG(LogTemp, Warning, TEXT("Component Owner: %s"), GetOwner() ? *GetOwner()->GetName() : TEXT("None"));
 256: 
 257: 
 258:     if (BaseIngredient)
 259:     {
 260:         UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT ---"));
 261:         PrintSpecificIngredientData(BaseIngredient, TEXT("Base"));
 262:     }
 263:     else
 264:     {
 265:         UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT: EMPTY ---"));
 266:     }
 267: 
 268: 
 269:     if (PrincipalIngredient)
 270:     {
 271:         UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT ---"));
 272:         PrintSpecificIngredientData(PrincipalIngredient, TEXT("Principal"));
 273:     }
 274:     else
 275:     {
 276:         UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT: EMPTY ---"));
 277:     }
 278: 
 279: 
 280:     if (ModifierIngredient)
 281:     {
 282:         UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT ---"));
 283:         PrintSpecificIngredientData(ModifierIngredient, TEXT("Modifier"));
 284:     }
 285:     else
 286:     {
 287:         UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT: EMPTY ---"));
 288:     }
 289: 
 290: 
 291:     UE_LOG(LogTemp, Warning, TEXT("--- CRAFTING STATUS ---"));
 292:     UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), CanCraftPotion() ? TEXT("YES") : TEXT("NO"));
 293:     UE_LOG(LogTemp, Warning, TEXT("Ingredient Combination Valid: %s"), ValidateIngredientCombination() ? TEXT("YES") : TEXT("NO"));
 294: 
 295: 
 296:     UE_LOG(LogTemp, Warning, TEXT("--- CURRENT CRAFTED POTION ---"));
 297:     UE_LOG(LogTemp, Warning, TEXT("Crafted Potion Valid: %s"), CraftedPotion.bIsValid ? TEXT("YES") : TEXT("NO"));
 298:     if (CraftedPotion.bIsValid)
 299:     {
 300:         UE_LOG(LogTemp, Warning, TEXT("Potion Essence: %s"), *CraftedPotion.PotionEssenceTag.ToString());
 301:         UE_LOG(LogTemp, Warning, TEXT("Base Liquid: %s"), *CraftedPotion.BaseLiquidTypeTag.ToString());
 302:         UE_LOG(LogTemp, Warning, TEXT("Final Potency: %.2f"), CraftedPotion.FinalPotency);
 303:         UE_LOG(LogTemp, Warning, TEXT("Final Duration: %.2f"), CraftedPotion.FinalDuration);
 304:         UE_LOG(LogTemp, Warning, TEXT("Final Charges: %d"), CraftedPotion.FinalCharges);
 305:     }
 306: 
 307:     UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG DATA ==="));
 308:     CalculatePotionProperties();
 309: }
 310: 
 311: void UCauldronCraftComponent::PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const
 312: {
 313:     if (!Ingredient)
 314:     {
 315:         UE_LOG(LogTemp, Warning, TEXT("%s Ingredient: NULL"), *SlotName);
 316:         return;
 317:     }
 318: 
 319: 
 320:     UE_LOG(LogTemp, Warning, TEXT("%s Ingredient Definition: %s"),
 321:            *SlotName,
 322:            Ingredient->GetItemDef() ? *Ingredient->GetItemDef()->GetName() : TEXT("None"));
 323:     UE_LOG(LogTemp, Warning, TEXT("%s Stack Count: %d"), *SlotName, Ingredient->GetTotalStackCount());
 324: 
 325: 
 326:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 327:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 328:             Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 329: 
 330:     if (!CraftingProps)
 331:     {
 332:         UE_LOG(LogTemp, Error, TEXT("%s Ingredient: NO CRAFTING PROPERTIES FRAGMENT FOUND!"), *SlotName);
 333:         return;
 334:     }
 335: 
 336: 
 337:     UE_LOG(LogTemp, Warning, TEXT("%s Slot Usage Tag: %s"), *SlotName, *CraftingProps->SlotUsageTag.ToString());
 338:     UE_LOG(LogTemp, Warning, TEXT("%s Tier Tag: %s"), *SlotName, *CraftingProps->TierTag.ToString());
 339:     UE_LOG(LogTemp, Warning, TEXT("%s Category Tag: %s"), *SlotName, *CraftingProps->CategoryTag.ToString());
 340: 
 341: 
 342:     UE_LOG(LogTemp, Warning, TEXT("%s Base Liquid Type: %s"),
 343:            *SlotName, *CraftingProps->BaseIngredientData.BaseLiquidTypeTag.ToString());
 344:     UE_LOG(LogTemp, Warning, TEXT("%s Default Charges: %d"),
 345:            *SlotName, CraftingProps->BaseIngredientData.DefaultChargesProvided);
 346:     UE_LOG(LogTemp, Warning, TEXT("%s Stability Modifier: %.3f"),
 347:            *SlotName, CraftingProps->BaseIngredientData.StabilityModifier);
 348: 
 349: 
 350:     UE_LOG(LogTemp, Warning, TEXT("%s Principal Essence: %s"),
 351:            *SlotName, *CraftingProps->PrincipalIngredientData.PrincipalEssenceTag.ToString());
 352:     UE_LOG(LogTemp, Warning, TEXT("%s Base Potency: %.3f"),
 353:            *SlotName, CraftingProps->PrincipalIngredientData.BasePotency);
 354:     UE_LOG(LogTemp, Warning, TEXT("%s Base Duration: %.3f"),
 355:            *SlotName, CraftingProps->PrincipalIngredientData.BaseDuration);
 356:     UE_LOG(LogTemp, Warning, TEXT("%s Is Ritual Essence: %s"),
 357:            *SlotName, CraftingProps->PrincipalIngredientData.bIsRitualEssence ? TEXT("YES") : TEXT("NO"));
 358: 
 359: 
 360:     FString ModifierEffectTagsString;
 361:     for (const FGameplayTag& Tag : CraftingProps->ModifierIngredientData.ModifierEffectTags)
 362:     {
 363:         if (!ModifierEffectTagsString.IsEmpty())
 364:         {
 365:             ModifierEffectTagsString += TEXT(", ");
 366:         }
 367:         ModifierEffectTagsString += Tag.ToString();
 368:     }
 369:     UE_LOG(LogTemp, Warning, TEXT("%s Modifier Effect Tags: [%s]"), *SlotName, *ModifierEffectTagsString);
 370:     UE_LOG(LogTemp, Warning, TEXT("%s Potency Modification: %.3f"),
 371:            *SlotName, CraftingProps->ModifierIngredientData.PotencyModificationValue);
 372:     UE_LOG(LogTemp, Warning, TEXT("%s Duration Modification: %.3f"),
 373:            *SlotName, CraftingProps->ModifierIngredientData.DurationModificationValue);
 374:     UE_LOG(LogTemp, Warning, TEXT("%s Granted Property Tag: %s"),
 375:            *SlotName, *CraftingProps->ModifierIngredientData.GrantedPropertyTag.ToString());
 376:     UE_LOG(LogTemp, Warning, TEXT("%s Added Effect Tag: %s"),
 377:            *SlotName, *CraftingProps->ModifierIngredientData.AddedEffectTag.ToString());
 378:     UE_LOG(LogTemp, Warning, TEXT("%s Modifier Strength: %.3f"),
 379:            *SlotName, CraftingProps->ModifierIngredientData.StrengthOfModifier);
 380: }
 381: 
 382: void UCauldronCraftComponent::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
 383: {
 384:     if (!GetOwner()->HasAuthority())
 385:     {
 386:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Not authority"));
 387:         return;
 388:     }
 389: 
 390:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
 391:     if (!PC)
 392:     {
 393:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
 394:         return;
 395:     }
 396: 
 397:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
 398:     if (!InventoryManager)
 399:     {
 400:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
 401:         return;
 402:     }
 403: 
 404:     UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);
 405: 
 406:     if (!InstanceFromInventory)
 407:     {
 408:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
 409:         return;
 410:     }
 411: 
 412:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 413:     if (!IngredientCraftingDetails)
 414:     {
 415:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
 416:         return;
 417:     }
 418: 
 419: 
 420:     const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
 421:     bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
 422:     bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
 423:     bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);
 424: 
 425: 
 426:     if (bIsBaseIngredient && BaseIngredient != nullptr)
 427:     {
 428:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
 429:         return;
 430:     }
 431: 
 432:     if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
 433:     {
 434:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
 435:         return;
 436:     }
 437: 
 438:     if (bIsModifierIngredient && ModifierIngredient != nullptr)
 439:     {
 440:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
 441:         return;
 442:     }
 443: 
 444: 
 445:     if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
 446:     {
 447:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
 448:         return;
 449:     }
 450: 
 451:     bool bConsumedSuccessfully = false;
 452:     int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
 453: 
 454:     if (CurrentStackCount > 0)
 455:     {
 456:         UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
 457: 
 458:         if (CurrentStackCount == 1)
 459:         {
 460:             IngredientToSet = InstanceFromInventory;
 461:             InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
 462:             bConsumedSuccessfully = true;
 463:         }
 464:         else
 465:         {
 466:             InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
 467:             IngredientToSet = InstanceFromInventory;
 468:             bConsumedSuccessfully = true;
 469:         }
 470: 
 471: 
 472:         const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
 473:         TSubclassOf<UUserWidget> IngredientIcon = nullptr;
 474:         if (IsValid(UIFragment))
 475:         {
 476:             IngredientIcon = UIFragment->IconWidget;
 477:         }
 478: 
 479: 
 480:         if (bIsBaseIngredient)
 481:         {
 482:             BaseIngredient = IngredientToSet;
 483:             BaseIngredientIcon = IngredientIcon;
 484:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient set successfully"));
 485: 
 486:             if (GetOwner()->HasAuthority())
 487:             {
 488:                 BroadcastBaseIngredientIconSet();
 489:             }
 490:         }
 491:         else if (bIsPrincipalIngredient)
 492:         {
 493:             PrincipalIngredient = IngredientToSet;
 494:             PrincipalIngredientIcon = IngredientIcon;
 495:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient set successfully"));
 496: 
 497:             if (GetOwner()->HasAuthority())
 498:             {
 499:                 BroadcastPrincipalIngredientIconSet();
 500:             }
 501:         }
 502:         else if (bIsModifierIngredient)
 503:         {
 504:             ModifierIngredient = IngredientToSet;
 505:             ModifierIngredientIcon = IngredientIcon;
 506:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient set successfully"));
 507: 
 508:             if (GetOwner()->HasAuthority())
 509:             {
 510:                 BroadcastModifierIngredientIconSet();
 511:             }
 512:         }
 513:     }
 514: }
 515: 
 516: 
 517: void UCauldronCraftComponent::BroadcastBaseIngredientDropped() const
 518: {
 519:     OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
 520: }
 521: 
 522: void UCauldronCraftComponent::BroadcastBaseIngredientIconSet() const
 523: {
 524:     OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
 525: }
 526: 
 527: void UCauldronCraftComponent::BroadcastPrincipalIngredientDropped() const
 528: {
 529:     OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
 530: }
 531: 
 532: void UCauldronCraftComponent::BroadcastPrincipalIngredientIconSet() const
 533: {
 534:     OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
 535: }
 536: 
 537: void UCauldronCraftComponent::BroadcastModifierIngredientDropped() const
 538: {
 539:     OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
 540: }
 541: 
 542: void UCauldronCraftComponent::BroadcastModifierIngredientIconSet() const
 543: {
 544:     OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
 545: }
 546: 
 547: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetBaseIngredient() const
 548: {
 549:     return BaseIngredient;
 550: }
 551: 
 552: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetPrincipalIngredient() const
 553: {
 554:     return PrincipalIngredient;
 555: }
 556: 
 557: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetModifierIngredient() const
 558: {
 559:     return ModifierIngredient;
 560: }
 561: 
 562: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetBaseIngredientIcon() const
 563: {
 564:     return BaseIngredientIcon;
 565: }
 566: 
 567: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetPrincipalIngredientIcon() const
 568: {
 569:     return PrincipalIngredientIcon;
 570: }
 571: 
 572: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetModifierIngredientIcon() const
 573: {
 574:     return ModifierIngredientIcon;
 575: }
 576: 
 577: 
 578: 
 579: 
 580: FExtractedBaseIngredientData UCauldronCraftComponent::ExtractBaseIngredientProperties() const
 581: {
 582:     FExtractedBaseIngredientData ExtractedData;
 583: 
 584:     if (!BaseIngredient)
 585:     {
 586:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No base ingredient found"));
 587:         return ExtractedData;
 588:     }
 589: 
 590:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 591:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 592:             BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 593: 
 594:     if (!CraftingProps)
 595:     {
 596:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No crafting properties found"));
 597:         return ExtractedData;
 598:     }
 599: 
 600: 
 601:     ExtractedData.BaseLiquidTypeTag = CraftingProps->BaseIngredientData.BaseLiquidTypeTag;
 602:     ExtractedData.DefaultChargesProvided = CraftingProps->BaseIngredientData.DefaultChargesProvided;
 603:     ExtractedData.StabilityModifier = CraftingProps->BaseIngredientData.StabilityModifier;
 604:     ExtractedData.TierTag = CraftingProps->TierTag;
 605:     ExtractedData.bIsValid = true;
 606: 
 607:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: Successfully extracted - Liquid: %s, Charges: %d, Stability: %.3f"),
 608:            *ExtractedData.BaseLiquidTypeTag.ToString(),
 609:            ExtractedData.DefaultChargesProvided,
 610:            ExtractedData.StabilityModifier);
 611: 
 612:     return ExtractedData;
 613: }
 614: 
 615: FExtractedPrincipalIngredientData UCauldronCraftComponent::ExtractPrincipalIngredientProperties() const
 616: {
 617:     FExtractedPrincipalIngredientData ExtractedData;
 618: 
 619:     if (!PrincipalIngredient)
 620:     {
 621:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No principal ingredient found"));
 622:         return ExtractedData;
 623:     }
 624: 
 625:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 626:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 627:             PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 628: 
 629:     if (!CraftingProps)
 630:     {
 631:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No crafting properties found"));
 632:         return ExtractedData;
 633:     }
 634: 
 635: 
 636:     ExtractedData.PrincipalEssenceTag = CraftingProps->PrincipalIngredientData.PrincipalEssenceTag;
 637:     ExtractedData.BasePotency = CraftingProps->PrincipalIngredientData.BasePotency;
 638:     ExtractedData.BaseDuration = CraftingProps->PrincipalIngredientData.BaseDuration;
 639:     ExtractedData.bIsRitualEssence = CraftingProps->PrincipalIngredientData.bIsRitualEssence;
 640:     ExtractedData.TierTag = CraftingProps->TierTag;
 641:     ExtractedData.bIsValid = true;
 642: 
 643:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: Successfully extracted - Essence: %s, Potency: %.3f, Duration: %.3f"),
 644:            *ExtractedData.PrincipalEssenceTag.ToString(),
 645:            ExtractedData.BasePotency,
 646:            ExtractedData.BaseDuration);
 647: 
 648:     return ExtractedData;
 649: }
 650: 
 651: FExtractedModifierIngredientData UCauldronCraftComponent::ExtractModifierIngredientProperties() const
 652: {
 653:     FExtractedModifierIngredientData ExtractedData;
 654: 
 655:     if (!ModifierIngredient)
 656:     {
 657:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No modifier ingredient found (this is optional)"));
 658:         return ExtractedData;
 659:     }
 660: 
 661:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 662:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 663:             ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 664: 
 665:     if (!CraftingProps)
 666:     {
 667:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No crafting properties found"));
 668:         return ExtractedData;
 669:     }
 670: 
 671: 
 672:     ExtractedData.ModifierEffectTags = CraftingProps->ModifierIngredientData.ModifierEffectTags;
 673:     ExtractedData.PotencyModificationValue = CraftingProps->ModifierIngredientData.PotencyModificationValue;
 674:     ExtractedData.DurationModificationValue = CraftingProps->ModifierIngredientData.DurationModificationValue;
 675:     ExtractedData.GrantedPropertyTag = CraftingProps->ModifierIngredientData.GrantedPropertyTag;
 676:     ExtractedData.AddedEffectTag = CraftingProps->ModifierIngredientData.AddedEffectTag;
 677:     ExtractedData.StrengthOfModifier = CraftingProps->ModifierIngredientData.StrengthOfModifier;
 678:     ExtractedData.TierTag = CraftingProps->TierTag;
 679:     ExtractedData.bIsValid = true;
 680: 
 681:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: Successfully extracted - Effects: %d, Potency Mod: %.3f, Duration Mod: %.3f"),
 682:            ExtractedData.ModifierEffectTags.Num(),
 683:            ExtractedData.PotencyModificationValue,
 684:            ExtractedData.DurationModificationValue);
 685: 
 686:     return ExtractedData;
 687: }
 688: 
 689: 
 690: 
 691: FPotionResult UCauldronCraftComponent::CalculatePotionProperties() const
 692: {
 693:     FPotionResult PotionResult;
 694: 
 695: 
 696:     if (!CanCraftPotion())
 697:     {
 698:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Cannot craft potion with current ingredients"));
 699:         return PotionResult;
 700:     }
 701: 
 702: 
 703:     FExtractedBaseIngredientData BaseData = ExtractBaseIngredientProperties();
 704:     FExtractedPrincipalIngredientData PrincipalData = ExtractPrincipalIngredientProperties();
 705:     FExtractedModifierIngredientData ModifierData = ExtractModifierIngredientProperties();
 706: 
 707: 
 708:     if (!BaseData.bIsValid || !PrincipalData.bIsValid)
 709:     {
 710:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Required ingredient data is invalid"));
 711:         return PotionResult;
 712:     }
 713: 
 714:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Starting potion calculation..."));
 715: 
 716: 
 717:     PotionResult.BaseLiquidTypeTag = BaseData.BaseLiquidTypeTag;
 718:     PotionResult.FinalCharges = BaseData.DefaultChargesProvided;
 719:     float StabilityFactor = BaseData.StabilityModifier;
 720: 
 721: 
 722:     PotionResult.PotionEssenceTag = PrincipalData.PrincipalEssenceTag;
 723:     PotionResult.FinalPotency = PrincipalData.BasePotency;
 724:     PotionResult.FinalDuration = PrincipalData.BaseDuration;
 725: 
 726: 
 727:     if (PrincipalData.PrincipalEssenceTag.IsValid())
 728:     {
 729:         PotionResult.GrantedEffectTags.AddTag(PrincipalData.PrincipalEssenceTag);
 730:     }
 731: 
 732: 
 733:     if (ModifierData.bIsValid)
 734:     {
 735:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Applying modifier effects..."));
 736: 
 737: 
 738:         PotionResult.FinalPotency *= ModifierData.PotencyModificationValue;
 739: 
 740: 
 741:         PotionResult.FinalDuration += ModifierData.DurationModificationValue;
 742: 
 743: 
 744:         PotionResult.GrantedEffectTags.AppendTags(ModifierData.ModifierEffectTags);
 745: 
 746: 
 747:         if (ModifierData.GrantedPropertyTag.IsValid())
 748:         {
 749:             PotionResult.GrantedPropertyTags.AddTag(ModifierData.GrantedPropertyTag);
 750:         }
 751: 
 752: 
 753:         if (ModifierData.AddedEffectTag.IsValid())
 754:         {
 755:             PotionResult.GrantedEffectTags.AddTag(ModifierData.AddedEffectTag);
 756:         }
 757: 
 758: 
 759:         PotionResult.FinalPotency *= ModifierData.StrengthOfModifier;
 760:     }
 761: 
 762: 
 763:     PotionResult.FinalPotency *= StabilityFactor;
 764: 
 765: 
 766:     PotionResult.PotionTierTag = CalculatePotionTier(BaseData, PrincipalData, ModifierData);
 767: 
 768: 
 769:     PotionResult.FinalPotency = FMath::Max(PotionResult.FinalPotency, 0.1f);
 770:     PotionResult.FinalDuration = FMath::Max(PotionResult.FinalDuration, 1.0f);
 771:     PotionResult.FinalCharges = FMath::Max(PotionResult.FinalCharges, 1);
 772: 
 773: 
 774:     PotionResult.bIsValid = true;
 775: 
 776:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Potion calculation complete - Potency: %.2f, Duration: %.2f, Charges: %d"),
 777:            PotionResult.FinalPotency,
 778:            PotionResult.FinalDuration,
 779:            PotionResult.FinalCharges);
 780: 
 781:     return PotionResult;
 782: }
 783: 
 784: FGameplayTag UCauldronCraftComponent::CalculatePotionTier(const FExtractedBaseIngredientData& BaseData,
 785:                                                          const FExtractedPrincipalIngredientData& PrincipalData,
 786:                                                          const FExtractedModifierIngredientData& ModifierData) const
 787: {
 788: 
 789: 
 790: 
 791:     TArray<FGameplayTag> TierTags;
 792: 
 793:     if (BaseData.bIsValid && BaseData.TierTag.IsValid())
 794:     {
 795:         TierTags.Add(BaseData.TierTag);
 796:     }
 797: 
 798:     if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
 799:     {
 800:         TierTags.Add(PrincipalData.TierTag);
 801:     }
 802: 
 803:     if (ModifierData.bIsValid && ModifierData.TierTag.IsValid())
 804:     {
 805:         TierTags.Add(ModifierData.TierTag);
 806:     }
 807: 
 808: 
 809: 
 810:     if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
 811:     {
 812:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using principal ingredient tier: %s"),
 813:                *PrincipalData.TierTag.ToString());
 814:         return PrincipalData.TierTag;
 815:     }
 816: 
 817: 
 818:     if (BaseData.bIsValid && BaseData.TierTag.IsValid())
 819:     {
 820:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using base ingredient tier: %s"),
 821:                *BaseData.TierTag.ToString());
 822:         return BaseData.TierTag;
 823:     }
 824: 
 825: 
 826:     UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionTier: No valid tier tags found, returning empty tag"));
 827:     return FGameplayTag();
 828: }
 829: 
 830: 
 831: 
 832: TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GeneratePotionItemDefinition(const FPotionResult& PotionData) const
 833: {
 834:     if (!PotionData.bIsValid)
 835:     {
 836:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Invalid potion data provided"));
 837:         return nullptr;
 838:     }
 839: 
 840:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
 841:     if (!BasePotionItemDefinition)
 842:     {
 843:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: BasePotionItemDefinition is not set"));
 844:         return nullptr;
 845:     }
 846: 
 847: 
 848: 
 849: 
 850:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Returning base potion definition for essence: %s"),
 851:            *PotionData.PotionEssenceTag.ToString());
 852: 
 853:     return BasePotionItemDefinition;
 854: }
 855: 
 856: UWitchPTInventoryItemDefinition* UCauldronCraftComponent::CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const
 857: {
 858:     if (!PotionData.bIsValid)
 859:     {
 860:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Invalid potion data provided"));
 861:         return nullptr;
 862:     }
 863: 
 864:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
 865:     if (!BasePotionItemDefinition)
 866:     {
 867:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: BasePotionItemDefinition is not set"));
 868:         return nullptr;
 869:     }
 870: 
 871: 
 872:     UWitchPTInventoryItemDefinition* PotionDefinition = NewObject<UWitchPTInventoryItemDefinition>(
 873:         GetTransientPackage(),
 874:         BasePotionItemDefinition
 875:     );
 876: 
 877:     if (!PotionDefinition)
 878:     {
 879:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Failed to create potion definition instance"));
 880:         return nullptr;
 881:     }
 882: 
 883: 
 884:     UWitchPTInventoryItemFragment_PotionProperties* PotionPropsFragment = nullptr;
 885: 
 886: 
 887:     const UWitchPTInventoryItemFragment_PotionProperties* ExistingFragment =
 888:         Cast<UWitchPTInventoryItemFragment_PotionProperties>(
 889:             PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_PotionProperties::StaticClass()));
 890: 
 891:     if (ExistingFragment)
 892:     {
 893: 
 894:         PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
 895: 
 896: 
 897: 
 898:     }
 899:     else
 900:     {
 901: 
 902:         PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
 903: 
 904: 
 905:         PotionDefinition->Fragments.Add(PotionPropsFragment);
 906:     }
 907: 
 908: 
 909:     if (PotionPropsFragment)
 910:     {
 911:         PotionPropsFragment->SetPotionProperties(
 912:             PotionData.PotionEssenceTag,
 913:             PotionData.BaseLiquidTypeTag,
 914:             PotionData.FinalPotency,
 915:             PotionData.FinalDuration,
 916:             PotionData.FinalCharges,
 917:             PotionData.PotionTierTag,
 918:             PotionData.GrantedEffectTags,
 919:             PotionData.GrantedPropertyTags
 920:         );
 921: 
 922:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Created potion definition with properties - %s"),
 923:                *PotionData.PotionEssenceTag.ToString());
 924:     }
 925: 
 926:     return PotionDefinition;
 927: }
 928: 
 929: 
 930: 
 931: UWitchPTInventoryItemInstance* UCauldronCraftComponent::CreatePotionInstance(const FPotionResult& PotionData) const
 932: {
 933:     if (!PotionData.bIsValid)
 934:     {
 935:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Invalid potion data provided"));
 936:         return nullptr;
 937:     }
 938: 
 939: 
 940:     UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
 941:     if (!PotionDefinition)
 942:     {
 943:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion definition"));
 944:         return nullptr;
 945:     }
 946: 
 947: 
 948:     UWitchPTInventoryItemInstance* PotionInstance = NewObject<UWitchPTInventoryItemInstance>();
 949:     if (!PotionInstance)
 950:     {
 951:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion instance"));
 952:         return nullptr;
 953:     }
 954: 
 955: 
 956:     PotionInstance->SetItemDef(PotionDefinition->GetClass());
 957:     PotionInstance->SetTotalStackCount(PotionData.FinalCharges);
 958: 
 959:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionInstance: Successfully created potion instance - %s with %d charges"),
 960:            *PotionData.PotionEssenceTag.ToString(),
 961:            PotionData.FinalCharges);
 962: 
 963:     return PotionInstance;
 964: }
 965: 
 966: bool UCauldronCraftComponent::SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const
 967: {
 968:     if (!PotionData.bIsValid)
 969:     {
 970:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Invalid potion data provided"));
 971:         return false;
 972:     }
 973: 
 974:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Attempting to spawn at location: %s"), *SpawnLocation.ToString());
 975:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Cauldron owner location: %s"), *GetOwner()->GetActorLocation().ToString());
 976: 
 977: 
 978:     UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
 979:     if (!PotionDefinition)
 980:     {
 981:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create potion definition"));
 982:         return false;
 983:     }
 984: 
 985: 
 986:     UWorld* World = GetWorld();
 987:     if (!World)
 988:     {
 989:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No valid world found"));
 990:         return false;
 991:     }
 992: 
 993: 
 994:     FActorSpawnParameters SpawnParams;
 995:     SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 996: 
 997:     APotionBase* PotionActor = World->SpawnActor<APotionBase>(SpawnLocation, FRotator::ZeroRotator, SpawnParams);
 998:     FItemManifest ItemManifest;
 999:     ItemManifest.ItemDef = PotionDefinition->GetClass();
1000:     PotionActor->StaticInventory = ItemManifest;
1001:     if (!PotionActor)
1002:     {
1003:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to spawn PotionBase actor"));
1004:         return false;
1005:     }
1006: 
1007:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned PotionBase at: %s"), *PotionActor->GetActorLocation().ToString());
1008: 
1009: 
1010:     const UWitchPTInventoryItemFragment_WorldDetails* WorldDetails =
1011:         Cast<UWitchPTInventoryItemFragment_WorldDetails>(
1012:             PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_WorldDetails::StaticClass()));
1013: 
1014:     if (WorldDetails && WorldDetails->HasValidWorldMesh())
1015:     {
1016: 
1017:         UStaticMeshComponent* MeshComponent = PotionActor->FindComponentByClass<UStaticMeshComponent>();
1018: 
1019:         if (!MeshComponent)
1020:         {
1021: 
1022:             MeshComponent = NewObject<UStaticMeshComponent>(PotionActor);
1023:             MeshComponent->SetupAttachment(PotionActor->GetRootComponent());
1024:             MeshComponent->RegisterComponent();
1025: 
1026:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Created new StaticMeshComponent for PotionBase"));
1027:         }
1028: 
1029:         if (MeshComponent)
1030:         {
1031: 
1032:             MeshComponent->SetStaticMesh(WorldDetails->WorldStaticMesh);
1033: 
1034: 
1035:             if (WorldDetails->WorldScale != FVector::OneVector)
1036:             {
1037:                 MeshComponent->SetWorldScale3D(WorldDetails->WorldScale);
1038:             }
1039: 
1040: 
1041:             if (WorldDetails->WorldMaterial)
1042:             {
1043:                 MeshComponent->SetMaterial(0, WorldDetails->WorldMaterial);
1044:             }
1045: 
1046: 
1047:             if (!WorldDetails->CollisionProfileName.IsNone())
1048:             {
1049:                 MeshComponent->SetCollisionProfileName(WorldDetails->CollisionProfileName);
1050:             }
1051: 
1052:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Applied mesh '%s' from WorldDetails fragment"),
1053:                    *WorldDetails->WorldStaticMesh->GetName());
1054:         }
1055:         else
1056:         {
1057:             UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create or find StaticMeshComponent"));
1058:         }
1059:     }
1060:     else
1061:     {
1062:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No WorldDetails fragment or invalid mesh - using default appearance"));
1063:     }
1064: 
1065: 
1066: 
1067: 
1068: 
1069:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned potion at location: %s"),
1070:            *SpawnLocation.ToString());
1071:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Potion: %s with %d charges, %.2f potency"),
1072:            *PotionData.PotionEssenceTag.ToString(),
1073:            PotionData.FinalCharges,
1074:            PotionData.FinalPotency);
1075: 
1076:     return true;
1077: }
1078: 
1079: UWitchPTInventoryItemInstance* UCauldronCraftComponent::AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const
1080: {
1081:     if (!TargetCharacter)
1082:     {
1083:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter is null"));
1084:         return nullptr;
1085:     }
1086: 
1087:     UWitchPTInventoryItemInstance* PotionInstance = CreatePotionInstance(PotionData);
1088:     if (!PotionInstance)
1089:     {
1090:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Failed to create potion instance"));
1091:         return nullptr;
1092:     }
1093: 
1094: 
1095:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(TargetCharacter->GetController());
1096:     if (!PC)
1097:     {
1098:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter does not have a valid PlayerController"));
1099:         return nullptr;
1100:     }
1101: 
1102:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
1103:     if (!InventoryManager)
1104:     {
1105:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Could not get InventoryManager from PlayerController"));
1106:         return nullptr;
1107:     }
1108: 
1109: 
1110: 
1111: 
1112: 
1113: 
1114: 
1115: 
1116: 
1117: 
1118: 
1119: 
1120: 
1121: 
1122:     return nullptr;
1123: }
1124: 
1125: 
1126: 
1127: FPotionResult UCauldronCraftComponent::CraftPotion(bool bAddToInventory, ACharacter* TargetCharacter, const FVector& WorldSpawnLocation)
1128: {
1129:     FPotionResult EmptyResult;
1130: 
1131: 
1132:     if (!GetOwner()->HasAuthority())
1133:     {
1134:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Not authority - crafting not allowed"));
1135:         return EmptyResult;
1136:     }
1137: 
1138: 
1139:     if (!CanPerformCrafting())
1140:     {
1141:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Cannot perform crafting with current setup"));
1142:         return EmptyResult;
1143:     }
1144: 
1145:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Starting potion crafting process..."));
1146: 
1147: 
1148:     FPotionResult CraftingResult = CalculatePotionProperties();
1149:     if (!CraftingResult.bIsValid)
1150:     {
1151:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to calculate valid potion properties"));
1152:         return EmptyResult;
1153:     }
1154: 
1155: 
1156:     bool bPotionCreatedSuccessfully = false;
1157: 
1158:     if (bAddToInventory)
1159:     {
1160: 
1161:         ACharacter* Target = TargetCharacter;
1162:         if (!Target)
1163:         {
1164: 
1165:             Target = Cast<ACharacter>(GetOwner());
1166:             if (!Target)
1167:             {
1168: 
1169:                 UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: No target character specified for inventory addition"));
1170:                 return EmptyResult;
1171:             }
1172:         }
1173: 
1174:         UWitchPTInventoryItemInstance* CreatedInstance = AddPotionToInventory(CraftingResult, Target);
1175:         bPotionCreatedSuccessfully = (CreatedInstance != nullptr);
1176:     }
1177:     else
1178:     {
1179: 
1180:         FVector CauldronLocation = GetOwner()->GetActorLocation();
1181:         FVector SpawnLoc;
1182: 
1183:         if (WorldSpawnLocation != FVector::ZeroVector)
1184:         {
1185: 
1186:             SpawnLoc = WorldSpawnLocation;
1187:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Using specified spawn location: %s"), *SpawnLoc.ToString());
1188:         }
1189:         else
1190:         {
1191: 
1192:             FRotator CauldronRotation = GetOwner()->GetActorRotation();
1193:             FVector ForwardOffset = CauldronRotation.RotateVector(FVector(150.0f, 0.0f, 0.0f));
1194:             FVector UpOffset = FVector(0.0f, 0.0f, 50.0f);
1195:             SpawnLoc = CauldronLocation + ForwardOffset + UpOffset;
1196: 
1197:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Cauldron location: %s"), *CauldronLocation.ToString());
1198:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Calculated spawn location: %s"), *SpawnLoc.ToString());
1199:         }
1200: 
1201:         bPotionCreatedSuccessfully = SpawnPotionInWorld(CraftingResult, SpawnLoc);
1202:     }
1203: 
1204:     if (!bPotionCreatedSuccessfully)
1205:     {
1206:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to create/spawn potion"));
1207:         return EmptyResult;
1208:     }
1209: 
1210: 
1211:     CraftedPotion = CraftingResult;
1212:     ClearIngredientSlots();
1213: 
1214:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Successfully crafted potion - %s with potency %.2f"),
1215:            *CraftingResult.PotionEssenceTag.ToString(),
1216:            CraftingResult.FinalPotency);
1217: 
1218:     return CraftingResult;
1219: }
1220: 
1221: 
1222: 
1223: bool UCauldronCraftComponent::CanPerformCrafting() const
1224: {
1225: 
1226:     if (!CanCraftPotion())
1227:     {
1228:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanPerformCrafting: Basic crafting requirements not met"));
1229:         return false;
1230:     }
1231: 
1232: 
1233:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
1234:     if (!BasePotionItemDefinition)
1235:     {
1236:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CanPerformCrafting: BasePotionItemDefinition is not set"));
1237:         return false;
1238:     }
1239: 
1240: 
1241: 
1242: 
1243: 
1244: 
1245: 
1246:     return true;
1247: }
1248: 
1249: void UCauldronCraftComponent::ClearIngredientSlots()
1250: {
1251:     if (!GetOwner()->HasAuthority())
1252:     {
1253:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Not authority"));
1254:         return;
1255:     }
1256: 
1257:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Clearing all ingredient slots"));
1258: 
1259: 
1260:     if (BaseIngredient)
1261:     {
1262:         BaseIngredient = nullptr;
1263:         BaseIngredientIcon = nullptr;
1264:         BroadcastBaseIngredientIconSet();
1265:     }
1266: 
1267: 
1268:     if (PrincipalIngredient)
1269:     {
1270:         PrincipalIngredient = nullptr;
1271:         PrincipalIngredientIcon = nullptr;
1272:         BroadcastPrincipalIngredientIconSet();
1273:     }
1274: 
1275: 
1276:     if (ModifierIngredient)
1277:     {
1278:         ModifierIngredient = nullptr;
1279:         ModifierIngredientIcon = nullptr;
1280:         BroadcastModifierIngredientIconSet();
1281:     }
1282: 
1283: 
1284:     CraftedPotion = FPotionResult();
1285: 
1286:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: All ingredient slots cleared"));
1287: }
1288: 
1289: 
1290: 
1291: void UCauldronCraftComponent::DebugTestCrafting()
1292: {
1293:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON DEBUG TEST CRAFTING ==="));
1294: 
1295: 
1296:     PrintIngredientDebugData();
1297: 
1298: 
1299:     UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING CALCULATIONS ---"));
1300:     FPotionResult TestResult = CalculatePotionProperties();
1301: 
1302:     if (TestResult.bIsValid)
1303:     {
1304:         UE_LOG(LogTemp, Warning, TEXT("CALCULATION SUCCESS: %s Potion - Potency: %.2f, Duration: %.2f, Charges: %d"),
1305:                *TestResult.PotionEssenceTag.ToString(),
1306:                TestResult.FinalPotency,
1307:                TestResult.FinalDuration,
1308:                TestResult.FinalCharges);
1309:     }
1310:     else
1311:     {
1312:         UE_LOG(LogTemp, Error, TEXT("CALCULATION FAILED: Invalid potion result"));
1313:     }
1314: 
1315: 
1316:     UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING VALIDATION ---"));
1317:     bool bCanCraft = CanCraftPotion();
1318:     bool bCanPerform = CanPerformCrafting();
1319: 
1320:     UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), bCanCraft ? TEXT("YES") : TEXT("NO"));
1321:     UE_LOG(LogTemp, Warning, TEXT("Can Perform Crafting: %s"), bCanPerform ? TEXT("YES") : TEXT("NO"));
1322: 
1323:     if (bCanPerform)
1324:     {
1325:         UE_LOG(LogTemp, Warning, TEXT("--- ATTEMPTING WORLD SPAWN CRAFT ---"));
1326: 
1327:         FPotionResult CraftResult = CraftPotion(false, nullptr, FVector::ZeroVector);
1328: 
1329:         if (CraftResult.bIsValid)
1330:         {
1331:             UE_LOG(LogTemp, Warning, TEXT("CRAFTING SUCCESS: Potion created and spawned near cauldron"));
1332:         }
1333:         else
1334:         {
1335:             UE_LOG(LogTemp, Error, TEXT("CRAFTING FAILED: No valid result"));
1336:         }
1337:     }
1338:     else
1339:     {
1340:         UE_LOG(LogTemp, Error, TEXT("CRAFTING VALIDATION FAILED: Cannot perform crafting"));
1341:     }
1342: 
1343:     UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG TEST ==="));
1344: }
1345: 
1346: 
1347: 
1348: TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GetBasePotionItemDefinition() const
1349: {
1350: 
1351:     ACauldronAltar* CauldronOwner = Cast<ACauldronAltar>(GetOwner());
1352:     if (!CauldronOwner)
1353:     {
1354:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GetBasePotionItemDefinition: Owner is not a CauldronAltar"));
1355:         return nullptr;
1356:     }
1357: 
1358:     return CauldronOwner->BasePotionItemDefinition;
1359: }

================
File: Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
================
 1: #include "Item/Ritual/RitualFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/CauldronWidgetController.h"
 7: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 8: 
 9: URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
10: {
11: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
12: 	{
13: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
14: 		{
15: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
16: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
17: 			UAttributeSet* AS = PS->GetAttributeSet();
18: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
19: 
20: 			return WitchPTHUD->SetRitualWidgetController(WCParams);
21: 		}
22: 	}
23: 	return nullptr;
24: }
25: 
26: UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
27: {
28: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
29: 	{
30: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
31: 		{
32: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
33: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
34: 			UAttributeSet* AS = PS->GetAttributeSet();
35: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
36: 			return WitchPTHUD->SetCauldronWidgetController(WCParams);
37: 		}
38: 	}
39: 	return nullptr;
40: }

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.generated.h"
 6: 
 7: class IInteractableTarget;
 8: 
 9: 
10: 
11: USTRUCT(BlueprintType)
12: struct FInteractionOption
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UPROPERTY(BlueprintReadWrite)
19: 	TScriptInterface<IInteractableTarget> InteractableTarget;
20: 
21: 
22: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
23: 	FText Text;
24: 
25: 
26: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
27: 	FText SubText;
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
36: 	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;
37: 
38: 
39: 
40: 
41: 
42: 
43: 	UPROPERTY(BlueprintReadOnly)
44: 	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;
45: 
46: 
47: 	UPROPERTY(BlueprintReadOnly)
48: 	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
49: 
50: 
51: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
52: 	bool bSupportsHoldInteraction = false;
53: 
54: 
55: 	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
56: 	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
57: 
58: 
59: 	UPROPERTY(BlueprintReadOnly)
60: 	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;
61: 
62: 
63: 
64: 
65: 
66: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
67: 	TSoftClassPtr<UUserWidget> InteractionWidgetClass;
68: 
69: 
70: 
71: public:
72: 	FORCEINLINE bool operator==(const FInteractionOption& Other) const
73: 	{
74: 		return InteractableTarget == Other.InteractableTarget &&
75: 			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
76: 			TargetAbilitySystem == Other.TargetAbilitySystem &&
77: 			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
78: 			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
79: 			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
80: 			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
81: 
82: 			Text.IdenticalTo(Other.Text) &&
83: 			SubText.IdenticalTo(Other.SubText);
84: 	}
85: 
86: 	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
87: 	{
88: 		return !operator==(Other);
89: 	}
90: 
91: 	FORCEINLINE bool operator<(const FInteractionOption& Other) const
92: 	{
93: 		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
94: 	}
95: };

================
File: Source/WitchPT/Public/Inventory/Collectable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "UObject/Interface.h"
 7: #include "UObject/ObjectPtr.h"
 8: #include "Collectable.generated.h"
 9: template <typename InterfaceType> class TScriptInterface;
10: 
11: 
12: class AActor;
13: class UWitchPTInventoryItemDefinition;
14: class UWitchPTInventoryItemInstance;
15: class UWitchPTInventoryManagerComponent;
16: class UObject;
17: struct FFrame;
18: 
19: USTRUCT(BlueprintType)
20: struct FItemManifest
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 	UPROPERTY(EditAnywhere)
26: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
27: };
28: 
29: 
30: UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
31: class UCollectable : public UInterface
32: {
33: 	GENERATED_BODY()
34: };
35: 
36: 
37: 
38: 
39: class WITCHPT_API ICollectable
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 
46: 
47: 	UFUNCTION(BlueprintCallable)
48: 	virtual FItemManifest GetPickupInventory() const = 0;
49: };
50: 
51: UCLASS()
52: class UCollectableStatics : public UBlueprintFunctionLibrary
53: {
54: 	GENERATED_BODY()
55: 
56: public:
57: 	UCollectableStatics();
58: 
59: 	UFUNCTION(BlueprintPure)
60: 	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);
61: 
62: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
63: 	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
64: };

================
File: Source/WitchPT/Public/Item/BaseInteractionPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/Item.h"
 5: #include "AbilitySystem/Interaction/InteractionOption.h"
 6: #include "GameplayTagContainer.h"
 7: #include "MechanicsInterface.h"
 8: #include "BaseInteractionPosition.generated.h"
 9: 
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: class ABaseInteractableAltar;
17: 
18: 
19: 
20: 
21: UCLASS(Abstract)
22: class WITCHPT_API ABaseInteractionPosition : public AItem
23: {
24:     GENERATED_BODY()
25: 
26: public:
27: 
28:     ABaseInteractionPosition();
29: 
30: 
31:     virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
32:     virtual void BeginPlay() override;
33: 
34: 
35: 
36:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
37: 
38: 
39: 
40: 
41:     UFUNCTION(BlueprintPure, Category = "Interaction")
42:     ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
43: 
44:     UFUNCTION(BlueprintPure, Category = "Interaction")
45:     FGameplayTag GetPositionTag() const { return PositionTag; }
46: 
47:     virtual bool IsOccupied() const;
48: 
49: 
50:     UFUNCTION()
51:     void SetOccupied(ACharacter* Character);
52: 
53:     UFUNCTION()
54:     void SetUnoccupied();
55: 
56:     UFUNCTION()
57:     void SetPositionTag(const FGameplayTag& NewTag);
58: 
59: protected:
60: 
61:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
62:     FGameplayTag PositionTag;
63: 
64: 
65:     UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
66:     bool bIsOccupied = false;
67: 
68: 
69:     UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
70:     TObjectPtr<ACharacter> OccupyingCharacter = nullptr;
71: 
72: 
73:     UPROPERTY()
74:     TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;
75: 
76:     UPROPERTY()
77:     TWeakObjectPtr<AController> InteractingController;
78: 
79: 
80:     UFUNCTION()
81:     void OnRep_IsOccupied();
82: 
83:     UFUNCTION()
84:     void OnRep_OccupyingCharacter();
85: 
86: 
87: 
88:     virtual void HandleInteraction(ACharacter* InteractingCharacter);
89: 
90: private:
91:     void RemoveCharacterFromPosition();
92: };

================
File: Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6: #include "RitualFunctionLibrary.generated.h"
 7: 
 8: class UWitchPTWidgetController;
 9: class URitualWidgetController;
10: 
11: 
12: 
13: UCLASS()
14: class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UFUNCTION(Category="Ritual")
19: 	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
20: 	UFUNCTION(Category="Cauldron")
21: 	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
22: };

================
File: Source/WitchPT/WitchPT.Build.cs
================
 1: using UnrealBuildTool;
 2: 
 3: public class WitchPT : ModuleRules
 4: {
 5: 	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
 6: 	{
 7: 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
 8: 
 9: 		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });
10: 
11: 		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 	}
21: }

================
File: Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/HUD.h"
 5: #include "WitchPTHUD.generated.h"
 6: 
 7: class UCauldronWidgetController;
 8: class UWitchPTWidgetController;
 9: class URitualWidgetController;
10: class UAbilitySystemComponent;
11: class UAttributeSet;
12: class UWitchPTUserWidget;
13: class UInventoryWidgetController;
14: struct FWidgetControllerParams;
15: class UOverlayWidgetController;
16: 
17: 
18: 
19: UCLASS()
20: class WITCHPT_API AWitchPTHUD : public AHUD
21: {
22: 	GENERATED_BODY()
23: public:
24: 	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
25: 	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
26: 	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
27: 	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
28: 
29: 	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
30: 	void InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
31: 	void InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
32: 	void InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
33: 
34: 	void ShowRitualWidget(class ARitualAltar* RitualAltar);
35: 	void HideRitualWidget();
36: 	void ShowInventoryWidget();
37: 	void HideInventoryWidget();
38: 	void ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar);
39: 	void HideCauldronWithInventory();
40: 
41: 
42: 
43: private:
44: 	UPROPERTY()
45: 	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
46: 	UPROPERTY(EditAnywhere)
47: 	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;
48: 
49: 	UPROPERTY()
50: 	TObjectPtr<UWitchPTUserWidget> InventoryWidget;
51: 	UPROPERTY(EditAnywhere)
52: 	TSubclassOf<UWitchPTUserWidget> InventoryWidgetClass;
53: 
54: 	UPROPERTY()
55: 	TObjectPtr<UWitchPTUserWidget> CauldronWidget;
56: 	UPROPERTY(EditAnywhere)
57: 	TSubclassOf<UWitchPTUserWidget> CauldronWidgetClass;
58: 	bool bCauldronWidgetVisible = false;
59: 
60: 	UPROPERTY()
61: 	TObjectPtr<UWitchPTUserWidget> RitualWidget;
62: 	UPROPERTY(EditAnywhere)
63: 	TSubclassOf<UWitchPTUserWidget> RitualWidgetClass;
64: 
65: 	UPROPERTY()
66: 	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
67: 	UPROPERTY(EditAnywhere)
68: 	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;
69: 
70: 	UPROPERTY()
71: 	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
72: 	UPROPERTY(EditAnywhere)
73: 	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;
74: 
75: 	UPROPERTY()
76: 	TObjectPtr<URitualWidgetController> RitualWidgetController;
77: 	UPROPERTY(EditAnywhere)
78: 	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;
79: 
80: 	UPROPERTY()
81: 	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
82: 	UPROPERTY(EditAnywhere)
83: 	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
84: };

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
================
 1: #include "Inventory/WitchPTInventoryItemInstance.h"
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Inventory/WitchPTInventoryItemDefinition.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "Net/UnrealNetwork.h"
 7: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
 8: class FLifetimeProperty;
 9: UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
10: 	:Super(ObjectInitializer)
11: {
12: }
13: 
14: void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
15: {
16: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
17: 
18: 	DOREPLIFETIME(ThisClass, ItemDef);
19: 	DOREPLIFETIME(ThisClass, TotalStackCount);
20: }
21: 
22: 
23: 
24: void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
25: {
26: 	ItemDef = InDef;
27: }
28: 
29: 
30: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
31: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
32: {
33: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
34: 	{
35: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
36: 	}
37: 
38: 	return nullptr;
39: }

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "InteractionOption.h"
  5: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  6: #include "GameplayAbility_Interact.generated.h"
  7: 
  8: class UObject;
  9: struct FFrame;
 10: struct FGameplayAbilityActorInfo;
 11: struct FGameplayEventData;
 12: 
 13: 
 14: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);
 15: 
 16: 
 17: 
 18: 
 19: UCLASS(Abstract)
 20: class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
 21: {
 22: 	GENERATED_BODY()
 23: 	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 24: 	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 25: 
 26: 	UFUNCTION(BlueprintCallable)
 27: 	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
 28: 
 29: 
 30: 	UFUNCTION(BlueprintCallable)
 31: 	void TriggerInteraction();
 32: 
 33: 
 34: 	UFUNCTION(BlueprintCallable)
 35: 	void TriggerHoldInteraction();
 36: 
 37: 
 38: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 39: 	void OnInteractionButtonPressed();
 40: 
 41: 
 42: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 43: 	void OnInteractionButtonReleased();
 44: 
 45: 
 46: 	UFUNCTION()
 47: 	void OnHoldInteractionTimeElapsed();
 48: 
 49: 
 50:     UFUNCTION()
 51:     void CheckInteractionValidity();
 52: 
 53: 
 54:     UFUNCTION(BlueprintCallable, Category = "Interaction")
 55:     void CancelCurrentInteraction();
 56: 
 57: 
 58:     UFUNCTION()
 59:     void OnMaxInteractionTimeElapsed();
 60: 
 61: 
 62: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 63: 	FOnInteractionComplete OnInteractionComplete;
 64: 
 65: 
 66: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 67: 	FOnInteractionComplete OnHoldInteractionComplete;
 68: 
 69: 
 70:     UPROPERTY(BlueprintAssignable, Category = "Interaction")
 71:     FOnInteractionComplete OnInteractionCancelled;
 72: 
 73: protected:
 74: 
 75: 	UPROPERTY(BlueprintReadWrite)
 76: 	TArray<FInteractionOption> CurrentOptions;
 77: 
 78: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
 79: 	float InteractionScanRate = 0.1f;
 80: 
 81: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
 82: 	float InteractionScanRange = 500;
 83: 
 84: 
 85: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
 86: 	float HoldInteractionTime = 1.0f;
 87: 
 88: 
 89:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
 90:     float ValidityCheckRate = 0.1f;
 91: 
 92: 
 93:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
 94:     float MaxInteractionTime = 10.0f;
 95: 
 96: 
 97: 	FTimerHandle HoldInteractionTimerHandle;
 98: 
 99: 
100:     FTimerHandle ValidityCheckTimerHandle;
101: 
102: 
103:     FTimerHandle MaxInteractionTimeTimerHandle;
104: 
105: 
106: 	bool bIsInteractionButtonHeld = false;
107: 
108: 
109: 	float InteractionStartTime = 0.0f;
110: 
111: 
112: 	bool bHoldInteractionFired = false;
113: 
114: 
115:     TScriptInterface<IInteractableTarget> InitialInteractableTarget;
116: 
117: 	UPROPERTY(EditDefaultsOnly)
118: 	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
119: 
120: 
121: };

================
File: Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
================
 1: #include "UI/WidgetControllers/InventoryWidgetController.h"
 2: 
 3: #include "Equipment/WitchPTEquipmentManagerComponent.h"
 4: #include "GameFramework/Character.h"
 5: #include "Inventory/WitchPTInventoryItemInstance.h"
 6: #include "Inventory/WitchPTInventoryManagerComponent.h"
 7: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
 8: #include "Player/WitchPTPlayerController.h"
 9: 
10: class UWitchPTEquipmentInstance;
11: class UWitchPTEquipmentManagerComponent;
12: 
13: void UInventoryWidgetController::BindCallbacksToDependencies()
14: {
15: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
16: 	if (WitchPtPlayerController)
17: 	{
18: 		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
19: 		if (InventoryManager)
20: 		{
21: 			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
22: 			{
23: 				OnItemAddedDelegate.Broadcast(ItemAdded);
24: 			});
25: 			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
26: 			{
27: 				OnItemStackChangedDelegate.Broadcast(ItemAdded);
28: 			});
29: 			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
30: 			{
31: 				OnItemRemovedDelegate.Broadcast(ItemRemoved);
32: 			});
33: 		}
34: 	}
35: }
36: 
37: void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
38: {
39: 	if (!ItemInstance)
40: 	{
41: 		return;
42: 	}
43: 
44: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
45: 	if (!WitchPtPlayerController)
46: 	{
47: 		return;
48: 	}
49: 
50: 	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
51: 	if (!InventoryManager)
52: 	{
53: 		return;
54: 	}
55: 
56: 	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
57: 
58: 
59: 	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
60: 	{
61: 		InventoryManager->Server_RemoveItemInstance(ItemInstance);
62: 	}
63: 	else
64: 	{
65: 
66: 		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
67: 	}
68: }
69: 
70: void UInventoryWidgetController::EquipItem(UWitchPTInventoryItemInstance* ItemInstance)
71: {
72: 	if (ItemInstance)
73: 	{
74: 		ACharacter* OwningCharacter = Cast<ACharacter>(PlayerController->GetPawn());
75: 		if (OwningCharacter)
76: 		{
77: 			UWitchPTEquipmentManagerComponent* EquipmentManager = OwningCharacter->FindComponentByClass<UWitchPTEquipmentManagerComponent>();
78: 			if (EquipmentManager)
79: 			{
80: 				UWitchPTEquipmentInstance* EquipmentInstance = EquipmentManager->FindEquipmentByInventoryItem(ItemInstance);
81: 				if (EquipmentInstance)
82: 				{
83: 					EquipmentManager->UnequipItem(EquipmentInstance);
84: 				}
85: 				else
86: 				{
87: 					const UWitchPTInventoryItemFragment* BaseFragment = ItemInstance->FindFragmentByClass(UWitchPTInventoryItemFragment_EquippableItem::StaticClass());
88: 					const UWitchPTInventoryItemFragment_EquippableItem* EquippableFragment = Cast<const UWitchPTInventoryItemFragment_EquippableItem>(BaseFragment);
89: 					EquipmentManager->EquipItem(EquippableFragment->EquipmentDefinition);
90: 				}
91: 			}
92: 		}
93: 		else
94: 		{
95: 			UE_LOG(LogTemp, Warning, TEXT("Owning character is not a valid ACharacter instance."));
96: 		}
97: 	}
98: }

================
File: Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "CauldronWidgetController.generated.h"
 6: 
 7: class ACauldronAltar;
 8: class UWitchPTInventoryItemInstance;
 9: 
10: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
13: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
14: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
16: 
17: 
18: 
19: UCLASS(BlueprintType, Blueprintable)
20: class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
21: {
22: 	GENERATED_BODY()
23: public:
24: 	UCauldronWidgetController();
25: 	virtual void BroadcastInitialValues() override;
26: 	virtual void BindCallbacksToDependencies() override;
27: 	void UnbindCallbacksFromDependencies();
28: 
29: 
30: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
31: 	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
32: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
33: 	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
34: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
35: 	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
36: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
37: 	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
38: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
39: 	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
40: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
41: 	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;
42: 
43: 	UFUNCTION(Category = "Cauldron")
44: 	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);
45: 
46: 
47: 	UFUNCTION(BlueprintPure, Category = "Cauldron")
48: 	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
49: 
50: 
51: protected:
52: 
53: 	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
54: 	TObjectPtr<ACauldronAltar> CauldronAltar;
55: 
56: 	UFUNCTION(Category = "Cauldron")
57: 	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
58: 	UFUNCTION(Category = "Cauldron")
59: 	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
60: 	UFUNCTION(Category = "Cauldron")
61: 	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
62: 	UFUNCTION(Category = "Cauldron")
63: 	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
64: 	UFUNCTION(Category = "Cauldron")
65: 	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
66: 	UFUNCTION(Category = "Cauldron")
67: 	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
68: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "InventoryWidgetController.generated.h"
 6: 
 7: class UWitchPTInventoryItemInstance;
 8: 
 9: 
10: 
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);
13: 
14: UCLASS(BlueprintType, Blueprintable)
15: class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 	UFUNCTION(BlueprintCallable)
21: 	virtual void BindCallbacksToDependencies() override;
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 	UFUNCTION(BlueprintCallable, Category = "Inventory")
30: 	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);
31: 
32: 	UFUNCTION(BlueprintCallable, Category = "Equipment")
33: 	void EquipItem(UWitchPTInventoryItemInstance* ItemInstance);
34: 
35: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
36: 	FOnItemAddedSignature OnItemAddedDelegate;
37: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
38: 	FOnItemAddedSignature OnItemStackChangedDelegate;
39: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
40: 	FOnItemRemovedSignature OnItemRemovedDelegate;
41: };

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
================
  1: #include "AbilitySystem/Interaction/GameplayAbility_Interact.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  5: #include "AbilitySystem/Interaction/InteractionStatics.h"
  6: #include "NativeGameplayTags.h"
  7: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  8: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  9: #include "Engine/World.h"
 10: #include "Player/WitchPTPlayerController.h"
 11: 
 12: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
 13: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");
 14: 
 15: UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
 16: 	: Super(ObjectInitializer)
 17: {
 18: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
 19: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 20: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 21: }
 22: 
 23: void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
 24: 	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
 25: 	const FGameplayEventData* TriggerEventData)
 26: {
 27: 	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
 28: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 29: 	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
 30: 	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
 31: 	{
 32: 
 33: 		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
 34: 		Task->ReadyForActivation();
 35: 
 36: 	}
 37: }
 38: 
 39: void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
 40: {
 41: 
 42: 	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
 43: 	{
 44: 
 45: 
 46: 		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
 47: 
 48: 		CurrentOptions = InteractiveOptions;
 49: 
 50: 		for (const FInteractionOption& InteractionOption : InteractiveOptions)
 51: 		{
 52: 			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 53: 
 54: 			if (InteractableTargetActor)
 55: 			{
 56: 				FString ActorName = InteractableTargetActor->GetName();
 57: 				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
 58: 			}
 59: 
 60: 
 61: 		}
 62: 		if (InteractiveOptions.Num() == 0)
 63: 		{
 64: 			WitchPt->HUDWidget->HidePickupMessage();
 65: 		}
 66: 
 67: 	}
 68: 
 69: 	CurrentOptions = InteractiveOptions;
 70: }
 71: 
 72: void UGameplayAbility_Interact::TriggerInteraction()
 73: {
 74: 	if (CurrentOptions.Num() == 0)
 75: 	{
 76: 		return;
 77: 	}
 78: 
 79: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 80: 	if (AbilitySystem)
 81: 	{
 82: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 83: 
 84: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 85: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 86: 
 87: 
 88: 
 89: 		FGameplayEventData Payload;
 90: 		Payload.EventTag = TAG_Ability_Interaction_Activate;
 91: 		Payload.Instigator = Instigator;
 92: 		Payload.Target = InteractableTargetActor;
 93: 
 94: 
 95: 
 96: 
 97: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
 98: 
 99: 
100: 
101: 
102: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
103: 
104: 
105: 		FGameplayAbilityActorInfo ActorInfo;
106: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
107: 
108: 
109: 
110: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
111: 			InteractionOption.TargetInteractionAbilityHandle,
112: 			&ActorInfo,
113: 			TAG_Ability_Interaction_Activate,
114: 			&Payload,
115: 			*InteractionOption.TargetAbilitySystem
116: 		);
117: 
118: 
119: 		OnInteractionComplete.Broadcast();
120: 	}
121: }
122: 
123: void UGameplayAbility_Interact::TriggerHoldInteraction()
124: {
125: 	if (CurrentOptions.Num() == 0)
126: 	{
127: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
128: 		OnInteractionCancelled.Broadcast();
129: 		return;
130: 	}
131: 
132: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
133: 	if (AbilitySystem)
134: 	{
135: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
136: 
137: 
138: 		if (!InteractionOption.bSupportsHoldInteraction)
139: 		{
140: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
141: 
142: 			TriggerInteraction();
143: 			return;
144: 		}
145: 
146: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
147: 
148: 		AActor* Instigator = GetAvatarActorFromActorInfo();
149: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
150: 
151: 
152: 		FGameplayEventData Payload;
153: 		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
154: 		Payload.Instigator = Instigator;
155: 		Payload.Target = InteractableTargetActor;
156: 
157: 
158: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);
159: 
160: 
161: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
162: 
163: 
164: 		FGameplayAbilityActorInfo ActorInfo;
165: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
166: 
167: 
168: 		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
169: 
170: 
171: 		if (!AbilityHandle.IsValid())
172: 		{
173: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
174: 			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
175: 		}
176: 		else
177: 		{
178: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
179: 		}
180: 
181: 
182: 
183: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
184: 			AbilityHandle,
185: 			&ActorInfo,
186: 			TAG_Ability_Interaction_Hold_Activate,
187: 			&Payload,
188: 			*InteractionOption.TargetAbilitySystem
189: 		);
190: 
191: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
192: 
193: 
194: 		OnHoldInteractionComplete.Broadcast();
195: 	}
196: }
197: 
198: void UGameplayAbility_Interact::OnInteractionButtonPressed()
199: {
200: 	if (CurrentOptions.Num() == 0)
201: 	{
202: 
203: 		OnInteractionCancelled.Broadcast();
204: 		return;
205: 	}
206: 
207: 
208: 	bIsInteractionButtonHeld = true;
209: 	bHoldInteractionFired = false;
210: 	InteractionStartTime = GetWorld()->GetTimeSeconds();
211: 
212: 
213: 	if (CurrentOptions.Num() > 0)
214: 	{
215: 		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
216: 
217: 	}
218: 
219: 
220: 	GetWorld()->GetTimerManager().SetTimer(
221: 		HoldInteractionTimerHandle,
222: 		this,
223: 		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
224: 		HoldInteractionTime,
225: 		false
226: 	);
227: 
228: 
229: 	GetWorld()->GetTimerManager().SetTimer(
230: 		ValidityCheckTimerHandle,
231: 		this,
232: 		&UGameplayAbility_Interact::CheckInteractionValidity,
233: 		ValidityCheckRate,
234: 		true
235: 	);
236: 
237: 
238: 	GetWorld()->GetTimerManager().SetTimer(
239: 		MaxInteractionTimeTimerHandle,
240: 		this,
241: 		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
242: 		MaxInteractionTime,
243: 		false
244: 	);
245: 
246: 
247: 
248: }
249: 
250: void UGameplayAbility_Interact::OnInteractionButtonReleased()
251: {
252: 
253: 
254: 	if (!bIsInteractionButtonHeld)
255: 	{
256: 
257: 		return;
258: 	}
259: 
260: 	bIsInteractionButtonHeld = false;
261: 
262: 
263: 	if (GetWorld())
264: 	{
265: 
266: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
267: 		{
268: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
269: 		}
270: 
271: 
272: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
273: 		{
274: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
275: 		}
276: 
277: 
278: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
279: 		{
280: 
281: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
282: 
283: 
284: 			if (bHoldInteractionFired)
285: 			{
286: 
287: 				return;
288: 			}
289: 
290: 
291: 			float CurrentTime = GetWorld()->GetTimeSeconds();
292: 			float HoldTime = CurrentTime - InteractionStartTime;
293: 
294: 
295: 
296: 			if (HoldTime < HoldInteractionTime)
297: 			{
298: 
299: 
300: 				TriggerInteraction();
301: 
302: 
303: 
304: 
305: 
306: 			}
307: 		}
308: 		else
309: 		{
310: 
311: 		}
312: 	}
313: 
314: 
315: 	InitialInteractableTarget = nullptr;
316: }
317: 
318: void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
319: {
320: 
321: 
322: 	if (bIsInteractionButtonHeld)
323: 	{
324: 
325: 
326: 		bHoldInteractionFired = true;
327: 
328: 
329: 
330: 		TriggerHoldInteraction();
331: 
332: 
333: 
334: 
335: 
336: 	}
337: 	else
338: 	{
339: 
340: 	}
341: }
342: 
343: void UGameplayAbility_Interact::CheckInteractionValidity()
344: {
345: 
346: 	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
347: 	{
348: 		return;
349: 	}
350: 
351: 
352: 	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
353: 
354: 
355: 	bool bHasValidInteraction = false;
356: 
357: 	if (CurrentOptions.Num() > 0)
358: 	{
359: 
360: 		for (const FInteractionOption& Option : CurrentOptions)
361: 		{
362: 			if (Option.InteractableTarget == InitialInteractableTarget)
363: 			{
364: 				bHasValidInteraction = true;
365: 				break;
366: 			}
367: 		}
368: 
369: 
370: 		if (bHasValidInteraction)
371: 		{
372: 			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
373: 		}
374: 		else
375: 		{
376: 
377: 			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
378: 			AActor* CurrentActor = CurrentOptions.Num() > 0 ?
379: 				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
380: 
381: 			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"),
382: 				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
383: 				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
384: 		}
385: 	}
386: 	else
387: 	{
388: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
389: 	}
390: 
391: 
392: 	if (!bHasValidInteraction)
393: 	{
394: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
395: 		CancelCurrentInteraction();
396: 	}
397: }
398: 
399: void UGameplayAbility_Interact::CancelCurrentInteraction()
400: {
401: 
402: 	if (!bIsInteractionButtonHeld)
403: 	{
404: 		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
405: 		return;
406: 	}
407: 
408: 
409: 	FString InitialObjectName = TEXT("Desconocido");
410: 	if (InitialInteractableTarget.GetInterface())
411: 	{
412: 		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
413: 		if (InitialActor)
414: 		{
415: 			InitialObjectName = InitialActor->GetName();
416: 		}
417: 	}
418: 
419: 	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
420: 
421: 
422: 	if (GetWorld())
423: 	{
424: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
425: 		{
426: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
427: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
428: 		}
429: 
430: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
431: 		{
432: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
433: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
434: 		}
435: 
436: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
437: 		{
438: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
439: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
440: 		}
441: 	}
442: 
443: 
444: 	bIsInteractionButtonHeld = false;
445: 	bHoldInteractionFired = false;
446: 
447: 
448: 	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
449: 	InitialInteractableTarget = nullptr;
450: 
451: 
452: 	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
453: 
454: 
455: 	OnInteractionCancelled.Broadcast();
456: }
457: 
458: void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
459: {
460: 
461: 	if (bIsInteractionButtonHeld)
462: 	{
463: 		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
464: 		CancelCurrentInteraction();
465: 
466: 
467: 		OnInteractionCancelled.Broadcast();
468: 	}
469: }

================
File: Source/WitchPT/Private/Item/RitualPosition.cpp
================
  1: #include "Item/RitualPosition.h"
  2: #include "Net/UnrealNetwork.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/RitualAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "AbilitySystemComponent.h"
  7: #include "AbilitySystemBlueprintLibrary.h"
  8: #include "FWitchPTGameplayTags.h"
  9: #include "GameplayEffect.h"
 10: #include "GameFramework/CharacterMovementComponent.h"
 11: #include "Components/CapsuleComponent.h"
 12: #include "Kismet/GameplayStatics.h"
 13: #include "Character/Components/WitchPTMechanicComponent.h"
 14: 
 15: 
 16: ARitualPosition::ARitualPosition()
 17: {
 18: 
 19: }
 20: 
 21: void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 22: {
 23: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 24: 
 25: 	DOREPLIFETIME(ARitualPosition, RitualAltar);
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: void ARitualPosition::BeginPlay()
 38: {
 39: 	Super::BeginPlay();
 40: 
 41: 
 42: 
 43: }
 44: 
 45: 
 46: void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 47: {
 48: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: }
 86: 
 87: ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
 88: {
 89: 	if (RitualAltar)
 90: 	{
 91: 		return RitualAltar;
 92: 	}
 93: 	return nullptr;
 94: }
 95: 
 96: bool ARitualPosition::IsOccupied_Implementation()
 97: {
 98: 	return bIsOccupied;
 99: }
100: 
101: 
102: void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
103: {
104: 	Super::HandleInteraction(InteractingCharacter);
105: 
106: 	if (!InteractingCharacter || !RitualAltar)
107: 	{
108: 		return;
109: 	}
110: 
111: }

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Systems/GameplayTagStack.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "WitchPTInventoryItemInstance.generated.h"
 7: class UWitchPTInventoryItemFragment;
 8: class UWitchPTInventoryItemDefinition;
 9: struct FFrame;
10: struct FGameplayTag;
11: 
12: 
13: 
14: 
15: UCLASS(BlueprintType)
16: class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
21: 	friend struct FWitchPTInventoryList;
22: 
23: 
24: 	virtual bool IsSupportedForNetworking() const override { return true; }
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable)
29: 	int32 GetTotalStackCount() const { return TotalStackCount; }
30: 
31: 	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
32: 	UFUNCTION(BlueprintCallable)
33: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
34: 	{
35: 		return ItemDef;
36: 	}
37: 
38: 	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
39: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
40: 
41: 	template <typename ResultClass>
42: 	const ResultClass* FindFragmentByClass() const
43: 	{
44: 		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
45: 	}
46: 
47: 	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);
48: 
49: 
50: private:
51: 	UPROPERTY(Replicated)
52: 	int32 TotalStackCount{0};
53: 
54: 	UPROPERTY(Replicated)
55: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
56: 
57: };

================
File: Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
================
  1: #include "UI/HUD/WitchPTHUD.h"
  2: 
  3: #include "Inventory/WitchPTInventoryManagerComponent.h"
  4: #include "Player/WitchPTPlayerController.h"
  5: #include "UI/WidgetControllers/CauldronWidgetController.h"
  6: #include "UI/WidgetControllers/InventoryWidgetController.h"
  7: #include "UI/WidgetControllers/OverlayWidgetController.h"
  8: #include "UI/WidgetControllers/RitualWidgetController.h"
  9: #include "UI/Widgets/WitchPTUserWidget.h"
 10: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 11: 
 12: UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
 13: {
 14: 	if (OverlayWidgetController == nullptr)
 15: 	{
 16: 		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
 17: 		OverlayWidgetController->SetWidgetControllerParams(WCParams);
 18: 		OverlayWidgetController->BindCallbacksToDependencies();
 19: 	}
 20: 	return OverlayWidgetController;
 21: }
 22: 
 23: UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
 24: {
 25: 	if (CauldronWidgetController == nullptr)
 26: 	{
 27: 		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
 28: 		CauldronWidgetController->SetWidgetControllerParams(WCParams);
 29: 
 30: 	}
 31: 	return CauldronWidgetController;
 32: }
 33: 
 34: UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
 35: {
 36: 	if (InventoryWidgetController == nullptr)
 37: 	{
 38: 		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
 39: 		InventoryWidgetController->SetWidgetControllerParams(WCParams);
 40: 		InventoryWidgetController->BindCallbacksToDependencies();
 41: 	}
 42: 	return InventoryWidgetController;
 43: }
 44: 
 45: URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
 46: {
 47: 	if (RitualWidgetController == nullptr)
 48: 	{
 49: 		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
 50: 		RitualWidgetController->SetWidgetControllerParams(WCParams);
 51: 	}
 52: 	return RitualWidgetController;
 53: }
 54: 
 55: void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
 56: {
 57: 	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
 58: 	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));
 59: 
 60: 
 61: 	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
 62: 	OverlayWidget = Cast<UWitchPTUserWidget>(Widget);
 63: 
 64: 	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
 65: 	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);
 66: 
 67: 	OverlayWidget->SetWidgetController(WidgetController);
 68: 	WidgetController->BroadcastInitialValues();
 69: 	Widget->AddToViewport();
 70: 
 71: 
 72: 	InitRitualWidget(PC, PS, ASC, AS);
 73: 
 74: 	InitInventoryWidget(PC, PS, ASC, AS);
 75: 
 76: 	InitCauldronWidget(PC, PS, ASC, AS);
 77: 
 78: }
 79: 
 80: void AWitchPTHUD::InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
 81: 	UAttributeSet* AS)
 82: {
 83: 	if (RitualWidgetClass)
 84: 	{
 85: 
 86: 		UUserWidget* RitualWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), RitualWidgetClass);
 87: 		RitualWidget = Cast<UWitchPTUserWidget>(RitualWidgetInstance);
 88: 
 89: 		if (RitualWidget)
 90: 		{
 91: 			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
 92: 
 93: 			URitualWidgetController* RitualController = SetRitualWidgetController(WidgetControllerParams);
 94: 			RitualWidget->SetWidgetController(RitualController);
 95: 
 96: 
 97: 			RitualWidgetInstance->AddToViewport();
 98: 			RitualWidgetInstance->SetVisibility(ESlateVisibility::Collapsed);
 99: 		}
100: 	}
101: }
102: 
103: void AWitchPTHUD::InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
104: 	UAttributeSet* AS)
105: {
106: 	if (InventoryWidgetClass && !InventoryWidget)
107: 	{
108: 		UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), InventoryWidgetClass);
109: 		InventoryWidget = Cast<UWitchPTUserWidget>(Widget);
110: 
111: 		if (InventoryWidget)
112: 		{
113: 			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
114: 			UInventoryWidgetController* Controller = SetInventoryWidgetController(WidgetControllerParams);
115: 			InventoryWidget->SetWidgetController(Controller);
116: 			Widget->AddToViewport();
117: 			Widget->SetVisibility(ESlateVisibility::Collapsed);
118: 		}
119: 	}
120: }
121: 
122: void AWitchPTHUD::InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
123: {
124: 	if (CauldronWidgetClass && !CauldronWidget)
125: 	{
126: 		UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), CauldronWidgetClass);
127: 		CauldronWidget = Cast<UWitchPTUserWidget>(Widget);
128: 
129: 		if (CauldronWidget)
130: 		{
131: 			const FWidgetControllerParams WCParams(PC, PS, ASC, AS);
132: 			UCauldronWidgetController* Controller = SetCauldronWidgetController(WCParams);
133: 			CauldronWidget->SetWidgetController(Controller);
134: 			Widget->AddToViewport();
135: 			Widget->SetVisibility(ESlateVisibility::Collapsed);
136: 		}
137: 	}
138: }
139: 
140: void AWitchPTHUD::ShowRitualWidget(class ARitualAltar* RitualAltar)
141: {
142: 	if (RitualWidget && RitualWidgetController)
143: 	{
144: 
145: 
146: 		RitualWidgetController->SetRitualAltar(RitualAltar);
147: 
148: 
149: 		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
150: 		if (RitualUserWidget)
151: 		{
152: 			RitualUserWidget->ShowForRitual(RitualAltar);
153: 		}
154: 
155: 
156: 		RitualWidget->SetVisibility(ESlateVisibility::Visible);
157: 
158: 
159: 		APlayerController* PC = GetOwningPlayerController();
160: 		if (PC)
161: 		{
162: 			FInputModeGameAndUI InputMode;
163: 			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
164: 			InputMode.SetHideCursorDuringCapture(false);
165: 			PC->SetInputMode(InputMode);
166: 			PC->bShowMouseCursor = true;
167: 		}
168: 	}
169: }
170: 
171: void AWitchPTHUD::HideRitualWidget()
172: {
173: 	if (RitualWidget)
174: 	{
175: 
176: 		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
177: 		if (RitualUserWidget)
178: 		{
179: 			RitualUserWidget->HideFromRitual();
180: 		}
181: 
182: 
183: 		RitualWidget->SetVisibility(ESlateVisibility::Collapsed);
184: 
185: 
186: 		if (RitualWidgetController)
187: 		{
188: 			RitualWidgetController->SetRitualAltar(nullptr);
189: 		}
190: 
191: 
192: 		APlayerController* PC = GetOwningPlayerController();
193: 		if (PC)
194: 		{
195: 			PC->SetInputMode(FInputModeGameOnly());
196: 			PC->bShowMouseCursor = false;
197: 		}
198: 	}
199: }
200: 
201: void AWitchPTHUD::ShowInventoryWidget()
202: {
203: 	if (InventoryWidget)
204: 	{
205: 		InventoryWidget->SetVisibility(ESlateVisibility::Visible);
206: 
207: 		APlayerController* PC = GetOwningPlayerController();
208: 		if (PC)
209: 		{
210: 			FInputModeGameAndUI InputMode;
211: 			PC->SetInputMode(InputMode);
212: 			PC->SetShowMouseCursor(true);
213: 		}
214: 	}
215: 
216: }
217: 
218: void AWitchPTHUD::HideInventoryWidget()
219: {
220: 	if (InventoryWidget)
221: 	{
222: 		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
223: 
224: 		APlayerController* PC = GetOwningPlayerController();
225: 		if (PC)
226: 		{
227: 			PC->SetInputMode(FInputModeGameOnly());
228: 			PC->SetShowMouseCursor(false);
229: 		}
230: 	}
231: }
232: 
233: void AWitchPTHUD::ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar)
234: {
235: 	if (CauldronWidget && InventoryWidget && CauldronWidgetController)
236: 	{
237: 
238: 		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
239: 		CauldronWidgetController->BindCallbacksToDependencies();
240: 		CauldronWidgetController->BroadcastInitialValues();
241: 
242: 
243: 		CauldronWidget->SetVisibility(ESlateVisibility::Visible);
244: 
245: 		bCauldronWidgetVisible = true;
246: 
247: 
248: 		APlayerController* PC = GetOwningPlayerController();
249: 		if (PC)
250: 		{
251: 			FInputModeGameAndUI InputMode;
252: 			PC->SetInputMode(InputMode);
253: 			PC->SetShowMouseCursor(true);
254: 		}
255: 	}
256: }
257: 
258: void AWitchPTHUD::HideCauldronWithInventory()
259: {
260: 	if (CauldronWidget && InventoryWidget)
261: 	{
262: 		CauldronWidget->SetVisibility(ESlateVisibility::Collapsed);
263: 		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
264: 
265: 		bCauldronWidgetVisible = false;
266: 
267: 
268: 		if (CauldronWidgetController)
269: 		{
270: 			CauldronWidgetController->SetCauldronAltar(nullptr);
271: 			CauldronWidgetController->UnbindCallbacksFromDependencies();
272: 		}
273: 
274: 
275: 		APlayerController* PC = GetOwningPlayerController();
276: 		if (PC)
277: 		{
278: 			PC->SetInputMode(FInputModeGameOnly());
279: 			PC->SetShowMouseCursor(false);
280: 		}
281: 	}
282: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
================
 1: #include "UI/WidgetControllers/CauldronWidgetController.h"
 2: 
 3: #include "Item/CauldronAltar.h"
 4: #include "Item/Components/CauldronCraftComponent.h"
 5: 
 6: UCauldronWidgetController::UCauldronWidgetController()
 7: {
 8: }
 9: 
10: void UCauldronWidgetController::BroadcastInitialValues()
11: {
12: 	if(CauldronAltar)
13: 	{
14: 		OnBaseIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredient());
15: 		OnBaseIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredientIcon());
16: 		OnPrincipalIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredient());
17: 		OnPrincipalIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredientIcon());
18: 		OnModifierIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredient());
19: 		OnModifierIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredientIcon());
20: 	}
21: 
22: }
23: 
24: void UCauldronWidgetController::BindCallbacksToDependencies()
25: {
26: 	Super::BindCallbacksToDependencies();
27: 	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
28: 	{
29: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
30: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
31: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
32: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
33: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
34: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
35: 	}
36: }
37: 
38: void UCauldronWidgetController::UnbindCallbacksFromDependencies()
39: {
40: 	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
41: 	{
42: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
43: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
44: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
45: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
46: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
47: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
48: 	}
49: }
50: void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
51: {
52: 	if (InCauldronAltar != nullptr)
53: 	{
54: 		CauldronAltar = InCauldronAltar;
55: 	}
56: 
57: }
58: 
59: void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
60: {
61: 	OnBaseIngredientSet.Broadcast(IngredientInstance);
62: }
63: 
64: void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
65: {
66: 	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
67: }
68: 
69: void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
70: {
71: 	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
72: }
73: 
74: void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
75: {
76: 	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
77: }
78: 
79: void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
80: {
81: 	OnModifierIngredientSet.Broadcast(IngredientInstance);
82: }
83: 
84: void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
85: {
86: 	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
87: }

================
File: Source/WitchPT/Public/Character/WitchPTCharacter.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "Item/CauldronAltar.h"
 6: #include "Item/MechanicsInterface.h"
 7: #include "Blueprint/UserWidget.h"
 8: #include "Components/WidgetComponent.h"
 9: #include "UObject/ConstructorHelpers.h"
10: #include "WitchPTCharacter.generated.h"
11: 
12: class UWitchPTEquipmentManagerComponent;
13: class UWitchPTMechanicComponent;
14: class ACauldronAltar;
15: class ARitualPosition;
16: 
17: UCLASS()
18: class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
19: {
20: 	GENERATED_BODY()
21: 
22: public:
23: 
24: 	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
25: 	virtual void PossessedBy(AController* NewController) override;
26: 	virtual void OnRep_PlayerState() override;
27: 
28: 	virtual void InitAbilityActorInfo() override;
29: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
30: 	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
31: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
32: 	TObjectPtr<UWitchPTEquipmentManagerComponent> EquipmentManagerComponent;
33: 
34: 
35: };

================
File: Source/WitchPT/Public/Item/RitualPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "MechanicsInterface.h"
 7: #include "PositionInterface.h"
 8: #include "RitualPosition.generated.h"
 9: 
10: 
11: class ARitualAltar;
12: class UAbilitySystemComponent;
13: struct FGameplayAbilitySpec;
14: class AController;
15: class UGameplayAbility;
16: class UBoxComponent;
17: class ACharacter;
18: 
19: UCLASS()
20: class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 
26: 	ARitualPosition();
27: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
28: 
29: 
30: 	virtual void BeginPlay() override;
31: 
32: 
33: 
34: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38: 	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
39: 
40: 
41: 	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
42: 	virtual bool IsOccupied_Implementation() override;
43: 
44: protected:
45: 
46: 	UPROPERTY(EditInstanceOnly, Replicated)
47: 	TObjectPtr<ARitualAltar> RitualAltar;
48: 
49: 
50: 	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
51: 
52: private:
53: 
54: 
55: };

================
File: Source/WitchPT/Public/FWitchPTGameplayTags.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: 
  6: 
  7: 
  8: 
  9: 
 10: 
 11: 
 12: struct FWitchPTGameplayTags
 13: {
 14: public:
 15: 	static FWitchPTGameplayTags& Get() { return GameplayTags; }
 16: 	static void InitializeGameplayTags();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 	FGameplayTag Attributes_Primary_Health;
 23: 	FGameplayTag Attributes_Primary_Age;
 24: 	FGameplayTag Attributes_Secondary_Mana;
 25: 	FGameplayTag Attributes_Secondary_Stamina;
 26: 
 27: 	FGameplayTag Character_State_Movement_Sprinting;
 28: 	FGameplayTag Character_State_Movement_Crouching;
 29: 	FGameplayTag Character_State_Movement_MovingToPosition;
 30: 	FGameplayTag Character_State_Dead;
 31: 	FGameplayTag Character_State_Aim;
 32: 	FGameplayTag Character_State_Blocked;
 33: 
 34: 	FGameplayTag Character_State_Cauldron_InPosition;
 35: 	FGameplayTag Character_State_Cauldron_Carrying;
 36: 	FGameplayTag Character_State_Cauldron_Placing;
 37: 	FGameplayTag Character_State_Cauldron_InGame;
 38: 	FGameplayTag Character_State_Cauldron_BrewingPotion;
 39: 
 40: 	FGameplayTag Character_State_Ritual_InPosition;
 41: 	FGameplayTag Character_State_Ritual_InGame;
 42: 
 43: 
 44: 	FGameplayTag Ability_Interact;
 45: 	FGameplayTag Ability_Sprint;
 46: 	FGameplayTag Ability_Jump;
 47: 	FGameplayTag Ability_Crouch;
 48: 	FGameplayTag Ability_Ritual_GoToPosition;
 49: 	FGameplayTag Ability_Ritual_ParticipatingInRitual;
 50: 	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
 51: 	FGameplayTag Ability_Ritual_Start;
 52: 	FGameplayTag Ability_Ritual_SendInput;
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
 60: 	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
 61: 	FGameplayTag Ability_Cauldron_CarryingCauldron;
 62: 	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
 63: 	FGameplayTag Ability_Cauldron_SetInPlace;
 64: 	FGameplayTag Ability_Cauldron_CancelSetInPlace;
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 	FGameplayTag InputTag_LMB;
 73: 	FGameplayTag InputTag_RMB;
 74: 	FGameplayTag InputTag_1;
 75: 	FGameplayTag InputTag_2;
 76: 	FGameplayTag InputTag_3;
 77: 	FGameplayTag InputTag_4;
 78: 	FGameplayTag InputTag_5;
 79: 	FGameplayTag InputTag_6;
 80: 	FGameplayTag InputTag_7;
 81: 	FGameplayTag InputTag_8;
 82: 	FGameplayTag InputTag_9;
 83: 	FGameplayTag InputTag_0;
 84: 	FGameplayTag InputTag_Ctrl;
 85: 	FGameplayTag InputTag_Alt;
 86: 	FGameplayTag InputTag_Shift;
 87: 	FGameplayTag InputTag_Tab;
 88: 
 89: 
 90: 
 91: 	FGameplayTag Ritual_Position_1;
 92: 	FGameplayTag Ritual_Position_2;
 93: 	FGameplayTag Ritual_Position_3;
 94: 	FGameplayTag Ritual_Position_4;
 95: 
 96: 	FGameplayTag Ritual_Input_Up;
 97: 	FGameplayTag Ritual_Input_Down;
 98: 	FGameplayTag Ritual_Input_Left;
 99: 	FGameplayTag Ritual_Input_Right;
100: 
101: 
102: 	FGameplayTag Event_Ritual_InputSuccess;
103: 	FGameplayTag Event_Ritual_InputFailure;
104: 	FGameplayTag Event_Ritual_SequenceSuccess;
105: 	FGameplayTag Event_Ritual_SequenceFailure;
106: 	FGameplayTag Event_Ritual_CatastrophicFailure;
107: 
108: 
109: 
110: 
111: 	FGameplayTag Event_Ritual_InputReceived;
112: 	FGameplayTag Event_Ritual_TurnAdvanced;
113: 	FGameplayTag Event_Ritual_SequenceFail;
114: 	FGameplayTag Event_Ritual_CatastrophicFail;
115: 
116: 
117: 	FGameplayTag Cauldron_State_Empty;
118: 	FGameplayTag Cauldron_State_Full;
119: 	FGameplayTag Cauldron_State_PotionReady;
120: 	FGameplayTag Event_Cauldron_CharacterPositioned;
121: 
122: 
123: 
124: 	FGameplayTag Communication_Message;
125: 
126: 
127: 	FGameplayTag Item;
128: 	FGameplayTag Item_Consumable;
129: 	FGameplayTag Item_Consumable_Potion;
130: 	FGameplayTag Item_Consumable_Potion_Tier_0;
131: 	FGameplayTag Item_Consumable_Potion_Tier_1;
132: 	FGameplayTag Item_Consumable_Potion_Tier_2;
133: 	FGameplayTag Item_Consumable_Potion_Tier_3;
134: 
135: 	FGameplayTag Item_Consumable_Ingredient;
136: 	FGameplayTag Item_Consumable_Ingredient_Tier_0;
137: 	FGameplayTag Item_Consumable_Ingredient_Tier_1;
138: 	FGameplayTag Item_Consumable_Ingredient_Tier_2;
139: 	FGameplayTag Item_Consumable_Ingredient_Tier_3;
140: 
141: 
142: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
143: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
144: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;
145: 
146: 	FGameplayTag Item_Consumable_Ingredient_Category_Base;
147: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
148: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
149: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
150: 
151: 
152: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
153: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
154: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
155: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
164: 
165: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
166: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
167: 
168: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
169: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
170: 
171: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
172: 
173: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
174: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
175: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
176: 
177: 
178: 
179: 
180: 
181: private:
182: 	static FWitchPTGameplayTags GameplayTags;
183: 
184: 
185: };

================
File: Source/WitchPT/Public/FWitchPTGameplayTags.cpp
================
  1: #include "FWitchPTGameplayTags.h"
  2: 
  3: #include "GameplayTagsManager.h"
  4: 
  5: FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;
  6: 
  7: void FWitchPTGameplayTags::InitializeGameplayTags()
  8: {
  9: 	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
 10: 	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
 11: 	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
 12: 	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
 13: 	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
 14: 	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
 15: 	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
 16: 	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
 17: 	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
 18: 	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
 19: 	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
 20: 	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
 21: 	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
 22: 	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
 23: 	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
 24: 	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
 25: 	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));
 26: 
 27: 	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
 28: 	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
 29: 	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
 30: 	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
 31: 
 32: 	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
 33: 	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
 34: 	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
 35: 	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
 36: 	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
 37: 
 38: 	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
 39: 	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
 40: 	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
 41: 	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
 42: 	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
 43: 	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
 44: 	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));
 45: 
 46: 
 47: 
 48: 
 49: 	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
 50: 	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
 51: 	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
 52: 	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
 53: 	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
 54: 	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
 55: 	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
 56: 	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
 57: 	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
 58: 	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
 59: 	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
 60: 	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
 61: 	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
 62: 	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
 63: 	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
 64: 	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
 65: 
 66: 	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
 67: 	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
 68: 	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
 69: 	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));
 70: 
 71: 	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
 72: 	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
 73: 	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
 74: 	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));
 75: 
 76: 
 77: 	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
 78: 	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
 79: 	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
 80: 	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
 81: 	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
 82: 	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
 83: 	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));
 84: 
 85: 
 86: 
 87: 	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
 88: 	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
 89: 	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
 90: 
 91: 
 92: 
 93: 
 94: 	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));
 95: 
 96: 
 97: 	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
 98: 	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
 99: 	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
100: 	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
101: 	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
102: 	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
103: 	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));
104: 
105: 	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
106: 	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
107: 	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
108: 	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
109: 	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));
110: 
111: 
112: 
113: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
114: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
115: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
116: 
117: 
118: 	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
119: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
120: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
121: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));
122: 
123: 
124: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
125: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
126: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
127: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));
128: 
129: 
130: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
131: 
132: 
133: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
134: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
135: 
136: 
137: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
138: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
139: 
140: 
141: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
142: 
143: 
144: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
145: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
146: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));
147: 
148: }

================
File: Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
================
  1: #include "Item/BaseInteractableAltar.h"
  2: 
  3: #include "FWitchPTGameplayTags.h"
  4: #include "Item/BaseInteractionPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Item/RitualAltar.h"
  8: #include "Item/RitualPosition.h"
  9: 
 10: 
 11: ABaseInteractableAltar::ABaseInteractableAltar()
 12: {
 13: 
 14:     PrimaryActorTick.bCanEverTick = true;
 15: 
 16: 
 17:     bReplicates = true;
 18:     bAlwaysRelevant = true;
 19: 
 20:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
 21:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
 22:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
 23:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);
 24: 
 25: }
 26: 
 27: void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 28: {
 29:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 30: 
 31:     DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
 32:     DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
 33:     DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
 34:     DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
 35: 
 36: }
 37: 
 38: 
 39: void ABaseInteractableAltar::BeginPlay()
 40: {
 41:     Super::BeginPlay();
 42: 
 43: 
 44:     CreateAltarPositions();
 45: }
 46: 
 47: 
 48: void ABaseInteractableAltar::Tick(float DeltaTime)
 49: {
 50:     Super::Tick(DeltaTime);
 51: 
 52: 
 53: }
 54: 
 55: 
 56: 
 57: void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 58: {
 59:     if (!Player || !Position || !HasAuthority())
 60:     {
 61:         return;
 62:     }
 63: 
 64:     Position->SetOccupied(nullptr);
 65: 
 66: 
 67:     ParticipatingPlayers.Remove(Player);
 68: 
 69: }
 70: void ABaseInteractableAltar::CreateAltarPositions()
 71: {
 72:     if (!HasAuthority() || !PositionClass)
 73:     {
 74:         return;
 75:     }
 76: 
 77: 
 78:     DestroyAltarPositions();
 79: 
 80:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
 81:     int positionIndex = 0;
 82: 
 83:     for (const FTransform& PosTransform : PositionTransforms)
 84:     {
 85: 
 86:         FTransform WorldTransform = PosTransform * GetActorTransform();
 87: 
 88: 
 89:         FVector Location = WorldTransform.GetLocation();
 90:         FRotator Rotation = WorldTransform.Rotator();
 91: 
 92: 
 93:         FActorSpawnParameters SpawnParams;
 94:         SpawnParams.Owner = this;
 95:         SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 96: 
 97: 
 98:         ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
 99:             PositionClass,
100:             Location,
101:             Rotation,
102:             SpawnParams);
103: 
104:         if (NewPosition)
105:         {
106: 
107: 
108: 
109:             NewPosition->SetPositionTag(TagsPositions[positionIndex]);
110:             ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
111:             if (RitualPosition)
112:             {
113:                 RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
114:             }
115:             positionIndex++;
116: 
117: 
118: 
119:             InteractionPositions.Add(NewPosition);
120: 
121:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
122:         }
123:     }
124: }
125: 
126: 
127: 
128: void ABaseInteractableAltar::DestroyAltarPositions()
129: {
130: 
131:     if (!HasAuthority())
132:     {
133:         return;
134:     }
135: 
136: 
137:     for (ABaseInteractionPosition* Position : InteractionPositions)
138:     {
139:         if (Position)
140:         {
141:             Position->Destroy();
142:         }
143:     }
144: 
145: 
146:     InteractionPositions.Empty();
147: 
148:     UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
149: }
150: 
151: 
152: void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
153: {
154: 
155:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
156: }
157: 
158: void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
159: {
160: 
161:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
162: }
163: 
164: void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
165: {
166: 
167:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
168: }
169: 
170: 
171: 
172: void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
173: {
174: 
175: }
176: 
177: 
178: void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
179: {
180: 
181:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
182: }
183: 
184: void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
185: {
186: 
187: }
188: 
189: void ABaseInteractableAltar::CheckState()
190: {
191: 
192: 
193: }
194: 
195: void ABaseInteractableAltar::CleanupInteraction()
196: {
197: 
198: }
199: 
200: void ABaseInteractableAltar::SpawnReward()
201: {
202: 
203: }
204: 
205: void ABaseInteractableAltar::SpawnDemon()
206: {
207: 
208: }
209: 
210: bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
211: {
212: 
213: 
214:     return Player && ParticipatingPlayers.Contains(Player);
215: }

================
File: Source/WitchPT/Public/Item/BaseInteractableAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/Actor.h"
  5: #include "GameplayTagContainer.h"
  6: #include "BaseInteractableAltar.generated.h"
  7: 
  8: class UWitchPTUserWidget;
  9: class ABaseInteractionPosition;
 10: class ACharacter;
 11: 
 12: 
 13: 
 14: 
 15: UENUM(BlueprintType)
 16: enum class EInteractionState : uint8
 17: {
 18:     Inactive    UMETA(DisplayName = "Inactive"),
 19:     WaitingForPlayers UMETA(DisplayName = "Waiting For Players"),
 20:     Preparing   UMETA(DisplayName = "Preparing"),
 21:     Active      UMETA(DisplayName = "Active"),
 22:     Succeeded   UMETA(DisplayName = "Succeeded"),
 23:     Failed      UMETA(DisplayName = "Failed"),
 24:     FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
 25: };
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
 28: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);
 29: 
 30: 
 31: USTRUCT(BlueprintType)
 32: struct FPlayerPositionTagEntry
 33: {
 34:     GENERATED_BODY();
 35: 
 36:     UPROPERTY(BlueprintReadWrite)
 37:     TObjectPtr<ACharacter> Player = nullptr;
 38: 
 39:     UPROPERTY(BlueprintReadWrite)
 40:     FGameplayTag PositionTag;
 41: };
 42: 
 43: 
 44: 
 45: 
 46: UCLASS(Abstract)
 47: class WITCHPT_API ABaseInteractableAltar : public AActor
 48: {
 49:     GENERATED_BODY()
 50: 
 51: public:
 52: 
 53:     ABaseInteractableAltar();
 54:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 55: 
 56: 
 57:     UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
 58:     EInteractionState CurrentState = EInteractionState::Inactive;
 59: 
 60: 
 61:     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
 62:     TArray<FTransform> PositionTransforms;
 63: 
 64: 
 65:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
 66:     TSubclassOf<ABaseInteractionPosition> PositionClass;
 67: 
 68:     UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
 69:     TArray<FGameplayTag> TagsPositions;
 70: 
 71: 
 72:     UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
 73:     TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
 74: 
 75: 
 76: 
 77:     UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 78:     TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;
 79: 
 80:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 81:     TArray<FPlayerPositionTagEntry> PlayerPositionTags;
 82: 
 83: 
 84: 
 85:     virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
 86: 
 87: 
 88:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 89:     virtual void CreateAltarPositions();
 90: 
 91: 
 92:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 93:     virtual void DestroyAltarPositions();
 94: 
 95: 
 96: 
 97: 
 98:     UFUNCTION(NetMulticast, Reliable)
 99:     void Multicast_OnStateChanged(EInteractionState NewState);
100: 
101:     UFUNCTION(NetMulticast, Reliable)
102:     virtual void Multicast_OnInputSuccess(ACharacter* Character);
103: 
104:     UFUNCTION(NetMulticast, Reliable)
105:     virtual void Multicast_OnInputFailed(ACharacter* Character);
106: 
107: 
108: 
109:     UFUNCTION(BlueprintPure, Category = "Interaction")
110:     EInteractionState GetCurrentState() const { return CurrentState; }
111: 
112:     UPROPERTY(EditDefaultsOnly)
113:     TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;
114: 
115: protected:
116:     virtual void BeginPlay() override;
117:     virtual void Tick(float DeltaTime) override;
118: 
119: 
120: 
121:     UFUNCTION()
122:     virtual void OnRep_ParticipatingPlayers();
123: 
124: 
125: 
126:     virtual void HandleInputSuccess(ACharacter* Player);
127:     virtual void HandleInputFailure(ACharacter* Player);
128:     virtual void CheckState();
129:     virtual void CleanupInteraction();
130:     virtual void SpawnReward();
131:     virtual void SpawnDemon();
132:     virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
133: 
134: };

================
File: Source/WitchPT/Private/Character/WitchPTCharacter.cpp
================
 1: #include "Character/WitchPTCharacter.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Character/Components/WitchPTMechanicComponent.h"
 7: #include "Equipment/WitchPTEquipmentManagerComponent.h"
 8: #include "Item/RitualAltar.h"
 9: #include "Item/RitualPosition.h"
10: #include "Player/WitchPTPlayerController.h"
11: #include "Player/WitchPTPlayerState.h"
12: #include "UI/HUD/WitchPTHUD.h"
13: #include "WitchPT/WitchPT.h"
14: 
15: 
16: 
17: AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
18: {
19: 
20: 	PrimaryActorTick.bCanEverTick = true;
21: 
22: 	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
23: 
24: 	EquipmentManagerComponent = CreateDefaultSubobject<UWitchPTEquipmentManagerComponent>(TEXT("EquipmentManagerComponent"));
25: 
26: }
27: 
28: void AWitchPTCharacter::PossessedBy(AController* NewController)
29: {
30: 	Super::PossessedBy(NewController);
31: 
32: 
33: 	InitAbilityActorInfo();
34: 
35: 
36: 
37: 	if (AbilitySystemComponent)
38: 	{
39: 		GrantStartupAbilities();
40: 		AddStartupEffects();
41: 	}
42: }
43: 
44: void AWitchPTCharacter::OnRep_PlayerState()
45: {
46: 	Super::OnRep_PlayerState();
47: 
48: 	InitAbilityActorInfo();
49: 	AddStartupEffects();
50: }
51: 
52: void AWitchPTCharacter::InitAbilityActorInfo()
53: {
54: 	Super::InitAbilityActorInfo();
55: 	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
56: 
57: 	if (!WitchPtPlayerState)
58: 	{
59: 		return;
60: 	}
61: 
62: 	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);
63: 
64: 	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
65: 	if (!AbilitySystemComponent)
66: 	{
67: 		return;
68: 	}
69: 
70: 	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
71: 	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
72: 
73: 
74: 
75: 
76: 
77: 
78: 
79: 	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
80: 	{
81: 		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
82: 		{
83: 			WitchPT_HUD->InitOverlay(WitchPT_PC, WitchPtPlayerState, AbilitySystemComponent, AttributeSet);
84: 		}
85: 	}
86: 	InitializeDefaultAttributes();
87: }

================
File: Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Components/ActorComponent.h"
 5: #include "Item/MechanicsInterface.h"
 6: #include "WitchPTMechanicComponent.generated.h"
 7: 
 8: class ACauldronAltar;
 9: 
10: UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
11: class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 
17: 	UWitchPTMechanicComponent();
18: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
19: 
20: 
21: 	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
22: 	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
23: 	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
24: 	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
25: 	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
26: 	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
27: 	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
28: 
29: 	virtual void RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
30: 	virtual void RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar) override;
31: 	virtual void RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar) override;
32: 
33: 	UFUNCTION(Server, Reliable)
34: 	void Server_RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
35: 	UFUNCTION(Server, Reliable)
36: 	void Server_RequestCraftPotion(ACauldronAltar* TargetAltar);
37: 
38: 
39: 
40: 
41: 
42: 	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
43: 	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
44: 	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
45: 	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
46: 
47: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Components/ActorComponent.h"
  5: #include "FastArray/FastArrayList.h"
  6: #include "Net/Serialization/FastArraySerializer.h"
  7: #include "WitchPTInventoryManagerComponent.generated.h"
  8: 
  9: class UInventoryUserWidget;
 10: class UWitchPTInventoryItemDefinition;
 11: class UWitchPTInventoryItemInstance;
 12: class UWitchPTInventoryManagerComponent;
 13: class UObject;
 14: struct FFrame;
 15: struct FNetDeltaSerializeInfo;
 16: struct FWitchPTInventoryList;
 17: struct FReplicationFlags;
 18: 
 19: 
 20: 
 21: 
 22: 
 23: 
 24: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);
 25: 
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: UCLASS(BlueprintType)
 34: class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
 35: {
 36: 	GENERATED_BODY()
 37: protected:
 38: 	virtual void BeginPlay() override;
 39: 
 40: public:
 41: 
 42: 	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 43: 
 44: 
 45: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
 46: 	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 47: 
 48: 
 49: 	UFUNCTION(Server, Reliable)
 50: 	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 51: 
 52: 
 53: 	UFUNCTION(Server, Reliable)
 54: 	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 55: 
 56: 
 57: 	UFUNCTION(Server, Reliable)
 58: 	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);
 59: 
 60: 
 61: 	UFUNCTION(Server, Reliable)
 62: 	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);
 63: 
 64: 
 65: 	UFUNCTION(Server, Reliable)
 66: 	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);
 67: 
 68: 
 69: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
 70: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 71: 
 72: 
 73: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
 74: 	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 75: 
 76: 
 77: 	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 78: 
 79: 
 80: 	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);
 81: 
 82: 
 83: 
 84: 
 85: 	FOnItemChanged OnItemAdded;
 86: 
 87: 
 88: 	FOnItemChanged OnItemStackChanged;
 89: 
 90: 
 91: 	FOnItemChanged OnItemRemoved;
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 99: 
100: 
101: 
102: 
103: 
104: 	virtual void ReadyForReplication() override;
105: 
106: 
107: 
108: 
109: private:
110: 
111: 
112: 
113: 
114: 	UPROPERTY(Replicated)
115: 	FWitchPTInventoryList InventoryList;
116: 
117: 
118: 	TWeakObjectPtr<APlayerController> OwningController;
119: 
120: 
121: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: #include "WitchPTWidgetController.h"
  6: #include "Item/RitualAltar.h"
  7: #include "RitualWidgetController.generated.h"
  8: 
  9: enum class ERitualInput : uint8;
 10: class ARitualAltar;
 11: class ACharacter;
 12: enum class EInteractionState : uint8;
 13: 
 14: 
 15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
 16: 
 17: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
 18: 
 19: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
 20: 
 21: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
 22: 
 23: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
 24: 
 25: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
 28: 
 29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);
 30: 
 31: 
 32: 
 33: 
 34: UCLASS(BlueprintType, Blueprintable)
 35: class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
 36: {
 37: 	GENERATED_BODY()
 38: 
 39: public:
 40: 	URitualWidgetController();
 41: 
 42: 	virtual void BroadcastInitialValues() override;
 43: 	virtual void BindCallbacksToDependencies() override;
 44: 
 45: 
 46: 	UFUNCTION(Category = "Ritual")
 47: 	void SetRitualAltar(ARitualAltar* InRitualAltar);
 48: 
 49: 
 50: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 51: 	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
 52: 
 53: 
 54: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 55: 	bool IsLocalPlayerActive() const;
 56: 
 57: 
 58: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 59: 	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;
 60: 
 61: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 62: 	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;
 63: 
 64: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 65: 	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
 66: 
 67: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 68: 	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
 69: 
 70: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 71: 	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
 72: 
 73: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 74: 	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
 75: 
 76: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 77: 	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
 78: 
 79: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 80: 	FOnRitualCompletedSignature_WC OnRitualCompleted;
 81: 
 82: protected:
 83: 
 84: 	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
 85: 	TObjectPtr<ARitualAltar> RitualAltar;
 86: 
 87: 
 88: 	UFUNCTION()
 89: 	void HandleRitualStateChanged(EInteractionState NewState);
 90: 
 91: 	UFUNCTION()
 92: 	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
 93: 
 94: 	UFUNCTION()
 95: 	void HandleCountdownTick(int32 CountdownValue);
 96: 
 97: 	UFUNCTION()
 98: 	void HandleTurnDataChanged(FUIRitualData TurnData);
 99: 
100: 	UFUNCTION()
101: 	void HandleCorruptionChanged(float CorruptionPercentage);
102: 
103: 	UFUNCTION()
104: 	void HandleSequenceProgressChanged(float ProgressPercentage);
105: 
106: 	UFUNCTION()
107: 	void HandleRitualCompleted(bool bWasSuccessful);
108: 
109: private:
110: 
111: 	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
112: };

================
File: Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
================
  1: #include "Character/Components/WitchPTMechanicComponent.h"
  2: #include "Item/CauldronAltar.h"
  3: #include "Net/UnrealNetwork.h"
  4: #include "GameFramework/Character.h"
  5: #include "Item/RitualAltar.h"
  6: #include "Item/Components/CauldronCraftComponent.h"
  7: 
  8: 
  9: UWitchPTMechanicComponent::UWitchPTMechanicComponent()
 10: {
 11: 
 12: 	PrimaryComponentTick.bCanEverTick = true;
 13: 	SetIsReplicatedByDefault(true);
 14: }
 15: 
 16: void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 17: {
 18: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 19: 
 20: 
 21: }
 22: 
 23: 
 24: 
 25: 
 26: void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
 27: {
 28: 	if (!TargetAltar)
 29: 	{
 30: 		return;
 31: 	}
 32: 
 33: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 34: 	if (!Character)
 35: 	{
 36: 		return;
 37: 	}
 38: 
 39: 	if (Character->HasAuthority())
 40: 	{
 41: 		TargetAltar->StartBrewingPotion(Character);
 42: 	}
 43: }
 44: 
 45: void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
 46: {
 47: 	if (!TargetAltar)
 48: 	{
 49: 		return;
 50: 	}
 51: 
 52: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 53: 	if (!Character)
 54: 	{
 55: 		return;
 56: 	}
 57: 
 58: 	if (GetOwnerRole() == ROLE_Authority)
 59: 	{
 60: 
 61: 		TargetAltar->StartCarryCauldron(Character);
 62: 	}
 63: 
 64: }
 65: 
 66: void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 67: {
 68: 	if (!TargetAltar)
 69: 	{
 70: 		return;
 71: 	}
 72: 
 73: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 74: 	if (!Character)
 75: 	{
 76: 		return;
 77: 	}
 78: 
 79: 	if (GetOwnerRole() == ROLE_Authority)
 80: 	{
 81: 
 82: 		TargetAltar->StartPlacementPreview(Character);
 83: 	}
 84: }
 85: 
 86: void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
 87: {
 88: 	if (!TargetAltar)
 89: 	{
 90: 		return;
 91: 	}
 92: 
 93: 	if (GetOwnerRole() == ROLE_Authority)
 94: 	{
 95: 
 96: 		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
 97: 	}
 98: }
 99: 
100: void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
101: {
102: 	if (!TargetAltar)
103: 	{
104: 		return;
105: 	}
106: 
107: 	if (GetOwnerRole() == ROLE_Authority)
108: 	{
109: 
110: 		TargetAltar->CancelPlacement();
111: 	}
112: 
113: }
114: 
115: void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
116: {
117: 	if (!TargetAltar)
118: 	{
119: 		return;
120: 	}
121: 
122: 	if (GetOwnerRole() == ROLE_Authority)
123: 	{
124: 
125: 		TargetAltar->FinalizePlacement();
126: 	}
127: 
128: }
129: 
130: void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
131: {
132: 	if (!TargetCauldron) return;
133: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
134: 	if (GetOwnerRole() == ROLE_Authority)
135: 	{
136: 		TargetCauldron->UnoccupyPosition(Character, nullptr);
137: 	}
138: }
139: 
140: void UWitchPTMechanicComponent::RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
141: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
142: {
143: 	if (!TargetAltar) return;
144: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
145: 
146: 
147: 	if(GetOwnerRole() == ROLE_Authority)
148: 	{
149: 		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
150: 	}
151: 	else
152: 	{
153: 		Server_RequestSetIngredientInSlot(TargetAltar, IngredientItemDef);
154: 	}
155: 
156: 
157: 
158: }
159: 
160: void UWitchPTMechanicComponent::RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar)
161: {
162: 	if (!TargetAltar) return;
163: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
164: 
165: 	if (GetOwnerRole() == ROLE_Authority)
166: 	{
167: 		FVector SpawnLocation = TargetAltar->GetActorLocation();
168: 		FPotionResult Result = TargetAltar->CauldronCraftComponent->CraftPotion(false, nullptr, SpawnLocation);
169: 	}
170: }
171: 
172: void UWitchPTMechanicComponent::RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
173: {
174: 	if (!TargetAltar) return;
175: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
176: 	if (GetOwnerRole() == ROLE_Authority)
177: 	{
178: 		TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
179: 	}
180: 	else
181: 	{
182: 		Server_RequestCraftPotion(TargetAltar);
183: 	}
184: 
185: }
186: 
187: void UWitchPTMechanicComponent::Server_RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
188:                                                                                  TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
189: {
190: 	if (!TargetAltar) return;
191: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
192: 
193: 	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
194: 
195: }
196: 
197: void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
198: {
199: 
200: 	if (!TargetAltar) return;
201: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
202: 
203: 	if (GetOwnerRole() == ROLE_Authority)
204: 	{
205: 		TargetAltar->OccupyPosition(Character, Position);
206: 	}
207: 
208: }
209: 
210: void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
211: 	ABaseInteractionPosition* Position)
212: {
213: 	if (!TargetAltar) return;
214: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
215: 	if (GetOwnerRole() == ROLE_Authority)
216: 	{
217: 		TargetAltar->UnoccupyPosition(Character, Position);
218: 	}
219: 
220: }
221: 
222: void UWitchPTMechanicComponent::Server_RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
223: {
224: 	if (!TargetAltar) return;
225: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
226: 	TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
227: }
228: 
229: void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
230: {
231: 	if (!TargetAltar) return;
232: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
233: 	if (GetOwnerRole() == ROLE_Authority)
234: 	{
235: 		TargetAltar->StartRitual(Character);
236: 	}
237: }
238: 
239: void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
240: {
241: 	if (!TargetAltar) return;
242: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
243: 	if (GetOwnerRole() == ROLE_Authority)
244: 	{
245: 		TargetAltar->HandlePlayerInput(Character, InputTag);
246: 	}
247: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
================
  1: #include "Inventory/WitchPTInventoryManagerComponent.h"
  2: 
  3: #include "Blueprint/UserWidget.h"
  4: #include "Components/PanelWidget.h"
  5: #include "Engine/ActorChannel.h"
  6: #include "Inventory/WitchPTInventoryItemDefinition.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  8: #include "Inventory/WitchPTInventoryItemInstance.h"
  9: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 11: #include "Net/UnrealNetwork.h"
 12: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 13: #include "Inventory/InventoryFunctionLibrary.h"
 14: #include "UI/WidgetControllers/InventoryWidgetController.h"
 15: 
 16: 
 17: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)
 18: 
 19: 
 20: void UWitchPTInventoryManagerComponent::BeginPlay()
 21: {
 22: 	Super::BeginPlay();
 23: 
 24: }
 25: 
 26: UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
 27: : Super(ObjectInitializer)
 28: 	, InventoryList(this)
 29: {
 30: 	PrimaryComponentTick.bCanEverTick = false;
 31: 	SetIsReplicatedByDefault(true);
 32: 	bReplicateUsingRegisteredSubObjectList = true;
 33: }
 34: void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
 35: {
 36: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 37: 
 38: 	DOREPLIFETIME(ThisClass, InventoryList);
 39: }
 40: 
 41: 
 42: 
 43: void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 44: {
 45: 	if(IsValid(ItemDef))
 46: 	{
 47: 		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 48: 		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 49: 		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 50: 
 51: 		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
 52: 		Server_UpdateItemStackCount(FoundItem, NewStackCount);
 53: 	}
 54: }
 55: 
 56: void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
 57: {
 58: 	if (IsValid(ItemInstance))
 59: 	{
 60: 		ItemInstance->SetTotalStackCount(NewCount);
 61: 
 62: 
 63: 		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 64: 		{
 65: 			if (Entry.Instance == ItemInstance)
 66: 			{
 67: 				InventoryList.MarkItemDirty(Entry);
 68: 				break;
 69: 			}
 70: 		}
 71: 
 72: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 73: 		{
 74: 			OnItemStackChanged.Broadcast(ItemInstance);
 75: 		}
 76: 	}
 77: }
 78: 
 79: void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
 80: {
 81: 	if (IsValid(ItemInstance))
 82: 	{
 83: 
 84: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 85: 		{
 86: 			OnItemRemoved.Broadcast(ItemInstance);
 87: 		}
 88: 
 89: 
 90: 		InventoryList.RemoveEntry(ItemInstance);
 91: 
 92: 
 93: 		if (IsUsingRegisteredSubObjectList())
 94: 		{
 95: 			RemoveReplicatedSubObject(ItemInstance);
 96: 		}
 97: 	}
 98: }
 99: 
100: void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
101: {
102: 	if (IsValid(ItemInstance))
103: 	{
104: 		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
105: 		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
106: 
107: 
108: 		if (NewCount <= 0)
109: 		{
110: 			Server_RemoveItemInstance(ItemInstance);
111: 		}
112: 		else
113: 		{
114: 
115: 			Server_UpdateItemStackCount(ItemInstance, NewCount);
116: 		}
117: 	}
118: }
119: 
120: TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
121: {
122: 	return InventoryList.GetAllItems();
123: }
124: 
125: bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
126: {
127: 	if (!ItemDef)
128: 	{
129: 		return false;
130: 	}
131: 
132: 	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
133: 	if (FoundItem)
134: 	{
135: 		Server_AddStacksToItem(ItemDef);
136: 		return false;
137: 	}
138: 	else
139: 	{
140: 		Server_AddItem(ItemDef);
141: 		return true;
142: 	}
143: }
144: 
145: 
146: 
147: void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
148: {
149: 	UWitchPTInventoryItemInstance* NewItem = nullptr;
150: 	if (ItemDef != nullptr)
151: 	{
152: 		NewItem = InventoryList.AddEntry(ItemDef);
153: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
154: 		{
155: 			OnItemAdded.Broadcast(NewItem);
156: 		}
157: 
158: 		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
159: 		{
160: 			AddReplicatedSubObject(NewItem);
161: 		}
162: 	}
163: 
164: }
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: 
177: 
178: 
179: UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
180: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
181: {
182: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
183: 	{
184: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
185: 
186: 		if (IsValid(Instance))
187: 		{
188: 			if (Instance->GetItemDef() == ItemDef)
189: 			{
190: 				return Instance;
191: 			}
192: 		}
193: 	}
194: 
195: 	return nullptr;
196: }
197: 
198: int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
199: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
200: {
201: 	int32 TotalCount = 0;
202: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
203: 	{
204: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
205: 
206: 		if (IsValid(Instance))
207: 		{
208: 			if (Instance->GetItemDef() == ItemDef)
209: 			{
210: 				++TotalCount;
211: 			}
212: 		}
213: 	}
214: 
215: 	return TotalCount;
216: }
217: 
218: bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
219: 	int32 NumToConsume)
220: {
221: 	AActor* OwningActor = GetOwner();
222: 	if (!OwningActor || !OwningActor->HasAuthority())
223: 	{
224: 		return false;
225: 	}
226: 
227: 
228: 	int32 TotalConsumed = 0;
229: 	while (TotalConsumed < NumToConsume)
230: 	{
231: 		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
232: 		{
233: 			InventoryList.RemoveEntry(Instance);
234: 			++TotalConsumed;
235: 		}
236: 		else
237: 		{
238: 			return false;
239: 		}
240: 	}
241: 
242: 	return TotalConsumed == NumToConsume;
243: }
244: 
245: 
246: bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
247:                                                             FReplicationFlags* RepFlags)
248: {
249: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
250: 
251: 	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
252: 	{
253: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
254: 
255: 		if (Instance && IsValid(Instance))
256: 		{
257: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
258: 		}
259: 	}
260: 
261: 	return WroteSomething;
262: }
263: 
264: void UWitchPTInventoryManagerComponent::ReadyForReplication()
265: {
266: 	Super::ReadyForReplication();
267: 
268: 	if (IsUsingRegisteredSubObjectList())
269: 	{
270: 		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
271: 		{
272: 			UWitchPTInventoryItemInstance* Instance = Entry.Instance;
273: 
274: 			if (IsValid(Instance))
275: 			{
276: 				AddReplicatedSubObject(Instance);
277: 			}
278: 		}
279: 	}
280: }

================
File: Source/WitchPT/Public/Player/WitchPTPlayerController.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "UI/Widgets/PointerWidget.h"
  6: #include "WitchPTPlayerController.generated.h"
  7: 
  8: class UCauldronUserWidget;
  9: class ABaseInteractableAltar;
 10: class ACauldronAltar;
 11: class ARitualAltar;
 12: class UWitchPTInventoryManagerComponent;
 13: struct FGameplayTag;
 14: class UWitchPTAbilitySystemComponent;
 15: class UWitchPTInputConfig;
 16: struct FInputActionValue;
 17: class UInputAction;
 18: class UInputMappingContext;
 19: 
 20: 
 21: 
 22: UCLASS()
 23: class WITCHPT_API AWitchPTPlayerController : public APlayerController
 24: {
 25: 	GENERATED_BODY()
 26: public:
 27: 	AWitchPTPlayerController();
 28: 	virtual void PlayerTick(float DeltaTime) override;
 29: 	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
 30: 	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
 31: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 32: 
 33: 	void LocalShowRitualWidget(ABaseInteractableAltar* Altar);
 34: 	void LocalHideRitualWidget();
 35: 	bool IsRitualWidgetVisible();
 36: 	void LocalToggleCauldronMenu();
 37: 
 38: 
 39: 
 40: 
 41: 	UFUNCTION(Client, Reliable)
 42: 	void Client_ShowRitualWidget(ABaseInteractableAltar* Altar);
 43: 
 44: 	UFUNCTION(Client, Reliable)
 45: 	void Client_HideRitualWidget();
 46: 
 47: 	UFUNCTION(Client, Reliable)
 48: 	void Client_ToggleCauldronMenu();
 49: 
 50: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 51: 	void OpenInventoryMenu();
 52: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 53: 	void CloseInventoryMenu();
 54: 
 55: 
 56: 	UFUNCTION(Exec, Category = "Debug")
 57: 	void ShowRitualWidgetDebug();
 58: 	UFUNCTION(Exec, Category = "Debug")
 59: 	void HideRitualWidgetDebug();
 60: 	UFUNCTION(Exec, Category = "Debug")
 61: 	void ToggleRitualWidgetDebug();
 62: 
 63: 
 64: 	UPROPERTY(Replicated, VisibleAnywhere)
 65: 	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
 66: 	UPROPERTY()
 67: 	TObjectPtr<UPointerWidget> HUDWidget;
 68: 	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
 69: protected:
 70: 	virtual void BeginPlay() override;
 71: 	virtual void SetupInputComponent() override;
 72: 
 73: 
 74: 	UPROPERTY(EditAnywhere, Category="Input")
 75: 	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
 76: 	UPROPERTY(EditAnywhere, Category="Input")
 77: 	TObjectPtr<UInputAction> MoveAction;
 78: 	UPROPERTY(EditAnywhere, Category= "Input")
 79: 	TObjectPtr<UInputAction> LookAction;
 80: 
 81: 	UPROPERTY(EditDefaultsOnly, Category= "Input")
 82: 	TObjectPtr<UWitchPTInputConfig> InputConfig;
 83: 
 84: 
 85: 	UPROPERTY()
 86: 	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;
 87: 
 88: 	UWitchPTAbilitySystemComponent* GetASC();
 89: 
 90: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 91: 	TSubclassOf<UPointerWidget> HUDWidgetClass;
 92: 
 93: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
 94: 	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;
 95: 
 96: 
 97: 
 98: private:
 99: 
100: 	void Move(const FInputActionValue& InputActionValue);
101: 
102: 	void Look(const FInputActionValue& Value);
103: 
104: 	void AbilityInputTagPressed(FGameplayTag InputTag);
105: 	void AbilityInputTagReleased(FGameplayTag InputTag);
106: 	void AbilityInputTagHeld(FGameplayTag InputTag);
107: 
108: 
109: 	void CreateHUDWidget();
110: 	void OpenCauldronMenu();
111: 	void CloseCauldronMenu();
112: 	bool bCauldronMenuOpen = false;
113: 
114: 
115: 	bool bRitualWidgetVisible = false;
116: 
117: 
118: };

================
File: Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
================
  1: #include "UI/WidgetControllers/RitualWidgetController.h"
  2: #include "Item/RitualAltar.h"
  3: #include "GameFramework/Character.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystemComponent.h"
  6: #include "AbilitySystemBlueprintLibrary.h"
  7: #include "FWitchPTGameplayTags.h"
  8: 
  9: URitualWidgetController::URitualWidgetController()
 10: {
 11: 
 12: }
 13: 
 14: void URitualWidgetController::BroadcastInitialValues()
 15: {
 16: 
 17:     if (!IsValid(RitualAltar))
 18:     {
 19:         UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BroadcastInitialValues called with invalid altar"));
 20:         return;
 21:     }
 22: 
 23: 
 24:     OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
 25: 
 26: 
 27:     FRitualReadyPlayersData ReadyPlayersData;
 28:     ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
 29:     ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
 30:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 31: 
 32: 
 33:     FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
 34:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
 35:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
 36: 
 37: 
 38:     OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
 39: 
 40: 
 41:     OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
 42: 
 43:     UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Initial values broadcasted"));
 44: }
 45: 
 46: void URitualWidgetController::BindCallbacksToDependencies()
 47: {
 48: 
 49:     if (!IsValid(RitualAltar))
 50:     {
 51:         UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BindCallbacksToDependencies called with invalid altar"));
 52:         return;
 53:     }
 54: 
 55: 
 56:     RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
 57:     RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
 58:     RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
 59:     RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
 60:     RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
 61:     RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
 62:     RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
 63: 
 64:     UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Callbacks bound to dependencies"));
 65: }
 66: 
 67: void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
 68: {
 69: 
 70: 
 71: 
 72:     if (IsValid(RitualAltar))
 73:     {
 74:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 75:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 76:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 77:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 78:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 79:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 80:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 81: 
 82:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound callbacks from previous altar"));
 83:     }
 84: 
 85: 
 86:     RitualAltar = InRitualAltar;
 87: 
 88: 
 89:     if (IsValid(RitualAltar))
 90:     {
 91:         BindCallbacksToDependencies();
 92:         BroadcastInitialValues();
 93:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Set new ritual altar and bound callbacks"));
 94:     }
 95:     else
 96:     {
 97:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Cleared ritual altar reference"));
 98:     }
 99: }
100: 
101: bool URitualWidgetController::IsLocalPlayerActive() const
102: {
103: 
104:     if (!IsValid(RitualAltar) || !IsValid(PlayerController))
105:     {
106:         return false;
107:     }
108: 
109: 
110:     ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
111:     if (!IsValid(LocalCharacter))
112:     {
113:         return false;
114:     }
115: 
116: 
117:     ACharacter* ActivePlayer = RitualAltar->GetCurrentActivePlayer();
118:     return IsValid(ActivePlayer) && ActivePlayer == LocalCharacter;
119: }
120: 
121: FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
122: {
123:     FUIRitualData ProcessedData = InTurnData;
124: 
125: 
126:     ProcessedData.bIsMyTurn = IsLocalPlayerActive();
127: 
128: 
129:     if (!ProcessedData.bIsMyTurn)
130:     {
131:         ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
132:         ProcessedData.CurrentInputTimeRemaining = 0.0f;
133:     }
134: 
135:     return ProcessedData;
136: }
137: 
138: 
139: 
140: void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
141: {
142:     OnRitualStateChanged.Broadcast(NewState);
143: }
144: 
145: void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
146: {
147:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
148: }
149: 
150: void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
151: {
152:     OnRitualCountdownTick.Broadcast(CountdownValue);
153: }
154: 
155: void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
156: {
157: 
158:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
159:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
160: 
161: 
162:     if (ProcessedTurnData.bIsMyTurn)
163:     {
164:         OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
165:     }
166:     else
167:     {
168:         OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
169:     }
170: }
171: 
172: void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
173: {
174:     OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
175: }
176: 
177: void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
178: {
179:     OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
180: }
181: 
182: void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
183: {
184:     OnRitualCompleted.Broadcast(bWasSuccessful);
185: 
186: 
187:     if (IsValid(RitualAltar))
188:     {
189:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
190:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
191:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
192:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
193:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
194:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
195:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
196: 
197:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound all delegates after ritual completion"));
198:     }
199: 
200: 
201:     RitualAltar = nullptr;
202: }

================
File: Source/WitchPT/Public/Item/MechanicsInterface.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "UObject/Interface.h"
 6: #include "MechanicsInterface.generated.h"
 7: 
 8: class UWitchPTInventoryItemDefinition;
 9: class UWitchPTInventoryItemInstance;
10: class ABaseInteractionPosition;
11: class ACauldronAltar;
12: class ARitualPosition;
13: class ARitualAltar;
14: class ACharacter;
15: 
16: 
17: UINTERFACE(MinimalAPI)
18: class UMechanicsInterface : public UInterface
19: {
20: 	GENERATED_BODY()
21: };
22: 
23: 
24: 
25: 
26: class WITCHPT_API IMechanicsInterface
27: {
28: 	GENERATED_BODY()
29: 
30: 
31: 
32: public:
33: 
34: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
35: 	void RequestStartRitual(ARitualAltar* TargetAltar);
36: 
37: 
38: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
39: 	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);
40: 
41: 
42: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
43: 	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
44: 
45: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
46: 	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
47: 
48: 
49: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
50: 	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);
51: 
52: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
53: 	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);
54: 
55: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
56: 	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);
57: 
58: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
59: 	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);
60: 
61: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
62: 	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);
63: 
64: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
65: 	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);
66: 
67: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
68: 	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);
69: 
70: 
71: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
72: 	void RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
73: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
74: 	void RequestPrintDebugData(ACauldronAltar* TargetAltar);
75: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
76: 	void RequestCraftPotion(ACauldronAltar* TargetAltar);
77: 
78: 
79: 
80: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
81: 	ARitualAltar* GetRitualAltarActor() const;
82: 
83: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
84: 	bool IsOccuppied() const;
85: 
86: };

================
File: Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
================
  1: #include "Player/WitchPTPlayerController.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "EnhancedInputSubsystems.h"
  5: #include "InputActionValue.h"
  6: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  7: #include "Blueprint/UserWidget.h"
  8: #include "Input/WitchPTInputComponent.h"
  9: #include "Inventory/WitchPTInventoryManagerComponent.h"
 10: #include "Item/CauldronAltar.h"
 11: #include "Item/RitualAltar.h"
 12: #include "Item/Ritual/RitualFunctionLibrary.h"
 13: #include "Kismet/GameplayStatics.h"
 14: #include "Net/UnrealNetwork.h"
 15: #include "UI/HUD/WitchPTHUD.h"
 16: #include "UI/WidgetControllers/CauldronWidgetController.h"
 17: #include "UI/WidgetControllers/RitualWidgetController.h"
 18: #include "UI/Widgets/CauldronUserWidget.h"
 19: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 20: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 21: #include "WitchPT/WitchPT.h"
 22: 
 23: AWitchPTPlayerController::AWitchPTPlayerController()
 24: {
 25: 	bReplicates = true;
 26: 	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
 27: 	InventoryManager->SetIsReplicated(true);
 28: 
 29: 
 30: }
 31: 
 32: void AWitchPTPlayerController::PlayerTick(float DeltaTime)
 33: {
 34: 	Super::PlayerTick(DeltaTime);
 35: }
 36: 
 37: void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
 38: {
 39: 	Super::PreProcessInput(DeltaTime, bGamePaused);
 40: }
 41: 
 42: void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
 43: {
 44: 	if (WitchPtAbilitySystemComponent)
 45: 	{
 46: 		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
 47: 	}
 48: 	Super::PostProcessInput(DeltaTime, bGamePaused);
 49: }
 50: 
 51: void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 52: {
 53: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 54: 	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
 55: }
 56: void AWitchPTPlayerController::LocalToggleCauldronMenu()
 57: {
 58: 
 59: 	if (bCauldronMenuOpen)
 60: 	{
 61: 		CloseCauldronMenu();
 62: 	}
 63: 	else
 64: 	{
 65: 		OpenCauldronMenu();
 66: 	}
 67: }
 68: void AWitchPTPlayerController::OpenInventoryMenu()
 69: {
 70: 	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
 71: 	{
 72: 		WitchPTHUD->ShowInventoryWidget();
 73: 	}
 74: }
 75: 
 76: void AWitchPTPlayerController::CloseInventoryMenu()
 77: {
 78: 	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
 79: 	{
 80: 		WitchPTHUD->HideInventoryWidget();
 81: 	}
 82: }
 83: 
 84: void AWitchPTPlayerController::LocalShowRitualWidget(ABaseInteractableAltar* Altar)
 85: {
 86: 	if (!Altar || !IsLocalController())
 87: 	{
 88: 		UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Invalid altar or not local controller!"));
 89: 		return;
 90: 	}
 91: 
 92: 	if (Altar->IsA<ARitualAltar>())
 93: 	{
 94: 
 95: 		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
 96: 
 97: 
 98: 		AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
 99: 		if (WitchPTHUD)
100: 		{
101: 			WitchPTHUD->ShowRitualWidget(RitualAltar);
102: 			bRitualWidgetVisible = true;
103: 			UE_LOG(LogTemp, Log, TEXT("LocalShowRitualWidget: Ritual widget shown for altar %s"), *RitualAltar->GetName());
104: 		}
105: 		else
106: 		{
107: 			UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Failed to get WitchPTHUD!"));
108: 		}
109: 	}
110: }
111: 
112: void AWitchPTPlayerController::LocalHideRitualWidget()
113: {
114: 	if (!IsLocalController())
115: 	{
116: 		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Not local controller!"));
117: 		return;
118: 	}
119: 
120: 
121: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
122: 	if (WitchPTHUD)
123: 	{
124: 		WitchPTHUD->HideRitualWidget();
125: 		bRitualWidgetVisible = false;
126: 		UE_LOG(LogTemp, Log, TEXT("LocalHideRitualWidget: Ritual widget hidden"));
127: 	}
128: 	else
129: 	{
130: 		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Failed to get WitchPTHUD!"));
131: 	}
132: }
133: 
134: bool AWitchPTPlayerController::IsRitualWidgetVisible()
135: {
136: 	return bRitualWidgetVisible;
137: }
138: 
139: void AWitchPTPlayerController::OpenCauldronMenu()
140: {
141: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
142: 	if (WitchPTHUD)
143: 	{
144: 
145: 		ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(
146: 			UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass())
147: 		);
148: 
149: 		if (CauldronAltar)
150: 		{
151: 			WitchPTHUD->ShowCauldronWithInventory(CauldronAltar);
152: 			bCauldronMenuOpen = true;
153: 		}
154: 	}
155: }
156: 
157: void AWitchPTPlayerController::CloseCauldronMenu()
158: {
159: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
160: 	if (WitchPTHUD)
161: 	{
162: 		WitchPTHUD->HideCauldronWithInventory();
163: 		bCauldronMenuOpen = false;
164: 	}
165: }
166: 
167: void AWitchPTPlayerController::Client_ShowRitualWidget_Implementation(ABaseInteractableAltar* Altar)
168: {
169: 
170: 	LocalShowRitualWidget(Altar);
171: }
172: 
173: void AWitchPTPlayerController::Client_HideRitualWidget_Implementation()
174: {
175: 
176: 	LocalHideRitualWidget();
177: }
178: 
179: void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
180: {
181: 	LocalToggleCauldronMenu();
182: }
183: void AWitchPTPlayerController::BeginPlay()
184: {
185: 	Super::BeginPlay();
186: 	check(WitchPtiInputMappingContext)
187: 	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
188: 	if (Subsystem)
189: 	{
190: 		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
191: 	}
192: 	CreateHUDWidget();
193: }
194: 
195: void AWitchPTPlayerController::SetupInputComponent()
196: {
197: 	Super::SetupInputComponent();
198: 	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
199: 	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
200: 	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
201: 	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
202: 
203: }
204: 
205: void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
206: {
207: 	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
208: 	const FRotator Rotation = GetControlRotation();
209: 	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);
210: 
211: 	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
212: 	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
213: 
214: 	if (APawn* ControlledPawn = GetPawn<APawn>())
215: 	{
216: 		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
217: 		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
218: 	}
219: 
220: }
221: 
222: void AWitchPTPlayerController::Look(const FInputActionValue& Value)
223: {
224: 
225: 	FVector2D LookAxisVector = Value.Get<FVector2D>();
226: 
227: 	if (APawn* ControlledPawn = GetPawn<APawn>())
228: 	{
229: 
230: 		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
231: 		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
232: 	}
233: }
234: 
235: void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
236: {
237: 	if (GetASC())
238: 	{
239: 		GetASC()->AbilityInputTagPressed(InputTag);
240: 	}
241: }
242: 
243: void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
244: {
245: 	if (GetASC())
246: 	{
247: 		GetASC()->AbilityInputTagReleased(InputTag);
248: 	}
249: }
250: 
251: void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
252: {
253: 	if (GetASC())
254: 	{
255: 		GetASC()->AbilityInputTagHeld(InputTag);
256: 	}
257: }
258: 
259: void AWitchPTPlayerController::CreateHUDWidget()
260: {
261: 	if (!IsLocalController()) return;
262: 	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
263: 	if (IsValid(HUDWidget))
264: 	{
265: 		HUDWidget->AddToViewport();
266: 	}
267: }
268: 
269: 
270: UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
271: {
272: 	if (WitchPtAbilitySystemComponent == nullptr)
273: 	{
274: 		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
275: 	}
276: 	return WitchPtAbilitySystemComponent;
277: }
278: 
279: 
280: void AWitchPTPlayerController::ShowRitualWidgetDebug()
281: {
282: 
283: 	ARitualAltar* TestAltar = Cast<ARitualAltar>(UGameplayStatics::GetActorOfClass(this, ARitualAltar::StaticClass()));
284: 	if (TestAltar)
285: 	{
286: 		LocalShowRitualWidget(TestAltar);
287: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: Showing ritual widget for test altar"));
288: 	}
289: 	else
290: 	{
291: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: No ritual altar found in level"));
292: 	}
293: }
294: 
295: void AWitchPTPlayerController::HideRitualWidgetDebug()
296: {
297: 	LocalHideRitualWidget();
298: 	UE_LOG(LogTemp, Warning, TEXT("[DEBUG] HideRitualWidgetDebug: Hiding ritual widget"));
299: }
300: 
301: void AWitchPTPlayerController::ToggleRitualWidgetDebug()
302: {
303: 	if (IsRitualWidgetVisible())
304: 	{
305: 		HideRitualWidgetDebug();
306: 	}
307: 	else
308: 	{
309: 		ShowRitualWidgetDebug();
310: 	}
311: }

================
File: Source/WitchPT/Private/Item/CauldronAltar.cpp
================
  1: #include "Item/CauldronAltar.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "Item/CauldronPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Kismet/GameplayStatics.h"
  8: #include "TimerManager.h"
  9: #include "Components/SkeletalMeshComponent.h"
 10: #include "Components/CapsuleComponent.h"
 11: #include "Components/StaticMeshComponent.h"
 12: #include "Engine/World.h"
 13: #include "DrawDebugHelpers.h"
 14: #include "FWitchPTGameplayTags.h"
 15: #include "Engine/ActorChannel.h"
 16: #include "Inventory/WitchPTInventoryItemDefinition.h"
 17: #include "Inventory/WitchPTInventoryItemInstance.h"
 18: #include "Inventory/WitchPTInventoryManagerComponent.h"
 19: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 20: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 21: #include "Item/Components/CauldronCraftComponent.h"
 22: #include "Player/WitchPTPlayerController.h"
 23: 
 24: 
 25: ACauldronAltar::ACauldronAltar()
 26: {
 27: 
 28:     PrimaryActorTick.bCanEverTick = true;
 29: 
 30: 
 31:     bReplicates = true;
 32:     bAlwaysRelevant = true;
 33:     CauldronPhysicState = ECauldronPhysicState::Static;
 34:     CarryingCharacter = nullptr;
 35:     CurrentPlacementState = ECauldronPlacementState::None;
 36:     bReplicateUsingRegisteredSubObjectList = true;
 37: 
 38: 
 39:     CauldronCraftComponent = CreateDefaultSubobject<UCauldronCraftComponent>(TEXT("CauldronCraftComponent"));
 40: }
 41: 
 42: void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 43: {
 44: 
 45:     FInteractionOption InteractionOption = Option;
 46: 
 47: 
 48:     InteractionOption.bSupportsHoldInteraction = true;
 49: 
 50: 
 51:     OptionBuilder.AddInteractionOption(InteractionOption);
 52: }
 53: 
 54: void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 55: {
 56:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 57: 
 58:     DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
 59:     DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
 60:     DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
 61:     DOREPLIFETIME(ACauldronAltar, CauldronCraftComponent);
 62: }
 63: 
 64: void ACauldronAltar::OnRep_CauldronPhysicState()
 65: {
 66: 
 67:     if (CauldronPhysicState == ECauldronPhysicState::Moving)
 68:     {
 69: 
 70:         SetActorEnableCollision(false);
 71:     }
 72:     else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
 73:     {
 74: 
 75:         SetActorEnableCollision(false);
 76:     }
 77: }
 78: 
 79: 
 80: 
 81: void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
 82: {
 83:     if (!InteractingCharacter)
 84:     {
 85:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
 86:         return;
 87:     }
 88: 
 89: 
 90:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 91:     {
 92:         FinalizePlacement();
 93:         return;
 94:     }
 95: 
 96: 
 97:     PositionCharacterForBrewing(InteractingCharacter);
 98: }
 99: 
100: void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
101: {
102:     if (!CauldronCraftComponent)
103:     {
104:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: CauldronCraftComponent is null"));
105:         return;
106:     }
107: 
108:     if (CauldronPhysicState != ECauldronPhysicState::Static)
109:     {
110:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
111:         return;
112:     }
113: 
114: 
115:     CauldronCraftComponent->TrySetIngredientInSlot(RequestingCharacter, IngredientItemDef);
116: }
117: 
118: void ACauldronAltar::BeginPlay()
119: {
120:     Super::BeginPlay();
121:     SetReplicateMovement(true);
122: }
123: 
124: bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
125:     FReplicationFlags* RepFlags)
126: {
127:     bool bWroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
128: 
129: 
130:     if (CauldronCraftComponent)
131:     {
132:         bWroteSomething |= Channel->ReplicateSubobject(CauldronCraftComponent, *Bunch, *RepFlags);
133:     }
134: 
135:     return bWroteSomething;
136: }
137: 
138: void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
139: {
140:     if (!InteractingCharacter)
141:     {
142:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
143:         return;
144:     }
145: 
146: 
147:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
148:     {
149:         CancelPlacement();
150:         return;
151:     }
152: 
153: 
154:     if (!CanBePickedUp())
155:     {
156:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
157:         return;
158:     }
159: 
160: 
161:     AttachToCharacter(InteractingCharacter);
162: }
163: 
164: bool ACauldronAltar::CanBePickedUp() const
165: {
166: 
167:     if (IsBeingCarried() || IsInPlacementPreview())
168:     {
169:         return false;
170:     }
171: 
172: 
173: 
174:     return true;
175: }
176: 
177: bool ACauldronAltar::IsBeingCarried() const
178: {
179:     return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
180: }
181: 
182: bool ACauldronAltar::IsInPlacementPreview() const
183: {
184:     return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
185: }
186: 
187: ACharacter* ACauldronAltar::GetCarryingCharacter() const
188: {
189:     return CarryingCharacter;
190: }
191: 
192: void ACauldronAltar::AttachToCharacter(ACharacter* Character)
193: {
194:     if (!Character || !HasAuthority())
195:     {
196:         return;
197:     }
198: 
199: 
200:     DestroyAltarPositions();
201: 
202: 
203:     CauldronPhysicState = ECauldronPhysicState::Moving;
204:     CarryingCharacter = Character;
205: 
206: 
207:     FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget,
208:                                           EAttachmentRule::KeepWorld, true);
209: 
210: 
211:     USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
212:     if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
213:     {
214: 
215:         AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
216: 
217: 
218:         SetActorEnableCollision(false);
219: 
220: 
221:         SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
222: 
223:         UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
224:     }
225: }
226: 
227: void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
228: {
229:     if (!Character || !HasAuthority() || Character != CarryingCharacter)
230:     {
231:         return;
232:     }
233: 
234: 
235:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
236: 
237: 
238:     FVector CharacterLocation = Character->GetActorLocation();
239:     FRotator CharacterRotation = Character->GetActorRotation();
240:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
241: 
242: 
243:     SetActorLocation(CharacterLocation + PlacementOffset);
244: 
245: 
246:     CauldronPhysicState = ECauldronPhysicState::Static;
247:     CarryingCharacter = nullptr;
248: 
249: 
250:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
251: 
252: 
253:     SetActorEnableCollision(true);
254: 
255: 
256:     CreateAltarPositions();
257: 
258:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
259: 
260: 
261: 
262: }
263: 
264: void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
265: {
266:     if (!Character || !HasAuthority())
267:     {
268:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
269:         return;
270:     }
271: 
272: 
273:     ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
274: 
275:     if (BrewingPosition)
276:     {
277:         Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
278:         ParticipatingPlayers.Add(Character);
279: 
280:         if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
281:         {
282: 
283:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
284:             {
285:                 PC->LocalToggleCauldronMenu();
286:             }
287:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
288:         {
289: 
290:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
291:             {
292:                 PC->Client_ToggleCauldronMenu();
293:             }
294:         }
295:         FGameplayEventData Payload;
296:         Payload.OptionalObject = Character;
297:         FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
298:         UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
299:         return BrewingPosition->SetOccupied(Character);
300: 
301: 
302:     }
303: 
304: 
305: }
306: 
307: ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
308: {
309: 
310:     if (InteractionPositions.Num() == 0)
311:     {
312:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
313:         return nullptr;
314:     }
315: 
316: 
317:     for (ABaseInteractionPosition* Position : InteractionPositions)
318:     {
319:         if (Position && !Position->IsOccupied())
320:         {
321:             return Position;
322:         }
323:     }
324: 
325: 
326:     UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
327: 
328:     return nullptr;
329: }
330: 
331: 
332: 
333: void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
334: {
335:     if (!Character || Character != CarryingCharacter || !HasAuthority())
336:     {
337:         return;
338:     }
339: 
340: 
341:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
342: 
343: 
344:     CauldronPhysicState = ECauldronPhysicState::Previewing;
345: 
346: 
347:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
348:     if (MeshComponent)
349:     {
350:         OriginalMaterials.Empty();
351:         for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
352:         {
353:             OriginalMaterials.Add(MeshComponent->GetMaterial(i));
354:         }
355:     }
356: 
357: 
358:     CurrentPlacementState = ECauldronPlacementState::Invalid;
359: 
360: 
361: 
362:     SetActorEnableCollision(false);
363: 
364: 
365:     FVector CharacterLocation = Character->GetActorLocation();
366:     FRotator CharacterRotation = Character->GetActorRotation();
367:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
368: 
369: 
370:     PreviewLocation = CharacterLocation + PlacementOffset;
371: 
372: 
373:     PreviewRotation.Pitch = 0;
374:     PreviewRotation.Roll = 0;
375:     PreviewRotation.Yaw = 0;
376: 
377:     SetActorLocation(PreviewLocation);
378:     SetActorRotation(PreviewRotation);
379: 
380: 
381:     Multicast_FinalizePlacement();
382: }
383: 
384: void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
385: {
386: 
387: 
388: }
389: 
390: void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
391: {
392: 
393: 
394:     if (!IsInPlacementPreview())
395:     {
396:         return;
397:     }
398: 
399: 
400:     PreviewLocation = HitLocation;
401: 
402: 
403:     FRotator SurfaceAlignedRotation = HitNormal.Rotation();
404: 
405: 
406: 
407:     FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
408: 
409: 
410:     if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
411:     {
412:         AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
413:     }
414: 
415:     if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
416:     {
417:         AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
418:     }
419: 
420:     PreviewRotation = AdjustedRotation;
421:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
422:     SetActorLocation(PreviewLocation);
423: 
424: 
425:     CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
426: }
427: 
428: void ACauldronAltar::FinalizePlacement()
429: {
430:     if (!IsInPlacementPreview() || !HasAuthority())
431:     {
432:         return;
433:     }
434: 
435: 
436:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
437:     SetActorLocation(PreviewLocation);
438:     SetActorRotation(PreviewRotation);
439: 
440: 
441:     RestoreOriginalMaterials();
442: 
443: 
444:     SetActorEnableCollision(true);
445: 
446: 
447:     CauldronPhysicState = ECauldronPhysicState::Static;
448:     CarryingCharacter = nullptr;
449:     CurrentPlacementState = ECauldronPlacementState::None;
450: 
451:     OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
452: 
453: 
454:     CreateAltarPositions();
455: 
456: 
457:     Multicast_FinalizePlacement();
458: 
459:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
460: }
461: 
462: void ACauldronAltar::CancelPlacement()
463: {
464:     if (!IsInPlacementPreview() || !HasAuthority())
465:     {
466:         return;
467:     }
468: 
469: 
470:     RestoreOriginalMaterials();
471: 
472: 
473:     ACharacter* Character = CarryingCharacter;
474: 
475: 
476:     CauldronPhysicState = ECauldronPhysicState::Moving;
477:     CarryingCharacter = nullptr;
478:     CurrentPlacementState = ECauldronPlacementState::None;
479: 
480: 
481:     if (Character)
482:     {
483:         AttachToCharacter(Character);
484:     }
485: 
486:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
487: }
488: 
489: void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
490: {
491: 
492:     for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
493:     {
494:         if(PositionOccupied->GetOccupyingCharacter() == Character)
495:         {
496: 
497:              if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
498:         {
499: 
500:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
501:             {
502:                 PC->LocalToggleCauldronMenu();
503: 
504:             }
505:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
506:         {
507: 
508:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
509:             {
510:                 PC->Client_ToggleCauldronMenu();
511: 
512:             }
513:         }
514:             PositionOccupied->SetOccupied(nullptr);
515:             break;
516:         }
517:     }
518: }
519: 
520: void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
521: {
522: 
523:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
524:     SetActorEnableCollision(true);
525: }
526: 
527: ECauldronPlacementState ACauldronAltar::GetPlacementState() const
528: {
529:     return CurrentPlacementState;
530: }
531: 
532: void ACauldronAltar::ApplyPlacementPreviewMaterial()
533: {
534:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
535:     if (!MeshComponent)
536:     {
537:         return;
538:     }
539: 
540: 
541:     UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ?
542:         ValidPlacementMaterial : InvalidPlacementMaterial;
543: 
544: 
545:     if (!MaterialToApply)
546:     {
547:         return;
548:     }
549: 
550: 
551:     for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
552:     {
553:         MeshComponent->SetMaterial(i, MaterialToApply);
554:     }
555: }
556: 
557: void ACauldronAltar::RestoreOriginalMaterials()
558: {
559: 
560:     if (CauldronPhysicState != ECauldronPhysicState::Previewing)
561:     {
562:         UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
563:         if (MeshComponent && OriginalMaterials.Num() > 0)
564:         {
565:             for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
566:             {
567:                 if (OriginalMaterials[i])
568:                 {
569:                     MeshComponent->SetMaterial(i, OriginalMaterials[i]);
570:                 }
571:             }
572:         }
573:     }
574: }
575: 
576: bool ACauldronAltar::IsPlacementValid() const
577: {
578:     if (!GetWorld())
579:     {
580:         return false;
581:     }
582: 
583: 
584:     TArray<FOverlapResult> Overlaps;
585:     FCollisionQueryParams QueryParams;
586:     QueryParams.AddIgnoredActor(this);
587: 
588:     if (CarryingCharacter)
589:     {
590:         QueryParams.AddIgnoredActor(CarryingCharacter);
591:     }
592: 
593:     bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
594:         Overlaps,
595:         PreviewLocation,
596:         FQuat::Identity,
597:         FCollisionObjectQueryParams::AllObjects,
598:         FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
599:         QueryParams
600:     );
601: 
602:     if (bHasOverlaps)
603:     {
604: 
605:         for (const FOverlapResult& Overlap : Overlaps)
606:         {
607: 
608:             if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
609:             {
610: 
611:                 return false;
612:             }
613:         }
614:     }
615: 
616: 
617: 
618:     FHitResult HitResult;
619:     FVector TraceStart = PreviewLocation;
620:     FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
621: 
622:     bool bHitGround = GetWorld()->LineTraceSingleByChannel(
623:         HitResult,
624:         TraceStart,
625:         TraceEnd,
626:         ECC_Visibility,
627:         QueryParams
628:     );
629: 
630:     if (!bHitGround)
631:     {
632: 
633:         return false;
634:     }
635: 
636: 
637:     float DistanceToGround = (HitResult.Location - TraceStart).Size();
638:     if (DistanceToGround > MaxGroundAlignmentHeight)
639:     {
640: 
641:         return false;
642:     }
643: 
644: 
645:     return true;
646: }
647: 
648: 
649: 
650: void ACauldronAltar::PrintCauldronDebugData() const
651: {
652:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON ALTAR DEBUG DATA ==="));
653:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Name: %s"), *GetName());
654:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Location: %s"), *GetActorLocation().ToString());
655:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Physics State: %s"),
656:            CauldronPhysicState == ECauldronPhysicState::Static ? TEXT("Static") :
657:            CauldronPhysicState == ECauldronPhysicState::Moving ? TEXT("Moving") :
658:            CauldronPhysicState == ECauldronPhysicState::Previewing ? TEXT("Previewing") : TEXT("Unknown"));
659:     UE_LOG(LogTemp, Warning, TEXT("Carrying Character: %s"),
660:            CarryingCharacter ? *CarryingCharacter->GetName() : TEXT("None"));
661:     UE_LOG(LogTemp, Warning, TEXT("Placement State: %s"),
662:            CurrentPlacementState == ECauldronPlacementState::Valid ? TEXT("Valid") :
663:            CurrentPlacementState == ECauldronPlacementState::Invalid ? TEXT("Invalid") :
664:            CurrentPlacementState == ECauldronPlacementState::None ? TEXT("None") : TEXT("Unknown"));
665:     UE_LOG(LogTemp, Warning, TEXT("Number of Interaction Positions: %d"), InteractionPositions.Num());
666:     UE_LOG(LogTemp, Warning, TEXT("Number of Participating Players: %d"), ParticipatingPlayers.Num());
667: 
668: 
669:     if (CauldronCraftComponent)
670:     {
671:         UE_LOG(LogTemp, Warning, TEXT("CauldronCraftComponent: Valid"));
672:         CauldronCraftComponent->PrintIngredientDebugData();
673:     }
674:     else
675:     {
676:         UE_LOG(LogTemp, Error, TEXT("CauldronCraftComponent: NULL - This should not happen!"));
677:     }
678: 
679:     UE_LOG(LogTemp, Warning, TEXT("=== END CAULDRON ALTAR DEBUG DATA ==="));
680: }

================
File: Source/WitchPT/Public/Item/CauldronAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "MechanicsInterface.h"
  7: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  8: #include "CauldronAltar.generated.h"
  9: 
 10: class UCauldronCraftComponent;
 11: class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
 12: class UWitchPTInventoryItemFragment;
 13: class UCauldronUserWidget;
 14: class ACauldronPosition;
 15: class ACharacter;
 16: 
 17: 
 18: USTRUCT(BlueprintType)
 19: struct FIngredientSequence
 20: {
 21:     GENERATED_BODY()
 22: 
 23:     UPROPERTY(BlueprintReadOnly)
 24:     TArray<FGameplayTag> Ingredients;
 25: };
 26: 
 27: 
 28: UENUM(BlueprintType)
 29: enum class ECauldronInput : uint8
 30: {
 31:     Ingredient1 UMETA(DisplayName = "Ingredient 1"),
 32:     Ingredient2 UMETA(DisplayName = "Ingredient 2"),
 33:     Ingredient3 UMETA(DisplayName = "Ingredient 3"),
 34:     Ingredient4 UMETA(DisplayName = "Ingredient 4"),
 35:     Ingredient5 UMETA(DisplayName = "Ingredient 5"),
 36:     None        UMETA(DisplayName = "None")
 37: };
 38: 
 39: UENUM(BlueprintType)
 40: enum ECauldronPhysicState
 41: {
 42:     Static UMETA(DisplayName = "InPlace"),
 43:     Moving UMETA(DisplayName = "Moving"),
 44:     Previewing UMETA(DisplayName = "Previewing")
 45: };
 46: 
 47: 
 48: UENUM(BlueprintType)
 49: enum class ECauldronPlacementState : uint8
 50: {
 51:     Valid UMETA(DisplayName = "Valid"),
 52:     Invalid UMETA(DisplayName = "Invalid"),
 53:     None UMETA(DisplayName = "None")
 54: };
 55: 
 56: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
 57: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
 58: 
 59: 
 60: 
 61: 
 62: UCLASS()
 63: class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
 64: {
 65:     GENERATED_BODY()
 66: 
 67: public:
 68: 
 69:     ACauldronAltar();
 70: 
 71: 
 72:     virtual void BeginPlay() override;
 73:     virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 74:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 75:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 76:     virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
 77: 
 78: 
 79:     UPROPERTY(EditAnywhere)
 80:     FInteractionOption Option;
 81: 
 82:     UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
 83:     TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;
 84: 
 85:     UPROPERTY(EditAnywhere, Replicated)
 86:     TObjectPtr<UCauldronCraftComponent> CauldronCraftComponent;
 87: 
 88: 
 89:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
 90:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition;
 91: 
 92: 
 93: 
 94: 
 95:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 96:     FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
 97: 
 98:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 99:     FOnCharacterPositioned OnCharacterPositioned;
100: 
101: 
102:     UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
103:     TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
104: 
105: 
106:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
107:     UMaterialInterface* ValidPlacementMaterial;
108: 
109:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
110:     UMaterialInterface* InvalidPlacementMaterial;
111: 
112:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
113:     float PlacementCollisionCheckRadius = 50.0f;
114: 
115:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
116:     float MaxGroundAlignmentHeight = 20.0f;
117: 
118: 
119: 
120:     void StartBrewingPotion(ACharacter* InteractingCharacter);
121: 
122:     void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
123: 
124: 
125: 
126:     UFUNCTION()
127:     void OnRep_CauldronPhysicState();
128: 
129:     UFUNCTION()
130:     void PositionCharacterForBrewing(ACharacter* Character);
131: 
132:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
133:     ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
134: 
135: 
136: 
137:     void StartCarryCauldron(ACharacter* InteractingCharacter);
138: 
139:     UFUNCTION()
140:     void AttachToCharacter(ACharacter* Character);
141: 
142:     UFUNCTION()
143:     void DetachFromCharacter(ACharacter* Character);
144: 
145: 
146:     void StartPlacementPreview(ACharacter* Character);
147:     void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
148:     void FinalizePlacement();
149:     void CancelPlacement();
150:     void ApplyPlacementPreviewMaterial();
151: 
152:     UFUNCTION(Client, Unreliable)
153:     void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
154: 
155:     UFUNCTION(NetMulticast, Reliable)
156:     void Multicast_FinalizePlacement();
157: 
158: 
159:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
160:     bool CanBePickedUp() const;
161: 
162:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
163:     bool IsBeingCarried() const;
164: 
165:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
166:     ACharacter* GetCarryingCharacter() const;
167: 
168:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
169:     ECauldronPlacementState GetPlacementState() const;
170: 
171:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
172:     bool IsInPlacementPreview() const;
173: 
174: 
175:     UFUNCTION(BlueprintCallable, Category = "Debug|Cauldron")
176:     void PrintCauldronDebugData() const;
177: 
178: private:
179:     UPROPERTY(Replicated)
180:     TObjectPtr<ACharacter> CarryingCharacter;
181: 
182:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
183:     FName BackAttachSocketName = "BackpackSocket";
184: 
185:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
186:     FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
187: 
188: 
189:     UPROPERTY(Replicated)
190:     ECauldronPlacementState CurrentPlacementState;
191: 
192:     UPROPERTY()
193:     TArray<UMaterialInterface*> OriginalMaterials;
194: 
195:     FVector PreviewLocation;
196:     FRotator PreviewRotation;
197: 
198: 
199:     void RestoreOriginalMaterials();
200:     bool IsPlacementValid() const;
201: };

================
File: Source/WitchPT/Public/Item/RitualAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "RitualAltar.generated.h"
  7: 
  8: class URitualUserWidget;
  9: class ARitualPosition;
 10: 
 11: 
 12: UENUM(BlueprintType)
 13: enum class ERitualInput : uint8
 14: {
 15: 	Up		UMETA(DisplayName = "Up"),
 16: 	Down	UMETA(DisplayName = "Down"),
 17: 	Left	UMETA(DisplayName = "Left"),
 18: 	Right	UMETA(DisplayName = "Right"),
 19: 	None	UMETA(DisplayName = "None")
 20: };
 21: 
 22: USTRUCT(BlueprintType)
 23: struct FUIRitualData
 24: {
 25: 	GENERATED_BODY()
 26: 	UPROPERTY(BlueprintReadOnly)
 27: 	bool bIsMyTurn = false;
 28: 	UPROPERTY(BlueprintReadOnly)
 29: 	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
 30: 	UPROPERTY(BlueprintReadOnly)
 31: 	float RitualPercentageCompleted = 0.0f;
 32: 	UPROPERTY(BlueprintReadOnly)
 33: 	float CorruptionPercentage = 0.0f;
 34: 	UPROPERTY(BlueprintReadOnly)
 35: 	float CurrentInputTimeRemaining = 0.0f;
 36: };
 37: 
 38: 
 39: USTRUCT(BlueprintType)
 40: struct FRitualReadyPlayersData
 41: {
 42: 	GENERATED_BODY()
 43: 
 44: 	UPROPERTY(BlueprintReadOnly)
 45: 	int32 TotalPlayers = 0;
 46: 
 47: 	UPROPERTY(BlueprintReadOnly)
 48: 	int32 ReadyPlayers = 0;
 49: 
 50: 	bool operator==(const FRitualReadyPlayersData& Other) const
 51: 	{
 52: 		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
 53: 	}
 54: 
 55: 	bool operator!=(const FRitualReadyPlayersData& Other) const
 56: 	{
 57: 		return !(*this == Other);
 58: 	}
 59: };
 60: 
 61: 
 62: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
 63: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
 64: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
 65: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
 66: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
 67: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
 68: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);
 69: 
 70: UCLASS()
 71: class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
 72: {
 73: 	GENERATED_BODY()
 74: 
 75: public:
 76: 
 77: 	ARitualAltar();
 78: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 79: 
 80: 
 81: 
 82: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
 83: 	EInteractionState CurrentRitualState = EInteractionState::Inactive;
 84: 
 85: 
 86: 	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
 87: 	TArray<FGameplayTag> InputSequence;
 88: 
 89: 
 90: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
 91: 	int32 CurrentSequenceIndex = -1;
 92: 
 93: 
 94: 	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
 95: 	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
 96: 
 97: 
 98: 	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
 99: 	FRitualReadyPlayersData ReadyPlayersData;
100: 
101: 
102: 	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
103: 	int32 StartCountdown = 3;
104: 
105: 
106: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
107: 	TObjectPtr<ACharacter> CurrentActivePlayer;
108: 
109: 
110: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
111: 	float CurrentInputTimer;
112: 
113: 
114: 	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
115: 	FUIRitualData CurrentTurnData;
116: 
117: 
118: 	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
119: 	float CorruptionAmount = 0.0f;
120: 
121: 
122: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
123: 	float MaxCorruption = 100.0f;
124: 
125: 
126: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
127: 	float CorruptionIncreasePerFail = 10.0f;
128: 
129: 
130: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
131: 	float BaseInputTimeWindow = 10.0f;
132: 
133: 
134: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
135: 	float DifficultyScalingMultiplier = 1.0f;
136: 
137: 
138: 	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
139: 	bool bRitualCompleted = false;
140: 
141: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
142: 	bool bRitualWasSuccessful = false;
143: 
144: 
145: 	FOnRitualStateChanged OnRitualStateChangedEvent;
146: 
147: 	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
148: 
149: 	FOnCountdownTick OnCountdownTickEvent;
150: 
151: 	FOnTurnDataChanged OnTurnDataChangedEvent;
152: 
153: 	FOnCorruptionChanged OnCorruptionChangedEvent;
154: 
155: 	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
156: 	UPROPERTY(BlueprintAssignable)
157: 	FOnRitualCompleted OnRitualCompletedEvent;
158: 
159: 
160: 	UFUNCTION()
161: 	void OnRep_CurrentRitualState();
162: 
163: 	UFUNCTION()
164: 	void OnRep_CurrentSequenceIndex();
165: 
166: 	UFUNCTION()
167: 	void OnRep_ReadyPlayersData();
168: 
169: 	UFUNCTION()
170: 	void OnRep_StartCountdown();
171: 
172: 	UFUNCTION()
173: 	void OnRep_CurrentActivePlayer();
174: 
175: 	UFUNCTION()
176: 	void OnRep_TurnData();
177: 
178: 	UFUNCTION()
179: 	void OnRep_CorruptionAmount();
180: 
181: 	UFUNCTION()
182: 	void OnRep_RitualCompleted();
183: 
184: 
185: 	UFUNCTION(NetMulticast, Reliable)
186: 	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
187: 
188: 	void StartRitual(ACharacter* RequestingCharacter);
189: 	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
190: 
191: 
192: 	UFUNCTION(BlueprintPure, Category = "Ritual")
193: 	bool IsPlayerReady(ACharacter* Player) const;
194: 
195: 
196: 	UFUNCTION(BlueprintPure, Category = "Ritual")
197: 	bool AreAllPlayersReady() const;
198: 
199: 	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
200: 	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
201: 
202: 
203: 	UFUNCTION(NetMulticast, Reliable)
204: 	void Multicast_OnRitualSucceeded();
205: 
206: 	UFUNCTION(NetMulticast, Reliable)
207: 	void Multicast_OnRitualCatastrophicFail();
208: 
209: 
210: 	UFUNCTION(NetMulticast, Reliable)
211: 	void Multicast_OnCountdownTick(int32 CountdownValue);
212: 
213: 	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
214: 
215: 
216: 	virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position) override;
217: 
218: 
219: 	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
220: 	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
221: 	float GetCorruptionPercentage() const;
222: 	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
223: 	float GetCurrentSequenceProgress() const;
224: 	FGameplayTag GetCurrentExpectedInput() const;
225: 	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
226: 	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
227: 	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }
228: 
229: 
230: protected:
231: 	virtual void BeginPlay() override;
232: 	virtual void Tick(float DeltaTime) override;
233: 
234: 
235: 	FTimerHandle RitualStartCountdownHandle;
236: 
237: 
238: 	FTimerHandle InputTimerHandle;
239: 
240: 
241: 	void GenerateInputSequence();
242: 	void AdvanceToNextPlayer();
243: 	virtual void HandleInputSuccess(ACharacter* Player) override;
244: 	virtual void HandleInputFailure(ACharacter* Player) override;
245: 	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
246: 	void StartInputTimer();
247: 	void OnInputTimerExpired();
248: 	void CheckRitualState();
249: 	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
250: 	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
251: 	void CleanupRitual();
252: 	void SpawnReward();
253: 	void SpawnDemon();
254: 	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
255: 	void UpdateTurnData();
256: 	void UpdateReadyPlayersData();
257: 
258: 
259: 	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
260: 	void StartRitualCountdown();
261: 	void ProcessCountdownTick();
262: 	void ActivateRitual();
263: 
264: 
265: 
266: 	void BroadcastRitualStateChanged();
267: 	void BroadcastReadyPlayersChanged();
268: 	void BroadcastCountdownTick();
269: 	void BroadcastTurnDataChanged();
270: 	void BroadcastCorruptionChanged();
271: 	void BroadcastSequenceProgressChanged();
272: 	void BroadcastRitualCompleted();
273: 
274: 
275: 
276: 	void HideRitualWidgetForAllPlayers();
277: 
278: 	UPROPERTY(EditDefaultsOnly)
279: 	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
280: 	UPROPERTY(EditDefaultsOnly)
281: 	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
282: 	UPROPERTY(EditDefaultsOnly)
283: 	TObjectPtr<UAnimMontage> FailedAnimMontage;
284: 	UPROPERTY(EditDefaultsOnly)
285: 	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
286: 
287: 
288: 	UPROPERTY(EditDefaultsOnly)
289: 	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
290: 	UPROPERTY(EditDefaultsOnly)
291: 	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
292: };

================
File: Source/WitchPT/Private/Item/RitualAltar.cpp
================
   1: #include "Item/RitualAltar.h"
   2: #include "Net/UnrealNetwork.h"
   3: #include "Item/RitualPosition.h"
   4: #include "GameFramework/Character.h"
   5: #include "AbilitySystemComponent.h"
   6: #include "AbilitySystemBlueprintLibrary.h"
   7: #include "FWitchPTGameplayTags.h"
   8: #include "Player/WitchPTPlayerController.h"
   9: 
  10: 
  11: ARitualAltar::ARitualAltar()
  12: {
  13: 
  14: 	PrimaryActorTick.bCanEverTick = true;
  15: 
  16: 	bReplicates = true;
  17: 
  18: 
  19: 	CurrentRitualState = EInteractionState::Inactive;
  20: 	CurrentSequenceIndex = -1;
  21: 	CurrentInputTimer = 0.0f;
  22: 	CorruptionAmount = 0.0f;
  23: 	MaxCorruption = 100.0f;
  24: 	StartCountdown = 3;
  25: 	bRitualCompleted = false;
  26: 	bRitualWasSuccessful = false;
  27: }
  28: 
  29: void ARitualAltar::BeginPlay()
  30: {
  31: 	Super::BeginPlay();
  32: 
  33: 
  34: 
  35: 
  36: 
  37: 
  38: 
  39: 
  40: 
  41: 
  42: 
  43: 
  44: 
  45: 
  46: 
  47: 
  48: 
  49: }
  50: 
  51: void ARitualAltar::Tick(float DeltaTime)
  52: {
  53: 	Super::Tick(DeltaTime);
  54: }
  55: 
  56: void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
  57: {
  58: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  59: 
  60: 	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
  61: 	DOREPLIFETIME(ARitualAltar, InputSequence);
  62: 	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
  63: 	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
  64: 	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
  65: 	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
  66: 	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
  67: 	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
  68: 	DOREPLIFETIME(ARitualAltar, MaxCorruption);
  69: 	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
  70: 	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
  71: 	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
  72: 	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
  73: 	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
  74: 	DOREPLIFETIME(ARitualAltar, StartCountdown);
  75: 	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
  76: 	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
  77: }
  78: 
  79: 
  80: 
  81: void ARitualAltar::OnRep_CurrentRitualState()
  82: {
  83: 	BroadcastRitualStateChanged();
  84: }
  85: 
  86: void ARitualAltar::OnRep_CurrentSequenceIndex()
  87: {
  88: 
  89: 	BroadcastSequenceProgressChanged();
  90: }
  91: 
  92: void ARitualAltar::OnRep_ReadyPlayersData()
  93: {
  94: 	BroadcastReadyPlayersChanged();
  95: }
  96: 
  97: void ARitualAltar::OnRep_StartCountdown()
  98: {
  99: 	BroadcastCountdownTick();
 100: }
 101: 
 102: void ARitualAltar::OnRep_CurrentActivePlayer()
 103: {
 104: 
 105: 
 106: }
 107: 
 108: void ARitualAltar::OnRep_TurnData()
 109: {
 110: 	BroadcastTurnDataChanged();
 111: }
 112: 
 113: void ARitualAltar::OnRep_CorruptionAmount()
 114: {
 115: 	BroadcastCorruptionChanged();
 116: }
 117: 
 118: void ARitualAltar::OnRep_RitualCompleted()
 119: {
 120: 	if (bRitualCompleted)
 121: 	{
 122: 		BroadcastRitualCompleted();
 123: 	}
 124: }
 125: 
 126: 
 127: 
 128: void ARitualAltar::BroadcastRitualStateChanged()
 129: {
 130: 	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
 131: }
 132: 
 133: void ARitualAltar::BroadcastReadyPlayersChanged()
 134: {
 135: 	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
 136: }
 137: 
 138: void ARitualAltar::BroadcastCountdownTick()
 139: {
 140: 	OnCountdownTickEvent.Broadcast(StartCountdown);
 141: }
 142: 
 143: void ARitualAltar::BroadcastTurnDataChanged()
 144: {
 145: 	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
 146: }
 147: 
 148: void ARitualAltar::BroadcastCorruptionChanged()
 149: {
 150: 	float CorruptionPercentage = GetCorruptionPercentage();
 151: 	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
 152: }
 153: 
 154: void ARitualAltar::BroadcastSequenceProgressChanged()
 155: {
 156: 	float Progress = GetCurrentSequenceProgress();
 157: 	OnSequenceProgressChangedEvent.Broadcast(Progress);
 158: }
 159: 
 160: void ARitualAltar::BroadcastRitualCompleted()
 161: {
 162: 	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
 163: }
 164: 
 165: 
 166: 
 167: void ARitualAltar::UpdateTurnData()
 168: {
 169: 
 170: 
 171: 
 172: 
 173: 	FUIRitualData NewTurnData;
 174: 	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
 175: 	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
 176: 	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
 177: 
 178: 
 179: 	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
 180: 	{
 181: 		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
 182: 	}
 183: 	else
 184: 	{
 185: 		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
 186: 	}
 187: 
 188: 
 189: 	NewTurnData.bIsMyTurn = false;
 190: 
 191: 
 192: 	if (HasAuthority())
 193: 	{
 194: 
 195: 		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
 196: 			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
 197: 			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
 198: 			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
 199: 			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
 200: 		{
 201: 			CurrentTurnData = NewTurnData;
 202: 
 203: 			BroadcastTurnDataChanged();
 204: 		}
 205: 	}
 206: 	else
 207: 	{
 208: 
 209: 		CurrentTurnData = NewTurnData;
 210: 		BroadcastTurnDataChanged();
 211: 	}
 212: }
 213: 
 214: void ARitualAltar::UpdateReadyPlayersData()
 215: {
 216: 	if (!HasAuthority())
 217: 	{
 218: 		return;
 219: 	}
 220: 
 221: 	FRitualReadyPlayersData NewData;
 222: 	NewData.TotalPlayers = ParticipatingPlayers.Num();
 223: 	NewData.ReadyPlayers = ReadyPlayers.Num();
 224: 
 225: 	if (ReadyPlayersData != NewData)
 226: 	{
 227: 		ReadyPlayersData = NewData;
 228: 
 229: 		BroadcastReadyPlayersChanged();
 230: 	}
 231: }
 232: 
 233: 
 234: 
 235: void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
 236: {
 237: 
 238: 	UpdateReadyPlayersData();
 239: }
 240: 
 241: void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
 242: {
 243: 	if (!HasAuthority() || !RequestingCharacter)
 244: 	{
 245: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
 246: 		return;
 247: 	}
 248: 
 249: 
 250: 	if (CurrentRitualState != EInteractionState::Inactive &&
 251: 	    CurrentRitualState != EInteractionState::WaitingForPlayers)
 252: 	{
 253: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
 254: 		return;
 255: 	}
 256: 
 257: 
 258: 	ProcessRitualReadyRequest(RequestingCharacter);
 259: }
 260: 
 261: void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
 262: {
 263: 	if (!HasAuthority() || !RequestingCharacter)
 264: 	{
 265: 		return;
 266: 	}
 267: 
 268: 
 269: 	if (ReadyPlayers.Contains(RequestingCharacter))
 270: 	{
 271: 
 272: 		ReadyPlayers.Remove(RequestingCharacter);
 273: 		UpdateReadyPlayersData();
 274: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
 275: 		return;
 276: 	}
 277: 
 278: 
 279: 	ReadyPlayers.Add(RequestingCharacter);
 280: 	UpdateReadyPlayersData();
 281: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
 282: 
 283: 
 284: 	if (AreAllPlayersReady())
 285: 	{
 286: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
 287: 		StartRitualCountdown();
 288: 	}
 289: }
 290: 
 291: bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
 292: {
 293: 	return ReadyPlayers.Contains(Player);
 294: }
 295: 
 296: bool ARitualAltar::AreAllPlayersReady() const
 297: {
 298: 
 299: 	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
 300: 	{
 301: 		return false;
 302: 	}
 303: 
 304: 	for (ACharacter* Player : ParticipatingPlayers)
 305: 	{
 306: 		if (!ReadyPlayers.Contains(Player))
 307: 		{
 308: 			return false;
 309: 		}
 310: 	}
 311: 
 312: 	return true;
 313: }
 314: 
 315: void ARitualAltar::StartRitualCountdown()
 316: {
 317: 	if (!HasAuthority())
 318: 	{
 319: 		return;
 320: 	}
 321: 
 322: 
 323: 	CurrentRitualState = EInteractionState::Preparing;
 324: 
 325: 	BroadcastRitualStateChanged();
 326: 
 327: 
 328: 	GenerateInputSequence();
 329: 
 330: 
 331: 	StartCountdown = 3;
 332: 
 333: 	BroadcastCountdownTick();
 334: 
 335: 
 336: 	GetWorldTimerManager().SetTimer(
 337: 		RitualStartCountdownHandle,
 338: 		this,
 339: 		&ARitualAltar::ProcessCountdownTick,
 340: 		1.0f,
 341: 		true
 342: 	);
 343: }
 344: 
 345: void ARitualAltar::ProcessCountdownTick()
 346: {
 347: 	if (!HasAuthority())
 348: 	{
 349: 		return;
 350: 	}
 351: 
 352: 
 353: 	StartCountdown--;
 354: 
 355: 	BroadcastCountdownTick();
 356: 
 357: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
 358: 
 359: 	if (StartCountdown <= 0)
 360: 	{
 361: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 362: 		ActivateRitual();
 363: 	}
 364: }
 365: 
 366: void ARitualAltar::ActivateRitual()
 367: {
 368: 	if (!HasAuthority())
 369: 	{
 370: 		return;
 371: 	}
 372: 
 373: 
 374: 	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
 375: 
 376: 
 377: 	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
 378: 	CurrentSequenceIndex = 0;
 379: 	CurrentRitualState = EInteractionState::Active;
 380: 
 381: 
 382: 	StartInputTimer();
 383: 
 384: 
 385: 	UpdateTurnData();
 386: 
 387: 
 388: 	BroadcastRitualStateChanged();
 389: }
 390: 
 391: void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
 392: {
 393: 
 394: 	StartCountdown = CountdownValue;
 395: }
 396: 
 397: void ARitualAltar::GenerateInputSequence()
 398: {
 399: 	if (!HasAuthority())
 400: 	{
 401: 		return;
 402: 	}
 403: 
 404: 	InputSequence.Empty();
 405: 
 406: 
 407: 	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
 408: 
 409: 
 410: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 411: 
 412: 	TArray<FGameplayTag> PossibleInputs;
 413: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
 414: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
 415: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
 416: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
 417: 
 418: 
 419: 	for (int32 i = 0; i < SequenceLength; ++i)
 420: 	{
 421: 		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
 422: 		InputSequence.Add(PossibleInputs[RandomIndex]);
 423: 	}
 424: 
 425: 
 426: 
 427: 
 428: }
 429: 
 430: void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
 431: {
 432: 	if (!Character || !HasAuthority())
 433: 	{
 434: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
 435: 		return;
 436: 	}
 437: 
 438: 
 439: 	if (CurrentRitualState != EInteractionState::Active)
 440: 	{
 441: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"),
 442: 			*Character->GetName(), static_cast<int32>(CurrentRitualState));
 443: 		return;
 444: 	}
 445: 
 446: 
 447: 	if (Character != CurrentActivePlayer)
 448: 	{
 449: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"),
 450: 			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
 451: 		return;
 452: 	}
 453: 
 454: 
 455: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 456: 	{
 457: 		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"),
 458: 			CurrentSequenceIndex, InputSequence.Num());
 459: 		return;
 460: 	}
 461: 
 462: 
 463: 	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
 464: 
 465: 
 466: 
 467: 	if (InputTag == ExpectedInput)
 468: 	{
 469: 		HandleInputSuccess(Character);
 470: 	}
 471: 	else
 472: 	{
 473: 		HandleInputFailure(Character);
 474: 	}
 475: }
 476: 
 477: void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 478: {
 479: 
 480: 	if (Character)
 481: 	{
 482: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 483: 		if (ASC)
 484: 		{
 485: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 486: 			FGameplayEventData EventData;
 487: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 488: 			EventData.Instigator = this;
 489: 			EventData.Target = Character;
 490: 
 491: 
 492: 			FGameplayTag* PositionTag = nullptr;
 493: 			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 494: 			{
 495: 				if (Entry.Player == Character)
 496: 				{
 497: 					PositionTag = &Entry.PositionTag;
 498: 					break;
 499: 				}
 500: 			}
 501: 			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
 502: 			{
 503: 				EventData.OptionalObject = PrimaryAnimMontage;
 504: 			} else
 505: 			{
 506: 				EventData.OptionalObject = SecondaryAnimMontage;
 507: 			}
 508: 
 509: 
 510: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
 511: 		}
 512: 
 513: 
 514: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 515: 	}
 516: }
 517: 
 518: void ARitualAltar::HandleInputSuccess(ACharacter* Player)
 519: {
 520: 	if (!HasAuthority() || !Player)
 521: 	{
 522: 		return;
 523: 	}
 524: 
 525: 
 526: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 527: 
 528: 
 529: 	CurrentSequenceIndex++;
 530: 
 531: 
 532: 	Multicast_OnInputSuccess(Player);
 533: 
 534: 
 535: 	if (CurrentSequenceIndex >= InputSequence.Num())
 536: 	{
 537: 
 538: 		CurrentRitualState = EInteractionState::Succeeded;
 539: 		bRitualCompleted = true;
 540: 		bRitualWasSuccessful = true;
 541: 
 542: 
 543: 		UpdateTurnData();
 544: 
 545: 
 546: 		BroadcastRitualStateChanged();
 547: 		BroadcastRitualCompleted();
 548: 
 549: 
 550: 		SpawnReward();
 551: 		Multicast_OnRitualSucceeded();
 552: 
 553: 
 554: 		CleanupRitual();
 555: 	}
 556: 	else
 557: 	{
 558: 
 559: 		AdvanceToNextPlayer();
 560: 
 561: 
 562: 		StartInputTimer();
 563: 
 564: 
 565: 		UpdateTurnData();
 566: 	}
 567: }
 568: 
 569: void ARitualAltar::HandleInputFailure(ACharacter* Player)
 570: {
 571: 	if (!HasAuthority() || !Player)
 572: 	{
 573: 		return;
 574: 	}
 575: 
 576: 
 577: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 578: 
 579: 
 580: 	CorruptionAmount += CorruptionIncreasePerFail;
 581: 
 582: 	BroadcastCorruptionChanged();
 583: 
 584: 
 585: 
 586: 
 587: 
 588: 	ApplyAgePenalty(Player);
 589: 
 590: 
 591: 	Multicast_OnInputFailed(Player);
 592: 
 593: 
 594: 	if (CorruptionAmount >= MaxCorruption)
 595: 	{
 596: 
 597: 		CurrentRitualState = EInteractionState::FailedCatastrophically;
 598: 		bRitualCompleted = true;
 599: 		bRitualWasSuccessful = false;
 600: 
 601: 
 602: 		UpdateTurnData();
 603: 
 604: 
 605: 		BroadcastRitualStateChanged();
 606: 		BroadcastRitualCompleted();
 607: 
 608: 
 609: 		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
 610: 		{
 611: 			if (ParticipatingPlayer)
 612: 			{
 613: 				ApplyAgePenalty(ParticipatingPlayer, true);
 614: 			}
 615: 		}
 616: 
 617: 
 618: 		SpawnDemon();
 619: 		Multicast_OnRitualCatastrophicFail();
 620: 
 621: 
 622: 		CleanupRitual();
 623: 	}
 624: 	else
 625: 	{
 626: 
 627: 		AdvanceToNextPlayer();
 628: 
 629: 
 630: 		StartInputTimer();
 631: 
 632: 
 633: 		UpdateTurnData();
 634: 	}
 635: }
 636: 
 637: void ARitualAltar::StartInputTimer()
 638: {
 639: 	if (!HasAuthority())
 640: 	{
 641: 		return;
 642: 	}
 643: 
 644: 
 645: 	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
 646: 	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f));
 647: 
 648: 
 649: 	CurrentInputTimer = ScaledTimeWindow;
 650: 
 651: 
 652: 
 653: 	GetWorldTimerManager().SetTimer(
 654: 		InputTimerHandle,
 655: 		this,
 656: 		&ARitualAltar::OnInputTimerExpired,
 657: 		ScaledTimeWindow,
 658: 		false
 659: 	);
 660: 
 661: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"),
 662: 		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"),
 663: 		CurrentSequenceIndex, InputSequence.Num()-1);
 664: 
 665: 
 666: 	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
 667: 	{
 668: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"),
 669: 			*InputSequence[CurrentSequenceIndex].ToString());
 670: 	}
 671: }
 672: 
 673: void ARitualAltar::OnInputTimerExpired()
 674: {
 675: 	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
 676: 	{
 677: 		return;
 678: 	}
 679: 
 680: 
 681: 	if (CurrentActivePlayer)
 682: 	{
 683: 		HandleInputFailure(CurrentActivePlayer);
 684: 	}
 685: 	else
 686: 	{
 687: 
 688: 		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
 689: 		AdvanceToNextPlayer();
 690: 		StartInputTimer();
 691: 	}
 692: }
 693: 
 694: void ARitualAltar::AdvanceToNextPlayer()
 695: {
 696: 	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
 697: 	{
 698: 		return;
 699: 	}
 700: 
 701: 
 702: 
 703: 	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
 704: 
 705: 
 706: 	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
 707: 	{
 708: 		CurrentPlayerIndex = 0;
 709: 	}
 710: 	else
 711: 	{
 712: 		CurrentPlayerIndex++;
 713: 	}
 714: 
 715: 
 716: 	int32 StartIndex = CurrentPlayerIndex;
 717: 	bool bFoundEligiblePlayer = false;
 718: 
 719: 
 720: 	do
 721: 	{
 722: 		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
 723: 		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
 724: 		{
 725: 			CurrentActivePlayer = NextPlayer;
 726: 			bFoundEligiblePlayer = true;
 727: 			break;
 728: 		}
 729: 
 730: 
 731: 		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
 732: 	}
 733: 	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
 734: 
 735: 
 736: 	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
 737: 	{
 738: 		CurrentActivePlayer = ParticipatingPlayers[0];
 739: 	}
 740: }
 741: 
 742: bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
 743: {
 744: 	if (!Player)
 745: 	{
 746: 		return false;
 747: 	}
 748: 
 749: 
 750: 	bool bIsInPosition = false;
 751: 	for (const ABaseInteractionPosition* Position : InteractionPositions)
 752: 	{
 753: 		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
 754: 		{
 755: 			bIsInPosition = true;
 756: 			break;
 757: 		}
 758: 	}
 759: 
 760: 
 761: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 762: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 763: 	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
 764: 
 765: 	return bIsInPosition && bHasPositionTag;
 766: }
 767: 
 768: 
 769: void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
 770: {
 771: 	if (!HasAuthority() || !Player)
 772: 	{
 773: 		return;
 774: 	}
 775: 
 776: 
 777: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 778: 	if (!ASC)
 779: 	{
 780: 		return;
 781: 	}
 782: 
 783: 
 784: 
 785: 
 786: 
 787: 
 788: 
 789: 
 790: 
 791: 
 792: 
 793: 
 794: 
 795: 
 796: 
 797: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"),
 798: 		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
 799: }
 800: 
 801: void ARitualAltar::SpawnReward()
 802: {
 803: 	if (!HasAuthority())
 804: 	{
 805: 		return;
 806: 	}
 807: 
 808: 
 809: 
 810: 
 811: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
 812: }
 813: 
 814: void ARitualAltar::SpawnDemon()
 815: {
 816: 	if (!HasAuthority())
 817: 	{
 818: 		return;
 819: 	}
 820: 
 821: 
 822: 
 823: 
 824: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
 825: }
 826: 
 827: void ARitualAltar::CleanupRitual()
 828: {
 829: 	if (!HasAuthority())
 830: 	{
 831: 		return;
 832: 	}
 833: 
 834: 
 835: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 836: 	GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 837: 
 838: 
 839: 	HideRitualWidgetForAllPlayers();
 840: 
 841: 
 842: 	CurrentSequenceIndex = 0;
 843: 	InputSequence.Empty();
 844: 	CurrentActivePlayer = nullptr;
 845: 	ReadyPlayers.Empty();
 846: 
 847: 
 848: 
 849: 
 850: 
 851: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up and widgets hidden"));
 852: }
 853: 
 854: float ARitualAltar::GetCurrentSequenceProgress() const
 855: {
 856: 	if (InputSequence.Num() == 0)
 857: 	{
 858: 		return 0.0f;
 859: 	}
 860: 
 861: 	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
 862: }
 863: 
 864: FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
 865: {
 866: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 867: 	{
 868: 
 869: 		return FGameplayTag();
 870: 	}
 871: 
 872: 	return InputSequence[CurrentSequenceIndex];
 873: }
 874: 
 875: 
 876: 
 877: FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
 878: {
 879: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 880: 
 881: 	switch (Input)
 882: 	{
 883: 	case ERitualInput::Up:
 884: 		return WitchPtGameplayTags.Ritual_Input_Up;
 885: 	case ERitualInput::Down:
 886: 		return WitchPtGameplayTags.Ritual_Input_Down;
 887: 	case ERitualInput::Left:
 888: 		return WitchPtGameplayTags.Ritual_Input_Left;
 889: 	case ERitualInput::Right:
 890: 		return WitchPtGameplayTags.Ritual_Input_Right;
 891: 	default:
 892: 		return FGameplayTag();
 893: 	}
 894: }
 895: 
 896: ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
 897: {
 898: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 899: 
 900: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
 901: 		return ERitualInput::Up;
 902: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
 903: 		return ERitualInput::Down;
 904: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
 905: 		return ERitualInput::Left;
 906: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
 907: 		return ERitualInput::Right;
 908: 
 909: 	return ERitualInput::None;
 910: }
 911: 
 912: void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 913: {
 914: 	if (Character)
 915: 	{
 916: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 917: 		if (ASC)
 918: 		{
 919: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 920: 			FGameplayEventData EventData;
 921: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 922: 			EventData.Instigator = this;
 923: 			EventData.Target = Character;
 924: 
 925: 			EventData.OptionalObject = FailedAnimMontage;
 926: 
 927: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
 928: 
 929: 		}
 930: 
 931: 
 932: 
 933: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 934: 	}
 935: 
 936: 
 937: }
 938: 
 939: 
 940: 
 941: void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 942: {
 943: 
 944: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
 945: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
 946: 	if (Player->IsLocallyControlled())
 947: 	{
 948: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
 949: 	}
 950: 	else
 951: 	{
 952: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
 953: 	}
 954: 
 955: 	if (!Player || !Position || !HasAuthority())
 956: 	{
 957: 		return;
 958: 	}
 959: 
 960: 
 961: 	if (Position->IsOccupied())
 962: 	{
 963: 
 964: 		return;
 965: 	}
 966: 	Position->SetOccupied(Player);
 967: 
 968: 	bool bFound = false;
 969: 	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 970: 	{
 971: 		if (Entry.Player == Player)
 972: 		{
 973: 			Entry.PositionTag = Position->GetPositionTag();
 974: 			bFound = true;
 975: 			break;
 976: 		}
 977: 	}
 978: 	if (!bFound)
 979: 	{
 980: 		FPlayerPositionTagEntry NewEntry;
 981: 		NewEntry.Player = Player;
 982: 		NewEntry.PositionTag = Position->GetPositionTag();
 983: 		PlayerPositionTags.Add(NewEntry);
 984: 	}
 985: 
 986: 
 987: 	if (!ParticipatingPlayers.Contains(Player))
 988: 	{
 989: 		ParticipatingPlayers.Add(Player);
 990: 	}
 991: 	CurrentRitualState = EInteractionState::WaitingForPlayers;
 992: 
 993: 
 994: 	if (HasAuthority())
 995: 	{
 996: 		BroadcastRitualStateChanged();
 997: 	}
 998: 
 999: 
1000: 	UpdateReadyPlayersData();
1001: 
1002: 
1003: 	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1004: 	if (PC)
1005: 	{
1006: 		if (Player->IsLocallyControlled())
1007: 		{
1008: 
1009: 			PC->LocalShowRitualWidget(this);
1010: 		}
1011: 		else
1012: 		{
1013: 
1014: 			PC->Client_ShowRitualWidget(this);
1015: 		}
1016: 
1017: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Showing ritual widget for player %s"), *Player->GetName());
1018: 	}
1019: }
1020: 
1021: void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
1022: {
1023: 
1024: 
1025: 
1026: 
1027: 
1028: 
1029: 
1030: 
1031: 	bRitualCompleted = true;
1032: 	bRitualWasSuccessful = true;
1033: 
1034: 
1035: 	if (HasAuthority())
1036: 	{
1037: 		HideRitualWidgetForAllPlayers();
1038: 	}
1039: 
1040: 	DestroyAltarPositions();
1041: 
1042: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback and widgets hidden"));
1043: }
1044: 
1045: void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
1046: {
1047: 
1048: 
1049: 
1050: 
1051: 
1052: 
1053: 
1054: 
1055: 	bRitualCompleted = true;
1056: 	bRitualWasSuccessful = false;
1057: 
1058: 
1059: 	if (HasAuthority())
1060: 	{
1061: 		HideRitualWidgetForAllPlayers();
1062: 	}
1063: 
1064: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback and widgets hidden"));
1065: }
1066: 
1067: float ARitualAltar::GetCorruptionPercentage() const
1068: {
1069: 	if (MaxCorruption == 0.0f)
1070: 	{
1071: 		return 0.0f;
1072: 	}
1073: 
1074: 	return CorruptionAmount / MaxCorruption;
1075: }
1076: 
1077: void ARitualAltar::HideRitualWidgetForAllPlayers()
1078: {
1079: 
1080: 	for (ACharacter* Player : ParticipatingPlayers)
1081: 	{
1082: 		if (Player)
1083: 		{
1084: 			AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1085: 			if (PC)
1086: 			{
1087: 
1088: 			if (Player->IsLocallyControlled())
1089: 			{
1090: 
1091: 				PC->LocalHideRitualWidget();
1092: 			}
1093: 			else
1094: 			{
1095: 
1096: 				PC->Client_HideRitualWidget();
1097: 			}
1098: 
1099: 				UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for player %s"), *Player->GetName());
1100: 			}
1101: 		}
1102: 	}
1103: }
1104: 
1105: void ARitualAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
1106: {
1107: 	if (!Player || !HasAuthority())
1108: 	{
1109: 		return;
1110: 	}
1111: 
1112: 
1113: 	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1114: 	if (PC)
1115: 	{
1116: 
1117: 		if (Player->IsLocallyControlled())
1118: 		{
1119: 
1120: 			PC->LocalHideRitualWidget();
1121: 		}
1122: 		else
1123: 		{
1124: 
1125: 			PC->Client_HideRitualWidget();
1126: 		}
1127: 
1128: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for leaving player %s"), *Player->GetName());
1129: 	}
1130: 
1131: 
1132: 	Super::UnoccupyPosition(Player, Position);
1133: 
1134: 
1135: 	ReadyPlayers.Remove(Player);
1136: 	UpdateReadyPlayersData();
1137: 
1138: 
1139: 	if (ParticipatingPlayers.Num() == 0)
1140: 	{
1141: 
1142: 		CurrentRitualState = EInteractionState::Inactive;
1143: 		BroadcastRitualStateChanged();
1144: 
1145: 
1146: 		CurrentSequenceIndex = 0;
1147: 		InputSequence.Empty();
1148: 		CurrentActivePlayer = nullptr;
1149: 		ReadyPlayers.Empty();
1150: 		UpdateReadyPlayersData();
1151: 
1152: 
1153: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
1154: 		GetWorldTimerManager().ClearTimer(InputTimerHandle);
1155: 	}
1156: }




================================================================
End of Codebase
================================================================
