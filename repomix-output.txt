This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Source/WitchPT
- Files matching these patterns are excluded: *.test.ts, docs/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
Source/WitchPT/Private/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.cpp
Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
Source/WitchPT/Private/Character/WitchPTCharacter.cpp
Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
Source/WitchPT/Private/Character/WitchPTEnemy.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp
Source/WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp
Source/WitchPT/Private/Equipment/WitchPTQuickBarComponent.cpp
Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
Source/WitchPT/Private/Inventory/Collectable.cpp
Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp
Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
Source/WitchPT/Private/Item/CauldronAltar.cpp
Source/WitchPT/Private/Item/CauldronPosition.cpp
Source/WitchPT/Private/Item/Components/CauldronCraftComponent.cpp
Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
Source/WitchPT/Private/Item/Item.cpp
Source/WitchPT/Private/Item/MechanicsInterface.cpp
Source/WitchPT/Private/Item/PositionInterface.cpp
Source/WitchPT/Private/Item/Potion/PotionBase.cpp
Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
Source/WitchPT/Private/Item/RitualAltar.cpp
Source/WitchPT/Private/Item/RitualPosition.cpp
Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
Source/WitchPT/Private/Subsystems/UIManagerSubsystem.cpp
Source/WitchPT/Private/Subsystems/WidgetCommunicatorSubsystem.cpp
Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/QuickBarWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/Layer/WitchPTUILayer.cpp
Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
Source/WitchPT/Private/UI/Widgets/QuickBarUserWidget.cpp
Source/WitchPT/Private/UI/Widgets/WitchPTPrimaryLayout.cpp
Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
Source/WitchPT/Private/WitchPTAssetManager.cpp
Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
Source/WitchPT/Public/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h
Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
Source/WitchPT/Public/Character/WitchPTCharacter.h
Source/WitchPT/Public/Character/WitchPTCharacterBase.h
Source/WitchPT/Public/Character/WitchPTEnemy.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentInstance.h
Source/WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h
Source/WitchPT/Public/Equipment/WitchPTQuickBarComponent.h
Source/WitchPT/Public/FWitchPTGameplayTags.cpp
Source/WitchPT/Public/FWitchPTGameplayTags.h
Source/WitchPT/Public/Game/WitchPTGameModeBase.h
Source/WitchPT/Public/Input/WitchPTInputComponent.h
Source/WitchPT/Public/Input/WitchPTInputConfig.h
Source/WitchPT/Public/Inventory/Collectable.h
Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h
Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
Source/WitchPT/Public/Item/BaseInteractableAltar.h
Source/WitchPT/Public/Item/BaseInteractionPosition.h
Source/WitchPT/Public/Item/CauldronAltar.h
Source/WitchPT/Public/Item/CauldronPosition.h
Source/WitchPT/Public/Item/Components/CauldronCraftComponent.h
Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
Source/WitchPT/Public/Item/Item.h
Source/WitchPT/Public/Item/MechanicsInterface.h
Source/WitchPT/Public/Item/PositionInterface.h
Source/WitchPT/Public/Item/Potion/PotionBase.h
Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
Source/WitchPT/Public/Item/RitualAltar.h
Source/WitchPT/Public/Item/RitualPosition.h
Source/WitchPT/Public/Player/WitchPTPlayerController.h
Source/WitchPT/Public/Player/WitchPTPlayerState.h
Source/WitchPT/Public/Subsystems/UIManagerSubsystem.h
Source/WitchPT/Public/Subsystems/WidgetCommunicatorSubsystem.h
Source/WitchPT/Public/Systems/GameplayTagStack.cpp
Source/WitchPT/Public/Systems/GameplayTagStack.h
Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/QuickBarWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
Source/WitchPT/Public/UI/Widgets/Layer/WitchPTUILayer.h
Source/WitchPT/Public/UI/Widgets/PointerWidget.h
Source/WitchPT/Public/UI/Widgets/QuickBarUserWidget.h
Source/WitchPT/Public/UI/Widgets/WitchPTPrimaryLayout.h
Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
Source/WitchPT/Public/WitchPTAssetManager.h
Source/WitchPT/WitchPT.Build.cs
Source/WitchPT/WitchPT.cpp
Source/WitchPT/WitchPT.h

================================================================
Files
================================================================

================
File: Source/WitchPT/Private/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.cpp
================
 1: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: 
 5: UWitchPTGameplayAbility::UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer)
 6: 	:Super(ObjectInitializer)
 7: {
 8: 	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
 9: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
10: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
11: 	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;
12: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnInputTriggered;
13: }
14: 
15: void UWitchPTGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo,
16:                                             const FGameplayAbilitySpec& Spec)
17: {
18: 	Super::OnGiveAbility(ActorInfo, Spec);
19: 	TryActivateAbilityOnSpawn(ActorInfo, Spec);
20: }
21: 
22: void UWitchPTGameplayAbility::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo,
23: 	const FGameplayAbilitySpec& Spec) const
24: {
25: 	if (ActorInfo && !Spec.IsActive() && (ActivationPolicy == EPrototypeAbilityActivationPolicy::OnSpawn))
26: 	{
27: 		UAbilitySystemComponent* AbilitySystem = ActorInfo->AbilitySystemComponent.Get();
28: 		AbilitySystem->TryActivateAbility(Spec.Handle);
29: 	}
30: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.cpp
================
  1: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "Engine/OverlapResult.h"
  5: #include "Engine/World.h"
  6: #include "GameFramework/Controller.h"
  7: 
  8: #include "TimerManager.h"
  9: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
 10: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 11: #include "AbilitySystem/Interaction/InteractionQuery.h"
 12: #include "AbilitySystem/Interaction/InteractionStatics.h"
 13: #include "WitchPT/WitchPT.h"
 14: 
 15: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_GrantNearbyInteraction)
 16: UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
 17: 	: Super(ObjectInitializer)
 18: {
 19: }
 20: void UAbilityTask_GrantNearbyInteraction::Activate()
 21: {
 22: 
 23: 	SetWaitingOnAvatar();
 24: 	UWorld* World = GetWorld();
 25: 	World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
 26: 
 27: }
 28: 
 29: void UAbilityTask_GrantNearbyInteraction::OnGameplayTaskActivated(UGameplayTask& Task)
 30: {
 31: 	Super::OnGameplayTaskActivated(Task);
 32: 
 33: }
 34: 
 35: UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility,
 36:                                                                                                              float InteractionScanRange, float InteractionScanRate)
 37: {
 38: 
 39: 	UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
 40: 	MyObj->InteractionScanRange = InteractionScanRange;
 41: 	MyObj->InteractionScanRate = InteractionScanRate;
 42: 	return MyObj;
 43: }
 44: 
 45: void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
 46: {
 47: 
 48: 	UWorld* World = GetWorld();
 49: 	if (World)
 50: 	{
 51: 		World->GetTimerManager().ClearTimer(QueryTimerHandle);
 52: 	}
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 	Super::OnDestroy(AbilityEnded);
 74: }
 75: 
 76: void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
 77: {
 78: 	UWorld* World = GetWorld();
 79: 	AActor* ActorOwner = GetAvatarActor();
 80: 
 81: 	if (World && ActorOwner)
 82: 	{
 83: 		FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);
 84: 
 85: 		TArray<FOverlapResult> OverlapResults;
 86: 		World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, WitchPT_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);
 87: 
 88: 		if (OverlapResults.Num() > 0)
 89: 		{
 90: 			TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
 91: 			UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
 92: 
 93: 			FInteractionQuery InteractionQuery;
 94: 			InteractionQuery.RequestingAvatar = ActorOwner;
 95: 			InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());
 96: 
 97: 			TArray<FInteractionOption> Options;
 98: 			for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
 99: 			{
100: 				FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
101: 				InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
102: 			}
103: 
104: 
105: 			for (FInteractionOption& Option : Options)
106: 			{
107: 
108: 				if (Option.InteractionAbilityToGrant)
109: 				{
110: 
111: 					FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
112: 					if (!InteractionAbilityCache.Find(ObjectKey))
113: 					{
114: 						FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
115: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
116: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
117: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
118: 						InteractionAbilityCache.Add(ObjectKey, Handle);
119: 					}
120: 				}
121: 
122: 
123: 				if (Option.bSupportsHoldInteraction && Option.HoldInteractionAbilityToGrant)
124: 				{
125: 					FObjectKey ObjectKey(Option.HoldInteractionAbilityToGrant);
126: 					if (!HoldInteractionAbilityCache.Find(ObjectKey))
127: 					{
128: 						FGameplayAbilitySpec Spec(Option.HoldInteractionAbilityToGrant, 1, INDEX_NONE, this);
129: 						UWitchPTGameplayAbility* AbilityBase = Cast<UWitchPTGameplayAbility>(Spec.Ability);
130: 						Spec.GetDynamicSpecSourceTags().AddTag(AbilityBase->StartupInputTag);
131: 						FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
132: 						HoldInteractionAbilityCache.Add(ObjectKey, Handle);
133: 					}
134: 				}
135: 			}
136: 		}
137: 	}
138: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/InteractionStatics.cpp
================
 1: #include "AbilitySystem/Interaction/InteractionStatics.h"
 2: 
 3: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 4: #include "Engine/OverlapResult.h"
 5: 
 6: UInteractionStatics::UInteractionStatics()
 7: 	: Super(FObjectInitializer::Get())
 8: {
 9: }
10: 
11: AActor* UInteractionStatics::GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget)
12: {
13: 	if (UObject* Object = InteractableTarget.GetObject())
14: 	{
15: 		if (AActor* Actor = Cast<AActor>(Object))
16: 		{
17: 			return Actor;
18: 		} else if (UActorComponent* ActorComponent = Cast<UActorComponent>(Object))
19: 		{
20: 			AActor* ActorToReturn = ActorComponent->GetOwner();
21: 			return ActorToReturn;
22: 		} else
23: 		{
24: 			unimplemented()
25: 		}
26: 	}
27: 	return nullptr;
28: }
29: 
30: void UInteractionStatics::GetInteractableTargetsFromActor(AActor* Actor,
31: 	TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
32: {
33: 
34: 	TScriptInterface<IInteractableTarget> InteractableActor(Actor);
35: 	if (InteractableActor)
36: 	{
37: 		OutInteractableTargets.Add(InteractableActor);
38: 	}
39: 
40: 
41: 	TArray<UActorComponent*> InteractableComponents = Actor ? Actor->GetComponentsByInterface(UInteractableTarget::StaticClass()) : TArray<UActorComponent*>();
42: 	for (UActorComponent* InteractableComponent : InteractableComponents)
43: 	{
44: 		OutInteractableTargets.Add(TScriptInterface<IInteractableTarget>(InteractableComponent));
45: 	}
46: }
47: 
48: void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
49: {
50: 	for (const FOverlapResult& Overlap : OverlapResults)
51: 	{
52: 		TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
53: 		if (InteractableActor)
54: 		{
55: 			OutInteractableTargets.AddUnique(InteractableActor);
56: 		}
57: 
58: 		TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
59: 		if (InteractableComponent)
60: 		{
61: 			OutInteractableTargets.AddUnique(InteractableComponent);
62: 		}
63: 	}
64: }
65: 
66: void UInteractionStatics::AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
67: {
68: 	TScriptInterface<IInteractableTarget> InteractableActor(HitResult.GetActor());
69: 	if (InteractableActor)
70: 	{
71: 		OutInteractableTargets.AddUnique(InteractableActor);
72: 	}
73: 
74: 	TScriptInterface<IInteractableTarget> InteractableComponent(HitResult.GetComponent());
75: 	if (InteractableComponent)
76: 	{
77: 		OutInteractableTargets.AddUnique(InteractableComponent);
78: 	}
79: }

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemGlobals.cpp
================
1: #include "AbilitySystem/WitchPTAbilitySystemGlobals.h"

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAttributeSet.cpp
================
  1: #include "AbilitySystem/WitchPTAttributeSet.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "GameplayEffectExtension.h"
  5: #include "GameFramework/Character.h"
  6: #include "Net/UnrealNetwork.h"
  7: #include "WitchPT/WitchPT.h"
  8: 
  9: void UWitchPTAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 10: {
 11: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 12: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Health, COND_None, REPNOTIFY_Always);
 13: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always)
 14: 
 15: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Mana, COND_None, REPNOTIFY_Always)
 16: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMana, COND_None, REPNOTIFY_Always)
 17: 
 18: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Stamina, COND_None, REPNOTIFY_Always)
 19: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always)
 20: 
 21: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Age, COND_None, REPNOTIFY_Always)
 22: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxAge, COND_None, REPNOTIFY_Always)
 23: 
 24: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, Strength, COND_None, REPNOTIFY_Always)
 25: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxStrength, COND_None, REPNOTIFY_Always)
 26: 
 27: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, SpeedMultiplier, COND_None, REPNOTIFY_Always)
 28: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, COND_None, REPNOTIFY_Always)
 29: 
 30: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MoveSpeed, COND_None, REPNOTIFY_Always)
 31: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, COND_None, REPNOTIFY_Always)
 32: 	DOREPLIFETIME_CONDITION_NOTIFY(UWitchPTAttributeSet, MinMoveSpeed, COND_None, REPNOTIFY_Always)
 33: 
 34: 
 35: }
 36: 
 37: UWitchPTAttributeSet::UWitchPTAttributeSet()
 38: {
 39: }
 40: 
 41: void UWitchPTAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
 42: {
 43: 	Super::PreAttributeChange(Attribute, NewValue);
 44: }
 45: 
 46: void UWitchPTAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 47: {
 48: 	Super::PostGameplayEffectExecute(Data);
 49: 	if (Data.EvaluatedData.Attribute == GetMoveSpeedAttribute())
 50: 	{
 51: 
 52: 	}
 53: 	if (Data.EvaluatedData.Attribute == GetAgeAttribute())
 54: 	{
 55: 		SetAge(FMath::Clamp(GetAge(), 0.f, GetMaxAge()));
 56: 	}
 57: }
 58: 
 59: void UWitchPTAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 60: {
 61: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Health, OldHealth);
 62: }
 63: 
 64: void UWitchPTAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana) const
 65: {
 66: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Mana, OldMana);
 67: }
 68: void UWitchPTAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const
 69: {
 70: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxHealth, OldMaxHealth);
 71: }
 72: 
 73: void UWitchPTAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const
 74: {
 75: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMana, OldMaxMana);
 76: }
 77: 
 78: void UWitchPTAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina) const
 79: {
 80: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Stamina, OldStamina);
 81: }
 82: 
 83: void UWitchPTAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const
 84: {
 85: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStamina, OldMaxStamina);
 86: }
 87: 
 88: void UWitchPTAttributeSet::OnRep_Age(const FGameplayAttributeData& OldAge) const
 89: {
 90: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Age, OldAge);
 91: }
 92: 
 93: void UWitchPTAttributeSet::OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const
 94: {
 95: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxAge, OldMaxAge);
 96: }
 97: 
 98: void UWitchPTAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength) const
 99: {
100: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, Strength, OldStrength);
101: }
102: 
103: void UWitchPTAttributeSet::OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const
104: {
105: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxStrength, OldMaxStrength);
106: }
107: 
108: void UWitchPTAttributeSet::OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const
109: {
110: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, SpeedMultiplier, OldSpeedMultiplier);
111: }
112: 
113: void UWitchPTAttributeSet::OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const
114: {
115: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxSpeedMultiplier, OldMaxSpeedMultiplier);
116: }
117: 
118: void UWitchPTAttributeSet::OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const
119: {
120: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MoveSpeed, OldMoveSpeed);
121: }
122: 
123: void UWitchPTAttributeSet::OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const
124: {
125: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MaxMoveSpeed, OldMaxMoveSpeed);
126: }
127: 
128: void UWitchPTAttributeSet::OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const
129: {
130: 	GAMEPLAYATTRIBUTE_REPNOTIFY(UWitchPTAttributeSet, MinMoveSpeed, OldMinMoveSpeed);
131: }

================
File: Source/WitchPT/Private/Character/Components/WitchPTCharacterMovementComponent.cpp
================
 1: #include "Character/Components/WitchPTCharacterMovementComponent.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Character/WitchPTCharacterBase.h"
 6: 
 7: 
 8: 
 9: UWitchPTCharacterMovementComponent::UWitchPTCharacterMovementComponent()
10: {
11: 
12: 	PrimaryComponentTick.bCanEverTick = true;
13: 
14: 
15: }
16: 
17: float UWitchPTCharacterMovementComponent::GetMaxSpeed() const
18: {
19: 
20: 	AWitchPTCharacterBase* Owner = Cast<AWitchPTCharacterBase>(GetOwner());
21: 
22: 	if (!Owner)
23: 	{
24: 
25: 		return Super::GetMaxSpeed();
26: 	}
27: 
28: 
29: 
30: 	if (Owner->GetAbilitySystemComponent()->HasMatchingGameplayTag(FGameplayTag::RequestGameplayTag(FName("Character.State.Blocked"))))
31: 	{
32: 
33: 		return 0.0f;
34: 	}
35: 
36: 	float FinalSpeed = Owner->GetMoveSpeed();
37: 	if (RequestToStartSprinting)
38: 	{
39: 		FinalSpeed = Owner->GetMoveSpeed() * Owner->GetSpeedMultiplier();
40: 
41: 	}
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 	return FinalSpeed;
50: }
51: 
52: void UWitchPTCharacterMovementComponent::UpdateFromCompressedFlags(uint8 Flags)
53: {
54: 	Super::UpdateFromCompressedFlags(Flags);
55: }
56: 
57: class FNetworkPredictionData_Client* UWitchPTCharacterMovementComponent::GetPredictionData_Client() const
58: {
59: 	return Super::GetPredictionData_Client();
60: }
61: 
62: 
63: void UWitchPTCharacterMovementComponent::StartSprinting()
64: {
65: 	RequestToStartSprinting = true;
66: }
67: 
68: void UWitchPTCharacterMovementComponent::StopSprinting()
69: {
70: 	RequestToStartSprinting = false;
71: }
72: 
73: void UWitchPTCharacterMovementComponent::StartAimDownSights()
74: {
75: 	RequestToStartADS = true;
76: }
77: 
78: void UWitchPTCharacterMovementComponent::StopAimDownSights()
79: {
80: 	RequestToStartADS = false;
81: 
82: }

================
File: Source/WitchPT/Private/Character/WitchPTCharacterBase.cpp
================
  1: #include "Character/WitchPTCharacterBase.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  5: #include "AbilitySystem/WitchPTAttributeSet.h"
  6: #include "Character/Components/WitchPTCharacterMovementComponent.h"
  7: #include "Components/CapsuleComponent.h"
  8: 
  9: 
 10: AWitchPTCharacterBase::AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer.SetDefaultSubobjectClass<UWitchPTCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
 12: {
 13: 
 14: 	PrimaryActorTick.bCanEverTick = true;
 15: 	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 16: 	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
 17: 
 18: }
 19: 
 20: UAbilitySystemComponent* AWitchPTCharacterBase::GetAbilitySystemComponent() const
 21: {
 22: 	return AbilitySystemComponent;
 23: }
 24: 
 25: 
 26: 
 27: 
 28: void AWitchPTCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
 29: {
 30: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
 31: 
 32: }
 33: 
 34: void AWitchPTCharacterBase::InitializeDefaultAttributes()
 35: {
 36: 	ApplyGameplayEffectToSelf(DefaultAttributes);
 37: 
 38: 
 39: }
 40: 
 41: void AWitchPTCharacterBase::GrantStartupAbilities()
 42: {
 43: 	if (!HasAuthority()) return;
 44: 
 45: 	UWitchPTAbilitySystemComponent* WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
 46: 
 47: 	WitchPtAbilitySystemComponent->GrantStartupAbilities(StartupAbilities);
 48: }
 49: 
 50: void AWitchPTCharacterBase::AddStartupEffects()
 51: {
 52: 	if (GetLocalRole() != ROLE_Authority || !IsValid(AbilitySystemComponent) || AbilitySystemComponent->bStartupEffectsApplied)
 53: 	{
 54: 		return;
 55: 	}
 56: 
 57: 	FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
 58: 	EffectContext.AddSourceObject(this);
 59: 
 60: 	for (TSubclassOf<UGameplayEffect> GameplayEffect : StartupEffects)
 61: 	{
 62: 		FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffect, 1.f, EffectContext);
 63: 		if (NewHandle.IsValid())
 64: 		{
 65: 			FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent->ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());
 66: 		}
 67: 	}
 68: 
 69: 	AbilitySystemComponent->bStartupEffectsApplied = true;
 70: }
 71: 
 72: void AWitchPTCharacterBase::InitAbilityActorInfo()
 73: {
 74: }
 75: 
 76: void AWitchPTCharacterBase::ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass)
 77: {
 78: 	check(IsValid(GetAbilitySystemComponent()));
 79: 	check(GameplayEffectClass);
 80: 	FGameplayEffectContextHandle EffectContextHandle = AbilitySystemComponent->MakeEffectContext();
 81: 	EffectContextHandle.AddSourceObject(this);
 82: 	FGameplayEffectSpecHandle EffectSpec = AbilitySystemComponent->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
 83: 	AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpec.Data.Get());
 84: 
 85: }
 86: 
 87: float AWitchPTCharacterBase::GetHealth() const
 88: {
 89: 	if (IsValid(AttributeSet))
 90: 	{
 91: 		return AttributeSet->GetHealth();
 92: 	}
 93: 	return 0.f;
 94: }
 95: 
 96: float AWitchPTCharacterBase::GetMaxHealth() const
 97: {
 98: 	if (IsValid(AttributeSet))
 99: 	{
100: 		return AttributeSet->GetMaxHealth();
101: 	}
102: 	return 0.f;
103: }
104: 
105: float AWitchPTCharacterBase::GetStamina() const
106: {
107: 	if (IsValid(AttributeSet))
108: 	{
109: 		return AttributeSet->GetStamina();
110: 	}
111: 	return 0.f;
112: }
113: 
114: float AWitchPTCharacterBase::GetMaxStamina() const
115: {
116: 	if (IsValid(AttributeSet))
117: 	{
118: 		return AttributeSet->GetMaxStamina();
119: 	}
120: 	return 0.f;
121: }
122: 
123: float AWitchPTCharacterBase::GetAge() const
124: {
125: 	if (IsValid(AttributeSet))
126: 	{
127: 		return AttributeSet->GetAge();
128: 	}
129: 	return 0.f;
130: }
131: 
132: float AWitchPTCharacterBase::GetMaxAge() const
133: {
134: 	if (IsValid(AttributeSet))
135: 	{
136: 		return AttributeSet->GetMaxAge();
137: 	}
138: 	return 0.f;
139: }
140: 
141: float AWitchPTCharacterBase::GetMana() const
142: {
143: 	if (IsValid(AttributeSet))
144: 	{
145: 		return AttributeSet->GetMana();
146: 	}
147: 	return 0.f;
148: }
149: 
150: float AWitchPTCharacterBase::GetMaxMana() const
151: {
152: 	if (IsValid(AttributeSet))
153: 	{
154: 		return AttributeSet->GetMaxMana();
155: 	}
156: 	return 0.f;
157: }
158: 
159: float AWitchPTCharacterBase::GetSpeedMultiplier() const
160: {
161: 	if (IsValid(AttributeSet))
162: 	{
163: 		return AttributeSet->GetSpeedMultiplier();
164: 	}
165: 	return 0.f;
166: }
167: 
168: float AWitchPTCharacterBase::GetMoveSpeed() const
169: {
170: 	if (IsValid(AttributeSet))
171: 	{
172: 		return AttributeSet->GetMoveSpeed();
173: 	}
174: 	return 0.f;
175: }
176: 
177: float AWitchPTCharacterBase::GetMaxMoveSpeed() const
178: {
179: 	if (IsValid(AttributeSet))
180: 	{
181: 		return AttributeSet->GetMaxMoveSpeed();
182: 	}
183: 	return 0.f;
184: }

================
File: Source/WitchPT/Private/Game/WitchPTGameModeBase.cpp
================
1: #include "Game/WitchPTGameModeBase.h"

================
File: Source/WitchPT/Private/Input/WitchPTInputComponent.cpp
================
1: #include "Input/WitchPTInputComponent.h"

================
File: Source/WitchPT/Private/Input/WitchPTInputConfig.cpp
================
 1: #include "Input/WitchPTInputConfig.h"
 2: 
 3: const UInputAction* UWitchPTInputConfig::GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound) const
 4: {
 5: 	for (const FWitchPTInputAction& Pair: AbilityInputActions)
 6: 	{
 7: 		if (InputTag == Pair.InputTag)
 8: 		{
 9: 			return Pair.InputAction;
10: 		}
11: 	}
12: 	if (bLogNotFound)
13: 	{
14: 		UE_LOG(LogTemp, Error, TEXT("Cant find AbilityInputAction for InputTag [%s] on InputConfig [%s]"), *InputTag.ToString(), *GetNameSafe(this) )
15: 	}
16: 	return nullptr;
17: 
18: }

================
File: Source/WitchPT/Private/Item/Item.cpp
================
 1: #include "Item/Item.h"
 2: 
 3: 
 4: 
 5: AItem::AItem()
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AItem::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AItem::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: void AItem::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
25: {
26: 	OptionBuilder.AddInteractionOption(Option);
27: }

================
File: Source/WitchPT/Private/Item/MechanicsInterface.cpp
================
1: #include "Item/MechanicsInterface.h"

================
File: Source/WitchPT/Private/Player/WitchPTPlayerState.cpp
================
 1: #include "Player/WitchPTPlayerState.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Item/RitualPosition.h"
 7: 
 8: AWitchPTPlayerState::AWitchPTPlayerState()
 9: {
10: 	SetNetUpdateFrequency(100.f);
11: 
12: 	AbilitySystemComponent = CreateDefaultSubobject<UWitchPTAbilitySystemComponent>("AbilitySystemComponent");
13: 	AbilitySystemComponent->SetIsReplicated(true);
14: 	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
15: 
16: 	AttributeSet = CreateDefaultSubobject<UWitchPTAttributeSet>("AttributeSet");
17: 
18: 
19: }
20: 
21: UAbilitySystemComponent* AWitchPTPlayerState::GetAbilitySystemComponent() const
22: {
23: 	return AbilitySystemComponent;
24: }

================
File: Source/WitchPT/Private/WitchPTAssetManager.cpp
================
 1: #include "WitchPTAssetManager.h"
 2: 
 3: #include "AbilitySystemGlobals.h"
 4: #include "FWitchPTGameplayTags.h"
 5: 
 6: UWitchPTAssetManager& UWitchPTAssetManager::Get()
 7: {
 8: 	check(GEngine)
 9: 	UWitchPTAssetManager* WitchPtAssetManager = Cast<UWitchPTAssetManager>(GEngine->AssetManager);
10: 	return *WitchPtAssetManager;
11: }
12: 
13: void UWitchPTAssetManager::StartInitialLoading()
14: {
15: 	Super::StartInitialLoading();
16: 	FWitchPTGameplayTags::InitializeGameplayTags();
17: 
18: 
19: 
20: 
21: 
22: 	UAbilitySystemGlobals::Get().InitGlobalData();
23: 
24: }

================
File: Source/WitchPT/Public/AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "WitchPTGameplayAbility.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UENUM(BlueprintType)
11: enum class EPrototypeAbilityActivationPolicy: uint8
12: {
13: 
14: 	OnInputTriggered,
15: 
16: 
17: 	WhileInputActive,
18: 
19: 
20: 	OnSpawn,
21: 
22: 	OnTriggeredEvent
23: };
24: UCLASS()
25: class WITCHPT_API UWitchPTGameplayAbility : public UGameplayAbility
26: {
27: 	GENERATED_BODY()
28: public:
29: 	UWitchPTGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
30: 	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
31: 	UPROPERTY(EditDefaultsOnly, Category="Input")
32: 	FGameplayTag StartupInputTag;
33: 	EPrototypeAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }
34: protected:
35: 
36: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "WitchPT |Ability Activation")
37: 	EPrototypeAbilityActivationPolicy ActivationPolicy;
38: 
39: 	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
40: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AbilityTask_GrantNearbyInteraction.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UAbilityTask_GrantNearbyInteraction : public UAbilityTask
12: {
13: 	GENERATED_UCLASS_BODY()
14: 
15: 
16: 	virtual void Activate() override;
17: 	virtual void OnGameplayTaskActivated(UGameplayTask& Task) override;
18: 
19: 
20: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
21: 	static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);
22: 
23: private:
24: 	virtual void OnDestroy(bool AbilityEnded) override;
25: 
26: 	void QueryInteractables();
27: 	float InteractionScanRange = 100;
28: 	float InteractionScanRate = 0.100;
29: 	FTimerHandle QueryTimerHandle;
30: 
31: 
32: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
33: 
34: 
35: 	TMap<FObjectKey, FGameplayAbilitySpecHandle> HoldInteractionAbilityCache;
36: 
37: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/IInteractableTarget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.h"
 6: #include "IInteractableTarget.generated.h"
 7: 
 8: struct FInteractionQuery;
 9: 
10: 
11: class FInteractionOptionBuilder
12: {
13: public:
14: 	FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
15: 		: Scope(InterfaceTargetScope)
16: 		, Options(InteractOptions)
17: 	{
18: 	}
19: 
20: 	void AddInteractionOption(const FInteractionOption& Option)
21: 	{
22: 		FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
23: 		OptionEntry.InteractableTarget = Scope;
24: 	}
25: 
26: private:
27: 	TScriptInterface<IInteractableTarget> Scope;
28: 	TArray<FInteractionOption>& Options;
29: };
30: 
31: 
32: UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
33: class UInteractableTarget : public UInterface
34: {
35: 	GENERATED_BODY()
36: };
37: 
38: 
39: class IInteractableTarget
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;
46: 
47: 
48: 	virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
49: 
50: 
51: 
52: 
53: 
54: 	virtual bool SupportsHoldInteraction() const { return false; }
55: 
56: 
57: 
58: 
59: 
60: 	virtual FGameplayAbilitySpecHandle GetHoldInteractionAbilityHandle() const { return FGameplayAbilitySpecHandle(); }
61: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionQuery.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionQuery.generated.h"
 6: 
 7: 
 8: 
 9: USTRUCT(BlueprintType)
10: struct FInteractionQuery
11: {
12: 	GENERATED_BODY()
13: 
14: public:
15: 
16: 	UPROPERTY(BlueprintReadWrite)
17: 	TWeakObjectPtr<AActor> RequestingAvatar;
18: 
19: 
20: 	UPROPERTY(BlueprintReadWrite)
21: 	TWeakObjectPtr<AController> RequestingController;
22: 
23: 
24: 	UPROPERTY(BlueprintReadWrite)
25: 	TWeakObjectPtr<UObject> OptionalObjectData;
26: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionStatics.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "InteractionStatics.generated.h"
 6: 
 7: template <typename InterfaceType> class TScriptInterface;
 8: class AActor;
 9: class IInteractableTarget;
10: class UObject;
11: 
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UInteractionStatics : public UBlueprintFunctionLibrary
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UInteractionStatics();
21: 
22: public:
23: 	UFUNCTION(BlueprintCallable)
24: 	static AActor* GetActorFromInteractableTarget(TScriptInterface<IInteractableTarget> InteractableTarget);
25: 
26: 	UFUNCTION(BlueprintCallable)
27: 	static void GetInteractableTargetsFromActor(AActor* Actor, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
28: 	static void AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
29: 	static void AppendInteractableTargetsFromHitResult(const FHitResult& HitResult, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets);
30: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemGlobals.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemGlobals.h"
 5: #include "WitchPTAbilitySystemGlobals.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAbilitySystemGlobals : public UAbilitySystemGlobals
12: {
13: 	GENERATED_BODY()
14: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAttributeSet.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "AbilitySystemComponent.h"
  5: #include "AttributeSet.h"
  6: #include "WitchPTAttributeSet.generated.h"
  7: 
  8: 
  9: 
 10: 
 11: 
 12: 
 13: #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 14: GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 15: GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 16: GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 17: GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 18: 
 19: 
 20: UCLASS()
 21: class WITCHPT_API UWitchPTAttributeSet : public UAttributeSet
 22: {
 23: 	GENERATED_BODY()
 24: public:
 25: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 26: 	UWitchPTAttributeSet();
 27: 	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
 28: 	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Age, Category= "Vital Attributes")
 35: 	FGameplayAttributeData Age;
 36: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Age);
 37: 
 38: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxAge, Category= "Vital Attributes")
 39: 	FGameplayAttributeData MaxAge;
 40: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxAge);
 41: 
 42: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category= "Vital Attributes")
 43: 	FGameplayAttributeData Health;
 44: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Health);
 45: 
 46: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category= "Secondary Attributes")
 47: 	FGameplayAttributeData MaxHealth;
 48: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxHealth);
 49: 
 50: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category= "Vital Attributes")
 51: 	FGameplayAttributeData Strength;
 52: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Strength);
 53: 
 54: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStrength, Category= "Vital Attributes")
 55: 	FGameplayAttributeData MaxStrength;
 56: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStrength);
 57: 
 58: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category= "Vital Attributes")
 59: 	FGameplayAttributeData Mana;
 60: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Mana);
 61: 
 62: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category= "Vital Attributes")
 63: 	FGameplayAttributeData MaxMana;
 64: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMana);
 65: 
 66: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Stamina, Category= "Vital Attributes")
 67: 	FGameplayAttributeData Stamina;
 68: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, Stamina);
 69: 
 70: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxStamina, Category= "Vital Attributes")
 71: 	FGameplayAttributeData MaxStamina;
 72: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxStamina);
 73: 
 74: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_SpeedMultiplier, Category= "Vital Attributes")
 75: 	FGameplayAttributeData SpeedMultiplier;
 76: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, SpeedMultiplier);
 77: 
 78: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxSpeedMultiplier, Category= "Vital Attributes")
 79: 	FGameplayAttributeData MaxSpeedMultiplier;
 80: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxSpeedMultiplier);
 81: 
 82: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MoveSpeed, Category= "Vital Attributes")
 83: 	FGameplayAttributeData MoveSpeed;
 84: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MoveSpeed);
 85: 
 86: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMoveSpeed, Category= "Vital Attributes")
 87: 	FGameplayAttributeData MaxMoveSpeed;
 88: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MaxMoveSpeed);
 89: 
 90: 	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MinMoveSpeed, Category= "Vital Attributes")
 91: 	FGameplayAttributeData MinMoveSpeed;
 92: 	ATTRIBUTE_ACCESSORS(UWitchPTAttributeSet, MinMoveSpeed);
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 	UFUNCTION()
 99: 	void OnRep_Health(const FGameplayAttributeData& OldHealth) const;
100: 	UFUNCTION()
101: 	void OnRep_Mana(const FGameplayAttributeData& OldMana) const;
102: 	UFUNCTION()
103: 	void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth) const;
104: 	UFUNCTION()
105: 	void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
106: 	UFUNCTION()
107: 	void OnRep_Stamina(const FGameplayAttributeData& OldStamina) const;
108: 	UFUNCTION()
109: 	void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina) const;
110: 	UFUNCTION()
111: 	void OnRep_Age(const FGameplayAttributeData& OldAge) const;
112: 	UFUNCTION()
113: 	void OnRep_MaxAge(const FGameplayAttributeData& OldMaxAge) const;
114: 	UFUNCTION()
115: 	void OnRep_Strength(const FGameplayAttributeData& OldStrength) const;
116: 	UFUNCTION()
117: 	void OnRep_MaxStrength(const FGameplayAttributeData& OldMaxStrength) const;
118: 	UFUNCTION()
119: 	void OnRep_SpeedMultiplier(const FGameplayAttributeData& OldSpeedMultiplier) const;
120: 	UFUNCTION()
121: 	void OnRep_MaxSpeedMultiplier(const FGameplayAttributeData& OldMaxSpeedMultiplier) const;
122: 	UFUNCTION()
123: 	void OnRep_MoveSpeed(const FGameplayAttributeData& OldMoveSpeed) const;
124: 	UFUNCTION()
125: 	void OnRep_MaxMoveSpeed(const FGameplayAttributeData& OldMaxMoveSpeed) const;
126: 	UFUNCTION()
127: 	void OnRep_MinMoveSpeed(const FGameplayAttributeData& OldMinMoveSpeed) const;
128: };

================
File: Source/WitchPT/Public/Character/Components/WitchPTCharacterMovementComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/CharacterMovementComponent.h"
 5: #include "WitchPTCharacterMovementComponent.generated.h"
 6: 
 7: 
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTCharacterMovementComponent : public UCharacterMovementComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	UWitchPTCharacterMovementComponent();
15: 	uint8 RequestToStartSprinting : 1;
16: 	uint8 RequestToStartADS : 1;
17: 	virtual float GetMaxSpeed() const override;
18: 	virtual void UpdateFromCompressedFlags(uint8 Flags) override;
19: 	virtual class FNetworkPredictionData_Client* GetPredictionData_Client() const override;
20: 
21: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
22: 	void StartSprinting();
23: 	UFUNCTION(BlueprintCallable, Category = "Sprint")
24: 	void StopSprinting();
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
29: 	void StartAimDownSights();
30: 	UFUNCTION(BlueprintCallable, Category = "Aim Down Sights")
31: 	void StopAimDownSights();
32: };

================
File: Source/WitchPT/Public/Character/WitchPTCharacterBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/Character.h"
 6: #include "WitchPTCharacterBase.generated.h"
 7: 
 8: class UWitchPTAbilitySystemComponent;
 9: class UWitchPTAttributeSet;
10: class UGameplayAbility;
11: class UGameplayEffect;
12: class UAttributeSet;
13: 
14: UCLASS(Abstract)
15: class WITCHPT_API AWitchPTCharacterBase : public ACharacter, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	AWitchPTCharacterBase(const class FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
25: 	UWitchPTAttributeSet* GetAttributeSet() { return AttributeSet; }
26: 
27: protected:
28: 	UPROPERTY()
29: 	TObjectPtr<UWitchPTAbilitySystemComponent> AbilitySystemComponent;
30: 	UPROPERTY()
31: 	TObjectPtr<UWitchPTAttributeSet> AttributeSet;
32: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
33: 
34: 	UPROPERTY(EditDefaultsOnly, Category = "Attributes")
35: 	TSubclassOf<UGameplayEffect> DefaultAttributes;
36: 	UPROPERTY(EditDefaultsOnly, Category = "Abilities")
37: 	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
38: 
39: 
40: 	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "GASDocumentation|Abilities")
41: 	TArray<TSubclassOf<class UGameplayEffect>> StartupEffects;
42: 
43: 	virtual void InitializeDefaultAttributes();
44: 
45: 	virtual void GrantStartupAbilities();
46: 
47: 	virtual void AddStartupEffects();
48: 
49: 	virtual void InitAbilityActorInfo();
50: private:
51: 	virtual void ApplyGameplayEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass);
52: 
53: 
54: 
55: public:
56: 
57: 
58: 
59: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
60: 	float GetHealth() const;
61: 
62: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
63: 	float GetMaxHealth() const;
64: 
65: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
66: 	float GetStamina() const;
67: 
68: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
69: 	float GetMaxStamina() const;
70: 
71: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
72: 	float GetAge() const;
73: 
74: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
75: 	float GetMaxAge() const;
76: 
77: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
78: 	float GetMana() const;
79: 
80: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
81: 	float GetMaxMana() const;
82: 
83: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
84: 	float GetSpeedMultiplier() const;
85: 
86: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
87: 	float GetMoveSpeed() const;
88: 
89: 	UFUNCTION(BlueprintCallable, Category = "WitchPT|WitchPTCharacter|Attributes")
90: 	float GetMaxMoveSpeed() const;
91: 
92: 
93: 
94: 
95: 
96: 
97: 
98: };

================
File: Source/WitchPT/Public/Character/WitchPTEnemy.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "WitchPTEnemy.generated.h"
 6: 
 7: UCLASS()
 8: class WITCHPT_API AWitchPTEnemy : public AWitchPTCharacterBase
 9: {
10: 	GENERATED_BODY()
11: 
12: public:
13: 
14: 	AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer);
15: 
16: protected:
17: 
18: 	virtual void BeginPlay() override;
19: 
20: public:
21: 
22: 	virtual void Tick(float DeltaTime) override;
23: 
24: 
25: 	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
26: };

================
File: Source/WitchPT/Public/Game/WitchPTGameModeBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameFramework/GameModeBase.h"
 5: #include "WitchPTGameModeBase.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API AWitchPTGameModeBase : public AGameModeBase
12: {
13: 	GENERATED_BODY()
14: };

================
File: Source/WitchPT/Public/Input/WitchPTInputComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "EnhancedInputComponent.h"
 5: #include "WitchPTInputConfig.h"
 6: 
 7: #include "WitchPTInputComponent.generated.h"
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInputComponent : public UEnhancedInputComponent
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 	template<class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
17: 	void BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc);
18: 
19: };
20: 
21: template <class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType>
22: void UWitchPTInputComponent::BindAbilityActions(const UWitchPTInputConfig* InputConfig, UserClass* Object,
23: 	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)
24: {
25: 	check(InputConfig);
26: 	for (const FWitchPTInputAction& Action: InputConfig->AbilityInputActions)
27: 	{
28: 		if (Action.InputAction && Action.InputTag.IsValid())
29: 		{
30: 			if (PressedFunc)
31: 			{
32: 				BindAction(Action.InputAction, ETriggerEvent::Started, Object, PressedFunc, Action.InputTag);
33: 			}
34: 			if (ReleasedFunc)
35: 			{
36: 				BindAction(Action.InputAction, ETriggerEvent::Completed, Object, ReleasedFunc, Action.InputTag);
37: 			}
38: 			if (HeldFunc)
39: 			{
40: 				BindAction(Action.InputAction, ETriggerEvent::Triggered, Object, HeldFunc, Action.InputTag);
41: 			}
42: 		}
43: 	}
44: 
45: }

================
File: Source/WitchPT/Public/Input/WitchPTInputConfig.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Engine/DataAsset.h"
 6: #include "WitchPTInputConfig.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FWitchPTInputAction
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly)
13: 	const class UInputAction* InputAction = nullptr;
14: 
15: 	UPROPERTY(EditDefaultsOnly)
16: 	FGameplayTag InputTag = FGameplayTag();
17: };
18: 
19: 
20: 
21: UCLASS()
22: class WITCHPT_API UWitchPTInputConfig : public UDataAsset
23: {
24: 	GENERATED_BODY()
25: 	const UInputAction* GetAbilityByInputTag(FGameplayTag& InputTag, bool bLogNotFound)const ;
26: public:
27: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
28: 	TArray<FWitchPTInputAction> AbilityInputActions;
29: 
30: };

================
File: Source/WitchPT/Public/Item/CauldronPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "CauldronPosition.generated.h"
 7: 
 8: 
 9: class ACauldronAltar;
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: 
17: 
18: 
19: 
20: UCLASS()
21: class WITCHPT_API ACauldronPosition : public ABaseInteractionPosition
22: {
23:     GENERATED_BODY()
24: 
25: public:
26: 
27:     ACauldronPosition();
28: 
29: 
30:     virtual void BeginPlay() override;
31: 
32: 
33: 
34:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38:     UFUNCTION(BlueprintPure, Category = "Cauldron")
39:     ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
40: 
41: 
42: 
43:     UFUNCTION(BlueprintCallable)
44:     void SetCauldronAltar(ACauldronAltar* Altar) { CauldronAltar = Altar; }
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: protected:
78: 
79:     UPROPERTY(EditInstanceOnly, BlueprintReadOnly, Category = "Cauldron", meta = (AllowPrivateAccess = "true"))
80:     TObjectPtr<ACauldronAltar> CauldronAltar;
81: 
82: 
83:     virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
84: 
85: private:
86: 
87:     void FindCauldronAltar();
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: };

================
File: Source/WitchPT/Public/Item/Item.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystem/Interaction/IInteractableTarget.h"
 5: #include "GameFramework/Actor.h"
 6: #include "Item.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AItem : public AActor, public IInteractableTarget
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AItem();
16: 
17: protected:
18: 
19: 	virtual void BeginPlay() override;
20: 	UPROPERTY(EditAnywhere)
21: 	FInteractionOption Option;
22: 
23: public:
24: 
25: 	virtual void Tick(float DeltaTime) override;
26: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
27: };

================
File: Source/WitchPT/Public/Player/WitchPTPlayerState.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemInterface.h"
 5: #include "GameFramework/PlayerState.h"
 6: #include "WitchPTPlayerState.generated.h"
 7: class ARitualPosition;
 8: class ARitualAltar;
 9: class UAbilitySystemComponent;
10: class UAttributeSet;
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API AWitchPTPlayerState : public APlayerState, public IAbilitySystemInterface
16: {
17: 	GENERATED_BODY()
18: 	AWitchPTPlayerState();
19: public:
20: 
21: 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
22: 	UAttributeSet* GetAttributeSet() const { return AttributeSet; }
23: 
24: protected:
25: 	UPROPERTY(VisibleAnywhere)
26: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
27: 	UPROPERTY(VisibleAnywhere)
28: 	TObjectPtr<UAttributeSet> AttributeSet;
29: 
30: 
31: };

================
File: Source/WitchPT/Public/WitchPTAssetManager.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Engine/AssetManager.h"
 5: #include "WitchPTAssetManager.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTAssetManager : public UAssetManager
12: {
13: 	GENERATED_BODY()
14: public:
15: 	static UWitchPTAssetManager& Get();
16: protected:
17: 	virtual void StartInitialLoading() override;
18: 
19: 
20: };

================
File: Source/WitchPT/WitchPT.cpp
================
1: #include "WitchPT.h"
2: #include "Modules/ModuleManager.h"
3: 
4: IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, WitchPT, "WitchPT" );

================
File: Source/WitchPT/WitchPT.h
================
1: #pragma once
2: 
3: #include "CoreMinimal.h"
4: #define ECC_Projectile ECollisionChannel::ECC_GameTraceChannel1;
5: #define WitchPT_TraceChannel_Interaction ECC_GameTraceChannel2
6: #define CONSOLE_LOG(Format, ...) UE_LOG(LogTemp, Warning, TEXT("%s: " Format), *FString(__FUNCTION__), ##__VA_ARGS__)

================
File: Source/WitchPT/Private/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.cpp
================
  1: #include "AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/PlayerController.h"
  4: #include "Engine/World.h"
  5: #include "DrawDebugHelpers.h"
  6: #include "TimerManager.h"
  7: #include "GameFramework/Character.h"
  8: #include "Camera/CameraComponent.h"
  9: 
 10: UAT_WaitForPlacementLocation_SLT::UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer)
 11: 	: Super(ObjectInitializer)
 12: {
 13: 	bTickingTask = true;
 14: 	TraceDistance = 500.0f;
 15: 	TraceRadius = 10.0f;
 16: 	bTraceComplex = false;
 17: 	bIgnoreBlockingHits = false;
 18: 	bShowDebug = false;
 19: 	LastHitLocation = FVector::ZeroVector;
 20: 	LastHitNormal = FVector::UpVector;
 21: }
 22: 
 23: UAT_WaitForPlacementLocation_SLT* UAT_WaitForPlacementLocation_SLT::WaitForPlacementLocation(
 24: 	UGameplayAbility* OwningAbility,
 25: 	float TraceDistance,
 26: 	float TraceRadius,
 27: 	bool TraceComplex,
 28: 	bool bIgnoreBlockingHits,
 29: 	bool bShowDebug)
 30: {
 31: 	UAT_WaitForPlacementLocation_SLT* MyObj = NewAbilityTask<UAT_WaitForPlacementLocation_SLT>(OwningAbility);
 32: 
 33: 	MyObj->TraceDistance = TraceDistance;
 34: 	MyObj->TraceRadius = TraceRadius;
 35: 	MyObj->bTraceComplex = TraceComplex;
 36: 	MyObj->bIgnoreBlockingHits = bIgnoreBlockingHits;
 37: 	MyObj->bShowDebug = bShowDebug;
 38: 
 39: 	return MyObj;
 40: }
 41: 
 42: void UAT_WaitForPlacementLocation_SLT::Activate()
 43: {
 44: 	Super::Activate();
 45: 
 46: 
 47: 	SetWaitingOnAvatar();
 48: 
 49: 
 50: 	PerformTrace();
 51: }
 52: 
 53: void UAT_WaitForPlacementLocation_SLT::OnDestroy(bool bInOwnerFinished)
 54: {
 55: 
 56: 	UWorld* World = GetWorld();
 57: 	if (World)
 58: 	{
 59: 		World->GetTimerManager().ClearTimer(TraceTimerHandle);
 60: 	}
 61: 
 62: 	Super::OnDestroy(bInOwnerFinished);
 63: }
 64: 
 65: void UAT_WaitForPlacementLocation_SLT::TickTask(float DeltaTime)
 66: {
 67: 	Super::TickTask(DeltaTime);
 68: 
 69: 
 70: 	PerformTrace();
 71: }
 72: 
 73: void UAT_WaitForPlacementLocation_SLT::PerformTrace()
 74: {
 75: 	if (!Ability || !Ability->GetCurrentActorInfo())
 76: 	{
 77: 		return;
 78: 	}
 79: 
 80: 
 81: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 82: 	if (!PC)
 83: 	{
 84: 		return;
 85: 	}
 86: 
 87: 
 88: 	ACharacter* Character = Cast<ACharacter>(Ability->GetCurrentActorInfo()->AvatarActor.Get());
 89: 	if (!Character)
 90: 	{
 91: 		return;
 92: 	}
 93: 
 94: 
 95: 	FVector TraceStart;
 96: 	FVector TraceDirection;
 97: 
 98: 
 99: 	UCameraComponent* CameraComponent = Character->FindComponentByClass<UCameraComponent>();
100: 	if (CameraComponent)
101: 	{
102: 
103: 		TraceStart = CameraComponent->GetComponentLocation();
104: 		TraceDirection = CameraComponent->GetForwardVector();
105: 	}
106: 	else
107: 	{
108: 
109: 		FRotator ControllerRotation = PC->GetControlRotation();
110: 		PC->GetPlayerViewPoint(TraceStart, ControllerRotation);
111: 		TraceDirection = ControllerRotation.Vector();
112: 	}
113: 
114: 	FVector TraceEnd = TraceStart + TraceDirection * TraceDistance;
115: 
116: 
117: 	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(WaitForPlacementLocation), bTraceComplex);
118: 	QueryParams.AddIgnoredActor(Character);
119: 
120: 
121: 	ECollisionChannel TraceChannel = ECC_Visibility;
122: 
123: 
124: 	FHitResult HitResult;
125: 	bool bHit = false;
126: 
127: 
128: 	if (TraceRadius > 0.0f)
129: 	{
130: 		bHit = GetWorld()->SweepSingleByChannel(
131: 			HitResult,
132: 			TraceStart,
133: 			TraceEnd,
134: 			FQuat::Identity,
135: 			TraceChannel,
136: 			FCollisionShape::MakeSphere(TraceRadius),
137: 			QueryParams
138: 		);
139: 	}
140: 	else
141: 	{
142: 		bHit = GetWorld()->LineTraceSingleByChannel(
143: 			HitResult,
144: 			TraceStart,
145: 			TraceEnd,
146: 			TraceChannel,
147: 			QueryParams
148: 		);
149: 	}
150: 
151: 
152: 	if (bHit && (HitResult.ImpactPoint != LastHitLocation || HitResult.ImpactNormal != LastHitNormal))
153: 	{
154: 
155: 		LastHitLocation = HitResult.ImpactPoint;
156: 		LastHitNormal = HitResult.ImpactNormal;
157: 
158: 
159: 		if (ShouldBroadcastAbilityTaskDelegates())
160: 		{
161: 			OnLocationFound.Broadcast(LastHitLocation, LastHitNormal);
162: 		}
163: 	}
164: 
165: 
166: 	if (bShowDebug)
167: 	{
168: 		DrawDebugLine(GetWorld(), TraceStart, bHit ? HitResult.ImpactPoint : TraceEnd, FColor::Green, false, 0.0f, 0, 2.0f);
169: 
170: 		if (bHit)
171: 		{
172: 
173: 			DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 12, FColor::Red, false, 0.0f);
174: 
175: 
176: 			DrawDebugLine(GetWorld(), HitResult.ImpactPoint, HitResult.ImpactPoint + HitResult.ImpactNormal * 50.0f, FColor::Blue, false, 0.0f, 0, 2.0f);
177: 		}
178: 	}
179: }

================
File: Source/WitchPT/Private/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.cpp
================
1: #include "AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h"
2: 
3: #include "FWitchPTGameplayTags.h"
4: 
5: UGA_QuickBarSlots::UGA_QuickBarSlots()
6: {
7: 
8: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.cpp
================
  1: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "Engine/World.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  6: #include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitForInteractable)
  7: struct FInteractionQuery;
  8: 
  9: UAbilityTask_WaitForInteractable::UAbilityTask_WaitForInteractable(const FObjectInitializer& ObjectInitializer)
 10: 	: Super(ObjectInitializer)
 11: {
 12: }
 13: void UAbilityTask_WaitForInteractable::LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params)
 14: {
 15: 	check(World);
 16: 
 17: 	OutHitResult = FHitResult();
 18: 	FHitResult HitResult;
 19: 
 20: 	World->LineTraceSingleByChannel(HitResult, Start, End, CollisionChannel);
 21: 	OutHitResult.TraceStart = Start;
 22: 	OutHitResult.TraceEnd = End;
 23: 
 24: 	OutHitResult = HitResult;
 25: }
 26: 
 27: void UAbilityTask_WaitForInteractable::AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch) const
 28: {
 29: 	if (!Ability)
 30: 	{
 31: 		return;
 32: 	}
 33: 
 34: 
 35: 	APlayerController* PC = Ability->GetCurrentActorInfo()->PlayerController.Get();
 36: 	check(PC);
 37: 
 38: 	FVector ViewStart;
 39: 	FRotator ViewRot;
 40: 	PC->GetPlayerViewPoint(ViewStart, ViewRot);
 41: 
 42: 	const FVector ViewDir = ViewRot.Vector();
 43: 	FVector ViewEnd = ViewStart + (ViewDir * MaxRange);
 44: 
 45: 	ClipCameraRayToAbilityRange(ViewStart, ViewDir, TraceStart, MaxRange, ViewEnd);
 46: 
 47: 	FHitResult HitResult;
 48: 	LineTrace(HitResult, InSourceActor->GetWorld(), ViewStart, ViewEnd, TraceProfile, Params);
 49: 
 50: 	const bool bUseTraceResult = HitResult.bBlockingHit && (FVector::DistSquared(TraceStart, HitResult.Location) <= (MaxRange * MaxRange));
 51: 
 52: 	const FVector AdjustedEnd = (bUseTraceResult) ? HitResult.Location : ViewEnd;
 53: 
 54: 	FVector AdjustedAimDir = (AdjustedEnd - TraceStart).GetSafeNormal();
 55: 	if (AdjustedAimDir.IsZero())
 56: 	{
 57: 		AdjustedAimDir = ViewDir;
 58: 	}
 59: 
 60: 	if (!bTraceAffectsAimPitch && bUseTraceResult)
 61: 	{
 62: 		FVector OriginalAimDir = (ViewEnd - TraceStart).GetSafeNormal();
 63: 
 64: 		if (!OriginalAimDir.IsZero())
 65: 		{
 66: 
 67: 			const FRotator OriginalAimRot = OriginalAimDir.Rotation();
 68: 
 69: 			FRotator AdjustedAimRot = AdjustedAimDir.Rotation();
 70: 			AdjustedAimRot.Pitch = OriginalAimRot.Pitch;
 71: 
 72: 			AdjustedAimDir = AdjustedAimRot.Vector();
 73: 		}
 74: 	}
 75: 
 76: 	OutTraceEnd = TraceStart + (AdjustedAimDir * MaxRange);
 77: }
 78: 
 79: bool UAbilityTask_WaitForInteractable::ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition)
 80: {
 81: 	FVector CameraToCenter = AbilityCenter - CameraLocation;
 82: 	float DotToCenter = FVector::DotProduct(CameraToCenter, CameraDirection);
 83: 	if (DotToCenter >= 0)
 84: 	{
 85: 		float DistanceSquared = CameraToCenter.SizeSquared() - (DotToCenter * DotToCenter);
 86: 		float RadiusSquared = (AbilityRange * AbilityRange);
 87: 		if (DistanceSquared <= RadiusSquared)
 88: 		{
 89: 			float DistanceFromCamera = FMath::Sqrt(RadiusSquared - DistanceSquared);
 90: 			float DistanceAlongRay = DotToCenter + DistanceFromCamera;
 91: 			ClippedPosition = CameraLocation + (DistanceAlongRay * CameraDirection);
 92: 			return true;
 93: 		}
 94: 	}
 95: 	return false;
 96: }
 97: 
 98: void UAbilityTask_WaitForInteractable::UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets)
 99: {
100: 	TArray<FInteractionOption> NewOptions;
101: 
102: 	for (const TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
103: 	{
104: 		TArray<FInteractionOption> TempOptions;
105: 		FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, TempOptions);
106: 		InteractiveTarget->GatherInteractionOptions(InteractQuery, InteractionBuilder);
107: 
108: 		for (FInteractionOption& Option : TempOptions)
109: 		{
110: 			FGameplayAbilitySpec* InteractionAbilitySpec = nullptr;
111: 
112: 
113: 			if (Option.TargetAbilitySystem && Option.TargetInteractionAbilityHandle.IsValid())
114: 			{
115: 
116: 				InteractionAbilitySpec = Option.TargetAbilitySystem->FindAbilitySpecFromHandle(Option.TargetInteractionAbilityHandle);
117: 			}
118: 
119: 			else if (Option.InteractionAbilityToGrant)
120: 			{
121: 
122: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.InteractionAbilityToGrant);
123: 
124: 				if (InteractionAbilitySpec)
125: 				{
126: 
127: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
128: 					Option.TargetInteractionAbilityHandle = InteractionAbilitySpec->Handle;
129: 				}
130: 			}
131: 			if (Option.HoldInteractionAbilityToGrant)
132: 			{
133: 
134: 				InteractionAbilitySpec = AbilitySystemComponent->FindAbilitySpecFromClass(Option.HoldInteractionAbilityToGrant);
135: 
136: 				if (InteractionAbilitySpec)
137: 				{
138: 
139: 					Option.TargetAbilitySystem = AbilitySystemComponent.Get();
140: 					Option.TargetHoldInteractionAbilityHandle = InteractionAbilitySpec->Handle;
141: 				}
142: 			}
143: 			if (InteractionAbilitySpec)
144: 			{
145: 
146: 				if (InteractionAbilitySpec->Ability->CanActivateAbility(InteractionAbilitySpec->Handle, AbilitySystemComponent->AbilityActorInfo.Get()))
147: 				{
148: 					NewOptions.Add(Option);
149: 				}
150: 			}
151: 		}
152: 	}
153: 
154: 	bool bOptionsChanged = false;
155: 	if (NewOptions.Num() == CurrentOptions.Num())
156: 	{
157: 		NewOptions.Sort();
158: 
159: 		for (int OptionIndex = 0; OptionIndex < NewOptions.Num(); OptionIndex++)
160: 		{
161: 			const FInteractionOption& NewOption = NewOptions[OptionIndex];
162: 			const FInteractionOption& CurrentOption = CurrentOptions[OptionIndex];
163: 
164: 			if (NewOption != CurrentOption)
165: 			{
166: 				bOptionsChanged = true;
167: 				break;
168: 			}
169: 		}
170: 	}
171: 	else
172: 	{
173: 		bOptionsChanged = true;
174: 	}
175: 
176: 	if (bOptionsChanged)
177: 	{
178: 		CurrentOptions = NewOptions;
179: 		InteractableObjectsChanged.Broadcast(CurrentOptions);
180: 	}
181: }

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.cpp
================
 1: #include "AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h"
 2: 
 3: #include "AbilitySystem/Interaction/InteractionStatics.h"
 4: #include "Kismet/GameplayStatics.h"
 5: 
 6: UAT_WaitForInteractable_SLT::UAT_WaitForInteractable_SLT(const FObjectInitializer& ObjectInitializer)
 7: 	: Super(ObjectInitializer)
 8: {
 9: }
10: 
11: UAT_WaitForInteractable_SLT* UAT_WaitForInteractable_SLT::WaitForInteractableTargets_SingleLineTrace(
12: 	UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile,
13: 	FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange, float InteractionScanRate,
14: 	bool bShowDebug)
15: {
16: 	UAT_WaitForInteractable_SLT* MyObj = NewAbilityTask<UAT_WaitForInteractable_SLT>(OwningAbility);
17: 	MyObj->InteractionScanRange = InteractionScanRange;
18: 	MyObj->InteractionScanRate = InteractionScanRate;
19: 	MyObj->StartLocation = StartLocation;
20: 	MyObj->InteractionQuery = InteractionQuery;
21: 	MyObj->TraceProfile = TraceProfile;
22: 	MyObj->bShowDebug = bShowDebug;
23: 
24: 	return MyObj;
25: }
26: void UAT_WaitForInteractable_SLT::Activate()
27: {
28: 	SetWaitingOnAvatar();
29: 
30: 	UWorld* World = GetWorld();
31: 	World->GetTimerManager().SetTimer(TimerHandle, this, &ThisClass::PerformTrace, InteractionScanRate, true);
32: }
33: 
34: void UAT_WaitForInteractable_SLT::OnDestroy(bool AbilityEnded)
35: {
36: 	if (UWorld* World = GetWorld())
37: 	{
38: 		World->GetTimerManager().ClearTimer(TimerHandle);
39: 	}
40: 
41: 	Super::OnDestroy(AbilityEnded);
42: }
43: 
44: void UAT_WaitForInteractable_SLT::PerformTrace()
45: {
46: 	AActor* AvatarActor = Ability->GetCurrentActorInfo()->AvatarActor.Get();
47: 
48: 	if (!AvatarActor)
49: 	{
50: 		return;
51: 	}
52: 
53: 	UWorld* World = GetWorld();
54: 
55: 	TArray<AActor*> ActorsToIgnore;
56: 	ActorsToIgnore.Add(AvatarActor);
57: 
58: 	const bool bTraceComplex = false;
59: 	FCollisionQueryParams Params(SCENE_QUERY_STAT(UAT_WaitForInteractable_SLT), bTraceComplex);
60: 	Params.AddIgnoredActors(ActorsToIgnore);
61: 	if (!IsValid(GEngine) || !IsValid(GEngine->GameViewport)) return;
62: 	FVector2D ViewportSize;
63: 	GEngine->GameViewport->GetViewportSize(ViewportSize);
64: 	const FVector2D ViewportCenter = ViewportSize / 2.f;
65: 	FVector TraceStart;
66: 	FVector Forward;
67: 	if (!UGameplayStatics::DeprojectScreenToWorld(Ability->GetCurrentActorInfo()->PlayerController.Get(), ViewportCenter, TraceStart, Forward)) return;
68: 
69: 
70: 	FVector TraceEnd;
71: 	AimWithPlayerController(AvatarActor, Params, TraceStart, InteractionScanRange, OUT TraceEnd);
72: 
73: 	FHitResult OutHitResult;
74: 	LineTrace(OutHitResult, World, TraceStart, TraceEnd, TraceProfile, Params);
75: 
76: 	TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
77: 	UInteractionStatics::AppendInteractableTargetsFromHitResult(OutHitResult, InteractableTargets);
78: 
79: 	UpdateInteractableOptions(InteractionQuery, InteractableTargets);
80: 
81: #if ENABLE_DRAW_DEBUG
82: 	if (bShowDebug)
83: 	{
84: 		FColor DebugColor = OutHitResult.bBlockingHit ? FColor::Red : FColor::Green;
85: 		if (OutHitResult.bBlockingHit)
86: 		{
87: 			DrawDebugLine(World, TraceStart, OutHitResult.Location, DebugColor, false, InteractionScanRate);
88: 			DrawDebugSphere(World, OutHitResult.Location, 5, 16, DebugColor, false, InteractionScanRate);
89: 		}
90: 		else
91: 		{
92: 			DrawDebugLine(World, TraceStart, TraceEnd, DebugColor, false, InteractionScanRate);
93: 		}
94: 	}
95: #endif
96: }

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemComponent.cpp
================
  1: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  2: 
  3: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  4: 
  5: 
  6: void UWitchPTAbilitySystemComponent::GrantStartupAbilities(
  7: 	const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant)
  8: {
  9: 	if (!AbilitiesToGrant.IsEmpty())
 10: 	{
 11: 		for (const TSubclassOf<UGameplayAbility> AbilityClass: AbilitiesToGrant)
 12: 		{
 13: 			if (!AbilityClass)
 14: 			{
 15: 				continue;
 16: 			}
 17: 
 18: 
 19: 			UWitchPTGameplayAbility* AbilityCDO = AbilityClass->GetDefaultObject<UWitchPTGameplayAbility>();
 20: 			if (!AbilityCDO)
 21: 			{
 22: 				continue;
 23: 			}
 24: 
 25: 			FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1);
 26: 
 27: 			AbilitySpec.SourceObject = this;
 28: 
 29: 			AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityCDO->StartupInputTag);
 30: 
 31: 			FGameplayAbilitySpecHandle AbilitySpecHandle = GiveAbility(AbilitySpec);
 32: 
 33: 			GrantedAbilities.Add(AbilitySpecHandle);
 34: 		}
 35: 	}
 36: }
 37: 
 38: void UWitchPTAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
 39: {
 40: 	if (InputTag.IsValid())
 41: 	{
 42: 
 43: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 44: 		{
 45: 
 46: 
 47: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 48: 			{
 49: 
 50: 				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
 51: 				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
 52: 			}
 53: 		}
 54: 	}
 55: }
 56: 
 57: void UWitchPTAbilitySystemComponent::AbilityInputTagHeld(const FGameplayTag& InputTag)
 58: {
 59: 	if (!InputTag.IsValid()) return;
 60: 	for (FGameplayAbilitySpec& AbilitySpec: GetActivatableAbilities())
 61: 	{
 62: 		if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
 63: 		{
 64: 			AbilitySpecInputPressed(AbilitySpec);
 65: 			if (!AbilitySpec.IsActive())
 66: 			{
 67: 				TryActivateAbility(AbilitySpec.Handle);
 68: 			}
 69: 		}
 70: 	}
 71: }
 72: 
 73: void UWitchPTAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
 74: {
 75: 	if (InputTag.IsValid())
 76: 	{
 77: 		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
 78: 		{
 79: 			if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
 80: 			{
 81: 				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
 82: 				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
 83: 			}
 84: 		}
 85: 	}
 86: }
 87: 
 88: void UWitchPTAbilitySystemComponent::AbilityActorInfoHaveBeenSet()
 89: {
 90: 	OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &UWitchPTAbilitySystemComponent::ClientEffectApplied);
 91: }
 92: 
 93: void UWitchPTAbilitySystemComponent::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
 94: {
 95: 		static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
 96: 	AbilitiesToActivate.Reset();
 97: 
 98: 
 99: 
100: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
101: 	{
102: 
103: 
104: 		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
105: 		{
106: 			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
107: 			{
108: 				const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
109: 				if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
110: 				{
111: 
112: 
113: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::WhileInputActive)
114: 					{
115: 						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
116: 					}
117: 				}
118: 			}
119: 		}
120: 	}
121: 
122: 
123: 
124: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
125: 	{
126: 
127: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
128: 		{
129: 			if (AbilitySpec->Ability)
130: 			{
131: 				AbilitySpec->InputPressed = true;
132: 
133: 				if (AbilitySpec->IsActive())
134: 				{
135: 
136: 
137: 
138: 					AbilitySpecInputPressed(*AbilitySpec);
139: 				}
140: 				else
141: 				{
142: 					const UWitchPTGameplayAbility* PTAbilityBase = Cast<UWitchPTGameplayAbility>(AbilitySpec->Ability);
143: 
144: 					if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
145: 					{
146: 						if (PTAbilityBase && PTAbilityBase->GetActivationPolicy() == EPrototypeAbilityActivationPolicy::OnInputTriggered)
147: 						{
148: 							AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
149: 						}
150: 					}
151: 				}
152: 			}
153: 		}
154: 	}
155: 
156: 
157: 
158: 
159: 
160: 	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
161: 	{
162: 		TryActivateAbility(AbilitySpecHandle);
163: 	}
164: 
165: 
166: 
167: 	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
168: 	{
169: 		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
170: 		{
171: 			if (AbilitySpec->Ability)
172: 			{
173: 				AbilitySpec->InputPressed = false;
174: 
175: 				if (AbilitySpec->IsActive())
176: 				{
177: 
178: 					AbilitySpecInputReleased(*AbilitySpec);
179: 				}
180: 			}
181: 		}
182: 	}
183: 
184: 
185: 
186: 
187: 	InputPressedSpecHandles.Reset();
188: 	InputReleasedSpecHandles.Reset();
189: 
190: }
191: 
192: void UWitchPTAbilitySystemComponent::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
193: {
194: 	Super::AbilitySpecInputPressed(Spec);
195: 
196: 
197: 	if (Spec.IsActive())
198: 	{
199: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
200: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
201: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
202: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
203: 
204: 
205: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
206: 	}
207: 
208: }
209: 
210: void UWitchPTAbilitySystemComponent::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
211: {
212: 	Super::AbilitySpecInputReleased(Spec);
213: 
214: 
215: 	if (Spec.IsActive())
216: 	{
217: 		PRAGMA_DISABLE_DEPRECATION_WARNINGS
218: 		const UGameplayAbility* Instance = Spec.GetPrimaryInstance();
219: 		FPredictionKey OriginalPredictionKey = Instance ? Instance->GetCurrentActivationInfo().GetActivationPredictionKey() : Spec.ActivationInfo.GetActivationPredictionKey();
220: 		PRAGMA_ENABLE_DEPRECATION_WARNINGS
221: 
222: 
223: 		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
224: 	}
225: }
226: 
227: void UWitchPTAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent,
228: 	const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
229: {
230: 	FGameplayTagContainer TagContainer;
231: 	EffectSpec.GetAllAssetTags(TagContainer);
232: 
233: 	OnEffectAssetTags.Broadcast(TagContainer);
234: }

================
File: Source/WitchPT/Private/AbilitySystem/WitchPTAbilitySystemLibrary.cpp
================
 1: #include "AbilitySystem/WitchPTAbilitySystemLibrary.h"
 2: 
 3: #include "Item/MechanicsInterface.h"
 4: 
 5: TScriptInterface<IMechanicsInterface> UWitchPTAbilitySystemLibrary::GetMechanicsInterface(AActor* Actor)
 6: {
 7: 	if (!Actor)
 8: 	{
 9: 		return TScriptInterface<IMechanicsInterface>();
10: 
11: 	}
12: 	TArray<UActorComponent*> ComponentsImplementingInterface = Actor->GetComponentsByInterface(UMechanicsInterface::StaticClass());
13: 	if (ComponentsImplementingInterface.Num() > 0)
14: 	{
15: 		return TScriptInterface<IMechanicsInterface>(ComponentsImplementingInterface[0]);
16: 	}
17: 	return TScriptInterface<IMechanicsInterface>();
18: }

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentDefinition.cpp
================
1: #include "Equipment/WitchPTEquipmentDefinition.h"
2: 
3: #include "Equipment/WitchPTEquipmentInstance.h"
4: 
5: UWitchPTEquipmentDefinition::UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer)
6: 	: Super(ObjectInitializer)
7: {
8: 	InstanceType = UWitchPTEquipmentInstance::StaticClass();
9: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_Stackable.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
2: 
3: #include "Inventory/WitchPTInventoryItemInstance.h"
4: 
5: void UWitchPTInventoryItemFragment_IngredientCraftingProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
6: {
7: 
8: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.cpp
================
 1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
 2: #include "Inventory/WitchPTInventoryItemInstance.h"
 3: 
 4: void UWitchPTInventoryItemFragment_PotionProperties::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
 5: {
 6: 
 7: 
 8: }
 9: 
10: bool UWitchPTInventoryItemFragment_PotionProperties::IsValidPotion() const
11: {
12: 
13: 	return PotionEssenceTag.IsValid() &&
14: 		   FinalPotency > 0.0f &&
15: 		   FinalDuration > 0.0f &&
16: 		   FinalCharges > 0;
17: }
18: 
19: FString UWitchPTInventoryItemFragment_PotionProperties::GetPotionDescription() const
20: {
21: 	if (!IsValidPotion())
22: 	{
23: 		return TEXT("Invalid Potion");
24: 	}
25: 
26: 
27: 	FString Description = FString::Printf(
28: 		TEXT("%s Potion\nPotency: %.1f\nDuration: %.1fs\nCharges: %d"),
29: 		*PotionEssenceTag.GetTagName().ToString(),
30: 		FinalPotency,
31: 		FinalDuration,
32: 		FinalCharges
33: 	);
34: 
35: 
36: 	if (PotionTierTag.IsValid())
37: 	{
38: 		Description += FString::Printf(TEXT("\nTier: %s"), *PotionTierTag.GetTagName().ToString());
39: 	}
40: 
41: 
42: 	if (BaseLiquidTypeTag.IsValid())
43: 	{
44: 		Description += FString::Printf(TEXT("\nBase: %s"), *BaseLiquidTypeTag.GetTagName().ToString());
45: 	}
46: 
47: 
48: 	if (GrantedEffectTags.Num() > 0)
49: 	{
50: 		Description += FString::Printf(TEXT("\nEffects: %d"), GrantedEffectTags.Num());
51: 	}
52: 
53: 
54: 	if (GrantedPropertyTags.Num() > 0)
55: 	{
56: 		Description += FString::Printf(TEXT("\nProperties: %d"), GrantedPropertyTags.Num());
57: 	}
58: 
59: 	return Description;
60: }
61: 
62: void UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties(
63: 	const FGameplayTag& InPotionEssence,
64: 	const FGameplayTag& InBaseLiquidType,
65: 	float InPotency,
66: 	float InDuration,
67: 	int32 InCharges,
68: 	const FGameplayTag& InTierTag,
69: 	const FGameplayTagContainer& InEffectTags,
70: 	const FGameplayTagContainer& InPropertyTags)
71: {
72: 	PotionEssenceTag = InPotionEssence;
73: 	BaseLiquidTypeTag = InBaseLiquidType;
74: 	FinalPotency = InPotency;
75: 	FinalDuration = InDuration;
76: 	FinalCharges = InCharges;
77: 	PotionTierTag = InTierTag;
78: 	GrantedEffectTags = InEffectTags;
79: 	GrantedPropertyTags = InPropertyTags;
80: 
81: 	UE_LOG(LogTemp, Log, TEXT("UWitchPTInventoryItemFragment_PotionProperties::SetPotionProperties: Potion properties set - %s, Potency: %.2f, Duration: %.2f, Charges: %d"),
82: 		   *PotionEssenceTag.ToString(),
83: 		   FinalPotency,
84: 		   FinalDuration,
85: 		   FinalCharges);
86: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.cpp
================
 1: #include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
 2: #include "Inventory/WitchPTInventoryItemInstance.h"
 3: 
 4: void UWitchPTInventoryItemFragment_WorldDetails::OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const
 5: {
 6: 
 7: 
 8: }
 9: 
10: bool UWitchPTInventoryItemFragment_WorldDetails::HasValidWorldMesh() const
11: {
12: 	return WorldStaticMesh != nullptr;
13: }

================
File: Source/WitchPT/Private/Inventory/Fragments/WitchPTInventoryItemFragment.cpp
================
1: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"

================
File: Source/WitchPT/Private/Item/PositionInterface.cpp
================
1: #include "Item/PositionInterface.h"

================
File: Source/WitchPT/Private/Subsystems/UIManagerSubsystem.cpp
================
  1: #include "Subsystems/UIManagerSubsystem.h"
  2: 
  3: #include "GameplayTagContainer.h"
  4: #include "UI/HUD/WitchPTHUD.h"
  5: #include "UI/Widgets/WitchPTPrimaryLayout.h"
  6: #include "UI/Widgets/WitchPTUserWidget.h"
  7: 
  8: AWitchPTHUD* UUIManagerSubsystem::GetWitchPTHUD()
  9: {
 10: 	if (ULocalPlayer * LocalPlayer = GetLocalPlayer())
 11: 	{
 12: 		if (APlayerController* PlayerController = LocalPlayer->GetPlayerController(GetWorld()))
 13: 		{
 14: 			if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PlayerController->GetHUD()))
 15: 			{
 16: 				return WitchPTHUD;
 17: 			}
 18: 		}
 19: 	}
 20: 	return nullptr;
 21: }
 22: 
 23: bool UUIManagerSubsystem::RegisterLayout(FGameplayTag LayoutTag, UWitchPTUILayer* InLayer)
 24: {
 25: 	if (LayoutTag.IsValid() && InLayer != nullptr)
 26: 	{
 27: 		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
 28: 		{
 29: 			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
 30: 			{
 31: 				return PrimaryLayout->RegisterLayer(LayoutTag, InLayer);
 32: 			}
 33: 		}
 34: 	}
 35: 	return false;
 36: }
 37: 
 38: bool UUIManagerSubsystem::UnRegisterLayout(FGameplayTag LayerTag)
 39: {
 40: 	if (LayerTag.IsValid())
 41: 	{
 42: 		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
 43: 		{
 44: 			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
 45: 			{
 46: 				return PrimaryLayout->UnRegisterLayer(LayerTag);
 47: 			}
 48: 		}
 49: 
 50: 	}
 51: 	return false;
 52: }
 53: 
 54: UUserWidget* UUIManagerSubsystem::PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass)
 55: {
 56: 	if (LayerTag.IsValid() && WidgetClass.IsValid())
 57: 	{
 58: 		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
 59: 		{
 60: 			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
 61: 			{
 62: 				return PrimaryLayout->PushContentToLayer(LayerTag, WidgetClass);
 63: 
 64: 			}
 65: 		}
 66: 
 67: 	}
 68: 	return nullptr;
 69: }
 70: 
 71: void UUIManagerSubsystem::PopContentFromLayer(FGameplayTag LayerTag)
 72: {
 73: 	if (LayerTag.IsValid())
 74: 	{
 75: 		if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
 76: 		{
 77: 			if (UWitchPTPrimaryLayout* PrimaryLayout = WitchPTHUD->GetPrimaryLayout())
 78: 			{
 79: 
 80: 				UE_LOG(LogTemp, Log, TEXT("Popping content from layer: %s"), *LayerTag.ToString());
 81: 			}
 82: 		}
 83: 	}
 84: }
 85: 
 86: void UUIManagerSubsystem::ClearAllLayers()
 87: {
 88: }
 89: 
 90: void UUIManagerSubsystem::ClearLayerExcept(FGameplayTag LayerTag)
 91: {
 92: }
 93: 
 94: void UUIManagerSubsystem::ClearLayer(FGameplayTag LayerTag)
 95: {
 96: }
 97: 
 98: UWitchPTUserWidget* UUIManagerSubsystem::GetPrimaryLayout()
 99: {
100: 	if (AWitchPTHUD* WitchPTHUD = GetWitchPTHUD())
101: 	{
102: 		if (WitchPTHUD->GetPrimaryLayout())
103: 		{
104: 			return WitchPTHUD->GetPrimaryLayout();
105: 		}
106: 		else
107: 		{
108: 			UE_LOG(LogTemp, Warning, TEXT("Primary Layout is not initialized in WitchPTHUD!"));
109: 		}
110: 	}
111: 	return nullptr;
112: }

================
File: Source/WitchPT/Private/Subsystems/WidgetCommunicatorSubsystem.cpp
================
1: #include "Subsystems/WidgetCommunicatorSubsystem.h"
2: 
3: void UWidgetCommunicatorSubsystem::OnItemDragged(UWitchPTInventoryItemInstance* ItemInstance)
4: {
5:     OnItemDraggedDelegate.Broadcast(ItemInstance);
6: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/OverlayWidgetController.cpp
================
 1: #include "UI/WidgetControllers/OverlayWidgetController.h"
 2: 
 3: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAttributeSet.h"
 5: 
 6: void UOverlayWidgetController::BroadcastInitialValues()
 7: {
 8: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
 9: 
10: 	OnHealthChanged.Broadcast(WitchPT_AS->GetHealth());
11: 	OnMaxHealthChanged.Broadcast(WitchPT_AS->GetMaxHealth());
12: 	OnStaminaChanged.Broadcast(WitchPT_AS->GetStamina());
13: 	OnMaxStaminaChanged.Broadcast(WitchPT_AS->GetMaxStamina());
14: 	OnAgeChanged.Broadcast(WitchPT_AS->GetAge());
15: 	OnMaxAgeChanged.Broadcast(WitchPT_AS->GetMaxAge());
16: }
17: 
18: void UOverlayWidgetController::BindCallbacksToDependencies()
19: {
20: 	const UWitchPTAttributeSet* WitchPT_AS = Cast<UWitchPTAttributeSet>(AttributeSet);
21: 
22: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
23: 	{
24: 		OnHealthChanged.Broadcast(Data.NewValue);
25: 	});
26: 
27: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxHealthAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
28: 	{
29: 		OnMaxHealthChanged.Broadcast(Data.NewValue);
30: 	});
31: 
32: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
33: 	{
34: 		OnStaminaChanged.Broadcast(Data.NewValue);
35: 	});
36: 
37: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxStaminaAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
38: 	{
39: 		OnMaxStaminaChanged.Broadcast(Data.NewValue);
40: 	});
41: 
42: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
43: 	{
44: 		OnAgeChanged.Broadcast(Data.NewValue);
45: 	});
46: 
47: 	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(WitchPT_AS->GetMaxAgeAttribute()).AddLambda([this](const FOnAttributeChangeData& Data)
48: 	{
49: 		OnMaxAgeChanged.Broadcast(Data.NewValue);
50: 	});
51: 
52: 	UWitchPTAbilitySystemComponent* WitchPTAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystemComponent);
53: 
54: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddUObject(this, &UOverlayWidgetController::OnAssetTagReceivedFromGE);
55: 
56: 
57: 	WitchPTAbilitySystemComponent->OnEffectAssetTags.AddLambda(
58: 
59: 		[this](const FGameplayTagContainer& AssetTags)
60: 	{
61: 		for (const auto& Tag : AssetTags)
62: 		{
63: 
64: 			FGameplayTag ParentMessageGameplayTag = FGameplayTag::RequestGameplayTag(FName("Communication.Message"));
65: 			if (Tag.MatchesTag(ParentMessageGameplayTag))
66: 			{
67: 
68: 
69: 				const FUIWidgetRow* Row = GetDataTableRowByTag<FUIWidgetRow>(MessageWidgetDataTable, Tag);
70: 				OnMessageWidgetRow.Broadcast(*Row);
71: 
72: 			}
73: 
74: 		}
75: 	});
76: 
77: 
78: 
79: }
80: void UOverlayWidgetController::OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const
81: {
82: 
83: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/WitchPTWidgetController.cpp
================
 1: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 2: 
 3: void UWitchPTWidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
 4: {
 5: 	PlayerController = WCParams.PlayerController;
 6: 	PlayerState = WCParams.PlayerState;
 7: 	AbilitySystemComponent = WCParams.AbilitySystemComponent;
 8: 	AttributeSet = WCParams.AttributeSet;
 9: }
10: 
11: void UWitchPTWidgetController::BroadcastInitialValues()
12: {
13: }
14: 
15: void UWitchPTWidgetController::BindCallbacksToDependencies()
16: {
17: }

================
File: Source/WitchPT/Private/UI/Widgets/Layer/WitchPTUILayer.cpp
================
  1: #include "UI/Widgets/Layer/WitchPTUILayer.h"
  2: 
  3: #include "Components/Border.h"
  4: 
  5: UUserWidget* UWitchPTUILayer::PushContent(TSoftClassPtr<UUserWidget> WidgetClass)
  6: {
  7: 	if (WidgetClass.IsValid())
  8: 	{
  9: 		if(UClass* LoadedClass = WidgetClass.Get())
 10: 		{
 11: 			UUserWidget* NewUserWidgetInstance = CreateWidget<UUserWidget>(GetOwningPlayer(), LoadedClass);
 12: 			PushedWidget = NewUserWidgetInstance;
 13: 			CollapseTop();
 14: 			Border->ClearChildren();
 15: 			Stack.Add(NewUserWidgetInstance);
 16: 			Border->AddChild(NewUserWidgetInstance);
 17: 			ShowTop();
 18: 			UE_LOG(LogTemp, Log, TEXT("Pushing widget: %s"), *NewUserWidgetInstance->GetName());
 19: 			return PushedWidget;
 20: 		}
 21: 	}
 22: 	return nullptr;
 23: }
 24: 
 25: void UWitchPTUILayer::PopContent()
 26: {
 27: 	if (!Stack.IsEmpty())
 28: 	{
 29: 		TopWidget = GetTopScreen();
 30: 		if (TopWidget)
 31: 		{
 32: 			TopWidget->RemoveFromParent();
 33: 
 34: 			Stack.RemoveAt(Stack.Num() - 1);
 35: 			Border->ClearChildren();
 36: 			TopWidget = GetTopScreen();
 37: 			if (TopWidget)
 38: 			{
 39: 				TopWidget->SetVisibility(ESlateVisibility::Visible);
 40: 				Border->AddChild(TopWidget);
 41: 			}
 42: 		}
 43: 
 44: 	}
 45: }
 46: 
 47: UUserWidget* UWitchPTUILayer::GetTopScreen() const
 48: {
 49: 	if (!Stack.IsEmpty())
 50: 	{
 51: 		return Stack.Last();
 52: 	}
 53: 	return nullptr;
 54: }
 55: 
 56: FText UWitchPTUILayer::GetStackListNames()
 57: {
 58: 
 59: 	FString StackNames;
 60: 	for (int32 i = Stack.Num() - 1; i >= 0; --i)
 61: 	{
 62: 		if (Stack[i])
 63: 		{
 64: 			StackNames += Stack[i]->GetName();
 65: 			if (i > 0)
 66: 			{
 67: 				StackNames += TEXT(", ");
 68: 			}
 69: 		}
 70: 	}
 71: 	return FText ::FromString(StackNames);
 72: }
 73: 
 74: void UWitchPTUILayer::ClearStack()
 75: {
 76: 	for (auto & Widget : Stack)
 77: 	{
 78: 		if (Widget)
 79: 		{
 80: 			Widget->RemoveFromParent();
 81: 		}
 82: 	}
 83: 	Stack.Empty();
 84: 	Border->ClearChildren();
 85: 
 86: 
 87: }
 88: 
 89: void UWitchPTUILayer::CollapseTop()
 90: {
 91: 	if (UUserWidget* TopWidgetToCollapse = GetTopScreen())
 92: 	{
 93: 		TopWidgetToCollapse->SetVisibility(ESlateVisibility::Collapsed);
 94: 	}
 95: }
 96: 
 97: void UWitchPTUILayer::ShowTop()
 98: {
 99: 	if (UUserWidget* TopWidgetToShow = GetTopScreen())
100: 	{
101: 		TopWidgetToShow->SetVisibility(ESlateVisibility::Visible);
102: 	}
103: }

================
File: Source/WitchPT/Private/UI/Widgets/PointerWidget.cpp
================
1: #include "UI/Widgets/PointerWidget.h"

================
File: Source/WitchPT/Private/UI/Widgets/QuickBarUserWidget.cpp
================
1: #include "UI/Widgets/QuickBarUserWidget.h"

================
File: Source/WitchPT/Public/AbilitySystem/Cauldron/AT_WaitForPlacementLocation_SLT.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "AT_WaitForPlacementLocation_SLT.generated.h"
 6: 
 7: 
 8: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FPlacementLocationFound, FVector, HitLocation, FVector, HitNormal);
 9: 
10: 
11: 
12: 
13: 
14: UCLASS()
15: class WITCHPT_API UAT_WaitForPlacementLocation_SLT : public UAbilityTask
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 
21: 	UAT_WaitForPlacementLocation_SLT(const FObjectInitializer& ObjectInitializer);
22: 
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
25: 	static UAT_WaitForPlacementLocation_SLT* WaitForPlacementLocation(
26: 		UGameplayAbility* OwningAbility,
27: 		float TraceDistance = 500.0f,
28: 		float TraceRadius = 10.0f,
29: 		bool TraceComplex = false,
30: 		bool bIgnoreBlockingHits = false,
31: 		bool bShowDebug = false);
32: 
33: 
34: 	UPROPERTY(BlueprintAssignable)
35: 	FPlacementLocationFound OnLocationFound;
36: 
37: 
38: 	virtual void Activate() override;
39: 
40: 
41: 	virtual void OnDestroy(bool bInOwnerFinished) override;
42: 
43: private:
44: 
45: 	void PerformTrace();
46: 
47: 
48: 	void TickTask(float DeltaTime);
49: 
50: 
51: 	FTimerHandle TraceTimerHandle;
52: 
53: 
54: 	float TraceDistance;
55: 
56: 
57: 	float TraceRadius;
58: 
59: 
60: 	bool bTraceComplex;
61: 
62: 
63: 	bool bIgnoreBlockingHits;
64: 
65: 
66: 	bool bShowDebug;
67: 
68: 
69: 	FVector LastHitLocation;
70: 
71: 
72: 	FVector LastHitNormal;
73: };

================
File: Source/WitchPT/Public/AbilitySystem/GameplayAbilities/GA_QuickBarSlots.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTGameplayAbility.h"
 5: #include "GA_QuickBarSlots.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UGA_QuickBarSlots : public UWitchPTGameplayAbility
12: {
13: 	GENERATED_BODY()
14: 	UGA_QuickBarSlots();
15: public:
16: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/Tasks/AbilityTask.h"
 5: #include "Engine/CollisionProfile.h"
 6: #include "InteractionOption.h"
 7: #include "AbilityTask_WaitForInteractable.generated.h"
 8: 
 9: 
10: 
11: 
12: class AActor;
13: class IInteractableTarget;
14: class UObject;
15: class UWorld;
16: struct FCollisionQueryParams;
17: struct FHitResult;
18: struct FInteractionQuery;
19: template <typename InterfaceType> class TScriptInterface;
20: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FInteractableObjectsChangedEvent, const TArray<FInteractionOption>&, InteractableOptions);
21: 
22: UCLASS(Abstract)
23: class UAbilityTask_WaitForInteractable : public UAbilityTask
24: {
25: 	GENERATED_UCLASS_BODY()
26: 
27: public:
28: 	UPROPERTY(BlueprintAssignable)
29: 	FInteractableObjectsChangedEvent InteractableObjectsChanged;
30: 
31: protected:
32: 
33: 	static void LineTrace(FHitResult& OutHitResult, const UWorld* World, const FVector& Start, const FVector& End, ECollisionChannel CollisionChannel, const FCollisionQueryParams Params);
34: 
35: 	void AimWithPlayerController(const AActor* InSourceActor, FCollisionQueryParams Params, const FVector& TraceStart, float MaxRange, FVector& OutTraceEnd, bool bIgnorePitch = false) const;
36: 
37: 	static bool ClipCameraRayToAbilityRange(FVector CameraLocation, FVector CameraDirection, FVector AbilityCenter, float AbilityRange, FVector& ClippedPosition);
38: 
39: 	void UpdateInteractableOptions(const FInteractionQuery& InteractQuery, const TArray<TScriptInterface<IInteractableTarget>>& InteractableTargets);
40: 
41: 	ECollisionChannel TraceProfile;
42: 
43: 
44: 	bool bTraceAffectsAimPitch = true;
45: 
46: 	TArray<FInteractionOption> CurrentOptions;
47: 
48: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/AT_WaitForInteractable_SLT.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "InteractionQuery.h"
 5: #include "AbilitySystem/Interaction/AbilityTask_WaitForInteractable.h"
 6: #include "AT_WaitForInteractable_SLT.generated.h"
 7: struct FCollisionProfileName;
 8: 
 9: class UGameplayAbility;
10: class UObject;
11: struct FFrame;
12: 
13: 
14: 
15: UCLASS()
16: class WITCHPT_API UAT_WaitForInteractable_SLT : public UAbilityTask_WaitForInteractable
17: {
18: 	GENERATED_UCLASS_BODY()
19: 
20: 	virtual void Activate() override;
21: 
22: 
23: 	UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
24: 	static UAT_WaitForInteractable_SLT* WaitForInteractableTargets_SingleLineTrace(UGameplayAbility* OwningAbility, FInteractionQuery InteractionQuery, ECollisionChannel TraceProfile, FGameplayAbilityTargetingLocationInfo StartLocation, float InteractionScanRange = 100, float InteractionScanRate = 0.100, bool bShowDebug = false);
25: 
26: private:
27: 
28: 	virtual void OnDestroy(bool AbilityEnded) override;
29: 
30: 	void PerformTrace();
31: 
32: 	UPROPERTY()
33: 	FInteractionQuery InteractionQuery;
34: 
35: 	UPROPERTY()
36: 	FGameplayAbilityTargetingLocationInfo StartLocation;
37: 
38: 	float InteractionScanRange = 100;
39: 	float InteractionScanRate = 0.100;
40: 	bool bShowDebug = false;
41: 
42: 	FTimerHandle TimerHandle;
43: 
44: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "WitchPTAbilitySystemComponent.generated.h"
 6: 
 7: DECLARE_MULTICAST_DELEGATE_OneParam(FEffectAssetTags,const FGameplayTagContainer& )
 8: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 9: class WITCHPT_API UWitchPTAbilitySystemComponent : public UAbilitySystemComponent
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 	void GrantStartupAbilities(const TArray<TSubclassOf<UGameplayAbility>>& AbilitiesToGrant);
15: 
16: 	void AbilityInputTagPressed(const FGameplayTag& InputTag);
17: 	void AbilityInputTagHeld(const FGameplayTag& InputTag);
18: 	void AbilityInputTagReleased(const FGameplayTag& InputTag);
19: 	void AbilityActorInfoHaveBeenSet();
20: 
21: 	FEffectAssetTags OnEffectAssetTags;
22: 
23: 	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);
24: 
25: 	bool bCharacterAbilitiesGiven = false;
26: 	bool bStartupEffectsApplied = false;
27: 
28: 	TArray<FGameplayAbilitySpecHandle> GrantedAbilities;
29: 
30: 
31: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
32: 	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;
33: 
34: 
35: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
36: 	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;
37: 
38: 
39: 
40: 	UPROPERTY(VisibleAnywhere, Category = "Ability System")
41: 	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
42: 
43: protected:
44: 	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
45: 	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;
46: 	UFUNCTION(Client, Reliable)
47: 	void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
48: 
49: };

================
File: Source/WitchPT/Public/AbilitySystem/WitchPTAbilitySystemLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTAbilitySystemLibrary.generated.h"
 6: 
 7: class IMechanicsInterface;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTAbilitySystemLibrary : public UBlueprintFunctionLibrary
13: {
14: 	GENERATED_BODY()
15: 	UFUNCTION(BlueprintPure, Category = "Ability|Mechanics", meta = (DisplayName = "Get Mechanics Interface", DeterminesOutputType = "IMechanicsInterface"))
16: 	static TScriptInterface<IMechanicsInterface> GetMechanicsInterface(AActor* Actor);
17: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_Stackable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryFragment_Stackable.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTInventoryFragment_Stackable : public UWitchPTInventoryItemFragment
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	int32 GetMaxStackSize() const { return MaxStackSize; }
17: 	int32 GetStackCount() const { return StackCount; }
18: 	void SetStackCount(int32 Count) { StackCount = Count; }
19: 
20: private:
21: 
22: 	UPROPERTY(EditAnywhere, Category = "Inventory")
23: 	int32 MaxStackSize{1};
24: 
25: 	UPROPERTY(EditAnywhere, Category = "Inventory")
26: 	int32 StackCount{1};
27: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryFragment_UIDetails.generated.h"
 7: 
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryFragment_UIDetails : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	FText Title;
18: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
19: 	FText Description;
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
21: 	TSubclassOf<UUserWidget> IconWidget;
22: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
23: 	FGameplayTag TierTag;
24: 
25: 
26: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryItemFragment_EquippableItem.generated.h"
 6: 
 7: class UWitchPTEquipmentDefinition;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryItemFragment_EquippableItem : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: public:
16: 	UPROPERTY(EditAnywhere, Category=Equipment)
17: 	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;
18: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryItemFragment_IngredientCraftingProperties.generated.h"
 7: 
 8: USTRUCT(BlueprintType)
 9: struct FBaseIngredientData
10: {
11: 	GENERATED_BODY()
12: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
13: 	FGameplayTag BaseLiquidTypeTag;
14: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
15: 	int32 DefaultChargesProvided;
16: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
17: 	float StabilityModifier;
18: };
19: 
20: USTRUCT(BlueprintType)
21: struct FPrincipalIngredientData
22: {
23: 	GENERATED_BODY()
24: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
25: 	FGameplayTag PrincipalEssenceTag;
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
27: 	float BasePotency;
28: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
29: 	float BaseDuration;
30: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
31: 	bool bIsRitualEssence;
32: };
33: 
34: USTRUCT(BlueprintType)
35: struct FModifierIngredientData
36: {
37: 	GENERATED_BODY()
38: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
39: 	FGameplayTagContainer ModifierEffectTags;
40: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
41: 	float PotencyModificationValue;
42: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
43: 	float DurationModificationValue;
44: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
45: 	FGameplayTag GrantedPropertyTag;
46: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
47: 	FGameplayTag AddedEffectTag;
48: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
49: 	float StrengthOfModifier;
50: 
51: };
52: UCLASS()
53: class WITCHPT_API UWitchPTInventoryItemFragment_IngredientCraftingProperties : public UWitchPTInventoryItemFragment
54: {
55: 	GENERATED_BODY()
56: public:
57: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
58: 	FGameplayTag SlotUsageTag;
59: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
60: 	FGameplayTag TierTag;
61: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
62: 	FGameplayTag CategoryTag;
63: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
64: 	FBaseIngredientData BaseIngredientData;
65: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
66: 	FPrincipalIngredientData PrincipalIngredientData;
67: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
68: 	FModifierIngredientData ModifierIngredientData;
69: 
70: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
71: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5: #include "WitchPTInventoryItemFragment_WorldDetails.generated.h"
 6: 
 7: 
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTInventoryItemFragment_WorldDetails : public UWitchPTInventoryItemFragment
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
19: 	UStaticMesh* WorldStaticMesh;
20: 
21: 
22: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
23: 	UMaterialInterface* WorldMaterial;
24: 
25: 
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
27: 	FVector WorldScale = FVector(1.0f, 1.0f, 1.0f);
28: 
29: 
30: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "World Representation")
31: 	FName CollisionProfileName = "Item";
32: 
33: 
34: 	UFUNCTION(BlueprintPure, Category = "World Details")
35: 	bool HasValidWorldMesh() const;
36: 
37: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
38: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "WitchPTInventoryFunctionLibrary.generated.h"
 6: 
 7: class UWitchPTInventoryItemDefinition;
 8: class UWitchPTInventoryItemFragment;
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API UWitchPTInventoryFunctionLibrary : public UBlueprintFunctionLibrary
14: {
15: 	GENERATED_BODY()
16: 	UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
17: 	static const UWitchPTInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass);
18: };

================
File: Source/WitchPT/Public/Item/PositionInterface.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Interface.h"
 5: #include "PositionInterface.generated.h"
 6: 
 7: class ARitualAltar;
 8: 
 9: UINTERFACE(MinimalAPI)
10: class UPositionInterface : public UInterface
11: {
12: 	GENERATED_BODY()
13: };
14: 
15: 
16: 
17: 
18: class WITCHPT_API IPositionInterface
19: {
20: 	GENERATED_BODY()
21: 
22: 
23: public:
24: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
25: 	ARitualAltar* GetRitualAltarActor() const;
26: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Position|Query")
27: 	bool IsOccupied();
28: };

================
File: Source/WitchPT/Public/Subsystems/UIManagerSubsystem.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Subsystems/LocalPlayerSubsystem.h"
 5: #include "UI/Widgets/WitchPTUserWidget.h"
 6: #include "UIManagerSubsystem.generated.h"
 7: 
 8: 
 9: 
10: 
11: 
12: class UWitchPTUILayer;
13: struct FGameplayTag;
14: class UWitchPTPrimaryLayout;
15: class AWitchPTHUD;
16: 
17: UCLASS()
18: class WITCHPT_API UUIManagerSubsystem : public ULocalPlayerSubsystem
19: {
20: 	GENERATED_BODY()
21: public:
22: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
23: 	AWitchPTHUD* GetWitchPTHUD();
24: 
25: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
26: 	bool RegisterLayout(FGameplayTag LayoutTag, UWitchPTUILayer* InLayer);
27: 
28: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
29: 	bool UnRegisterLayout(FGameplayTag LayerTag);
30: 
31: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
32: 	UUserWidget* PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass);
33: 
34: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
35: 	void PopContentFromLayer(FGameplayTag LayerTag);
36: 
37: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
38: 	void ClearAllLayers();
39: 
40: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
41: 	void ClearLayerExcept(FGameplayTag LayerTag);
42: 
43: 	UFUNCTION(BlueprintCallable, Category = "UI Manager")
44: 	void ClearLayer(FGameplayTag LayerTag);
45: private:
46: 
47: 	UWitchPTUserWidget* GetPrimaryLayout();
48: 
49: };

================
File: Source/WitchPT/Public/Systems/GameplayTagStack.cpp
================
  1: #include "Systems/GameplayTagStack.h"
  2: 
  3: #include "UObject/Stack.h"
  4: 
  5: #include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayTagStack)
  6: 
  7: 
  8: 
  9: 
 10: FString FGameplayTagStack::GetDebugString() const
 11: {
 12: 	return FString::Printf(TEXT("%sx%d"), *Tag.ToString(), StackCount);
 13: }
 14: 
 15: 
 16: 
 17: 
 18: void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
 19: {
 20: 	if (!Tag.IsValid())
 21: 	{
 22: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
 23: 		return;
 24: 	}
 25: 
 26: 	if (StackCount > 0)
 27: 	{
 28: 		for (FGameplayTagStack& Stack : Stacks)
 29: 		{
 30: 			if (Stack.Tag == Tag)
 31: 			{
 32: 				const int32 NewCount = Stack.StackCount + StackCount;
 33: 				Stack.StackCount = NewCount;
 34: 				TagToCountMap[Tag] = NewCount;
 35: 				MarkItemDirty(Stack);
 36: 				return;
 37: 			}
 38: 		}
 39: 
 40: 		FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
 41: 		MarkItemDirty(NewStack);
 42: 		TagToCountMap.Add(Tag, StackCount);
 43: 	}
 44: }
 45: 
 46: void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
 47: {
 48: 	if (!Tag.IsValid())
 49: 	{
 50: 		FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
 51: 		return;
 52: 	}
 53: 
 54: 
 55: 	if (StackCount > 0)
 56: 	{
 57: 		for (auto It = Stacks.CreateIterator(); It; ++It)
 58: 		{
 59: 			FGameplayTagStack& Stack = *It;
 60: 			if (Stack.Tag == Tag)
 61: 			{
 62: 				if (Stack.StackCount <= StackCount)
 63: 				{
 64: 					It.RemoveCurrent();
 65: 					TagToCountMap.Remove(Tag);
 66: 					MarkArrayDirty();
 67: 				}
 68: 				else
 69: 				{
 70: 					const int32 NewCount = Stack.StackCount - StackCount;
 71: 					Stack.StackCount = NewCount;
 72: 					TagToCountMap[Tag] = NewCount;
 73: 					MarkItemDirty(Stack);
 74: 				}
 75: 				return;
 76: 			}
 77: 		}
 78: 	}
 79: }
 80: 
 81: void FGameplayTagStackContainer::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 82: {
 83: 	for (int32 Index : RemovedIndices)
 84: 	{
 85: 		const FGameplayTag Tag = Stacks[Index].Tag;
 86: 		TagToCountMap.Remove(Tag);
 87: 	}
 88: }
 89: 
 90: void FGameplayTagStackContainer::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 91: {
 92: 	for (int32 Index : AddedIndices)
 93: 	{
 94: 		const FGameplayTagStack& Stack = Stacks[Index];
 95: 		TagToCountMap.Add(Stack.Tag, Stack.StackCount);
 96: 	}
 97: }
 98: 
 99: void FGameplayTagStackContainer::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
100: {
101: 	for (int32 Index : ChangedIndices)
102: 	{
103: 		const FGameplayTagStack& Stack = Stacks[Index];
104: 		TagToCountMap[Stack.Tag] = Stack.StackCount;
105: 	}
106: }

================
File: Source/WitchPT/Public/Systems/GameplayTagStack.h
================
 1: #pragma once
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Net/Serialization/FastArraySerializer.h"
 5: 
 6: #include "GameplayTagStack.generated.h"
 7: 
 8: struct FGameplayTagStackContainer;
 9: struct FNetDeltaSerializeInfo;
10: 
11: 
12: 
13: 
14: USTRUCT(BlueprintType)
15: struct FGameplayTagStack : public FFastArraySerializerItem
16: {
17: 	GENERATED_BODY()
18: 
19: 	FGameplayTagStack()
20: 	{}
21: 
22: 	FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
23: 		: Tag(InTag)
24: 		, StackCount(InStackCount)
25: 	{
26: 	}
27: 
28: 	FString GetDebugString() const;
29: 
30: private:
31: 	friend FGameplayTagStackContainer;
32: 
33: 	UPROPERTY()
34: 	FGameplayTag Tag;
35: 
36: 	UPROPERTY()
37: 	int32 StackCount = 0;
38: };
39: 
40: 
41: USTRUCT(BlueprintType)
42: struct FGameplayTagStackContainer : public FFastArraySerializer
43: {
44: 	GENERATED_BODY()
45: 
46: 	FGameplayTagStackContainer()
47: 
48: 	{
49: 	}
50: 
51: public:
52: 
53: 	void AddStack(FGameplayTag Tag, int32 StackCount);
54: 
55: 
56: 	void RemoveStack(FGameplayTag Tag, int32 StackCount);
57: 
58: 
59: 	int32 GetStackCount(FGameplayTag Tag) const
60: 	{
61: 		return TagToCountMap.FindRef(Tag);
62: 	}
63: 
64: 
65: 	bool ContainsTag(FGameplayTag Tag) const
66: 	{
67: 		return TagToCountMap.Contains(Tag);
68: 	}
69: 
70: 
71: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
72: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
73: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
74: 
75: 
76: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
77: 	{
78: 		return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
79: 	}
80: 
81: private:
82: 
83: 	UPROPERTY()
84: 	TArray<FGameplayTagStack> Stacks;
85: 
86: 
87: 	TMap<FGameplayTag, int32> TagToCountMap;
88: };
89: 
90: template<>
91: struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
92: {
93: 	enum
94: 	{
95: 		WithNetDeltaSerializer = true,
96: 	};
97: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/OverlayWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "WitchPTWidgetController.h"
 6: #include "OverlayWidgetController.generated.h"
 7: class UWitchPTUserWidget;
 8: 
 9: USTRUCT()
10: struct FUIWidgetRow: public FTableRowBase
11: {
12: 	GENERATED_BODY()
13: 
14: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
15: 	FGameplayTag MessageGameplayTag = FGameplayTag();
16: 
17: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
18: 	FText Message = FText();
19: 
20: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
21: 	TSubclassOf<UWitchPTUserWidget> MessageWidget;
22: 
23: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
24: 	UTexture2D* Image = nullptr;
25: 
26: };
27: 
28: 
29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewHealth);
30: 
31: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnMessageWidgetRowSignature, FUIWidgetRow, Row);
32: 
33: UCLASS(BlueprintType, Blueprintable)
34: class WITCHPT_API UOverlayWidgetController : public UWitchPTWidgetController
35: {
36: 	GENERATED_BODY()
37: public:
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 	void OnAssetTagReceivedFromGE(const FGameplayTagContainer& TagContainer) const;
48: 	virtual void BroadcastInitialValues() override;
49: 
50: 	virtual void BindCallbacksToDependencies() override;
51: 
52: 
53: 
54: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
55: 	FOnAttributeChangedSignature OnHealthChanged;
56: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
57: 	FOnAttributeChangedSignature OnMaxHealthChanged;
58: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
59: 	FOnAttributeChangedSignature OnStaminaChanged;
60: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
61: 	FOnAttributeChangedSignature OnMaxStaminaChanged;
62: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
63: 	FOnAttributeChangedSignature OnAgeChanged;
64: 	UPROPERTY(BlueprintAssignable, Category="GAS|Attributes")
65: 	FOnAttributeChangedSignature OnMaxAgeChanged;
66: 
67: 	UPROPERTY(BlueprintAssignable, Category="Widget Data")
68: 	FOnMessageWidgetRowSignature OnMessageWidgetRow;
69: protected:
70: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Widget Data")
71: 	TObjectPtr<UDataTable> MessageWidgetDataTable;
72: 
73: 	template<typename T>
74: T* GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag);
75: };
76: 
77: template <typename T>
78: T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag& GameplayTag)
79: {
80: 	return  DataTable->FindRow<T>(GameplayTag.GetTagName(), TEXT(""));
81: 
82: }

================
File: Source/WitchPT/Public/UI/WidgetControllers/WitchPTWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "WitchPTWidgetController.generated.h"
 6: 
 7: class UAbilitySystemComponent;
 8: class UAttributeSet;
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: USTRUCT(BlueprintType)
24: struct FWidgetControllerParams
25: {
26: 	GENERATED_BODY()
27: 	FWidgetControllerParams() {};
28: 	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
29: 	:
30: 	PlayerController(PC),
31: 	PlayerState(PS),
32: 	AbilitySystemComponent(ASC),
33: 	AttributeSet(AS)
34: 	{}
35: 
36: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
37: 	TObjectPtr<APlayerController> PlayerController = nullptr;
38: 
39: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
40: 	TObjectPtr<APlayerState> PlayerState = nullptr;
41: 
42: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
43: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;
44: 
45: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
46: 	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
47: 
48: };
49: UCLASS()
50: class WITCHPT_API UWitchPTWidgetController : public UObject
51: {
52: 	GENERATED_BODY()
53: public:
54: 	UFUNCTION(BlueprintCallable)
55: 	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
56: 
57: 	UFUNCTION(BlueprintCallable)
58: 	virtual void BroadcastInitialValues();
59: 	virtual void BindCallbacksToDependencies();
60: protected:
61: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
62: 	TObjectPtr<APlayerController> PlayerController;
63: 
64: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
65: 	TObjectPtr<APlayerState> PlayerState;
66: 
67: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
68: 	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
69: 
70: 	UPROPERTY(BlueprintReadOnly, Category= "WidgetController")
71: 	TObjectPtr<UAttributeSet> AttributeSet;
72: };

================
File: Source/WitchPT/Public/UI/Widgets/Layer/WitchPTUILayer.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "WitchPTUILayer.generated.h"
 6: 
 7: class UBorder;
 8: 
 9: 
10: 
11: UCLASS()
12: class WITCHPT_API UWitchPTUILayer : public UWitchPTUserWidget
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UFUNCTION(Blueprintable, Category= "UI Layer")
19: 	UUserWidget* PushContent(TSoftClassPtr<UUserWidget> WidgetClass);
20: 
21: 	UFUNCTION(BlueprintCallable, Category= "UI Layer")
22: 	void PopContent();
23: 
24: 	UFUNCTION(BlueprintPure, Category= "UI Layer")
25: 	UUserWidget* GetTopScreen() const;
26: 	UFUNCTION(BlueprintCallable, Category= "UI Layer")
27: 	FText GetStackListNames();
28: 	UFUNCTION(BlueprintCallable, Category= "UI Layer")
29: 	void ClearStack();
30: 
31: protected:
32: 	UPROPERTY(meta = (BindWidget))
33: 	TObjectPtr<UBorder> Border;
34: private:
35: 	UPROPERTY()
36: 	TArray<TObjectPtr<UUserWidget>> Stack;
37: 	UPROPERTY()
38: 	TObjectPtr<UUserWidget> TopWidget = nullptr;
39: 	UPROPERTY()
40: 	TObjectPtr<UUserWidget> PushedWidget = nullptr;
41: 
42: 
43: 	void CollapseTop();
44: 	void ShowTop();
45: 
46: 
47: 
48: 
49: };

================
File: Source/WitchPT/Public/UI/Widgets/PointerWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "PointerWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UPointerWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 
16: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
17: 	void ShowPickupMessage(const FString& Message);
18: 
19: 	UFUNCTION(BlueprintImplementableEvent, Category = "Inventory")
20: 	void HidePickupMessage();
21: };

================
File: Source/WitchPT/Public/UI/Widgets/QuickBarUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTUserWidget.h"
 5: #include "QuickBarUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UQuickBarUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: };

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentInstance.cpp
================
 1: #include "Equipment/WitchPTEquipmentInstance.h"
 2: 
 3: #include "Equipment/WitchPTEquipmentDefinition.h"
 4: #include "GameFramework/Character.h"
 5: 
 6: UWitchPTEquipmentInstance::UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer)
 7: {
 8: }
 9: 
10: UWorld* UWitchPTEquipmentInstance::GetWorld() const
11: {
12: 	if (const APawn* OwningPawn = GetPawn())
13: 	{
14: 		return OwningPawn->GetWorld();
15: 	}
16: 	return nullptr;
17: }
18: 
19: void UWitchPTEquipmentInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
20: {
21: 	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);
22: 	DOREPLIFETIME(ThisClass, Instigator);
23: }
24: 
25: void UWitchPTEquipmentInstance::SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn)
26: {
27: 	if (APawn* OwningPawn = GetPawn())
28: 	{
29: 		USceneComponent* AttachTarget = OwningPawn->GetRootComponent();
30: 		if (ACharacter* Char = Cast<ACharacter>(OwningPawn))
31: 		{
32: 			AttachTarget = Char->GetMesh();
33: 		}
34: 
35: 		for (const FWitchPTEquipmentActorToSpawn& SpawnInfo : ActorsToSpawn)
36: 		{
37: 			AActor* NewActor = GetWorld()->SpawnActorDeferred<AActor>(SpawnInfo.ActorToSpawn, FTransform::Identity, OwningPawn);
38: 			NewActor->FinishSpawning(FTransform::Identity,  true);
39: 			NewActor->SetActorRelativeTransform(SpawnInfo.AttachTransform);
40: 			NewActor->AttachToComponent(AttachTarget, FAttachmentTransformRules::KeepRelativeTransform, SpawnInfo.AttachSocket);
41: 
42: 			SpawnedActors.Add(NewActor);
43: 		}
44: 	}
45: }
46: 
47: void UWitchPTEquipmentInstance::DestroyEquipmentActors()
48: {
49: 	for (AActor* Actor : SpawnedActors)
50: 	{
51: 		if (Actor)
52: 		{
53: 			Actor->Destroy();
54: 		}
55: 	}
56: }
57: 
58: void UWitchPTEquipmentInstance::OnEquipped()
59: {
60: 	UE_LOG(LogTemp, Warning, TEXT("✅ EQUIPPED: %s"), *GetClass()->GetName());
61: 	K2_OnEquipped();
62: }
63: 
64: void UWitchPTEquipmentInstance::OnUnequipped()
65: {
66: 	UE_LOG(LogTemp, Warning, TEXT("❌ UNEQUIPPED: %s"), *GetClass()->GetName());
67: 	K2_OnUnequipped();
68: }
69: 
70: APawn* UWitchPTEquipmentInstance::GetPawn() const
71: {
72: 	return Cast<APawn>(GetOuter());
73: }
74: 
75: void UWitchPTEquipmentInstance::OnRep_Instigator()
76: {
77: }

================
File: Source/WitchPT/Private/Inventory/InventoryFunctionLibrary.cpp
================
 1: #include "Inventory/InventoryFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/QuickBarWidgetController.h"
 7: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 8: 
 9: UInventoryWidgetController* UInventoryFunctionLibrary::SetInventoryWidgetController(const UObject* WorldContextObject)
10: {
11: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
12: 	{
13: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
14: 		{
15: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
16: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
17: 			UAttributeSet* AS = PS->GetAttributeSet();
18: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
19: 
20: 			return WitchPTHUD->SetInventoryWidgetController(WCParams);
21: 		}
22: 	}
23: 	return nullptr;
24: }
25: 
26: UQuickBarWidgetController* UInventoryFunctionLibrary::SetQuickBarWidgetController(const UObject* WorldContextObject)
27: {
28: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
29: 	{
30: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
31: 		{
32: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
33: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
34: 			UAttributeSet* AS = PS->GetAttributeSet();
35: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
36: 
37: 			return WitchPTHUD->SetQuickBarWidgetController(WCParams);
38: 		}
39: 	}
40: 	return nullptr;
41: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryFunctionLibrary.cpp
================
 1: #include "Inventory/WitchPTInventoryFunctionLibrary.h"
 2: 
 3: #include "Inventory/WitchPTInventoryItemDefinition.h"
 4: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 5: 
 6: const UWitchPTInventoryItemFragment* UWitchPTInventoryFunctionLibrary::FindItemDefinitionFragment(
 7: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass)
 8: {
 9: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
10: 	{
11: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
12: 	}
13: 	return nullptr;
14: }

================
File: Source/WitchPT/Private/Item/CauldronPosition.cpp
================
  1: #include "Item/CauldronPosition.h"
  2: #include "AbilitySystemComponent.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/CauldronAltar.h"
  5: #include "Kismet/GameplayStatics.h"
  6: 
  7: ACauldronPosition::ACauldronPosition()
  8: {
  9: 
 10:     bIsOccupied = false;
 11:     OccupyingCharacter = nullptr;
 12: }
 13: 
 14: void ACauldronPosition::BeginPlay()
 15: {
 16:     Super::BeginPlay();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 
 23: }
 24: 
 25: void ACauldronPosition::FindCauldronAltar()
 26: {
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: 
 38: 
 39: 
 40: 
 41: 
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: }
 56: 
 57: void ACauldronPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 58: {
 59:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 
138: 
139: 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: 
177: 
178: 
179: 
180: 
181: }
182: 
183: void ACauldronPosition::HandleInteraction(ACharacter* InteractingCharacter)
184: {
185:     Super::HandleInteraction(InteractingCharacter);
186: 
187:     if (!InteractingCharacter || !CauldronAltar)
188:     {
189:         return;
190:     }
191: 
192: 
193: 
194: }

================
File: Source/WitchPT/Private/Item/Ingredient/IngredientBase.cpp
================
 1: #include "Item/Ingredient/IngredientBase.h"
 2: 
 3: 
 4: 
 5: AIngredientBase::AIngredientBase()
 6: {
 7: 
 8: }
 9: 
10: void AIngredientBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
11: 	FInteractionOptionBuilder& OptionBuilder)
12: {
13: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
14: }
15: 
16: FItemManifest AIngredientBase::GetPickupInventory() const
17: {
18: 	return StaticInventory;
19: }

================
File: Source/WitchPT/Private/Item/Potion/PotionBase.cpp
================
 1: #include "Item/Potion/PotionBase.h"
 2: 
 3: 
 4: 
 5: APotionBase::APotionBase()
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: 
10: 	InteractionAbilityClass = TSoftClassPtr<UGameplayAbility>(FSoftObjectPath(TEXT("/Game/Blueprints/AbilitySystem/GameplayAbilities/Interact/GA_Interact_Collect.GA_Interact_Collect_C")));
11: }
12: 
13: void APotionBase::GatherInteractionOptions(const FInteractionQuery& InteractQuery,
14: 	FInteractionOptionBuilder& OptionBuilder)
15: {
16: 
17: 	if (!LoadedInteractionAbility && !InteractionAbilityClass.IsNull())
18: 	{
19: 		LoadedInteractionAbility = InteractionAbilityClass.LoadSynchronous();
20: 	}
21: 
22: 
23: 	if (LoadedInteractionAbility)
24: 	{
25: 		Option.InteractionAbilityToGrant = LoadedInteractionAbility;
26: 		Option.Text = FText::FromString(TEXT("Pick up Potion"));
27: 
28: 	}
29: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
30: }
31: 
32: FItemManifest APotionBase::GetPickupInventory() const
33: {
34: 	return StaticInventory;
35: }

================
File: Source/WitchPT/Private/UI/Widgets/Inventory/InventoryUserWidget.cpp
================
1: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
2: 
3: FReply UInventoryUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
4: {
5: 
6: 	return FReply::Handled();
7: }

================
File: Source/WitchPT/Private/UI/Widgets/Inventory/RitualUserWidget.cpp
================
 1: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 2: #include "Item/RitualAltar.h"
 3: #include "Components/Widget.h"
 4: 
 5: URitualUserWidget::URitualUserWidget(const FObjectInitializer& ObjectInitializer)
 6:     : Super(ObjectInitializer)
 7:     , bIsActiveForRitual(false)
 8:     , CurrentRitualAltar(nullptr)
 9: {
10: 
11: }
12: 
13: void URitualUserWidget::NativeOnInitialized()
14: {
15:     Super::NativeOnInitialized();
16: 
17: 
18:     ResetWidgetState();
19: }
20: 
21: void URitualUserWidget::NativeDestruct()
22: {
23: 
24:     HideFromRitual();
25: 
26:     Super::NativeDestruct();
27: }
28: 
29: void URitualUserWidget::ShowForRitual(ARitualAltar* Altar)
30: {
31:     if (!Altar)
32:     {
33:         UE_LOG(LogTemp, Warning, TEXT("[RitualUserWidget] ShowForRitual called with null altar"));
34:         return;
35:     }
36: 
37: 
38:     if (bIsActiveForRitual && CurrentRitualAltar != Altar)
39:     {
40:         ResetWidgetState();
41:     }
42: 
43: 
44:     CurrentRitualAltar = Altar;
45:     bIsActiveForRitual = true;
46: 
47: 
48:     OnShownForRitual(Altar);
49: 
50:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Shown for ritual altar"));
51: }
52: 
53: void URitualUserWidget::HideFromRitual()
54: {
55:     if (!bIsActiveForRitual)
56:     {
57:         return;
58:     }
59: 
60: 
61:     bIsActiveForRitual = false;
62:     ARitualAltar* PreviousAltar = CurrentRitualAltar;
63:     CurrentRitualAltar = nullptr;
64: 
65: 
66:     OnHiddenFromRitual();
67: 
68: 
69:     ResetWidgetState();
70: 
71:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Hidden from ritual"));
72: }
73: 
74: void URitualUserWidget::ResetWidgetState()
75: {
76: 
77: 
78: 
79: 
80: 
81: 
82:     UE_LOG(LogTemp, Log, TEXT("[RitualUserWidget] Widget state reset"));
83: }

================
File: Source/WitchPT/Private/UI/Widgets/WitchPTPrimaryLayout.cpp
================
  1: #include "UI/Widgets/WitchPTPrimaryLayout.h"
  2: 
  3: #include "FWitchPTGameplayTags.h"
  4: #include "Subsystems/UIManagerSubsystem.h"
  5: #include "UI/Widgets/Layer/WitchPTUILayer.h"
  6: 
  7: UWitchPTPrimaryLayout::UWitchPTPrimaryLayout()
  8: {
  9: 
 10: 
 11: }
 12: 
 13: void UWitchPTPrimaryLayout::NativeConstruct()
 14: {
 15: 	Super::NativeConstruct();
 16: 
 17: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 18: 	if (GameLayer)
 19: 	{
 20: 		RegisterLayer(WitchPtGameplayTags.UI_Layer_Game, GameLayer);
 21: 	}
 22: 	if (GameMenuLayer)
 23: 	{
 24: 		RegisterLayer(WitchPtGameplayTags.UI_Layer_GameMenu, GameMenuLayer);
 25: 	}
 26: 	if (MenuLayer)
 27: 	{
 28: 		RegisterLayer(WitchPtGameplayTags.UI_Layer_Menu, MenuLayer);
 29: 	}
 30: 	if (ModalLayer)
 31: 	{
 32: 		RegisterLayer(WitchPtGameplayTags.UI_Layer_Modal, ModalLayer);
 33: 	}
 34: 	PushInitialScreens();
 35: 
 36: }
 37: 
 38: bool UWitchPTPrimaryLayout::RegisterLayer(FGameplayTag LayerTag, UWitchPTUILayer* InLayer)
 39: {
 40: 
 41: 	if (InLayer != nullptr && LayerTag.IsValid())
 42: 	{
 43: 		if (Layers.Contains(LayerTag))
 44: 		{
 45: 			UE_LOG(LogTemp, Warning, TEXT("Layer %s is already registered!"), *LayerTag.ToString());
 46: 			return false;
 47: 		}
 48: 
 49: 
 50: 		Layers.Add(LayerTag, InLayer);
 51: 		UE_LOG(LogTemp, Log, TEXT("Registered layer: %s"), *LayerTag.ToString());
 52: 
 53: 		return true;
 54: 	}
 55: 	return false;
 56: }
 57: 
 58: bool UWitchPTPrimaryLayout::UnRegisterLayer(FGameplayTag LayerTag)
 59: {
 60: 	if (LayerTag.IsValid())
 61: 	{
 62: 		if (UWitchPTUILayer* LayerToRemove = Layers.FindRef(LayerTag))
 63: 		{
 64: 			LayerToRemove->RemoveFromParent();
 65: 			Layers.Remove(LayerTag);
 66: 			UE_LOG(LogTemp, Log, TEXT("Unregistered layer: %s"), *LayerTag.ToString());
 67: 			return true;
 68: 		}
 69: 	}
 70: 	return false;
 71: }
 72: UUserWidget* UWitchPTPrimaryLayout::PushContentToLayer(FGameplayTag LayerTag,
 73: 	TSoftClassPtr<UUserWidget> WidgetClass)
 74: {
 75: 	if (LayerTag.IsValid() && WidgetClass.IsValid())
 76: 	{
 77: 		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
 78: 		{
 79: 			UUserWidget* PushedWidget = Layer->PushContent(WidgetClass);
 80: 			return PushedWidget;
 81: 		}
 82: 	}
 83: 	return nullptr;
 84: }
 85: 
 86: void UWitchPTPrimaryLayout::PopContentFromLayer(FGameplayTag LayerTag)
 87: {
 88: 	if (LayerTag.IsValid())
 89: 	{
 90: 		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
 91: 		{
 92: 			Layer->PopContent();
 93: 		}
 94: 
 95: 	}
 96: }
 97: 
 98: void UWitchPTPrimaryLayout::ClearAllLayers()
 99: {
100: 	for (auto& LayerPair : Layers)
101: 	{
102: 		if (LayerPair.Value)
103: 		{
104: 			LayerPair.Value->ClearStack();
105: 		}
106: 	}
107: }
108: 
109: void UWitchPTPrimaryLayout::ClearAllLayersExcept(FGameplayTag LayerTag)
110: {
111: 	if (LayerTag.IsValid())
112: 	{
113: 		for (auto& LayerPair : Layers)
114: 		{
115: 			if (LayerPair.Key != LayerTag && LayerPair.Value)
116: 			{
117: 				LayerPair.Value->ClearStack();
118: 			}
119: 		}
120: 	}
121: }
122: 
123: void UWitchPTPrimaryLayout::ClearLayer(FGameplayTag LayerTag)
124: {
125: 	if (LayerTag.IsValid())
126: 	{
127: 		if (UWitchPTUILayer* Layer = Layers.FindRef(LayerTag))
128: 		{
129: 			Layer->ClearStack();
130: 		}
131: 
132: 	}
133: }
134: 
135: void UWitchPTPrimaryLayout::PushInitialScreens()
136: {
137: 	if (InitialScreens.Num())
138: 	{
139: 		for (auto & ScreenPair : InitialScreens)
140: 		{
141: 			if (ScreenPair.Value.IsValid())
142: 			{
143: 				if (ULocalPlayer* LocalPlayer = GetOwningLocalPlayer())
144: 				{
145: 					if (UUIManagerSubsystem* UIManagerSubsystem = LocalPlayer->GetSubsystem<UUIManagerSubsystem>())
146: 					{
147: 						UIManagerSubsystem->PushContentToLayer(ScreenPair.Key, ScreenPair.Value);
148: 					}
149: 				}
150: 			}
151: 		}
152: 	}
153: }

================
File: Source/WitchPT/Private/UI/Widgets/WitchPTUserWidget.cpp
================
 1: #include "UI/Widgets/WitchPTUserWidget.h"
 2: 
 3: void UWitchPTUserWidget::NativeConstruct()
 4: {
 5: 	Super::NativeConstruct();
 6: 
 7: }
 8: 
 9: void UWitchPTUserWidget::SetWidgetController(UObject* InWidgetController)
10: {
11: 	WidgetController = InWidgetController;
12: 	OnWidgetControllerSet();
13: }

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentDefinition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "WitchPTEquipmentDefinition.generated.h"
 6: 
 7: class UWitchPTEquipmentInstance;
 8: class UGameplayAbility;
 9: 
10: USTRUCT()
11: struct FWitchPTEquipmentActorToSpawn
12: {
13: 	GENERATED_BODY()
14: 	FWitchPTEquipmentActorToSpawn() {};
15: 
16: 	UPROPERTY(EditAnywhere, Category=Equipment)
17: 	TSubclassOf<AActor> ActorToSpawn;
18: 
19: 	UPROPERTY(EditAnywhere, Category=Equipment)
20: 	FName AttachSocket;
21: 
22: 	UPROPERTY(EditAnywhere, Category=Equipment)
23: 	FTransform AttachTransform;
24: };
25: 
26: 
27: 
28: 
29: 
30: 
31: UCLASS(Blueprintable, BlueprintType)
32: class WITCHPT_API UWitchPTEquipmentDefinition : public UObject
33: {
34: 	GENERATED_BODY()
35: public:
36: 	UWitchPTEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
37: 
38: 
39: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
40: 	TSubclassOf<UWitchPTEquipmentInstance> InstanceType;
41: 
42: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
43: 	TArray<TSubclassOf<UGameplayAbility>> AbilitiesToGrant;
44: 
45: 	UPROPERTY(EditDefaultsOnly, Category=Equipment)
46: 	TArray<FWitchPTEquipmentActorToSpawn> ActorsToSpawn;
47: };

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentInstance.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/Object.h"
 5: #include "Net/UnrealNetwork.h"
 6: #include "WitchPTEquipmentInstance.generated.h"
 7: 
 8: struct FWitchPTEquipmentActorToSpawn;
 9: 
10: 
11: 
12: UCLASS(BlueprintType, Blueprintable)
13: class WITCHPT_API UWitchPTEquipmentInstance : public UObject
14: {
15: 	GENERATED_BODY()
16: public:
17: 	UWitchPTEquipmentInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
18: 
19: 
20: 
21: 
22: 	virtual bool IsSupportedForNetworking() const override { return true; }
23: 	virtual UWorld* GetWorld() const override final;
24: 	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
25: 
26: 	virtual void SpawnEquipmentActors(const TArray<FWitchPTEquipmentActorToSpawn>& ActorsToSpawn);
27: 	virtual void DestroyEquipmentActors();
28: 	virtual void OnEquipped();
29: 	virtual void OnUnequipped();
30: 
31: 	UFUNCTION(BlueprintPure, Category=Equipment)
32: 	APawn* GetPawn() const;
33: 	UFUNCTION(BlueprintPure, Category=Equipment)
34: 	UObject* GetInstigator() const { return Instigator; }
35: 
36: 	void SetInstigator(UObject* InInstigator) { Instigator = InInstigator; }
37: protected:
38: 	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
39: 	void K2_OnEquipped();
40: 
41: 	UFUNCTION(BlueprintImplementableEvent, Category=Equipment)
42: 	void K2_OnUnequipped();
43: 
44: private:
45: 	UPROPERTY(ReplicatedUsing=OnRep_Instigator)
46: 	TObjectPtr<UObject> Instigator;
47: 
48: 	UPROPERTY(Replicated)
49: 	TArray<TObjectPtr<AActor>> SpawnedActors;
50: 
51: 
52: 	UFUNCTION()
53: 	void OnRep_Instigator();
54: 
55: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "WitchPTInventoryItemFragment_PotionProperties.generated.h"
 7: 
 8: class UGameplayAbility;
 9: 
10: 
11: 
12: 
13: UCLASS()
14: class WITCHPT_API UWitchPTInventoryItemFragment_PotionProperties : public UWitchPTInventoryItemFragment
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
21: 	UGameplayAbility* CollectAbility;
22: 
23: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
24: 	FGameplayTag PotionEssenceTag;
25: 
26: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
27: 	FGameplayTag BaseLiquidTypeTag;
28: 
29: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
30: 	float FinalPotency = 0.0f;
31: 
32: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
33: 	float FinalDuration = 0.0f;
34: 
35: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
36: 	int32 FinalCharges = 1;
37: 
38: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Properties")
39: 	FGameplayTag PotionTierTag;
40: 
41: 
42: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
43: 	FGameplayTagContainer GrantedEffectTags;
44: 
45: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Effects")
46: 	FGameplayTagContainer GrantedPropertyTags;
47: 
48: 
49: 	UFUNCTION(BlueprintPure, Category = "Potion Properties")
50: 	bool IsValidPotion() const;
51: 
52: 	UFUNCTION(BlueprintPure, Category = "Potion Properties")
53: 	FString GetPotionDescription() const;
54: 
55: 
56: 	UFUNCTION(BlueprintCallable, Category = "Potion Properties")
57: 	void SetPotionProperties(const FGameplayTag& InPotionEssence,
58: 							const FGameplayTag& InBaseLiquidType,
59: 							float InPotency,
60: 							float InDuration,
61: 							int32 InCharges,
62: 							const FGameplayTag& InTierTag,
63: 							const FGameplayTagContainer& InEffectTags,
64: 							const FGameplayTagContainer& InPropertyTags);
65: 
66: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const override;
67: };

================
File: Source/WitchPT/Public/Inventory/InventoryFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "UI/WidgetControllers/QuickBarWidgetController.h"
 6: #include "InventoryFunctionLibrary.generated.h"
 7: 
 8: class UInventoryWidgetController;
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
14: {
15: 	GENERATED_BODY()
16: public:
17: 	UFUNCTION(BlueprintPure, Category="Inventory")
18: 	static UInventoryWidgetController* SetInventoryWidgetController(const UObject* WorldContextObject);
19: 
20: 	UFUNCTION(BlueprintPure, Category="QuickBar")
21: 	static UQuickBarWidgetController* SetQuickBarWidgetController(const UObject* WorldContextObject);
22: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemDefinition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UObject/NoExportTypes.h"
 5: #include "Kismet/BlueprintFunctionLibrary.h"
 6: #include "WitchPTInventoryItemDefinition.generated.h"
 7: 
 8: class UWitchPTInventoryItemFragment;
 9: struct FFrame;
10: 
11: 
12: 
13: UCLASS(Blueprintable, Const, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemDefinition : public UObject
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
19: 
20: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
21: 	TArray<TObjectPtr<UWitchPTInventoryItemFragment>> Fragments;
22: 
23: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
24: };

================
File: Source/WitchPT/Public/Item/Ingredient/IngredientBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Collectable.h"
 5: #include "Item/Item.h"
 6: #include "IngredientBase.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API AIngredientBase : public AItem, public ICollectable
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	AIngredientBase();
16: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
17: 	virtual FItemManifest GetPickupInventory() const override;
18: 
19: protected:
20: 
21: 	UPROPERTY(EditAnywhere)
22: 	FItemManifest StaticInventory;
23: 
24: };

================
File: Source/WitchPT/Public/Item/Potion/PotionBase.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Inventory/Collectable.h"
 5: #include "Item/Item.h"
 6: #include "PotionBase.generated.h"
 7: 
 8: UCLASS()
 9: class WITCHPT_API APotionBase : public AItem, public ICollectable
10: {
11: 	GENERATED_BODY()
12: 
13: public:
14: 
15: 	APotionBase();
16: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
17: 	virtual FItemManifest GetPickupInventory() const override;
18: 
19: 	UPROPERTY(EditAnywhere)
20: 	FItemManifest StaticInventory;
21: protected:
22: 
23: 
24: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Interaction")
25: 	TSoftClassPtr<UGameplayAbility> InteractionAbilityClass;
26: 
27: 
28: 	UPROPERTY(Transient)
29: 	TSubclassOf<UGameplayAbility> LoadedInteractionAbility;
30: 
31: };

================
File: Source/WitchPT/Public/Subsystems/WidgetCommunicatorSubsystem.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Subsystems/LocalPlayerSubsystem.h"
 5: #include "WidgetCommunicatorSubsystem.generated.h"
 6: 
 7: class UWitchPTInventoryItemInstance;
 8: 
 9: 
10: 
11: 
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemDraggedDelegate, const UWitchPTInventoryItemInstance*, ItemInstance);
13: UCLASS(BlueprintType)
14: class WITCHPT_API UWidgetCommunicatorSubsystem : public ULocalPlayerSubsystem
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UFUNCTION(BlueprintCallable, Category= "WidgetCommunicator")
19: 	void OnItemDragged(UWitchPTInventoryItemInstance* ItemInstance);
20: 
21: 
22: 	UPROPERTY(BlueprintAssignable)
23: 	FOnItemDraggedDelegate OnItemDraggedDelegate;
24: };

================
File: Source/WitchPT/Public/UI/Widgets/CauldronUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTUserWidget.h"
 5: #include "CauldronUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UCauldronUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: private:
15: 	virtual void NativeConstruct() override;
16: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
17: };

================
File: Source/WitchPT/Public/UI/Widgets/Inventory/InventoryUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "InventoryUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UInventoryUserWidget : public UWitchPTUserWidget
12: {
13: 	GENERATED_BODY()
14: 	virtual FReply NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent) override;
15: 
16: };

================
File: Source/WitchPT/Public/UI/Widgets/Inventory/RitualUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "UI/Widgets/WitchPTUserWidget.h"
 5: #include "RitualUserWidget.generated.h"
 6: 
 7: class ARitualAltar;
 8: 
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API URitualUserWidget : public UWitchPTUserWidget
14: {
15: 	GENERATED_BODY()
16: 
17: public:
18: 	URitualUserWidget(const FObjectInitializer& ObjectInitializer);
19: 
20: 
21: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
22: 	void ShowForRitual(ARitualAltar* Altar);
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
25: 	void HideFromRitual();
26: 
27: 
28: 	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
29: 	bool IsActiveForRitual() const { return bIsActiveForRitual; }
30: 
31: 
32: 	UFUNCTION(BlueprintPure, Category = "Ritual Widget")
33: 	ARitualAltar* GetCurrentRitualAltar() const { return CurrentRitualAltar; }
34: 
35: protected:
36: 
37: 	virtual void NativeOnInitialized() override;
38: 	virtual void NativeDestruct() override;
39: 
40: 
41: 	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
42: 	void OnShownForRitual(ARitualAltar* Altar);
43: 
44: 
45: 	UFUNCTION(BlueprintImplementableEvent, Category = "Ritual Widget")
46: 	void OnHiddenFromRitual();
47: 
48: 
49: 	UFUNCTION(BlueprintCallable, Category = "Ritual Widget")
50: 	void ResetWidgetState();
51: 
52: private:
53: 
54: 	UPROPERTY()
55: 	bool bIsActiveForRitual = false;
56: 
57: 
58: 	UPROPERTY()
59: 	TObjectPtr<ARitualAltar> CurrentRitualAltar;
60: };

================
File: Source/WitchPT/Public/UI/Widgets/WitchPTPrimaryLayout.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTUserWidget.h"
 5: #include "GameplayTagContainer.h"
 6: #include "WitchPTPrimaryLayout.generated.h"
 7: 
 8: class UWitchPTUILayer;
 9: 
10: 
11: 
12: UCLASS()
13: class WITCHPT_API UWitchPTPrimaryLayout : public UWitchPTUserWidget
14: {
15: 	GENERATED_BODY()
16: public:
17: 	UWitchPTPrimaryLayout();
18: 	virtual void NativeConstruct() override;
19: 
20: 	UPROPERTY(EditDefaultsOnly, Category = "Layout")
21: 	TMap<FGameplayTag, TSoftClassPtr<UUserWidget>> InitialScreens;
22: 
23: 
24: 	UFUNCTION(BlueprintCallable, Category = "UI")
25: 	bool RegisterLayer(FGameplayTag LayerTag, UWitchPTUILayer* InLayer);
26: 
27: 	UFUNCTION(BlueprintCallable, Category = "UI")
28: 	bool UnRegisterLayer(FGameplayTag LayerTag);
29: 
30: 	UFUNCTION(BlueprintCallable, Category = "UI")
31: 	UUserWidget* PushContentToLayer(FGameplayTag LayerTag, TSoftClassPtr<UUserWidget> WidgetClass);
32: 
33: 	UFUNCTION(BlueprintCallable, Category = "UI")
34: 	void PopContentFromLayer(FGameplayTag LayerTag);
35: 
36: 	UFUNCTION(BlueprintCallable, Category = "UI")
37: 	void ClearAllLayers();
38: 	UFUNCTION(BlueprintCallable, Category = "UI")
39: 	void ClearAllLayersExcept(FGameplayTag LayerTag);
40: 	UFUNCTION(BlueprintCallable, Category = "UI")
41: 	void ClearLayer(FGameplayTag LayerTag);
42: 	UFUNCTION(BlueprintCallable, Category = "UI")
43: 	void PushInitialScreens();
44: 
45: 
46: private:
47: 
48: 	UPROPERTY(VisibleAnywhere)
49: 	TMap<FGameplayTag, TObjectPtr<UWitchPTUILayer>> Layers;
50: 
51: 
52: 	UPROPERTY(meta = (BindWidget))
53: 	TObjectPtr<UWitchPTUILayer> GameLayer;
54: 
55: 
56: 	UPROPERTY(meta = (BindWidget))
57: 	TObjectPtr<UWitchPTUILayer> GameMenuLayer;
58: 
59: 
60: 	UPROPERTY(meta = (BindWidget))
61: 	TObjectPtr<UWitchPTUILayer> MenuLayer;
62: 
63: 
64: 	UPROPERTY(meta = (BindWidget))
65: 	TObjectPtr<UWitchPTUILayer> ModalLayer;
66: };

================
File: Source/WitchPT/Public/UI/Widgets/WitchPTUserWidget.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Blueprint/UserWidget.h"
 5: #include "WitchPTUserWidget.generated.h"
 6: 
 7: 
 8: 
 9: 
10: UCLASS()
11: class WITCHPT_API UWitchPTUserWidget : public UUserWidget
12: {
13: 	GENERATED_BODY()
14: public:
15: 	virtual void NativeConstruct() override;
16: 	UFUNCTION(BlueprintCallable)
17: 	void SetWidgetController(UObject* InWidgetController);
18: 	UPROPERTY(BlueprintReadOnly)
19: 	TObjectPtr<UObject> WidgetController;
20: 
21: 	UFUNCTION(BlueprintImplementableEvent)
22: 	void OnWidgetControllerSet();
23: };

================
File: Source/WitchPT/Private/Equipment/WitchPTEquipmentManagerComponent.cpp
================
  1: #include "Equipment/WitchPTEquipmentManagerComponent.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystemGlobals.h"
  5: #include "Engine/ActorChannel.h"
  6: #include "Equipment/WitchPTEquipmentDefinition.h"
  7: #include "Equipment/WitchPTEquipmentInstance.h"
  8: #include "Inventory/WitchPTInventoryItemDefinition.h"
  9: #include "Inventory/WitchPTInventoryItemInstance.h"
 10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
 11: #include "Net/UnrealNetwork.h"
 12: 
 13: 
 14: void FWitchPTEquipmentList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 15: {
 16: 	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
 17: 	if (!IsValid(EquipmentManager)) return;
 18: 
 19: 	for (int32 Index : RemovedIndices)
 20: 	{
 21: 		const FWitchPTEquipmentEntry& Entry = Entries[Index];
 22: 		if (Entry.Instance != nullptr)
 23: 		{
 24: 			Entry.Instance->OnUnequipped();
 25: 			EquipmentManager->OnItemUnequipped.Broadcast(Entry.Instance);
 26: 		}
 27: 	}
 28: }
 29: 
 30: void FWitchPTEquipmentList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 31: {
 32: 	UWitchPTEquipmentManagerComponent* EquipmentManager = Cast<UWitchPTEquipmentManagerComponent>(OwnerComponent);
 33: 	if (!IsValid(EquipmentManager)) return;
 34: 
 35: 	for (int32 Index : AddedIndices)
 36: 	{
 37: 		const FWitchPTEquipmentEntry& Entry = Entries[Index];
 38: 		if (Entry.Instance != nullptr)
 39: 		{
 40: 			Entry.Instance->OnEquipped();
 41: 			EquipmentManager->OnItemEquipped.Broadcast(Entry.Instance);
 42: 		}
 43: 	}
 44: }
 45: 
 46: void FWitchPTEquipmentList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 47: {
 48: }
 49: 
 50: UWitchPTEquipmentInstance* FWitchPTEquipmentList::AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
 51: {
 52: 	UWitchPTEquipmentInstance* Result = nullptr;
 53: 
 54: 	check(EquipmentDefinition != nullptr);
 55: 	check(OwnerComponent);
 56: 	check(OwnerComponent->GetOwner()->HasAuthority());
 57: 
 58: 	const UWitchPTEquipmentDefinition* EquipmentCDO = GetDefault<UWitchPTEquipmentDefinition>(EquipmentDefinition);
 59: 
 60: 	TSubclassOf<UWitchPTEquipmentInstance> InstanceType = EquipmentCDO->InstanceType;
 61: 	if (InstanceType == nullptr)
 62: 	{
 63: 		InstanceType = UWitchPTEquipmentInstance::StaticClass();
 64: 	}
 65: 
 66: 	FWitchPTEquipmentEntry& NewEntry = Entries.AddDefaulted_GetRef();
 67: 	NewEntry.EquipmentDefinition = EquipmentDefinition;
 68: 	NewEntry.Instance = NewObject<UWitchPTEquipmentInstance>(OwnerComponent->GetOwner(), InstanceType);
 69: 	Result = NewEntry.Instance;
 70: 
 71: 
 72: 	if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
 73: 	{
 74: 		for (TSubclassOf<UGameplayAbility> AbilityClass : EquipmentCDO->AbilitiesToGrant)
 75: 		{
 76: 			if (AbilityClass)
 77: 			{
 78: 				FGameplayAbilitySpec AbilitySpec(AbilityClass, 1, INDEX_NONE, Result);
 79: 				FGameplayAbilitySpecHandle Handle = ASC->GiveAbility(AbilitySpec);
 80: 				NewEntry.AbilityHandles.GrantedHandles.Add(Handle);
 81: 				UE_LOG(LogTemp, Warning, TEXT("🎯 Granted ability: %s"), *AbilityClass->GetName());
 82: 			}
 83: 		}
 84: 	}
 85: 	Result->SpawnEquipmentActors(EquipmentCDO->ActorsToSpawn);
 86: 
 87: 	MarkItemDirty(NewEntry);
 88: 	return Result;
 89: }
 90: 
 91: void FWitchPTEquipmentList::RemoveEntry(UWitchPTEquipmentInstance* Instance)
 92: {
 93: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
 94: 	{
 95: 		FWitchPTEquipmentEntry& Entry = *EntryIt;
 96: 		if (Entry.Instance == Instance)
 97: 		{
 98: 
 99: 			if (UAbilitySystemComponent* ASC = GetAbilitySystemComponent())
100: 			{
101: 				for (const FGameplayAbilitySpecHandle& Handle : Entry.AbilityHandles.GrantedHandles)
102: 				{
103: 					if (Handle.IsValid())
104: 					{
105: 						ASC->ClearAbility(Handle);
106: 						UE_LOG(LogTemp, Warning, TEXT("🚫 Removed ability"));
107: 					}
108: 				}
109: 			}
110: 
111: 			EntryIt.RemoveCurrent();
112: 			Instance->DestroyEquipmentActors();
113: 			MarkArrayDirty();
114: 		}
115: 	}
116: }
117: 
118: UAbilitySystemComponent* FWitchPTEquipmentList::GetAbilitySystemComponent() const
119: {
120: 	check(OwnerComponent);
121: 	AActor* OwningActor = OwnerComponent->GetOwner();
122: 	return Cast<UAbilitySystemComponent>(UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor));
123: }
124: 
125: 
126: 
127: UWitchPTEquipmentManagerComponent::UWitchPTEquipmentManagerComponent()
128: 	: EquipmentList(this)
129: {
130: 	SetIsReplicatedByDefault(true);
131: 	bReplicateUsingRegisteredSubObjectList = true;
132: }
133: 
134: void UWitchPTEquipmentManagerComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
135: {
136: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
137: 	DOREPLIFETIME(ThisClass, EquipmentList);
138: }
139: 
140: bool UWitchPTEquipmentManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
141: 	FReplicationFlags* RepFlags)
142: {
143: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
144: 
145: 	for (FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
146: 	{
147: 		UWitchPTEquipmentInstance* Instance = Entry.Instance;
148: 		if (IsValid(Instance))
149: 		{
150: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
151: 		}
152: 	}
153: 
154: 	return WroteSomething;
155: }
156: 
157: void UWitchPTEquipmentManagerComponent::InitializeComponent()
158: {
159: 	Super::InitializeComponent();
160: }
161: 
162: void UWitchPTEquipmentManagerComponent::UninitializeComponent()
163: {
164: 	TArray<UWitchPTEquipmentInstance*> AllEquipmentInstances;
165: 
166: 
167: 	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
168: 	{
169: 		AllEquipmentInstances.Add(Entry.Instance);
170: 	}
171: 
172: 	for (UWitchPTEquipmentInstance* EquipInstance : AllEquipmentInstances)
173: 	{
174: 		UnequipItem(EquipInstance);
175: 	}
176: 
177: 	Super::UninitializeComponent();
178: }
179: 
180: void UWitchPTEquipmentManagerComponent::ReadyForReplication()
181: {
182: 	Super::ReadyForReplication();
183: 
184: 	if (IsUsingRegisteredSubObjectList())
185: 	{
186: 		for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
187: 		{
188: 			UWitchPTEquipmentInstance* Instance = Entry.Instance;
189: 			if (IsValid(Instance))
190: 			{
191: 				AddReplicatedSubObject(Instance);
192: 			}
193: 		}
194: 	}
195: }
196: 
197: void UWitchPTEquipmentManagerComponent::EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
198: {
199: 	if (GetOwner()->GetLocalRole() < ROLE_Authority)
200: 	{
201: 		Server_EquipItem(EquipmentDefinition);
202: 	}
203: 	else
204: 	{
205: 		if (EquipmentDefinition != nullptr)
206: 		{
207: 			UWitchPTEquipmentInstance* NewInstance = EquipmentList.AddEntry(EquipmentDefinition);
208: 			if (NewInstance != nullptr)
209: 			{
210: 				NewInstance->OnEquipped();
211: 				OnItemEquipped.Broadcast(NewInstance);
212: 
213: 				if (IsUsingRegisteredSubObjectList())
214: 				{
215: 					AddReplicatedSubObject(NewInstance);
216: 				}
217: 			}
218: 		}
219: 	}
220: }
221: 
222: void UWitchPTEquipmentManagerComponent::Server_EquipItem_Implementation(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition)
223: {
224: 	EquipItem(EquipmentDefinition);
225: }
226: 
227: void UWitchPTEquipmentManagerComponent::UnequipItem(UWitchPTEquipmentInstance* ItemInstance)
228: {
229: 	if (GetOwner()->GetLocalRole() < ROLE_Authority)
230: 	{
231: 		Server_UnequipItem(ItemInstance);
232: 	}
233: 	else
234: 	{
235: 		if (ItemInstance != nullptr)
236: 		{
237: 			if (IsUsingRegisteredSubObjectList())
238: 			{
239: 				RemoveReplicatedSubObject(ItemInstance);
240: 			}
241: 
242: 			ItemInstance->OnUnequipped();
243: 			OnItemUnequipped.Broadcast(ItemInstance);
244: 			EquipmentList.RemoveEntry(ItemInstance);
245: 		}
246: 	}
247: }
248: 
249: void UWitchPTEquipmentManagerComponent::Server_UnequipItem_Implementation(UWitchPTEquipmentInstance* ItemInstance)
250: {
251: 	UnequipItem(ItemInstance);
252: }
253: 
254: 
255: bool UWitchPTEquipmentManagerComponent::IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const
256: {
257: 	return FindEquipmentByInventoryItem(InventoryItem) != nullptr;
258: }
259: 
260: UWitchPTEquipmentInstance* UWitchPTEquipmentManagerComponent::FindEquipmentByInventoryItem(
261: 	UWitchPTInventoryItemInstance* InventoryItem) const
262: {
263: 	for (const FWitchPTEquipmentEntry& Entry : EquipmentList.Entries)
264: 	{
265: 		if (UWitchPTEquipmentInstance* Equipment = Entry.Instance)
266: 		{
267: 			if (Equipment && Equipment->GetInstigator() == InventoryItem)
268: 			{
269: 				return Equipment;
270: 			}
271: 		}
272: 	}
273: 	return nullptr;
274: }
275: 
276: void UWitchPTEquipmentManagerComponent::PrintEquippedItems()
277: {
278: 	UE_LOG(LogTemp, Warning, TEXT("📦 EQUIPPED ITEMS: %d total"), EquipmentList.Entries.Num());
279: 	for (int32 i = 0; i < EquipmentList.Entries.Num(); i++)
280: 	{
281: 		const FWitchPTEquipmentEntry& Entry = EquipmentList.Entries[i];
282: 		UE_LOG(LogTemp, Warning, TEXT("  [%d]: %s"), i, Entry.Instance ? *Entry.Instance->GetClass()->GetName() : TEXT("NULL"));
283: 	}
284: }
285: 
286: UAbilitySystemComponent* UWitchPTEquipmentManagerComponent::GetAbilitySystemComponent() const
287: {
288: 	if (APawn* OwnerPawn = Cast<APawn>(GetOwner()))
289: 	{
290: 		return UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwnerPawn);
291: 	}
292: 	return nullptr;
293: }

================
File: Source/WitchPT/Private/Inventory/Collectable.cpp
================
 1: #include "Inventory/Collectable.h"
 2: 
 3: #include "Inventory/WitchPTInventoryManagerComponent.h"
 4: 
 5: UCollectableStatics::UCollectableStatics()
 6: : Super(FObjectInitializer::Get())
 7: {
 8: }
 9: 
10: TScriptInterface<ICollectable> UCollectableStatics::GetFirstPickupableFromActor(AActor* Actor)
11: {
12: 	TScriptInterface<ICollectable> PickupableActor(Actor);
13: 	if (PickupableActor)
14: 	{
15: 		return PickupableActor;
16: 	}
17: 
18: 	TArray<UActorComponent*> PickupableComponents = Actor ? Actor->GetComponentsByInterface(UCollectable::StaticClass()) : TArray<UActorComponent*>();
19: 	if (PickupableComponents.Num() > 0)
20: 	{
21: 		return TScriptInterface<ICollectable>(PickupableComponents[0]);
22: 	}
23: 
24: 	return TScriptInterface<ICollectable>();
25: }
26: 
27: 
28: void UCollectableStatics::AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent,
29: 	TScriptInterface<ICollectable> Collectable)
30: {
31: 	if (InventoryComponent && Collectable)
32: 	{
33: 		const FItemManifest& ItemManifest = Collectable->GetPickupInventory();
34: 		InventoryComponent->TryAddItemDefinition(ItemManifest.ItemDef);
35: 	}
36: }

================
File: Source/WitchPT/Private/Inventory/FastArray/FastArrayList.cpp
================
  1: #pragma once
  2: 
  3: #include "Inventory/FastArray/FastArrayList.h"
  4: 
  5: #include "CoreMinimal.h"
  6: #include "Inventory/WitchPTInventoryItemDefinition.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  8: #include "Inventory/WitchPTInventoryItemInstance.h"
  9: #include "Inventory/WitchPTInventoryManagerComponent.h"
 10: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 11: 
 12: 
 13: class FLifetimeProperty;
 14: struct FReplicationFlags;
 15: 
 16: 
 17: FString FWitchPTInventoryEntry::GetDebugString() const
 18: {
 19: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
 20: 	if (Instance != nullptr)
 21: 	{
 22: 		ItemDef = Instance->GetItemDef();
 23: 	}
 24: 
 25: 	return FString::Printf(TEXT("%s ( x %s)"), *GetNameSafe(Instance),  *GetNameSafe(ItemDef));
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: void FWitchPTInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
 33: {
 34: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 35: 	if (!IsValid(IMC)) return;
 36: 	for (int32 Index : RemovedIndices)
 37: 	{
 38: 		IMC->OnItemRemoved.Broadcast(Entries[Index].Instance);
 39: 	}
 40: }
 41: 
 42: void FWitchPTInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
 43: {
 44: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 45: 	if (!IsValid(IMC)) return;
 46: 	for (int32 Index : AddedIndices)
 47: 	{
 48: 		IMC->OnItemAdded.Broadcast(Entries[Index].Instance);
 49: 	}
 50: }
 51: 
 52: void FWitchPTInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
 53: {
 54: 	UWitchPTInventoryManagerComponent* IMC = Cast<UWitchPTInventoryManagerComponent>(OwnerComponent);
 55: 	if (!IsValid(IMC)) return;
 56: 
 57: 	for (int32 Index : ChangedIndices)
 58: 	{
 59: 		IMC->OnItemStackChanged.Broadcast(Entries[Index].Instance);
 60: 	}
 61: }
 62: 
 63: UWitchPTInventoryItemInstance* FWitchPTInventoryList::AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 64: {
 65: 	UWitchPTInventoryItemInstance* Result = nullptr;
 66: 
 67: 	check(ItemDef != nullptr);
 68: 	check(OwnerComponent);
 69: 
 70: 	AActor* OwningActor = OwnerComponent->GetOwner();
 71: 	check(OwningActor->HasAuthority());
 72: 
 73: 
 74: 	FWitchPTInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
 75: 	NewEntry.Instance = NewObject<UWitchPTInventoryItemInstance>(OwnerComponent->GetOwner());
 76: 	NewEntry.Instance->SetItemDef(ItemDef);
 77: 
 78: 	const UWitchPTInventoryItemFragment* BaseFragment = NewEntry.Instance->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 79: 	const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 80: 	if (IsValid(StackableFragment))
 81: 	{
 82: 		NewEntry.Instance->SetTotalStackCount(StackableFragment->GetStackCount());
 83: 	}
 84: 	for (UWitchPTInventoryItemFragment* Fragment : GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->Fragments)
 85: 	{
 86: 		if (Fragment != nullptr)
 87: 		{
 88: 			Fragment->OnInstanceCreated(NewEntry.Instance);
 89: 		}
 90: 	}
 91: 
 92: 	Result = NewEntry.Instance;
 93: 
 94: 
 95: 	MarkItemDirty(NewEntry);
 96: 
 97: 	return Result;
 98: }
 99: 
100: void FWitchPTInventoryList::AddEntry(UWitchPTInventoryItemInstance* Instance)
101: {
102: 	unimplemented();
103: }
104: 
105: void FWitchPTInventoryList::RemoveEntry(UWitchPTInventoryItemInstance* Instance)
106: {
107: 	for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
108: 	{
109: 		FWitchPTInventoryEntry& Entry = *EntryIt;
110: 		if (Entry.Instance == Instance)
111: 		{
112: 			EntryIt.RemoveCurrent();
113: 			MarkArrayDirty();
114: 		}
115: 	}
116: }
117: TArray<UWitchPTInventoryItemInstance*> FWitchPTInventoryList::GetAllItems() const
118: {
119: 	TArray<UWitchPTInventoryItemInstance*> Results;
120: 	Results.Reserve(Entries.Num());
121: 	for (const FWitchPTInventoryEntry& Entry : Entries)
122: 	{
123: 		if (Entry.Instance != nullptr)
124: 		{
125: 			Results.Add(Entry.Instance);
126: 		}
127: 	}
128: 	return Results;
129: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemDefinition.cpp
================
 1: #include "Inventory/WitchPTInventoryItemDefinition.h"
 2: 
 3: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 4: 
 5: UWitchPTInventoryItemDefinition::UWitchPTInventoryItemDefinition(const FObjectInitializer& ObjectInitializer)
 6: : Super(ObjectInitializer)
 7: 
 8: {
 9: }
10: 
11: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemDefinition::FindFragmentByClass(
12: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
13: {
14: 	if (FragmentClass != nullptr)
15: 	{
16: 		for (UWitchPTInventoryItemFragment* Fragment : Fragments)
17: 		{
18: 			if (Fragment && Fragment->IsA(FragmentClass))
19: 			{
20: 				return Fragment;
21: 			}
22: 		}
23: 	}
24: 
25: 	return nullptr;
26: }

================
File: Source/WitchPT/Private/Item/BaseInteractionPosition.cpp
================
 1: #include "Item/BaseInteractionPosition.h"
 2: #include "Net/UnrealNetwork.h"
 3: #include "Engine/ActorChannel.h"
 4: #include "AbilitySystemComponent.h"
 5: #include "Components/BoxComponent.h"
 6: #include "GameFramework/Character.h"
 7: 
 8: ABaseInteractionPosition::ABaseInteractionPosition()
 9: {
10: 
11:     PrimaryActorTick.bCanEverTick = true;
12: 
13: 
14:     bReplicates = true;
15:     bAlwaysRelevant = true;
16: }
17: 
18: void ABaseInteractionPosition::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
19: {
20:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
21: 
22: 
23:     DOREPLIFETIME(ABaseInteractionPosition, bIsOccupied);
24:     DOREPLIFETIME(ABaseInteractionPosition, OccupyingCharacter);
25:     DOREPLIFETIME(ABaseInteractionPosition, PositionTag);
26: 
27: 
28: }
29: 
30: void ABaseInteractionPosition::BeginPlay()
31: {
32:     Super::BeginPlay();
33: 
34: 
35: }
36: 
37: void ABaseInteractionPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
38: {
39: 
40:     Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
41: }
42: 
43: bool ABaseInteractionPosition::IsOccupied() const
44: {
45:     return bIsOccupied;
46: }
47: 
48: void ABaseInteractionPosition::SetOccupied(ACharacter* Character)
49: {
50:     if (GetLocalRole() != ROLE_Authority)
51:     {
52:         return;
53:     }
54: 
55:     OccupyingCharacter = Character;
56:     bIsOccupied = (Character != nullptr);
57: }
58: 
59: void ABaseInteractionPosition::SetUnoccupied()
60: {
61:     if (GetLocalRole() != ROLE_Authority)
62:     {
63:         return;
64:     }
65: 
66:     RemoveCharacterFromPosition();
67: }
68: 
69: void ABaseInteractionPosition::SetPositionTag(const FGameplayTag& NewTag)
70: {
71:     PositionTag = NewTag;
72: }
73: 
74: void ABaseInteractionPosition::OnRep_IsOccupied()
75: {
76: 
77: }
78: 
79: void ABaseInteractionPosition::OnRep_OccupyingCharacter()
80: {
81: 
82: }
83: 
84: void ABaseInteractionPosition::HandleInteraction(ACharacter* InteractingCharacter)
85: {
86: 
87:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractionPosition] %s handling interaction with %s"),
88:         *GetName(), *InteractingCharacter->GetName());
89: }
90: 
91: void ABaseInteractionPosition::RemoveCharacterFromPosition()
92: {
93:     OccupyingCharacter = nullptr;
94:     bIsOccupied = false;
95: }

================
File: Source/WitchPT/Private/UI/Widgets/CauldronUserWidget.cpp
================
 1: #include "UI/Widgets/CauldronUserWidget.h"
 2: 
 3: void UCauldronUserWidget::NativeConstruct()
 4: {
 5: 	Super::NativeConstruct();
 6: 
 7: 
 8: }
 9: 
10: FReply UCauldronUserWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
11: {
12: 	return FReply::Handled();
13: }

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/GameplayAbility_Interact.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "InteractionOption.h"
  5: #include "AbilitySystem/GameplayAbilities/WitchPTGameplayAbility.h"
  6: #include "GameplayAbility_Interact.generated.h"
  7: 
  8: class UObject;
  9: struct FFrame;
 10: struct FGameplayAbilityActorInfo;
 11: struct FGameplayEventData;
 12: 
 13: 
 14: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInteractionComplete);
 15: 
 16: 
 17: 
 18: 
 19: UCLASS(Abstract)
 20: class WITCHPT_API UGameplayAbility_Interact : public UWitchPTGameplayAbility
 21: {
 22: 	GENERATED_BODY()
 23: 	UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 24: 	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
 25: 
 26: 	UFUNCTION(BlueprintCallable)
 27: 	void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);
 28: 
 29: 
 30: 	UFUNCTION(BlueprintCallable)
 31: 	void TriggerInteraction();
 32: 
 33: 
 34: 	UFUNCTION(BlueprintCallable)
 35: 	void TriggerHoldInteraction();
 36: 
 37: 
 38: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 39: 	void OnInteractionButtonPressed();
 40: 
 41: 
 42: 	UFUNCTION(BlueprintCallable, Category = "Interaction")
 43: 	void OnInteractionButtonReleased();
 44: 
 45: 
 46: 	UFUNCTION()
 47: 	void OnHoldInteractionTimeElapsed();
 48: 
 49: 
 50:     UFUNCTION()
 51:     void CheckInteractionValidity();
 52: 
 53: 
 54:     UFUNCTION(BlueprintCallable, Category = "Interaction")
 55:     void CancelCurrentInteraction();
 56: 
 57: 
 58:     UFUNCTION()
 59:     void OnMaxInteractionTimeElapsed();
 60: 
 61: 
 62: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 63: 	FOnInteractionComplete OnInteractionComplete;
 64: 
 65: 
 66: 	UPROPERTY(BlueprintAssignable, Category = "Interaction")
 67: 	FOnInteractionComplete OnHoldInteractionComplete;
 68: 
 69: 
 70:     UPROPERTY(BlueprintAssignable, Category = "Interaction")
 71:     FOnInteractionComplete OnInteractionCancelled;
 72: 
 73: protected:
 74: 
 75: 	UPROPERTY(BlueprintReadWrite)
 76: 	TArray<FInteractionOption> CurrentOptions;
 77: 
 78: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1"))
 79: 	float InteractionScanRate = 0.1f;
 80: 
 81: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0"))
 82: 	float InteractionScanRange = 500;
 83: 
 84: 
 85: 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.1", ToolTip="Tiempo en segundos que el jugador debe mantener presionado el botón para activar una interacción mantenida"))
 86: 	float HoldInteractionTime = 1.0f;
 87: 
 88: 
 89:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="0.05", ToolTip="Tiempo en segundos entre comprobaciones de validez del objeto interactuable"))
 90:     float ValidityCheckRate = 0.1f;
 91: 
 92: 
 93:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category="Interaction", meta=(ClampMin="1.0", ToolTip="Tiempo máximo en segundos que puede durar una interacción antes de ser cancelada automáticamente"))
 94:     float MaxInteractionTime = 10.0f;
 95: 
 96: 
 97: 	FTimerHandle HoldInteractionTimerHandle;
 98: 
 99: 
100:     FTimerHandle ValidityCheckTimerHandle;
101: 
102: 
103:     FTimerHandle MaxInteractionTimeTimerHandle;
104: 
105: 
106: 	bool bIsInteractionButtonHeld = false;
107: 
108: 
109: 	float InteractionStartTime = 0.0f;
110: 
111: 
112: 	bool bHoldInteractionFired = false;
113: 
114: 
115:     TScriptInterface<IInteractableTarget> InitialInteractableTarget;
116: 
117: 	UPROPERTY(EditDefaultsOnly)
118: 	TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
119: 
120: 
121: };

================
File: Source/WitchPT/Public/AbilitySystem/Interaction/InteractionOption.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Abilities/GameplayAbility.h"
 5: #include "InteractionOption.generated.h"
 6: 
 7: class IInteractableTarget;
 8: 
 9: 
10: 
11: USTRUCT(BlueprintType)
12: struct FInteractionOption
13: {
14: 	GENERATED_BODY()
15: 
16: public:
17: 
18: 	UPROPERTY(BlueprintReadWrite)
19: 	TScriptInterface<IInteractableTarget> InteractableTarget;
20: 
21: 
22: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
23: 	FText Text;
24: 
25: 
26: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
27: 	FText SubText;
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
36: 	TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;
37: 
38: 
39: 
40: 
41: 
42: 
43: 	UPROPERTY(BlueprintReadOnly)
44: 	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;
45: 
46: 
47: 	UPROPERTY(BlueprintReadOnly)
48: 	FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;
49: 
50: 
51: 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
52: 	bool bSupportsHoldInteraction = false;
53: 
54: 
55: 	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "bSupportsHoldInteraction"))
56: 	TSubclassOf<UGameplayAbility> HoldInteractionAbilityToGrant;
57: 
58: 
59: 	UPROPERTY(BlueprintReadOnly)
60: 	FGameplayAbilitySpecHandle TargetHoldInteractionAbilityHandle;
61: 
62: 
63: 
64: 
65: 
66: 	UPROPERTY(EditAnywhere, BlueprintReadWrite)
67: 	TSoftClassPtr<UUserWidget> InteractionWidgetClass;
68: 
69: 
70: 
71: public:
72: 	FORCEINLINE bool operator==(const FInteractionOption& Other) const
73: 	{
74: 		return InteractableTarget == Other.InteractableTarget &&
75: 			InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
76: 			TargetAbilitySystem == Other.TargetAbilitySystem &&
77: 			TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
78: 			bSupportsHoldInteraction == Other.bSupportsHoldInteraction &&
79: 			HoldInteractionAbilityToGrant == Other.HoldInteractionAbilityToGrant &&
80: 			TargetHoldInteractionAbilityHandle == Other.TargetHoldInteractionAbilityHandle &&
81: 
82: 			Text.IdenticalTo(Other.Text) &&
83: 			SubText.IdenticalTo(Other.SubText);
84: 	}
85: 
86: 	FORCEINLINE bool operator!=(const FInteractionOption& Other) const
87: 	{
88: 		return !operator==(Other);
89: 	}
90: 
91: 	FORCEINLINE bool operator<(const FInteractionOption& Other) const
92: 	{
93: 		return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
94: 	}
95: };

================
File: Source/WitchPT/Public/Equipment/WitchPTEquipmentManagerComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayAbilitySpecHandle.h"
  5: #include "Components/ActorComponent.h"
  6: #include "Net/Serialization/FastArraySerializer.h"
  7: #include "WitchPTEquipmentManagerComponent.generated.h"
  8: 
  9: 
 10: class UWitchPTEquipmentManagerComponent;
 11: class UWitchPTInventoryItemInstance;
 12: class UAbilitySystemComponent;
 13: class UWitchPTEquipmentDefinition;
 14: class UWitchPTEquipmentInstance;
 15: 
 16: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemEquipped, UWitchPTEquipmentInstance*);
 17: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemUnequipped, UWitchPTEquipmentInstance*);
 18: 
 19: USTRUCT()
 20: struct FEquipmentAbilityHandles
 21: {
 22: 	GENERATED_BODY()
 23: 	TArray<FGameplayAbilitySpecHandle> GrantedHandles;
 24: };
 25: 
 26: USTRUCT(BlueprintType)
 27: struct FWitchPTEquipmentEntry: public FFastArraySerializerItem
 28: {
 29: 	GENERATED_BODY()
 30: 	FWitchPTEquipmentEntry() {};
 31: 
 32: 	UPROPERTY()
 33: 	TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition;
 34: 
 35: 	UPROPERTY()
 36: 	TObjectPtr<UWitchPTEquipmentInstance> Instance = nullptr;
 37: 
 38: 	FEquipmentAbilityHandles AbilityHandles;
 39: };
 40: 
 41: USTRUCT(BlueprintType)
 42: struct FWitchPTEquipmentList : public FFastArraySerializer
 43: {
 44: 	GENERATED_BODY()
 45: 
 46: 	FWitchPTEquipmentList() : OwnerComponent(nullptr) {}
 47: 	FWitchPTEquipmentList(UActorComponent* InOwnerComponent) : OwnerComponent(InOwnerComponent) {}
 48: 
 49: 
 50: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 51: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 52: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 53: 
 54: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
 55: 	{
 56: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTEquipmentEntry, FWitchPTEquipmentList>(Entries, DeltaParms, *this);
 57: 	}
 58: 
 59: 
 60: 
 61: 	UWitchPTEquipmentInstance* AddEntry(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
 62: 	void RemoveEntry(UWitchPTEquipmentInstance* Instance);
 63: 
 64: private:
 65: 	UAbilitySystemComponent* GetAbilitySystemComponent() const;
 66: 
 67: 	UPROPERTY()
 68: 	TArray<FWitchPTEquipmentEntry> Entries;
 69: 
 70: 	UPROPERTY(NotReplicated)
 71: 	TObjectPtr<UActorComponent> OwnerComponent;
 72: 
 73: 	friend UWitchPTEquipmentManagerComponent;
 74: };
 75: 
 76: 
 77: template<>
 78: struct TStructOpsTypeTraits<FWitchPTEquipmentList> : public TStructOpsTypeTraitsBase2<FWitchPTEquipmentList>
 79: {
 80: 	enum { WithNetDeltaSerializer = true };
 81: };
 82: 
 83: 
 84: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 85: class WITCHPT_API UWitchPTEquipmentManagerComponent : public UActorComponent
 86: {
 87: 	GENERATED_BODY()
 88: 
 89: public:
 90: 
 91: 	UWitchPTEquipmentManagerComponent();
 92: 
 93: 	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
 94: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 95: 
 96: 
 97: 	virtual void InitializeComponent() override;
 98: 	virtual void UninitializeComponent() override;
 99: 	virtual void ReadyForReplication() override;
100: 
101: 
102: 	UFUNCTION(BlueprintCallable, Category="Equipment")
103: 	void EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
104: 
105: 	UFUNCTION(BlueprintCallable, Category="Equipment")
106: 	void UnequipItem(UWitchPTEquipmentInstance* ItemInstance);
107: 
108: 	UFUNCTION(Server, Reliable)
109: 	void Server_EquipItem(TSubclassOf<UWitchPTEquipmentDefinition> EquipmentDefinition);
110: 
111: 	UFUNCTION(Server, Reliable)
112: 	void Server_UnequipItem(UWitchPTEquipmentInstance* ItemInstance);
113: 
114: 
115: 	UFUNCTION(BlueprintPure, Category="Equipment")
116: 	bool IsInventoryItemEquipped(UWitchPTInventoryItemInstance* InventoryItem) const;
117: 
118: 	UFUNCTION(BlueprintPure, Category="Equipment")
119: 	UWitchPTEquipmentInstance* FindEquipmentByInventoryItem(UWitchPTInventoryItemInstance* InventoryItem) const;
120: 
121: 
122: 	UFUNCTION(BlueprintCallable, Category="Equipment")
123: 	void PrintEquippedItems();
124: 
125: 	FOnItemEquipped OnItemEquipped;
126: 	FOnItemUnequipped OnItemUnequipped;
127: 
128: protected:
129: 	UPROPERTY(Replicated)
130: 	FWitchPTEquipmentList EquipmentList;
131: 
132: 
133: 	UPROPERTY()
134: 	TMap<TObjectPtr<UWitchPTEquipmentInstance>, FEquipmentAbilityHandles> EquipmentAbilities;
135: 
136: private:
137: 	UAbilitySystemComponent* GetAbilitySystemComponent() const;
138: 
139: 
140: };

================
File: Source/WitchPT/Public/Inventory/FastArray/FastArrayList.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Net/Serialization/FastArraySerializer.h"
  5: 
  6: #include "FastArrayList.generated.h"
  7: 
  8: class UWitchPTInventoryItemDefinition;
  9: class UWitchPTInventoryItemInstance;
 10: class UWitchPTInventoryManagerComponent;
 11: struct FWitchPTInventoryList;
 12: 
 13: 
 14: 
 15: 
 16: 
 17: 
 18: 
 19: USTRUCT(BlueprintType)
 20: struct FWitchPTInventoryEntry : public FFastArraySerializerItem
 21: {
 22: 	GENERATED_BODY()
 23: 
 24: 	FWitchPTInventoryEntry()
 25: 	{}
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 	FString GetDebugString() const;
 32: 
 33: private:
 34: 	friend FWitchPTInventoryList;
 35: 	friend UWitchPTInventoryManagerComponent;
 36: 
 37: 
 38: 	UPROPERTY()
 39: 	TObjectPtr<UWitchPTInventoryItemInstance> Instance = nullptr;
 40: 
 41: };
 42: 
 43: 
 44: 
 45: 
 46: 
 47: 
 48: 
 49: 
 50: USTRUCT(BlueprintType)
 51: struct FWitchPTInventoryList : public FFastArraySerializer
 52: {
 53: 	GENERATED_BODY()
 54: 
 55: 
 56: 	FWitchPTInventoryList()
 57: 		: OwnerComponent(nullptr)
 58: 	{
 59: 	}
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 	FWitchPTInventoryList(UActorComponent* InOwnerComponent)
 66: 		: OwnerComponent(InOwnerComponent)
 67: 	{
 68: 	}
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 75: 
 76: public:
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
 83: 
 84: 
 85: 
 86: 
 87: 
 88: 	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
 89: 
 90: 
 91: 
 92: 
 93: 
 94: 	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
 95: 
 96: 
 97: 
 98: 
 99: 
100: 
101: 	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
102: 	{
103: 		return FFastArraySerializer::FastArrayDeltaSerialize<FWitchPTInventoryEntry, FWitchPTInventoryList>(Entries, DeltaParms, *this);
104: 	}
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: 
113: 	UWitchPTInventoryItemInstance* AddEntry(TSubclassOf<UWitchPTInventoryItemDefinition> ItemClass);
114: 
115: 
116: 
117: 
118: 
119: 
120: 	void AddEntry(UWitchPTInventoryItemInstance* Instance);
121: 
122: 
123: 
124: 
125: 
126: 
127: 	void RemoveEntry(UWitchPTInventoryItemInstance* Instance);
128: 
129: private:
130: 	friend UWitchPTInventoryManagerComponent;
131: 
132: private:
133: 
134: 	UPROPERTY()
135: 	TArray<FWitchPTInventoryEntry> Entries;
136: 
137: 
138: 	UPROPERTY(NotReplicated)
139: 	TObjectPtr<UActorComponent> OwnerComponent;
140: };
141: 
142: 
143: 
144: 
145: 
146: template<>
147: struct TStructOpsTypeTraits<FWitchPTInventoryList> : public TStructOpsTypeTraitsBase2<FWitchPTInventoryList>
148: {
149: 	enum { WithNetDeltaSerializer = true };
150: };

================
File: Source/WitchPT/Public/Inventory/Fragments/WitchPTInventoryItemFragment.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Templates/SubclassOf.h"
 5: #include "WitchPTInventoryItemFragment.generated.h"
 6: 
 7: template <typename T> class TSubclassOf;
 8: 
 9: class UWitchPTInventoryItemInstance;
10: 
11: 
12: 
13: UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
14: class WITCHPT_API UWitchPTInventoryItemFragment : public UObject
15: {
16: 	GENERATED_BODY()
17: 
18: public:
19: 	virtual void OnInstanceCreated(UWitchPTInventoryItemInstance* Instance) const {}
20: 
21: };

================
File: Source/WitchPT/Public/Item/BaseInteractionPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/Item.h"
 5: #include "AbilitySystem/Interaction/InteractionOption.h"
 6: #include "GameplayTagContainer.h"
 7: #include "MechanicsInterface.h"
 8: #include "BaseInteractionPosition.generated.h"
 9: 
10: class UAbilitySystemComponent;
11: struct FGameplayAbilitySpec;
12: class AController;
13: class UGameplayAbility;
14: class UBoxComponent;
15: class ACharacter;
16: class ABaseInteractableAltar;
17: 
18: 
19: 
20: 
21: UCLASS(Abstract)
22: class WITCHPT_API ABaseInteractionPosition : public AItem
23: {
24:     GENERATED_BODY()
25: 
26: public:
27: 
28:     ABaseInteractionPosition();
29: 
30: 
31:     virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
32:     virtual void BeginPlay() override;
33: 
34: 
35: 
36:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
37: 
38: 
39: 
40: 
41:     UFUNCTION(BlueprintPure, Category = "Interaction")
42:     ACharacter* GetOccupyingCharacter() const { return OccupyingCharacter; }
43: 
44:     UFUNCTION(BlueprintPure, Category = "Interaction")
45:     FGameplayTag GetPositionTag() const { return PositionTag; }
46: 
47:     virtual bool IsOccupied() const;
48: 
49: 
50:     UFUNCTION()
51:     void SetOccupied(ACharacter* Character);
52: 
53:     UFUNCTION()
54:     void SetUnoccupied();
55: 
56:     UFUNCTION()
57:     void SetPositionTag(const FGameplayTag& NewTag);
58: 
59: protected:
60: 
61:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction")
62:     FGameplayTag PositionTag;
63: 
64: 
65:     UPROPERTY(ReplicatedUsing = OnRep_IsOccupied, BlueprintReadOnly, Category = "Interaction|State")
66:     bool bIsOccupied = false;
67: 
68: 
69:     UPROPERTY(ReplicatedUsing = OnRep_OccupyingCharacter, VisibleAnywhere, BlueprintReadOnly, Category = "Interaction|State")
70:     TObjectPtr<ACharacter> OccupyingCharacter = nullptr;
71: 
72: 
73:     UPROPERTY()
74:     TWeakObjectPtr<UAbilitySystemComponent> InteractingASC;
75: 
76:     UPROPERTY()
77:     TWeakObjectPtr<AController> InteractingController;
78: 
79: 
80:     UFUNCTION()
81:     void OnRep_IsOccupied();
82: 
83:     UFUNCTION()
84:     void OnRep_OccupyingCharacter();
85: 
86: 
87: 
88:     virtual void HandleInteraction(ACharacter* InteractingCharacter);
89: 
90: private:
91:     void RemoveCharacterFromPosition();
92: };

================
File: Source/WitchPT/Public/Item/Components/CauldronCraftComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Components/ActorComponent.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameplayTagContainer.h"
  7: #include "CauldronCraftComponent.generated.h"
  8: 
  9: class UWitchPTInventoryItemDefinition;
 10: class UWitchPTInventoryItemInstance;
 11: class ACharacter;
 12: 
 13: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 14: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature, TSubclassOf<UUserWidget>, BaseIngredientIcon);
 15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 16: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
 17: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature, UWitchPTInventoryItemInstance*, IngredientInstance);
 18: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
 19: 
 20: 
 21: USTRUCT(BlueprintType)
 22: struct FPotionResult
 23: {
 24: 	GENERATED_BODY()
 25: 
 26: 	UPROPERTY(BlueprintReadOnly)
 27: 	FGameplayTag PotionEssenceTag;
 28: 
 29: 	UPROPERTY(BlueprintReadOnly)
 30: 	FGameplayTag BaseLiquidTypeTag;
 31: 
 32: 	UPROPERTY(BlueprintReadOnly)
 33: 	float FinalPotency = 0.0f;
 34: 
 35: 	UPROPERTY(BlueprintReadOnly)
 36: 	float FinalDuration = 0.0f;
 37: 
 38: 	UPROPERTY(BlueprintReadOnly)
 39: 	int32 FinalCharges = 0;
 40: 
 41: 	UPROPERTY(BlueprintReadOnly)
 42: 	FGameplayTag PotionTierTag;
 43: 
 44: 	UPROPERTY(BlueprintReadOnly)
 45: 	FGameplayTagContainer GrantedEffectTags;
 46: 
 47: 	UPROPERTY(BlueprintReadOnly)
 48: 	FGameplayTagContainer GrantedPropertyTags;
 49: 
 50: 	UPROPERTY(BlueprintReadOnly)
 51: 	bool bIsValid = false;
 52: 
 53: 	UPROPERTY(BlueprintReadOnly)
 54: 	TSubclassOf<UWitchPTInventoryItemDefinition> ResultPotionItemDef;
 55: };
 56: 
 57: USTRUCT(BlueprintType)
 58: struct FPotionCraftingRecipe
 59: {
 60: 	GENERATED_BODY()
 61: 
 62: 	UPROPERTY(BlueprintReadOnly)
 63: 	bool bRequiresBaseIngredient = true;
 64: 
 65: 	UPROPERTY(BlueprintReadOnly)
 66: 	bool bRequiresPrincipalIngredient = true;
 67: 
 68: 	UPROPERTY(BlueprintReadOnly)
 69: 	bool bRequiresModifierIngredient = false;
 70: 
 71: 	UPROPERTY(BlueprintReadOnly)
 72: 	FGameplayTagContainer AllowedBaseLiquidTypes;
 73: 
 74: 	UPROPERTY(BlueprintReadOnly)
 75: 	FGameplayTagContainer AllowedPrincipalEssences;
 76: 
 77: 	UPROPERTY(BlueprintReadOnly)
 78: 	FGameplayTagContainer IncompatibleCombinations;
 79: };
 80: 
 81: 
 82: USTRUCT(BlueprintType)
 83: struct FExtractedBaseIngredientData
 84: {
 85: 	GENERATED_BODY()
 86: 
 87: 	UPROPERTY(BlueprintReadOnly)
 88: 	FGameplayTag BaseLiquidTypeTag;
 89: 
 90: 	UPROPERTY(BlueprintReadOnly)
 91: 	int32 DefaultChargesProvided = 0;
 92: 
 93: 	UPROPERTY(BlueprintReadOnly)
 94: 	float StabilityModifier = 1.0f;
 95: 
 96: 	UPROPERTY(BlueprintReadOnly)
 97: 	FGameplayTag TierTag;
 98: 
 99: 	UPROPERTY(BlueprintReadOnly)
100: 	bool bIsValid = false;
101: };
102: 
103: USTRUCT(BlueprintType)
104: struct FExtractedPrincipalIngredientData
105: {
106: 	GENERATED_BODY()
107: 
108: 	UPROPERTY(BlueprintReadOnly)
109: 	FGameplayTag PrincipalEssenceTag;
110: 
111: 	UPROPERTY(BlueprintReadOnly)
112: 	float BasePotency = 0.0f;
113: 
114: 	UPROPERTY(BlueprintReadOnly)
115: 	float BaseDuration = 0.0f;
116: 
117: 	UPROPERTY(BlueprintReadOnly)
118: 	bool bIsRitualEssence = false;
119: 
120: 	UPROPERTY(BlueprintReadOnly)
121: 	FGameplayTag TierTag;
122: 
123: 	UPROPERTY(BlueprintReadOnly)
124: 	bool bIsValid = false;
125: };
126: 
127: USTRUCT(BlueprintType)
128: struct FExtractedModifierIngredientData
129: {
130: 	GENERATED_BODY()
131: 
132: 	UPROPERTY(BlueprintReadOnly)
133: 	FGameplayTagContainer ModifierEffectTags;
134: 
135: 	UPROPERTY(BlueprintReadOnly)
136: 	float PotencyModificationValue = 1.0f;
137: 
138: 	UPROPERTY(BlueprintReadOnly)
139: 	float DurationModificationValue = 0.0f;
140: 
141: 	UPROPERTY(BlueprintReadOnly)
142: 	FGameplayTag GrantedPropertyTag;
143: 
144: 	UPROPERTY(BlueprintReadOnly)
145: 	FGameplayTag AddedEffectTag;
146: 
147: 	UPROPERTY(BlueprintReadOnly)
148: 	float StrengthOfModifier = 1.0f;
149: 
150: 	UPROPERTY(BlueprintReadOnly)
151: 	FGameplayTag TierTag;
152: 
153: 	UPROPERTY(BlueprintReadOnly)
154: 	bool bIsValid = false;
155: };
156: 
157: UCLASS(Blueprintable)
158: class WITCHPT_API UCauldronCraftComponent : public UActorComponent
159: {
160: 	GENERATED_BODY()
161: 
162: public:
163: 
164: 	UCauldronCraftComponent();
165: 
166: protected:
167: 
168: 	virtual void BeginPlay() override;
169: 
170: public:
171: 
172: 	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
173: 	                           FActorComponentTickFunction* ThisTickFunction) override;
174: 
175: 
176: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
177: 
178: 
179: 	UPROPERTY(VisibleAnywhere)
180: 	UWitchPTInventoryItemInstance* BaseIngredient;
181: 	UPROPERTY(VisibleAnywhere)
182: 	UWitchPTInventoryItemInstance* PrincipalIngredient;
183: 	UPROPERTY(VisibleAnywhere)
184: 	UWitchPTInventoryItemInstance* ModifierIngredient;
185: 
186: 	UPROPERTY(ReplicatedUsing = OnRep_BaseIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
187: 	TSubclassOf<UUserWidget> BaseIngredientIcon;
188: 
189: 	UPROPERTY(ReplicatedUsing = OnRep_PrincipalIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
190: 	TSubclassOf<UUserWidget> PrincipalIngredientIcon;
191: 
192: 	UPROPERTY(ReplicatedUsing = OnRep_PotentiatorIngredientIcon, Category= "Cauldron|Ingredients", VisibleAnywhere)
193: 	TSubclassOf<UUserWidget> ModifierIngredientIcon;
194: 
195: 
196: 	UPROPERTY(ReplicatedUsing = OnRep_CraftedPotion, BlueprintReadOnly, Category = "Potion Crafting")
197: 	FPotionResult CraftedPotion;
198: 
199: 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
200: 	FPotionCraftingRecipe DefaultCraftingRecipe;
201: 
202: 
203: 	FOnBaseIngredientSetSignature OnBaseIngredientSetDelegate;
204: 	FOnBaseIngredientIconSetSignature OnBaseIngredientIconSetDelegate;
205: 	FOnPrincipalIngredientSetSignature OnPrincipalIngredientSetDelegate;
206: 	FOnPrincipalIngredientIconSetSignature OnPrincipalIngredientIconSetDelegate;
207: 	FOnModifierIngredientSetSignature OnModifierIngredientSetDelegate;
208: 	FOnModifierIngredientIconSetSignature OnModifierIngredientIconSetDelegate;
209: 
210: 
211: 	void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
212: 
213: 
214: 	UFUNCTION()
215: 	void OnRep_BaseIngredientIcon();
216: 	UFUNCTION()
217: 	void OnRep_PrincipalIngredientIcon();
218: 	UFUNCTION()
219: 	void OnRep_PotentiatorIngredientIcon();
220: 	UFUNCTION()
221: 	void OnRep_CraftedPotion();
222: 
223: 
224: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
225: 	bool CanCraftPotion() const;
226: 
227: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
228: 	FPotionCraftingRecipe GetRequiredIngredients() const;
229: 
230: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting")
231: 	bool ValidateIngredientCombination() const;
232: 
233: 
234: 	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
235: 	void PrintIngredientDebugData() const;
236: 
237: 	UFUNCTION(BlueprintCallable, Category = "Debug|Potion Crafting")
238: 	void PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const;
239: 
240: 
241: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
242: 	FExtractedBaseIngredientData ExtractBaseIngredientProperties() const;
243: 
244: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
245: 	FExtractedPrincipalIngredientData ExtractPrincipalIngredientProperties() const;
246: 
247: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Data Extraction")
248: 	FExtractedModifierIngredientData ExtractModifierIngredientProperties() const;
249: 
250: 
251: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Calculation")
252: 	FPotionResult CalculatePotionProperties() const;
253: 
254: 	UFUNCTION(BlueprintPure, Category = "Potion Crafting|Calculation")
255: 	FGameplayTag CalculatePotionTier(const FExtractedBaseIngredientData& BaseData,
256: 									 const FExtractedPrincipalIngredientData& PrincipalData,
257: 									 const FExtractedModifierIngredientData& ModifierData) const;
258: 
259: 
260: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
261: 	TSubclassOf<UWitchPTInventoryItemDefinition> GeneratePotionItemDefinition(const FPotionResult& PotionData) const;
262: 
263: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|ItemDefinition")
264: 	UWitchPTInventoryItemDefinition* CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const;
265: 
266: 
267: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
268: 	bool SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const;
269: 
270: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
271: 	UWitchPTInventoryItemInstance* AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const;
272: 
273: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Spawning")
274: 	UWitchPTInventoryItemInstance* CreatePotionInstance(const FPotionResult& PotionData) const;
275: 
276: 
277: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Main", CallInEditor, meta = (DisplayName = "Craft Potion"))
278: 	FPotionResult CraftPotion(bool bAddToInventory = true, ACharacter* TargetCharacter = nullptr, const FVector& WorldSpawnLocation = FVector::ZeroVector);
279: 
280: 
281: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
282: 	bool CanPerformCrafting() const;
283: 
284: 	UFUNCTION(BlueprintCallable, Category = "Potion Crafting|Helpers")
285: 	void ClearIngredientSlots();
286: 
287: 
288: 	UFUNCTION(BlueprintCallable, Category = "Debug|Testing", CallInEditor, meta = (DisplayName = "Quick Test Craft"))
289: 	void DebugTestCrafting();
290: 
291: 
292: 	UWitchPTInventoryItemInstance* GetBaseIngredient() const;
293: 	UWitchPTInventoryItemInstance* GetPrincipalIngredient() const;
294: 	UWitchPTInventoryItemInstance* GetModifierIngredient() const;
295: 	TSubclassOf<UUserWidget> GetBaseIngredientIcon() const;
296: 	TSubclassOf<UUserWidget> GetPrincipalIngredientIcon() const;
297: 	TSubclassOf<UUserWidget> GetModifierIngredientIcon() const;
298: 
299: protected:
300: 
301: 	void BroadcastBaseIngredientDropped() const;
302: 	void BroadcastBaseIngredientIconSet() const;
303: 	void BroadcastPrincipalIngredientDropped() const;
304: 	void BroadcastPrincipalIngredientIconSet() const;
305: 	void BroadcastModifierIngredientDropped() const;
306: 	void BroadcastModifierIngredientIconSet() const;
307: 
308: private:
309: 
310: 	bool HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const;
311: 
312: 
313: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetBasePotionItemDefinition() const;
314: };

================
File: Source/WitchPT/Private/AbilitySystem/Interaction/GameplayAbility_Interact.cpp
================
  1: #include "AbilitySystem/Interaction/GameplayAbility_Interact.h"
  2: 
  3: #include "AbilitySystemComponent.h"
  4: #include "AbilitySystem/Interaction/AbilityTask_GrantNearbyInteraction.h"
  5: #include "AbilitySystem/Interaction/InteractionStatics.h"
  6: #include "NativeGameplayTags.h"
  7: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  8: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  9: #include "Engine/World.h"
 10: #include "Player/WitchPTPlayerController.h"
 11: 
 12: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
 13: UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Hold_Activate, "Ability.Interaction.HoldActivate");
 14: 
 15: UGameplayAbility_Interact::UGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
 16: 	: Super(ObjectInitializer)
 17: {
 18: 	ActivationPolicy = EPrototypeAbilityActivationPolicy::OnSpawn;
 19: 	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
 20: 	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
 21: }
 22: 
 23: void UGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle,
 24: 	const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo,
 25: 	const FGameplayEventData* TriggerEventData)
 26: {
 27: 	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
 28: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 29: 	UWitchPTAbilitySystemComponent* CustomAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(AbilitySystem);
 30: 	if (CustomAbilitySystemComponent && CustomAbilitySystemComponent->GetOwnerRole() == ROLE_Authority)
 31: 	{
 32: 
 33: 		UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
 34: 		Task->ReadyForActivation();
 35: 
 36: 	}
 37: }
 38: 
 39: void UGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
 40: {
 41: 
 42: 	if (CurrentActorInfo && CurrentActorInfo->PlayerController.IsValid())
 43: 	{
 44: 
 45: 
 46: 		AWitchPTPlayerController* WitchPt = Cast<AWitchPTPlayerController>(CurrentActorInfo->PlayerController.Get());
 47: 
 48: 		CurrentOptions = InteractiveOptions;
 49: 
 50: 		for (const FInteractionOption& InteractionOption : InteractiveOptions)
 51: 		{
 52: 			AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 53: 
 54: 			if (InteractableTargetActor)
 55: 			{
 56: 				FString ActorName = InteractableTargetActor->GetName();
 57: 				WitchPt->HUDWidget->ShowPickupMessage(InteractionOption.Text.ToString());
 58: 			}
 59: 
 60: 
 61: 		}
 62: 		if (InteractiveOptions.Num() == 0)
 63: 		{
 64: 			WitchPt->HUDWidget->HidePickupMessage();
 65: 		}
 66: 
 67: 	}
 68: 
 69: 	CurrentOptions = InteractiveOptions;
 70: }
 71: 
 72: void UGameplayAbility_Interact::TriggerInteraction()
 73: {
 74: 	if (CurrentOptions.Num() == 0)
 75: 	{
 76: 		return;
 77: 	}
 78: 
 79: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
 80: 	if (AbilitySystem)
 81: 	{
 82: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
 83: 
 84: 		AActor* Instigator = GetAvatarActorFromActorInfo();
 85: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
 86: 
 87: 
 88: 
 89: 		FGameplayEventData Payload;
 90: 		Payload.EventTag = TAG_Ability_Interaction_Activate;
 91: 		Payload.Instigator = Instigator;
 92: 		Payload.Target = InteractableTargetActor;
 93: 
 94: 
 95: 
 96: 
 97: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);
 98: 
 99: 
100: 
101: 
102: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
103: 
104: 
105: 		FGameplayAbilityActorInfo ActorInfo;
106: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
107: 
108: 
109: 
110: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
111: 			InteractionOption.TargetInteractionAbilityHandle,
112: 			&ActorInfo,
113: 			TAG_Ability_Interaction_Activate,
114: 			&Payload,
115: 			*InteractionOption.TargetAbilitySystem
116: 		);
117: 
118: 
119: 		OnInteractionComplete.Broadcast();
120: 	}
121: }
122: 
123: void UGameplayAbility_Interact::TriggerHoldInteraction()
124: {
125: 	if (CurrentOptions.Num() == 0)
126: 	{
127: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay opciones de interacción disponibles"));
128: 		OnInteractionCancelled.Broadcast();
129: 		return;
130: 	}
131: 
132: 	UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
133: 	if (AbilitySystem)
134: 	{
135: 		const FInteractionOption& InteractionOption = CurrentOptions[0];
136: 
137: 
138: 		if (!InteractionOption.bSupportsHoldInteraction)
139: 		{
140: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: El objeto no soporta interacción mantenida, usando interacción normal"));
141: 
142: 			TriggerInteraction();
143: 			return;
144: 		}
145: 
146: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Activando interacción mantenida en objeto que la soporta"));
147: 
148: 		AActor* Instigator = GetAvatarActorFromActorInfo();
149: 		AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);
150: 
151: 
152: 		FGameplayEventData Payload;
153: 		Payload.EventTag = TAG_Ability_Interaction_Hold_Activate;
154: 		Payload.Instigator = Instigator;
155: 		Payload.Target = InteractableTargetActor;
156: 
157: 
158: 		InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Hold_Activate, Payload);
159: 
160: 
161: 		AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));
162: 
163: 
164: 		FGameplayAbilityActorInfo ActorInfo;
165: 		ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);
166: 
167: 
168: 		FGameplayAbilitySpecHandle AbilityHandle = InteractionOption.TargetHoldInteractionAbilityHandle;
169: 
170: 
171: 		if (!AbilityHandle.IsValid())
172: 		{
173: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: No hay handle específico para interacción mantenida, usando el handle normal"));
174: 			AbilityHandle = InteractionOption.TargetInteractionAbilityHandle;
175: 		}
176: 		else
177: 		{
178: 			UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Usando handle específico para interacción mantenida"));
179: 		}
180: 
181: 
182: 
183: 		const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
184: 			AbilityHandle,
185: 			&ActorInfo,
186: 			TAG_Ability_Interaction_Hold_Activate,
187: 			&Payload,
188: 			*InteractionOption.TargetAbilitySystem
189: 		);
190: 
191: 		UE_LOG(LogTemp, Warning, TEXT("TriggerHoldInteraction: Resultado de activación: %s"), bSuccess ? TEXT("Éxito") : TEXT("Fallido"));
192: 
193: 
194: 		OnHoldInteractionComplete.Broadcast();
195: 	}
196: }
197: 
198: void UGameplayAbility_Interact::OnInteractionButtonPressed()
199: {
200: 	if (CurrentOptions.Num() == 0)
201: 	{
202: 
203: 		OnInteractionCancelled.Broadcast();
204: 		return;
205: 	}
206: 
207: 
208: 	bIsInteractionButtonHeld = true;
209: 	bHoldInteractionFired = false;
210: 	InteractionStartTime = GetWorld()->GetTimeSeconds();
211: 
212: 
213: 	if (CurrentOptions.Num() > 0)
214: 	{
215: 		InitialInteractableTarget = CurrentOptions[0].InteractableTarget;
216: 
217: 	}
218: 
219: 
220: 	GetWorld()->GetTimerManager().SetTimer(
221: 		HoldInteractionTimerHandle,
222: 		this,
223: 		&UGameplayAbility_Interact::OnHoldInteractionTimeElapsed,
224: 		HoldInteractionTime,
225: 		false
226: 	);
227: 
228: 
229: 	GetWorld()->GetTimerManager().SetTimer(
230: 		ValidityCheckTimerHandle,
231: 		this,
232: 		&UGameplayAbility_Interact::CheckInteractionValidity,
233: 		ValidityCheckRate,
234: 		true
235: 	);
236: 
237: 
238: 	GetWorld()->GetTimerManager().SetTimer(
239: 		MaxInteractionTimeTimerHandle,
240: 		this,
241: 		&UGameplayAbility_Interact::OnMaxInteractionTimeElapsed,
242: 		MaxInteractionTime,
243: 		false
244: 	);
245: 
246: 
247: 
248: }
249: 
250: void UGameplayAbility_Interact::OnInteractionButtonReleased()
251: {
252: 
253: 
254: 	if (!bIsInteractionButtonHeld)
255: 	{
256: 
257: 		return;
258: 	}
259: 
260: 	bIsInteractionButtonHeld = false;
261: 
262: 
263: 	if (GetWorld())
264: 	{
265: 
266: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
267: 		{
268: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
269: 		}
270: 
271: 
272: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
273: 		{
274: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
275: 		}
276: 
277: 
278: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
279: 		{
280: 
281: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
282: 
283: 
284: 			if (bHoldInteractionFired)
285: 			{
286: 
287: 				return;
288: 			}
289: 
290: 
291: 			float CurrentTime = GetWorld()->GetTimeSeconds();
292: 			float HoldTime = CurrentTime - InteractionStartTime;
293: 
294: 
295: 
296: 			if (HoldTime < HoldInteractionTime)
297: 			{
298: 
299: 
300: 				TriggerInteraction();
301: 
302: 
303: 
304: 
305: 
306: 			}
307: 		}
308: 		else
309: 		{
310: 
311: 		}
312: 	}
313: 
314: 
315: 	InitialInteractableTarget = nullptr;
316: }
317: 
318: void UGameplayAbility_Interact::OnHoldInteractionTimeElapsed()
319: {
320: 
321: 
322: 	if (bIsInteractionButtonHeld)
323: 	{
324: 
325: 
326: 		bHoldInteractionFired = true;
327: 
328: 
329: 
330: 		TriggerHoldInteraction();
331: 
332: 
333: 
334: 
335: 
336: 	}
337: 	else
338: 	{
339: 
340: 	}
341: }
342: 
343: void UGameplayAbility_Interact::CheckInteractionValidity()
344: {
345: 
346: 	if (!bIsInteractionButtonHeld || !InitialInteractableTarget.GetInterface())
347: 	{
348: 		return;
349: 	}
350: 
351: 
352: 	UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Verificando validez de interacción. Opciones actuales: %d"), CurrentOptions.Num());
353: 
354: 
355: 	bool bHasValidInteraction = false;
356: 
357: 	if (CurrentOptions.Num() > 0)
358: 	{
359: 
360: 		for (const FInteractionOption& Option : CurrentOptions)
361: 		{
362: 			if (Option.InteractableTarget == InitialInteractableTarget)
363: 			{
364: 				bHasValidInteraction = true;
365: 				break;
366: 			}
367: 		}
368: 
369: 
370: 		if (bHasValidInteraction)
371: 		{
372: 			UE_LOG(LogTemp, Verbose, TEXT("CheckInteractionValidity: Objetivo de interacción aún es válido"));
373: 		}
374: 		else
375: 		{
376: 
377: 			AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
378: 			AActor* CurrentActor = CurrentOptions.Num() > 0 ?
379: 				UInteractionStatics::GetActorFromInteractableTarget(CurrentOptions[0].InteractableTarget) : nullptr;
380: 
381: 			UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: Objetivo de interacción inválido. Inicial: %s, Actual: %s"),
382: 				InitialActor ? *InitialActor->GetName() : TEXT("Ninguno"),
383: 				CurrentActor ? *CurrentActor->GetName() : TEXT("Ninguno"));
384: 		}
385: 	}
386: 	else
387: 	{
388: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: No hay opciones de interacción disponibles"));
389: 	}
390: 
391: 
392: 	if (!bHasValidInteraction)
393: 	{
394: 		UE_LOG(LogTemp, Warning, TEXT("CheckInteractionValidity: El objetivo de interacción ha cambiado o no es válido, cancelando interacción"));
395: 		CancelCurrentInteraction();
396: 	}
397: }
398: 
399: void UGameplayAbility_Interact::CancelCurrentInteraction()
400: {
401: 
402: 	if (!bIsInteractionButtonHeld)
403: 	{
404: 		UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: No hay interacción activa para cancelar"));
405: 		return;
406: 	}
407: 
408: 
409: 	FString InitialObjectName = TEXT("Desconocido");
410: 	if (InitialInteractableTarget.GetInterface())
411: 	{
412: 		AActor* InitialActor = UInteractionStatics::GetActorFromInteractableTarget(InitialInteractableTarget);
413: 		if (InitialActor)
414: 		{
415: 			InitialObjectName = InitialActor->GetName();
416: 		}
417: 	}
418: 
419: 	UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: Cancelando interacción actual con %s"), *InitialObjectName);
420: 
421: 
422: 	if (GetWorld())
423: 	{
424: 		if (GetWorld()->GetTimerManager().IsTimerActive(ValidityCheckTimerHandle))
425: 		{
426: 			GetWorld()->GetTimerManager().ClearTimer(ValidityCheckTimerHandle);
427: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de validez detenido"));
428: 		}
429: 
430: 		if (GetWorld()->GetTimerManager().IsTimerActive(HoldInteractionTimerHandle))
431: 		{
432: 			GetWorld()->GetTimerManager().ClearTimer(HoldInteractionTimerHandle);
433: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de interacción mantenida detenido"));
434: 		}
435: 
436: 		if (GetWorld()->GetTimerManager().IsTimerActive(MaxInteractionTimeTimerHandle))
437: 		{
438: 			GetWorld()->GetTimerManager().ClearTimer(MaxInteractionTimeTimerHandle);
439: 			UE_LOG(LogTemp, Verbose, TEXT("CancelCurrentInteraction: Temporizador de seguridad detenido"));
440: 		}
441: 	}
442: 
443: 
444: 	bIsInteractionButtonHeld = false;
445: 	bHoldInteractionFired = false;
446: 
447: 
448: 	TScriptInterface<IInteractableTarget> CanceledTarget = InitialInteractableTarget;
449: 	InitialInteractableTarget = nullptr;
450: 
451: 
452: 	UE_LOG(LogTemp, Log, TEXT("GameplayAbility_Interact: Estado de interacción restablecido completamente"));
453: 
454: 
455: 	OnInteractionCancelled.Broadcast();
456: }
457: 
458: void UGameplayAbility_Interact::OnMaxInteractionTimeElapsed()
459: {
460: 
461: 	if (bIsInteractionButtonHeld)
462: 	{
463: 		UE_LOG(LogTemp, Warning, TEXT("GameplayAbility_Interact: ¡Tiempo máximo de interacción alcanzado! Forzando cancelación después de %f segundos"), MaxInteractionTime);
464: 		CancelCurrentInteraction();
465: 
466: 
467: 		OnInteractionCancelled.Broadcast();
468: 	}
469: }

================
File: Source/WitchPT/Private/Character/WitchPTEnemy.cpp
================
 1: #include "Character/WitchPTEnemy.h"
 2: 
 3: 
 4: 
 5: AWitchPTEnemy::AWitchPTEnemy(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
 6: {
 7: 
 8: 	PrimaryActorTick.bCanEverTick = true;
 9: }
10: 
11: 
12: void AWitchPTEnemy::BeginPlay()
13: {
14: 	Super::BeginPlay();
15: 
16: }
17: 
18: 
19: void AWitchPTEnemy::Tick(float DeltaTime)
20: {
21: 	Super::Tick(DeltaTime);
22: }
23: 
24: 
25: void AWitchPTEnemy::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
26: {
27: 	Super::SetupPlayerInputComponent(PlayerInputComponent);
28: 
29: }

================
File: Source/WitchPT/Private/Equipment/WitchPTQuickBarComponent.cpp
================
 1: #include "Equipment/WitchPTQuickBarComponent.h"
 2: 
 3: #include "Net/UnrealNetwork.h"
 4: 
 5: 
 6: 
 7: UWitchPTQuickBarComponent::UWitchPTQuickBarComponent()
 8: {
 9: 	SetIsReplicatedByDefault(true);
10: }
11: 
12: void UWitchPTQuickBarComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
13: {
14: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
15: 	DOREPLIFETIME(ThisClass, Slots);
16: 	DOREPLIFETIME(ThisClass, ActiveSlotIndex);
17: }
18: 
19: void UWitchPTQuickBarComponent::BeginPlay()
20: {
21: 	Super::BeginPlay();
22: 
23: 	if (Slots.Num() < NumSlots)
24: 	{
25: 		Slots.AddDefaulted(NumSlots - Slots.Num());
26: 	}
27: }
28: 
29: void UWitchPTQuickBarComponent::AddItemToSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* Item)
30: {
31: 	if (Slots.IsValidIndex(SlotIndex) && (Item != nullptr))
32: 	{
33: 		if (Slots[SlotIndex] == nullptr)
34: 		{
35: 			Slots[SlotIndex] = Item;
36: 			OnRep_Slots();
37: 		}
38: 	}
39: }
40: 
41: 
42: void UWitchPTQuickBarComponent::EquipItemInSlot()
43: {
44: }
45: 
46: void UWitchPTQuickBarComponent::UnequipItemInSlot()
47: {
48: }
49: 
50: void UWitchPTQuickBarComponent::OnRep_Slots()
51: {
52: }
53: 
54: void UWitchPTQuickBarComponent::OnRep_ActiveSlotIndex()
55: {
56: 	OnActiveSlotChanged.Broadcast(ActiveSlotIndex);
57: }
58: 
59: void UWitchPTQuickBarComponent::SetActiveSlotIndex_Implementation(int32 NewIndex)
60: {
61: 	UE_LOG(LogTemp, Log, TEXT("Setting active slot index to %d"), NewIndex);
62: 	if (Slots.IsValidIndex(NewIndex) && (ActiveSlotIndex != NewIndex))
63: 	{
64: 		UnequipItemInSlot();
65: 
66: 		ActiveSlotIndex = NewIndex;
67: 
68: 		EquipItemInSlot();
69: 
70: 		OnRep_ActiveSlotIndex();
71: 	}
72: }

================
File: Source/WitchPT/Private/Item/Components/CauldronCraftComponent.cpp
================
   1: #include "Item/Components/CauldronCraftComponent.h"
   2: #include "Net/UnrealNetwork.h"
   3: #include "GameFramework/Character.h"
   4: #include "FWitchPTGameplayTags.h"
   5: #include "Inventory/WitchPTInventoryItemDefinition.h"
   6: #include "Inventory/WitchPTInventoryItemInstance.h"
   7: #include "Inventory/WitchPTInventoryManagerComponent.h"
   8: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
   9: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
  10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_PotionProperties.h"
  11: #include "Inventory/Fragments/WitchPTInventoryItemFragment_WorldDetails.h"
  12: #include "Player/WitchPTPlayerController.h"
  13: #include "Item/CauldronAltar.h"
  14: #include "Item/Potion/PotionBase.h"
  15: #include "Components/StaticMeshComponent.h"
  16: #include "Engine/World.h"
  17: 
  18: 
  19: UCauldronCraftComponent::UCauldronCraftComponent()
  20: {
  21: 
  22: 
  23: 	PrimaryComponentTick.bCanEverTick = true;
  24: 	SetIsReplicatedByDefault(true);
  25: 
  26: 	BaseIngredient = nullptr;
  27: 	PrincipalIngredient = nullptr;
  28: 	ModifierIngredient = nullptr;
  29: 
  30: 
  31: 	DefaultCraftingRecipe.bRequiresBaseIngredient = true;
  32: 	DefaultCraftingRecipe.bRequiresPrincipalIngredient = true;
  33: 	DefaultCraftingRecipe.bRequiresModifierIngredient = false;
  34: }
  35: 
  36: 
  37: void UCauldronCraftComponent::BeginPlay()
  38: {
  39: 	Super::BeginPlay();
  40: }
  41: 
  42: 
  43: void UCauldronCraftComponent::TickComponent(float DeltaTime, ELevelTick TickType,
  44:                                             FActorComponentTickFunction* ThisTickFunction)
  45: {
  46: 	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
  47: }
  48: 
  49: void UCauldronCraftComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
  50: {
  51:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  52: 
  53:     DOREPLIFETIME(UCauldronCraftComponent, BaseIngredientIcon);
  54:     DOREPLIFETIME(UCauldronCraftComponent, PrincipalIngredientIcon);
  55:     DOREPLIFETIME(UCauldronCraftComponent, ModifierIngredientIcon);
  56:     DOREPLIFETIME(UCauldronCraftComponent, CraftedPotion);
  57: }
  58: 
  59: void UCauldronCraftComponent::OnRep_BaseIngredientIcon()
  60: {
  61:     BroadcastBaseIngredientIconSet();
  62: }
  63: 
  64: void UCauldronCraftComponent::OnRep_PrincipalIngredientIcon()
  65: {
  66:     BroadcastPrincipalIngredientIconSet();
  67: }
  68: 
  69: void UCauldronCraftComponent::OnRep_PotentiatorIngredientIcon()
  70: {
  71:     BroadcastModifierIngredientIconSet();
  72: }
  73: 
  74: void UCauldronCraftComponent::OnRep_CraftedPotion()
  75: {
  76: 
  77:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::OnRep_CraftedPotion: Potion crafted with validity: %s"),
  78:            CraftedPotion.bIsValid ? TEXT("Valid") : TEXT("Invalid"));
  79: }
  80: 
  81: 
  82: 
  83: bool UCauldronCraftComponent::CanCraftPotion() const
  84: {
  85:     const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
  86: 
  87: 
  88:     if (Recipe.bRequiresBaseIngredient)
  89:     {
  90:         if (!BaseIngredient || !HasValidCraftingProperties(BaseIngredient))
  91:         {
  92:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Base ingredient missing or invalid"));
  93:             return false;
  94:         }
  95:     }
  96: 
  97: 
  98:     if (Recipe.bRequiresPrincipalIngredient)
  99:     {
 100:         if (!PrincipalIngredient || !HasValidCraftingProperties(PrincipalIngredient))
 101:         {
 102:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Principal ingredient missing or invalid"));
 103:             return false;
 104:         }
 105:     }
 106: 
 107: 
 108:     if (Recipe.bRequiresModifierIngredient)
 109:     {
 110:         if (!ModifierIngredient || !HasValidCraftingProperties(ModifierIngredient))
 111:         {
 112:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Modifier ingredient missing or invalid"));
 113:             return false;
 114:         }
 115:     }
 116: 
 117: 
 118:     if (!ValidateIngredientCombination())
 119:     {
 120:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanCraftPotion: Ingredient combination is not valid"));
 121:         return false;
 122:     }
 123: 
 124:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CanCraftPotion: All requirements met, can craft potion"));
 125:     return true;
 126: }
 127: 
 128: FPotionCraftingRecipe UCauldronCraftComponent::GetRequiredIngredients() const
 129: {
 130: 
 131: 
 132:     return DefaultCraftingRecipe;
 133: }
 134: 
 135: bool UCauldronCraftComponent::ValidateIngredientCombination() const
 136: {
 137:     const FPotionCraftingRecipe& Recipe = GetRequiredIngredients();
 138: 
 139: 
 140:     if (Recipe.bRequiresBaseIngredient && !BaseIngredient)
 141:     {
 142:         return false;
 143:     }
 144: 
 145:     if (Recipe.bRequiresPrincipalIngredient && !PrincipalIngredient)
 146:     {
 147:         return false;
 148:     }
 149: 
 150: 
 151:     if (BaseIngredient && Recipe.AllowedBaseLiquidTypes.Num() > 0)
 152:     {
 153:         const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps =
 154:             Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 155:                 BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 156: 
 157:         if (BaseProps && !Recipe.AllowedBaseLiquidTypes.HasTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag))
 158:         {
 159:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Base liquid type not allowed"));
 160:             return false;
 161:         }
 162:     }
 163: 
 164: 
 165:     if (PrincipalIngredient && Recipe.AllowedPrincipalEssences.Num() > 0)
 166:     {
 167:         const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps =
 168:             Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 169:                 PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 170: 
 171:         if (PrincipalProps && !Recipe.AllowedPrincipalEssences.HasTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag))
 172:         {
 173:             UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Principal essence not allowed"));
 174:             return false;
 175:         }
 176:     }
 177: 
 178: 
 179:     if (Recipe.IncompatibleCombinations.Num() > 0)
 180:     {
 181: 
 182:         FGameplayTagContainer CurrentCombination;
 183: 
 184:         if (BaseIngredient)
 185:         {
 186:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* BaseProps =
 187:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 188:                     BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 189:             if (BaseProps)
 190:             {
 191:                 CurrentCombination.AddTag(BaseProps->BaseIngredientData.BaseLiquidTypeTag);
 192:                 CurrentCombination.AddTag(BaseProps->CategoryTag);
 193:             }
 194:         }
 195: 
 196:         if (PrincipalIngredient)
 197:         {
 198:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* PrincipalProps =
 199:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 200:                     PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 201:             if (PrincipalProps)
 202:             {
 203:                 CurrentCombination.AddTag(PrincipalProps->PrincipalIngredientData.PrincipalEssenceTag);
 204:                 CurrentCombination.AddTag(PrincipalProps->CategoryTag);
 205:             }
 206:         }
 207: 
 208:         if (ModifierIngredient)
 209:         {
 210:             const UWitchPTInventoryItemFragment_IngredientCraftingProperties* ModifierProps =
 211:                 Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 212:                     ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 213:             if (ModifierProps)
 214:             {
 215:                 CurrentCombination.AppendTags(ModifierProps->ModifierIngredientData.ModifierEffectTags);
 216:                 CurrentCombination.AddTag(ModifierProps->CategoryTag);
 217:             }
 218:         }
 219: 
 220: 
 221:         for (const FGameplayTag& IncompatibleTag : Recipe.IncompatibleCombinations)
 222:         {
 223:             if (CurrentCombination.HasTag(IncompatibleTag))
 224:             {
 225:                 UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Found incompatible combination: %s"),
 226:                        *IncompatibleTag.ToString());
 227:                 return false;
 228:             }
 229:         }
 230:     }
 231: 
 232:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ValidateIngredientCombination: Ingredient combination is valid"));
 233:     return true;
 234: }
 235: 
 236: bool UCauldronCraftComponent::HasValidCraftingProperties(UWitchPTInventoryItemInstance* Ingredient) const
 237: {
 238:     if (!Ingredient)
 239:     {
 240:         return false;
 241:     }
 242: 
 243:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 244:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 245:             Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 246: 
 247:     return CraftingProps != nullptr;
 248: }
 249: 
 250: 
 251: 
 252: void UCauldronCraftComponent::PrintIngredientDebugData() const
 253: {
 254:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON CRAFT COMPONENT DEBUG DATA ==="));
 255:     UE_LOG(LogTemp, Warning, TEXT("Component Owner: %s"), GetOwner() ? *GetOwner()->GetName() : TEXT("None"));
 256: 
 257: 
 258:     if (BaseIngredient)
 259:     {
 260:         UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT ---"));
 261:         PrintSpecificIngredientData(BaseIngredient, TEXT("Base"));
 262:     }
 263:     else
 264:     {
 265:         UE_LOG(LogTemp, Warning, TEXT("--- BASE INGREDIENT SLOT: EMPTY ---"));
 266:     }
 267: 
 268: 
 269:     if (PrincipalIngredient)
 270:     {
 271:         UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT ---"));
 272:         PrintSpecificIngredientData(PrincipalIngredient, TEXT("Principal"));
 273:     }
 274:     else
 275:     {
 276:         UE_LOG(LogTemp, Warning, TEXT("--- PRINCIPAL INGREDIENT SLOT: EMPTY ---"));
 277:     }
 278: 
 279: 
 280:     if (ModifierIngredient)
 281:     {
 282:         UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT ---"));
 283:         PrintSpecificIngredientData(ModifierIngredient, TEXT("Modifier"));
 284:     }
 285:     else
 286:     {
 287:         UE_LOG(LogTemp, Warning, TEXT("--- MODIFIER INGREDIENT SLOT: EMPTY ---"));
 288:     }
 289: 
 290: 
 291:     UE_LOG(LogTemp, Warning, TEXT("--- CRAFTING STATUS ---"));
 292:     UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), CanCraftPotion() ? TEXT("YES") : TEXT("NO"));
 293:     UE_LOG(LogTemp, Warning, TEXT("Ingredient Combination Valid: %s"), ValidateIngredientCombination() ? TEXT("YES") : TEXT("NO"));
 294: 
 295: 
 296:     UE_LOG(LogTemp, Warning, TEXT("--- CURRENT CRAFTED POTION ---"));
 297:     UE_LOG(LogTemp, Warning, TEXT("Crafted Potion Valid: %s"), CraftedPotion.bIsValid ? TEXT("YES") : TEXT("NO"));
 298:     if (CraftedPotion.bIsValid)
 299:     {
 300:         UE_LOG(LogTemp, Warning, TEXT("Potion Essence: %s"), *CraftedPotion.PotionEssenceTag.ToString());
 301:         UE_LOG(LogTemp, Warning, TEXT("Base Liquid: %s"), *CraftedPotion.BaseLiquidTypeTag.ToString());
 302:         UE_LOG(LogTemp, Warning, TEXT("Final Potency: %.2f"), CraftedPotion.FinalPotency);
 303:         UE_LOG(LogTemp, Warning, TEXT("Final Duration: %.2f"), CraftedPotion.FinalDuration);
 304:         UE_LOG(LogTemp, Warning, TEXT("Final Charges: %d"), CraftedPotion.FinalCharges);
 305:     }
 306: 
 307:     UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG DATA ==="));
 308:     CalculatePotionProperties();
 309: }
 310: 
 311: void UCauldronCraftComponent::PrintSpecificIngredientData(UWitchPTInventoryItemInstance* Ingredient, const FString& SlotName) const
 312: {
 313:     if (!Ingredient)
 314:     {
 315:         UE_LOG(LogTemp, Warning, TEXT("%s Ingredient: NULL"), *SlotName);
 316:         return;
 317:     }
 318: 
 319: 
 320:     UE_LOG(LogTemp, Warning, TEXT("%s Ingredient Definition: %s"),
 321:            *SlotName,
 322:            Ingredient->GetItemDef() ? *Ingredient->GetItemDef()->GetName() : TEXT("None"));
 323:     UE_LOG(LogTemp, Warning, TEXT("%s Stack Count: %d"), *SlotName, Ingredient->GetTotalStackCount());
 324: 
 325: 
 326:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 327:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 328:             Ingredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 329: 
 330:     if (!CraftingProps)
 331:     {
 332:         UE_LOG(LogTemp, Error, TEXT("%s Ingredient: NO CRAFTING PROPERTIES FRAGMENT FOUND!"), *SlotName);
 333:         return;
 334:     }
 335: 
 336: 
 337:     UE_LOG(LogTemp, Warning, TEXT("%s Slot Usage Tag: %s"), *SlotName, *CraftingProps->SlotUsageTag.ToString());
 338:     UE_LOG(LogTemp, Warning, TEXT("%s Tier Tag: %s"), *SlotName, *CraftingProps->TierTag.ToString());
 339:     UE_LOG(LogTemp, Warning, TEXT("%s Category Tag: %s"), *SlotName, *CraftingProps->CategoryTag.ToString());
 340: 
 341: 
 342:     UE_LOG(LogTemp, Warning, TEXT("%s Base Liquid Type: %s"),
 343:            *SlotName, *CraftingProps->BaseIngredientData.BaseLiquidTypeTag.ToString());
 344:     UE_LOG(LogTemp, Warning, TEXT("%s Default Charges: %d"),
 345:            *SlotName, CraftingProps->BaseIngredientData.DefaultChargesProvided);
 346:     UE_LOG(LogTemp, Warning, TEXT("%s Stability Modifier: %.3f"),
 347:            *SlotName, CraftingProps->BaseIngredientData.StabilityModifier);
 348: 
 349: 
 350:     UE_LOG(LogTemp, Warning, TEXT("%s Principal Essence: %s"),
 351:            *SlotName, *CraftingProps->PrincipalIngredientData.PrincipalEssenceTag.ToString());
 352:     UE_LOG(LogTemp, Warning, TEXT("%s Base Potency: %.3f"),
 353:            *SlotName, CraftingProps->PrincipalIngredientData.BasePotency);
 354:     UE_LOG(LogTemp, Warning, TEXT("%s Base Duration: %.3f"),
 355:            *SlotName, CraftingProps->PrincipalIngredientData.BaseDuration);
 356:     UE_LOG(LogTemp, Warning, TEXT("%s Is Ritual Essence: %s"),
 357:            *SlotName, CraftingProps->PrincipalIngredientData.bIsRitualEssence ? TEXT("YES") : TEXT("NO"));
 358: 
 359: 
 360:     FString ModifierEffectTagsString;
 361:     for (const FGameplayTag& Tag : CraftingProps->ModifierIngredientData.ModifierEffectTags)
 362:     {
 363:         if (!ModifierEffectTagsString.IsEmpty())
 364:         {
 365:             ModifierEffectTagsString += TEXT(", ");
 366:         }
 367:         ModifierEffectTagsString += Tag.ToString();
 368:     }
 369:     UE_LOG(LogTemp, Warning, TEXT("%s Modifier Effect Tags: [%s]"), *SlotName, *ModifierEffectTagsString);
 370:     UE_LOG(LogTemp, Warning, TEXT("%s Potency Modification: %.3f"),
 371:            *SlotName, CraftingProps->ModifierIngredientData.PotencyModificationValue);
 372:     UE_LOG(LogTemp, Warning, TEXT("%s Duration Modification: %.3f"),
 373:            *SlotName, CraftingProps->ModifierIngredientData.DurationModificationValue);
 374:     UE_LOG(LogTemp, Warning, TEXT("%s Granted Property Tag: %s"),
 375:            *SlotName, *CraftingProps->ModifierIngredientData.GrantedPropertyTag.ToString());
 376:     UE_LOG(LogTemp, Warning, TEXT("%s Added Effect Tag: %s"),
 377:            *SlotName, *CraftingProps->ModifierIngredientData.AddedEffectTag.ToString());
 378:     UE_LOG(LogTemp, Warning, TEXT("%s Modifier Strength: %.3f"),
 379:            *SlotName, CraftingProps->ModifierIngredientData.StrengthOfModifier);
 380: }
 381: 
 382: void UCauldronCraftComponent::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
 383: {
 384:     if (!GetOwner()->HasAuthority())
 385:     {
 386:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Not authority"));
 387:         return;
 388:     }
 389: 
 390:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(RequestingCharacter->GetController());
 391:     if (!PC)
 392:     {
 393:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: RequestingCharacter does not have a valid PlayerController."));
 394:         return;
 395:     }
 396: 
 397:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
 398:     if (!InventoryManager)
 399:     {
 400:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Could not get InventoryManager from PlayerController."));
 401:         return;
 402:     }
 403: 
 404:     UWitchPTInventoryItemInstance* InstanceFromInventory = InventoryManager->FindFirstItemStackByDefinition(IngredientItemDef);
 405: 
 406:     if (!InstanceFromInventory)
 407:     {
 408:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: ItemDefinition %s not found in inventory for %s."), *IngredientItemDef->GetName(), *RequestingCharacter->GetName());
 409:         return;
 410:     }
 411: 
 412:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* IngredientCraftingDetails = Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 413:     if (!IngredientCraftingDetails)
 414:     {
 415:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: IngredientCraftingDetails is not valid for %s."), *RequestingCharacter->GetName());
 416:         return;
 417:     }
 418: 
 419: 
 420:     const FWitchPTGameplayTags& GameplayTags = FWitchPTGameplayTags::Get();
 421:     bool bIsBaseIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot);
 422:     bool bIsPrincipalIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot);
 423:     bool bIsModifierIngredient = IngredientCraftingDetails->SlotUsageTag.MatchesTag(GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot);
 424: 
 425: 
 426:     if (bIsBaseIngredient && BaseIngredient != nullptr)
 427:     {
 428:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient slot is already occupied"));
 429:         return;
 430:     }
 431: 
 432:     if (bIsPrincipalIngredient && PrincipalIngredient != nullptr)
 433:     {
 434:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient slot is already occupied"));
 435:         return;
 436:     }
 437: 
 438:     if (bIsModifierIngredient && ModifierIngredient != nullptr)
 439:     {
 440:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient slot is already occupied"));
 441:         return;
 442:     }
 443: 
 444: 
 445:     if (!bIsBaseIngredient && !bIsPrincipalIngredient && !bIsModifierIngredient)
 446:     {
 447:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Ingredient %s doesn't have a valid slot usage tag"), *IngredientItemDef->GetName());
 448:         return;
 449:     }
 450: 
 451:     bool bConsumedSuccessfully = false;
 452:     int32 CurrentStackCount = InstanceFromInventory->GetTotalStackCount();
 453: 
 454:     if (CurrentStackCount > 0)
 455:     {
 456:         UWitchPTInventoryItemInstance* IngredientToSet = nullptr;
 457: 
 458:         if (CurrentStackCount == 1)
 459:         {
 460:             IngredientToSet = InstanceFromInventory;
 461:             InventoryManager->Server_RemoveItemInstance(InstanceFromInventory);
 462:             bConsumedSuccessfully = true;
 463:         }
 464:         else
 465:         {
 466:             InventoryManager->Server_UpdateItemStackCount(InstanceFromInventory, CurrentStackCount - 1);
 467:             IngredientToSet = InstanceFromInventory;
 468:             bConsumedSuccessfully = true;
 469:         }
 470: 
 471: 
 472:         const UWitchPTInventoryFragment_UIDetails* UIFragment = Cast<UWitchPTInventoryFragment_UIDetails>(InstanceFromInventory->FindFragmentByClass(UWitchPTInventoryFragment_UIDetails::StaticClass()));
 473:         TSubclassOf<UUserWidget> IngredientIcon = nullptr;
 474:         if (IsValid(UIFragment))
 475:         {
 476:             IngredientIcon = UIFragment->IconWidget;
 477:         }
 478: 
 479: 
 480:         if (bIsBaseIngredient)
 481:         {
 482:             BaseIngredient = IngredientToSet;
 483:             BaseIngredientIcon = IngredientIcon;
 484:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Base ingredient set successfully"));
 485: 
 486:             if (GetOwner()->HasAuthority())
 487:             {
 488:                 BroadcastBaseIngredientIconSet();
 489:             }
 490:         }
 491:         else if (bIsPrincipalIngredient)
 492:         {
 493:             PrincipalIngredient = IngredientToSet;
 494:             PrincipalIngredientIcon = IngredientIcon;
 495:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Principal ingredient set successfully"));
 496: 
 497:             if (GetOwner()->HasAuthority())
 498:             {
 499:                 BroadcastPrincipalIngredientIconSet();
 500:             }
 501:         }
 502:         else if (bIsModifierIngredient)
 503:         {
 504:             ModifierIngredient = IngredientToSet;
 505:             ModifierIngredientIcon = IngredientIcon;
 506:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::TrySetIngredientInSlot: Modifier ingredient set successfully"));
 507: 
 508:             if (GetOwner()->HasAuthority())
 509:             {
 510:                 BroadcastModifierIngredientIconSet();
 511:             }
 512:         }
 513:     }
 514: }
 515: 
 516: 
 517: void UCauldronCraftComponent::BroadcastBaseIngredientDropped() const
 518: {
 519:     OnBaseIngredientSetDelegate.Broadcast(BaseIngredient);
 520: }
 521: 
 522: void UCauldronCraftComponent::BroadcastBaseIngredientIconSet() const
 523: {
 524:     OnBaseIngredientIconSetDelegate.Broadcast(BaseIngredientIcon);
 525: }
 526: 
 527: void UCauldronCraftComponent::BroadcastPrincipalIngredientDropped() const
 528: {
 529:     OnPrincipalIngredientSetDelegate.Broadcast(PrincipalIngredient);
 530: }
 531: 
 532: void UCauldronCraftComponent::BroadcastPrincipalIngredientIconSet() const
 533: {
 534:     OnPrincipalIngredientIconSetDelegate.Broadcast(PrincipalIngredientIcon);
 535: }
 536: 
 537: void UCauldronCraftComponent::BroadcastModifierIngredientDropped() const
 538: {
 539:     OnModifierIngredientSetDelegate.Broadcast(ModifierIngredient);
 540: }
 541: 
 542: void UCauldronCraftComponent::BroadcastModifierIngredientIconSet() const
 543: {
 544:     OnModifierIngredientIconSetDelegate.Broadcast(ModifierIngredientIcon);
 545: }
 546: 
 547: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetBaseIngredient() const
 548: {
 549:     return BaseIngredient;
 550: }
 551: 
 552: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetPrincipalIngredient() const
 553: {
 554:     return PrincipalIngredient;
 555: }
 556: 
 557: UWitchPTInventoryItemInstance* UCauldronCraftComponent::GetModifierIngredient() const
 558: {
 559:     return ModifierIngredient;
 560: }
 561: 
 562: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetBaseIngredientIcon() const
 563: {
 564:     return BaseIngredientIcon;
 565: }
 566: 
 567: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetPrincipalIngredientIcon() const
 568: {
 569:     return PrincipalIngredientIcon;
 570: }
 571: 
 572: TSubclassOf<UUserWidget> UCauldronCraftComponent::GetModifierIngredientIcon() const
 573: {
 574:     return ModifierIngredientIcon;
 575: }
 576: 
 577: 
 578: 
 579: 
 580: FExtractedBaseIngredientData UCauldronCraftComponent::ExtractBaseIngredientProperties() const
 581: {
 582:     FExtractedBaseIngredientData ExtractedData;
 583: 
 584:     if (!BaseIngredient)
 585:     {
 586:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No base ingredient found"));
 587:         return ExtractedData;
 588:     }
 589: 
 590:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 591:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 592:             BaseIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 593: 
 594:     if (!CraftingProps)
 595:     {
 596:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: No crafting properties found"));
 597:         return ExtractedData;
 598:     }
 599: 
 600: 
 601:     ExtractedData.BaseLiquidTypeTag = CraftingProps->BaseIngredientData.BaseLiquidTypeTag;
 602:     ExtractedData.DefaultChargesProvided = CraftingProps->BaseIngredientData.DefaultChargesProvided;
 603:     ExtractedData.StabilityModifier = CraftingProps->BaseIngredientData.StabilityModifier;
 604:     ExtractedData.TierTag = CraftingProps->TierTag;
 605:     ExtractedData.bIsValid = true;
 606: 
 607:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractBaseIngredientProperties: Successfully extracted - Liquid: %s, Charges: %d, Stability: %.3f"),
 608:            *ExtractedData.BaseLiquidTypeTag.ToString(),
 609:            ExtractedData.DefaultChargesProvided,
 610:            ExtractedData.StabilityModifier);
 611: 
 612:     return ExtractedData;
 613: }
 614: 
 615: FExtractedPrincipalIngredientData UCauldronCraftComponent::ExtractPrincipalIngredientProperties() const
 616: {
 617:     FExtractedPrincipalIngredientData ExtractedData;
 618: 
 619:     if (!PrincipalIngredient)
 620:     {
 621:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No principal ingredient found"));
 622:         return ExtractedData;
 623:     }
 624: 
 625:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 626:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 627:             PrincipalIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 628: 
 629:     if (!CraftingProps)
 630:     {
 631:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: No crafting properties found"));
 632:         return ExtractedData;
 633:     }
 634: 
 635: 
 636:     ExtractedData.PrincipalEssenceTag = CraftingProps->PrincipalIngredientData.PrincipalEssenceTag;
 637:     ExtractedData.BasePotency = CraftingProps->PrincipalIngredientData.BasePotency;
 638:     ExtractedData.BaseDuration = CraftingProps->PrincipalIngredientData.BaseDuration;
 639:     ExtractedData.bIsRitualEssence = CraftingProps->PrincipalIngredientData.bIsRitualEssence;
 640:     ExtractedData.TierTag = CraftingProps->TierTag;
 641:     ExtractedData.bIsValid = true;
 642: 
 643:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractPrincipalIngredientProperties: Successfully extracted - Essence: %s, Potency: %.3f, Duration: %.3f"),
 644:            *ExtractedData.PrincipalEssenceTag.ToString(),
 645:            ExtractedData.BasePotency,
 646:            ExtractedData.BaseDuration);
 647: 
 648:     return ExtractedData;
 649: }
 650: 
 651: FExtractedModifierIngredientData UCauldronCraftComponent::ExtractModifierIngredientProperties() const
 652: {
 653:     FExtractedModifierIngredientData ExtractedData;
 654: 
 655:     if (!ModifierIngredient)
 656:     {
 657:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No modifier ingredient found (this is optional)"));
 658:         return ExtractedData;
 659:     }
 660: 
 661:     const UWitchPTInventoryItemFragment_IngredientCraftingProperties* CraftingProps =
 662:         Cast<UWitchPTInventoryItemFragment_IngredientCraftingProperties>(
 663:             ModifierIngredient->FindFragmentByClass(UWitchPTInventoryItemFragment_IngredientCraftingProperties::StaticClass()));
 664: 
 665:     if (!CraftingProps)
 666:     {
 667:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: No crafting properties found"));
 668:         return ExtractedData;
 669:     }
 670: 
 671: 
 672:     ExtractedData.ModifierEffectTags = CraftingProps->ModifierIngredientData.ModifierEffectTags;
 673:     ExtractedData.PotencyModificationValue = CraftingProps->ModifierIngredientData.PotencyModificationValue;
 674:     ExtractedData.DurationModificationValue = CraftingProps->ModifierIngredientData.DurationModificationValue;
 675:     ExtractedData.GrantedPropertyTag = CraftingProps->ModifierIngredientData.GrantedPropertyTag;
 676:     ExtractedData.AddedEffectTag = CraftingProps->ModifierIngredientData.AddedEffectTag;
 677:     ExtractedData.StrengthOfModifier = CraftingProps->ModifierIngredientData.StrengthOfModifier;
 678:     ExtractedData.TierTag = CraftingProps->TierTag;
 679:     ExtractedData.bIsValid = true;
 680: 
 681:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ExtractModifierIngredientProperties: Successfully extracted - Effects: %d, Potency Mod: %.3f, Duration Mod: %.3f"),
 682:            ExtractedData.ModifierEffectTags.Num(),
 683:            ExtractedData.PotencyModificationValue,
 684:            ExtractedData.DurationModificationValue);
 685: 
 686:     return ExtractedData;
 687: }
 688: 
 689: 
 690: 
 691: FPotionResult UCauldronCraftComponent::CalculatePotionProperties() const
 692: {
 693:     FPotionResult PotionResult;
 694: 
 695: 
 696:     if (!CanCraftPotion())
 697:     {
 698:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Cannot craft potion with current ingredients"));
 699:         return PotionResult;
 700:     }
 701: 
 702: 
 703:     FExtractedBaseIngredientData BaseData = ExtractBaseIngredientProperties();
 704:     FExtractedPrincipalIngredientData PrincipalData = ExtractPrincipalIngredientProperties();
 705:     FExtractedModifierIngredientData ModifierData = ExtractModifierIngredientProperties();
 706: 
 707: 
 708:     if (!BaseData.bIsValid || !PrincipalData.bIsValid)
 709:     {
 710:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Required ingredient data is invalid"));
 711:         return PotionResult;
 712:     }
 713: 
 714:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Starting potion calculation..."));
 715: 
 716: 
 717:     PotionResult.BaseLiquidTypeTag = BaseData.BaseLiquidTypeTag;
 718:     PotionResult.FinalCharges = BaseData.DefaultChargesProvided;
 719:     float StabilityFactor = BaseData.StabilityModifier;
 720: 
 721: 
 722:     PotionResult.PotionEssenceTag = PrincipalData.PrincipalEssenceTag;
 723:     PotionResult.FinalPotency = PrincipalData.BasePotency;
 724:     PotionResult.FinalDuration = PrincipalData.BaseDuration;
 725: 
 726: 
 727:     if (PrincipalData.PrincipalEssenceTag.IsValid())
 728:     {
 729:         PotionResult.GrantedEffectTags.AddTag(PrincipalData.PrincipalEssenceTag);
 730:     }
 731: 
 732: 
 733:     if (ModifierData.bIsValid)
 734:     {
 735:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Applying modifier effects..."));
 736: 
 737: 
 738:         PotionResult.FinalPotency *= ModifierData.PotencyModificationValue;
 739: 
 740: 
 741:         PotionResult.FinalDuration += ModifierData.DurationModificationValue;
 742: 
 743: 
 744:         PotionResult.GrantedEffectTags.AppendTags(ModifierData.ModifierEffectTags);
 745: 
 746: 
 747:         if (ModifierData.GrantedPropertyTag.IsValid())
 748:         {
 749:             PotionResult.GrantedPropertyTags.AddTag(ModifierData.GrantedPropertyTag);
 750:         }
 751: 
 752: 
 753:         if (ModifierData.AddedEffectTag.IsValid())
 754:         {
 755:             PotionResult.GrantedEffectTags.AddTag(ModifierData.AddedEffectTag);
 756:         }
 757: 
 758: 
 759:         PotionResult.FinalPotency *= ModifierData.StrengthOfModifier;
 760:     }
 761: 
 762: 
 763:     PotionResult.FinalPotency *= StabilityFactor;
 764: 
 765: 
 766:     PotionResult.PotionTierTag = CalculatePotionTier(BaseData, PrincipalData, ModifierData);
 767: 
 768: 
 769:     PotionResult.FinalPotency = FMath::Max(PotionResult.FinalPotency, 0.1f);
 770:     PotionResult.FinalDuration = FMath::Max(PotionResult.FinalDuration, 1.0f);
 771:     PotionResult.FinalCharges = FMath::Max(PotionResult.FinalCharges, 1);
 772: 
 773: 
 774:     PotionResult.bIsValid = true;
 775: 
 776:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionProperties: Potion calculation complete - Potency: %.2f, Duration: %.2f, Charges: %d"),
 777:            PotionResult.FinalPotency,
 778:            PotionResult.FinalDuration,
 779:            PotionResult.FinalCharges);
 780: 
 781:     return PotionResult;
 782: }
 783: 
 784: FGameplayTag UCauldronCraftComponent::CalculatePotionTier(const FExtractedBaseIngredientData& BaseData,
 785:                                                          const FExtractedPrincipalIngredientData& PrincipalData,
 786:                                                          const FExtractedModifierIngredientData& ModifierData) const
 787: {
 788: 
 789: 
 790: 
 791:     TArray<FGameplayTag> TierTags;
 792: 
 793:     if (BaseData.bIsValid && BaseData.TierTag.IsValid())
 794:     {
 795:         TierTags.Add(BaseData.TierTag);
 796:     }
 797: 
 798:     if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
 799:     {
 800:         TierTags.Add(PrincipalData.TierTag);
 801:     }
 802: 
 803:     if (ModifierData.bIsValid && ModifierData.TierTag.IsValid())
 804:     {
 805:         TierTags.Add(ModifierData.TierTag);
 806:     }
 807: 
 808: 
 809: 
 810:     if (PrincipalData.bIsValid && PrincipalData.TierTag.IsValid())
 811:     {
 812:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using principal ingredient tier: %s"),
 813:                *PrincipalData.TierTag.ToString());
 814:         return PrincipalData.TierTag;
 815:     }
 816: 
 817: 
 818:     if (BaseData.bIsValid && BaseData.TierTag.IsValid())
 819:     {
 820:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CalculatePotionTier: Using base ingredient tier: %s"),
 821:                *BaseData.TierTag.ToString());
 822:         return BaseData.TierTag;
 823:     }
 824: 
 825: 
 826:     UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CalculatePotionTier: No valid tier tags found, returning empty tag"));
 827:     return FGameplayTag();
 828: }
 829: 
 830: 
 831: 
 832: TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GeneratePotionItemDefinition(const FPotionResult& PotionData) const
 833: {
 834:     if (!PotionData.bIsValid)
 835:     {
 836:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Invalid potion data provided"));
 837:         return nullptr;
 838:     }
 839: 
 840:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
 841:     if (!BasePotionItemDefinition)
 842:     {
 843:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: BasePotionItemDefinition is not set"));
 844:         return nullptr;
 845:     }
 846: 
 847: 
 848: 
 849: 
 850:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::GeneratePotionItemDefinition: Returning base potion definition for essence: %s"),
 851:            *PotionData.PotionEssenceTag.ToString());
 852: 
 853:     return BasePotionItemDefinition;
 854: }
 855: 
 856: UWitchPTInventoryItemDefinition* UCauldronCraftComponent::CreatePotionItemDefinitionInstance(const FPotionResult& PotionData) const
 857: {
 858:     if (!PotionData.bIsValid)
 859:     {
 860:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Invalid potion data provided"));
 861:         return nullptr;
 862:     }
 863: 
 864:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
 865:     if (!BasePotionItemDefinition)
 866:     {
 867:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: BasePotionItemDefinition is not set"));
 868:         return nullptr;
 869:     }
 870: 
 871: 
 872:     UWitchPTInventoryItemDefinition* PotionDefinition = NewObject<UWitchPTInventoryItemDefinition>(
 873:         GetTransientPackage(),
 874:         BasePotionItemDefinition
 875:     );
 876: 
 877:     if (!PotionDefinition)
 878:     {
 879:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Failed to create potion definition instance"));
 880:         return nullptr;
 881:     }
 882: 
 883: 
 884:     UWitchPTInventoryItemFragment_PotionProperties* PotionPropsFragment = nullptr;
 885: 
 886: 
 887:     const UWitchPTInventoryItemFragment_PotionProperties* ExistingFragment =
 888:         Cast<UWitchPTInventoryItemFragment_PotionProperties>(
 889:             PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_PotionProperties::StaticClass()));
 890: 
 891:     if (ExistingFragment)
 892:     {
 893: 
 894:         PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
 895: 
 896: 
 897: 
 898:     }
 899:     else
 900:     {
 901: 
 902:         PotionPropsFragment = NewObject<UWitchPTInventoryItemFragment_PotionProperties>(PotionDefinition);
 903: 
 904: 
 905:         PotionDefinition->Fragments.Add(PotionPropsFragment);
 906:     }
 907: 
 908: 
 909:     if (PotionPropsFragment)
 910:     {
 911:         PotionPropsFragment->SetPotionProperties(
 912:             PotionData.PotionEssenceTag,
 913:             PotionData.BaseLiquidTypeTag,
 914:             PotionData.FinalPotency,
 915:             PotionData.FinalDuration,
 916:             PotionData.FinalCharges,
 917:             PotionData.PotionTierTag,
 918:             PotionData.GrantedEffectTags,
 919:             PotionData.GrantedPropertyTags
 920:         );
 921: 
 922:         UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionItemDefinitionInstance: Created potion definition with properties - %s"),
 923:                *PotionData.PotionEssenceTag.ToString());
 924:     }
 925: 
 926:     return PotionDefinition;
 927: }
 928: 
 929: 
 930: 
 931: UWitchPTInventoryItemInstance* UCauldronCraftComponent::CreatePotionInstance(const FPotionResult& PotionData) const
 932: {
 933:     if (!PotionData.bIsValid)
 934:     {
 935:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Invalid potion data provided"));
 936:         return nullptr;
 937:     }
 938: 
 939: 
 940:     UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
 941:     if (!PotionDefinition)
 942:     {
 943:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion definition"));
 944:         return nullptr;
 945:     }
 946: 
 947: 
 948:     UWitchPTInventoryItemInstance* PotionInstance = NewObject<UWitchPTInventoryItemInstance>();
 949:     if (!PotionInstance)
 950:     {
 951:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CreatePotionInstance: Failed to create potion instance"));
 952:         return nullptr;
 953:     }
 954: 
 955: 
 956:     PotionInstance->SetItemDef(PotionDefinition->GetClass());
 957:     PotionInstance->SetTotalStackCount(PotionData.FinalCharges);
 958: 
 959:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CreatePotionInstance: Successfully created potion instance - %s with %d charges"),
 960:            *PotionData.PotionEssenceTag.ToString(),
 961:            PotionData.FinalCharges);
 962: 
 963:     return PotionInstance;
 964: }
 965: 
 966: bool UCauldronCraftComponent::SpawnPotionInWorld(const FPotionResult& PotionData, const FVector& SpawnLocation) const
 967: {
 968:     if (!PotionData.bIsValid)
 969:     {
 970:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Invalid potion data provided"));
 971:         return false;
 972:     }
 973: 
 974:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Attempting to spawn at location: %s"), *SpawnLocation.ToString());
 975:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Cauldron owner location: %s"), *GetOwner()->GetActorLocation().ToString());
 976: 
 977: 
 978:     UWitchPTInventoryItemDefinition* PotionDefinition = CreatePotionItemDefinitionInstance(PotionData);
 979:     if (!PotionDefinition)
 980:     {
 981:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create potion definition"));
 982:         return false;
 983:     }
 984: 
 985: 
 986:     UWorld* World = GetWorld();
 987:     if (!World)
 988:     {
 989:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No valid world found"));
 990:         return false;
 991:     }
 992: 
 993: 
 994:     FActorSpawnParameters SpawnParams;
 995:     SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 996: 
 997:     APotionBase* PotionActor = World->SpawnActor<APotionBase>(SpawnLocation, FRotator::ZeroRotator, SpawnParams);
 998:     FItemManifest ItemManifest;
 999:     ItemManifest.ItemDef = PotionDefinition->GetClass();
1000:     PotionActor->StaticInventory = ItemManifest;
1001:     if (!PotionActor)
1002:     {
1003:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to spawn PotionBase actor"));
1004:         return false;
1005:     }
1006: 
1007:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned PotionBase at: %s"), *PotionActor->GetActorLocation().ToString());
1008: 
1009: 
1010:     const UWitchPTInventoryItemFragment_WorldDetails* WorldDetails =
1011:         Cast<UWitchPTInventoryItemFragment_WorldDetails>(
1012:             PotionDefinition->FindFragmentByClass(UWitchPTInventoryItemFragment_WorldDetails::StaticClass()));
1013: 
1014:     if (WorldDetails && WorldDetails->HasValidWorldMesh())
1015:     {
1016: 
1017:         UStaticMeshComponent* MeshComponent = PotionActor->FindComponentByClass<UStaticMeshComponent>();
1018: 
1019:         if (!MeshComponent)
1020:         {
1021: 
1022:             MeshComponent = NewObject<UStaticMeshComponent>(PotionActor);
1023:             MeshComponent->SetupAttachment(PotionActor->GetRootComponent());
1024:             MeshComponent->RegisterComponent();
1025: 
1026:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Created new StaticMeshComponent for PotionBase"));
1027:         }
1028: 
1029:         if (MeshComponent)
1030:         {
1031: 
1032:             MeshComponent->SetStaticMesh(WorldDetails->WorldStaticMesh);
1033: 
1034: 
1035:             if (WorldDetails->WorldScale != FVector::OneVector)
1036:             {
1037:                 MeshComponent->SetWorldScale3D(WorldDetails->WorldScale);
1038:             }
1039: 
1040: 
1041:             if (WorldDetails->WorldMaterial)
1042:             {
1043:                 MeshComponent->SetMaterial(0, WorldDetails->WorldMaterial);
1044:             }
1045: 
1046: 
1047:             if (!WorldDetails->CollisionProfileName.IsNone())
1048:             {
1049:                 MeshComponent->SetCollisionProfileName(WorldDetails->CollisionProfileName);
1050:             }
1051: 
1052:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Applied mesh '%s' from WorldDetails fragment"),
1053:                    *WorldDetails->WorldStaticMesh->GetName());
1054:         }
1055:         else
1056:         {
1057:             UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Failed to create or find StaticMeshComponent"));
1058:         }
1059:     }
1060:     else
1061:     {
1062:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: No WorldDetails fragment or invalid mesh - using default appearance"));
1063:     }
1064: 
1065: 
1066: 
1067: 
1068: 
1069:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Successfully spawned potion at location: %s"),
1070:            *SpawnLocation.ToString());
1071:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::SpawnPotionInWorld: Potion: %s with %d charges, %.2f potency"),
1072:            *PotionData.PotionEssenceTag.ToString(),
1073:            PotionData.FinalCharges,
1074:            PotionData.FinalPotency);
1075: 
1076:     return true;
1077: }
1078: 
1079: UWitchPTInventoryItemInstance* UCauldronCraftComponent::AddPotionToInventory(const FPotionResult& PotionData, ACharacter* TargetCharacter) const
1080: {
1081:     if (!TargetCharacter)
1082:     {
1083:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter is null"));
1084:         return nullptr;
1085:     }
1086: 
1087:     UWitchPTInventoryItemInstance* PotionInstance = CreatePotionInstance(PotionData);
1088:     if (!PotionInstance)
1089:     {
1090:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Failed to create potion instance"));
1091:         return nullptr;
1092:     }
1093: 
1094: 
1095:     AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(TargetCharacter->GetController());
1096:     if (!PC)
1097:     {
1098:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: TargetCharacter does not have a valid PlayerController"));
1099:         return nullptr;
1100:     }
1101: 
1102:     UWitchPTInventoryManagerComponent* InventoryManager = PC->GetInventoryManager();
1103:     if (!InventoryManager)
1104:     {
1105:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::AddPotionToInventory: Could not get InventoryManager from PlayerController"));
1106:         return nullptr;
1107:     }
1108: 
1109: 
1110: 
1111: 
1112: 
1113: 
1114: 
1115: 
1116: 
1117: 
1118: 
1119: 
1120: 
1121: 
1122:     return nullptr;
1123: }
1124: 
1125: 
1126: 
1127: FPotionResult UCauldronCraftComponent::CraftPotion(bool bAddToInventory, ACharacter* TargetCharacter, const FVector& WorldSpawnLocation)
1128: {
1129:     FPotionResult EmptyResult;
1130: 
1131: 
1132:     if (!GetOwner()->HasAuthority())
1133:     {
1134:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Not authority - crafting not allowed"));
1135:         return EmptyResult;
1136:     }
1137: 
1138: 
1139:     if (!CanPerformCrafting())
1140:     {
1141:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: Cannot perform crafting with current setup"));
1142:         return EmptyResult;
1143:     }
1144: 
1145:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Starting potion crafting process..."));
1146: 
1147: 
1148:     FPotionResult CraftingResult = CalculatePotionProperties();
1149:     if (!CraftingResult.bIsValid)
1150:     {
1151:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to calculate valid potion properties"));
1152:         return EmptyResult;
1153:     }
1154: 
1155: 
1156:     bool bPotionCreatedSuccessfully = false;
1157: 
1158:     if (bAddToInventory)
1159:     {
1160: 
1161:         ACharacter* Target = TargetCharacter;
1162:         if (!Target)
1163:         {
1164: 
1165:             Target = Cast<ACharacter>(GetOwner());
1166:             if (!Target)
1167:             {
1168: 
1169:                 UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CraftPotion: No target character specified for inventory addition"));
1170:                 return EmptyResult;
1171:             }
1172:         }
1173: 
1174:         UWitchPTInventoryItemInstance* CreatedInstance = AddPotionToInventory(CraftingResult, Target);
1175:         bPotionCreatedSuccessfully = (CreatedInstance != nullptr);
1176:     }
1177:     else
1178:     {
1179: 
1180:         FVector CauldronLocation = GetOwner()->GetActorLocation();
1181:         FVector SpawnLoc;
1182: 
1183:         if (WorldSpawnLocation != FVector::ZeroVector)
1184:         {
1185: 
1186:             SpawnLoc = WorldSpawnLocation;
1187:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Using specified spawn location: %s"), *SpawnLoc.ToString());
1188:         }
1189:         else
1190:         {
1191: 
1192:             FRotator CauldronRotation = GetOwner()->GetActorRotation();
1193:             FVector ForwardOffset = CauldronRotation.RotateVector(FVector(150.0f, 0.0f, 0.0f));
1194:             FVector UpOffset = FVector(0.0f, 0.0f, 50.0f);
1195:             SpawnLoc = CauldronLocation + ForwardOffset + UpOffset;
1196: 
1197:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Cauldron location: %s"), *CauldronLocation.ToString());
1198:             UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Calculated spawn location: %s"), *SpawnLoc.ToString());
1199:         }
1200: 
1201:         bPotionCreatedSuccessfully = SpawnPotionInWorld(CraftingResult, SpawnLoc);
1202:     }
1203: 
1204:     if (!bPotionCreatedSuccessfully)
1205:     {
1206:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CraftPotion: Failed to create/spawn potion"));
1207:         return EmptyResult;
1208:     }
1209: 
1210: 
1211:     CraftedPotion = CraftingResult;
1212:     ClearIngredientSlots();
1213: 
1214:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::CraftPotion: Successfully crafted potion - %s with potency %.2f"),
1215:            *CraftingResult.PotionEssenceTag.ToString(),
1216:            CraftingResult.FinalPotency);
1217: 
1218:     return CraftingResult;
1219: }
1220: 
1221: 
1222: 
1223: bool UCauldronCraftComponent::CanPerformCrafting() const
1224: {
1225: 
1226:     if (!CanCraftPotion())
1227:     {
1228:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::CanPerformCrafting: Basic crafting requirements not met"));
1229:         return false;
1230:     }
1231: 
1232: 
1233:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition = GetBasePotionItemDefinition();
1234:     if (!BasePotionItemDefinition)
1235:     {
1236:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::CanPerformCrafting: BasePotionItemDefinition is not set"));
1237:         return false;
1238:     }
1239: 
1240: 
1241: 
1242: 
1243: 
1244: 
1245: 
1246:     return true;
1247: }
1248: 
1249: void UCauldronCraftComponent::ClearIngredientSlots()
1250: {
1251:     if (!GetOwner()->HasAuthority())
1252:     {
1253:         UE_LOG(LogTemp, Warning, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Not authority"));
1254:         return;
1255:     }
1256: 
1257:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: Clearing all ingredient slots"));
1258: 
1259: 
1260:     if (BaseIngredient)
1261:     {
1262:         BaseIngredient = nullptr;
1263:         BaseIngredientIcon = nullptr;
1264:         BroadcastBaseIngredientIconSet();
1265:     }
1266: 
1267: 
1268:     if (PrincipalIngredient)
1269:     {
1270:         PrincipalIngredient = nullptr;
1271:         PrincipalIngredientIcon = nullptr;
1272:         BroadcastPrincipalIngredientIconSet();
1273:     }
1274: 
1275: 
1276:     if (ModifierIngredient)
1277:     {
1278:         ModifierIngredient = nullptr;
1279:         ModifierIngredientIcon = nullptr;
1280:         BroadcastModifierIngredientIconSet();
1281:     }
1282: 
1283: 
1284:     CraftedPotion = FPotionResult();
1285: 
1286:     UE_LOG(LogTemp, Log, TEXT("UCauldronCraftComponent::ClearIngredientSlots: All ingredient slots cleared"));
1287: }
1288: 
1289: 
1290: 
1291: void UCauldronCraftComponent::DebugTestCrafting()
1292: {
1293:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON DEBUG TEST CRAFTING ==="));
1294: 
1295: 
1296:     PrintIngredientDebugData();
1297: 
1298: 
1299:     UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING CALCULATIONS ---"));
1300:     FPotionResult TestResult = CalculatePotionProperties();
1301: 
1302:     if (TestResult.bIsValid)
1303:     {
1304:         UE_LOG(LogTemp, Warning, TEXT("CALCULATION SUCCESS: %s Potion - Potency: %.2f, Duration: %.2f, Charges: %d"),
1305:                *TestResult.PotionEssenceTag.ToString(),
1306:                TestResult.FinalPotency,
1307:                TestResult.FinalDuration,
1308:                TestResult.FinalCharges);
1309:     }
1310:     else
1311:     {
1312:         UE_LOG(LogTemp, Error, TEXT("CALCULATION FAILED: Invalid potion result"));
1313:     }
1314: 
1315: 
1316:     UE_LOG(LogTemp, Warning, TEXT("--- TESTING CRAFTING VALIDATION ---"));
1317:     bool bCanCraft = CanCraftPotion();
1318:     bool bCanPerform = CanPerformCrafting();
1319: 
1320:     UE_LOG(LogTemp, Warning, TEXT("Can Craft Potion: %s"), bCanCraft ? TEXT("YES") : TEXT("NO"));
1321:     UE_LOG(LogTemp, Warning, TEXT("Can Perform Crafting: %s"), bCanPerform ? TEXT("YES") : TEXT("NO"));
1322: 
1323:     if (bCanPerform)
1324:     {
1325:         UE_LOG(LogTemp, Warning, TEXT("--- ATTEMPTING WORLD SPAWN CRAFT ---"));
1326: 
1327:         FPotionResult CraftResult = CraftPotion(false, nullptr, FVector::ZeroVector);
1328: 
1329:         if (CraftResult.bIsValid)
1330:         {
1331:             UE_LOG(LogTemp, Warning, TEXT("CRAFTING SUCCESS: Potion created and spawned near cauldron"));
1332:         }
1333:         else
1334:         {
1335:             UE_LOG(LogTemp, Error, TEXT("CRAFTING FAILED: No valid result"));
1336:         }
1337:     }
1338:     else
1339:     {
1340:         UE_LOG(LogTemp, Error, TEXT("CRAFTING VALIDATION FAILED: Cannot perform crafting"));
1341:     }
1342: 
1343:     UE_LOG(LogTemp, Warning, TEXT("=== END DEBUG TEST ==="));
1344: }
1345: 
1346: 
1347: 
1348: TSubclassOf<UWitchPTInventoryItemDefinition> UCauldronCraftComponent::GetBasePotionItemDefinition() const
1349: {
1350: 
1351:     ACauldronAltar* CauldronOwner = Cast<ACauldronAltar>(GetOwner());
1352:     if (!CauldronOwner)
1353:     {
1354:         UE_LOG(LogTemp, Error, TEXT("UCauldronCraftComponent::GetBasePotionItemDefinition: Owner is not a CauldronAltar"));
1355:         return nullptr;
1356:     }
1357: 
1358:     return CauldronOwner->BasePotionItemDefinition;
1359: }

================
File: Source/WitchPT/Private/Item/Ritual/RitualFunctionLibrary.cpp
================
 1: #include "Item/Ritual/RitualFunctionLibrary.h"
 2: 
 3: #include "Kismet/GameplayStatics.h"
 4: #include "Player/WitchPTPlayerState.h"
 5: #include "UI/HUD/WitchPTHUD.h"
 6: #include "UI/WidgetControllers/CauldronWidgetController.h"
 7: #include "UI/WidgetControllers/WitchPTWidgetController.h"
 8: 
 9: URitualWidgetController* URitualFunctionLibrary::SetRitualWidgetController(const UObject* WorldContextObject)
10: {
11: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
12: 	{
13: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
14: 		{
15: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
16: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
17: 			UAttributeSet* AS = PS->GetAttributeSet();
18: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
19: 
20: 			return WitchPTHUD->SetRitualWidgetController(WCParams);
21: 		}
22: 	}
23: 	return nullptr;
24: }
25: 
26: UCauldronWidgetController* URitualFunctionLibrary::SetCauldronWidgetController(const UObject* WorldContextObject)
27: {
28: 	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
29: 	{
30: 		if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD()))
31: 		{
32: 			AWitchPTPlayerState* PS = PC->GetPlayerState<AWitchPTPlayerState>();
33: 			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
34: 			UAttributeSet* AS = PS->GetAttributeSet();
35: 			const FWidgetControllerParams WCParams = FWidgetControllerParams(PC, PS,ASC, AS);
36: 			return WitchPTHUD->SetCauldronWidgetController(WCParams);
37: 		}
38: 	}
39: 	return nullptr;
40: }

================
File: Source/WitchPT/Private/Item/RitualPosition.cpp
================
  1: #include "Item/RitualPosition.h"
  2: #include "Net/UnrealNetwork.h"
  3: #include "GameFramework/Character.h"
  4: #include "Item/RitualAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "AbilitySystemComponent.h"
  7: #include "AbilitySystemBlueprintLibrary.h"
  8: #include "FWitchPTGameplayTags.h"
  9: #include "GameplayEffect.h"
 10: #include "GameFramework/CharacterMovementComponent.h"
 11: #include "Components/CapsuleComponent.h"
 12: #include "Kismet/GameplayStatics.h"
 13: #include "Character/Components/WitchPTMechanicComponent.h"
 14: 
 15: 
 16: ARitualPosition::ARitualPosition()
 17: {
 18: 
 19: }
 20: 
 21: void ARitualPosition::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 22: {
 23: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 24: 
 25: 	DOREPLIFETIME(ARitualPosition, RitualAltar);
 26: }
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: 
 34: 
 35: 
 36: 
 37: void ARitualPosition::BeginPlay()
 38: {
 39: 	Super::BeginPlay();
 40: 
 41: 
 42: 
 43: }
 44: 
 45: 
 46: void ARitualPosition::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 47: {
 48: 	Super::GatherInteractionOptions(InteractQuery, OptionBuilder);
 49: 
 50: 
 51: 
 52: 
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 
 60: 
 61: 
 62: 
 63: 
 64: 
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 
 73: 
 74: 
 75: 
 76: 
 77: 
 78: 
 79: 
 80: 
 81: 
 82: 
 83: 
 84: 
 85: }
 86: 
 87: ARitualAltar* ARitualPosition::GetRitualAltarActor_Implementation() const
 88: {
 89: 	if (RitualAltar)
 90: 	{
 91: 		return RitualAltar;
 92: 	}
 93: 	return nullptr;
 94: }
 95: 
 96: bool ARitualPosition::IsOccupied_Implementation()
 97: {
 98: 	return bIsOccupied;
 99: }
100: 
101: 
102: void ARitualPosition::HandleInteraction(ACharacter* InteractingCharacter)
103: {
104: 	Super::HandleInteraction(InteractingCharacter);
105: 
106: 	if (!InteractingCharacter || !RitualAltar)
107: 	{
108: 		return;
109: 	}
110: 
111: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/QuickBarWidgetController.cpp
================
 1: #include "UI/WidgetControllers/QuickBarWidgetController.h"
 2: 
 3: #include "Character/WitchPTCharacter.h"
 4: #include "Equipment/WitchPTEquipmentManagerComponent.h"
 5: #include "Equipment/WitchPTQuickBarComponent.h"
 6: #include "GameFramework/Character.h"
 7: #include "Inventory/WitchPTInventoryItemInstance.h"
 8: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
 9: #include "Player/WitchPTPlayerController.h"
10: #include "Subsystems/WidgetCommunicatorSubsystem.h"
11: 
12: void UQuickBarWidgetController::BroadcastInitialValues()
13: {
14: 
15: }
16: 
17: void UQuickBarWidgetController::BindCallbacksToDependencies()
18: {
19: 
20: 	if (AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController))
21: 	{
22: 
23: 		if (UWitchPTQuickBarComponent* QuickBarComponent = WitchPtPlayerController->GetQuickBarComponent())
24: 		{
25: 			QuickBarComponent->OnActiveSlotChanged.AddDynamic(this, &UQuickBarWidgetController::OnActiveSlotChanged);
26: 		}
27: 	}
28: 
29: 
30: 
31: 	if (ULocalPlayer* LocalPlayer = PlayerController->GetLocalPlayer())
32: 	{
33: 		if (UWidgetCommunicatorSubsystem* WidgetCommunicator = LocalPlayer->GetSubsystem<UWidgetCommunicatorSubsystem>())
34: 		{
35: 			WidgetCommunicator->OnItemDraggedDelegate.AddDynamic(this, &UQuickBarWidgetController::OnEquipableItemDragStart);
36: 		}
37: 	}
38: 
39: }
40: 
41: void UQuickBarWidgetController::AddItemToQuickBarSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* ItemInstance)
42: {
43: 	if (ItemInstance != nullptr)
44: 	{
45: 		if (AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController))
46: 		{
47: 			WitchPtPlayerController->GetQuickBarComponent()->AddItemToSlot(SlotIndex, ItemInstance);
48: 
49: 
50: 		}
51: 	}
52: 
53: }
54: 
55: void UQuickBarWidgetController::OnActiveSlotChanged(int32 NewActiveSlotIndex)
56: {
57: 	OnActiveSlotChangedDelegate.Broadcast(NewActiveSlotIndex);
58: }
59: 
60: void UQuickBarWidgetController::OnEquipableItemDragStart(const UWitchPTInventoryItemInstance* ItemInstance)
61: {
62: 	if (ItemInstance != nullptr)
63: 	{
64: 
65: 		const UWitchPTInventoryItemFragment_EquippableItem* EquipableFragment =
66: 			Cast<UWitchPTInventoryItemFragment_EquippableItem>(
67: 				ItemInstance->FindFragmentByClass(UWitchPTInventoryItemFragment_EquippableItem::StaticClass()));
68: 		if (EquipableFragment)
69: 		{
70: 			OnEquipableItemDragStartDelegate.Broadcast();
71: 		}
72: 
73: 
74: 	}
75: }

================
File: Source/WitchPT/Public/Equipment/WitchPTQuickBarComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Components/ActorComponent.h"
 5: #include "WitchPTQuickBarComponent.generated.h"
 6: 
 7: 
 8: class UWitchPTInventoryItemInstance;
 9: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnActiveSlotChangedSignature, int32, NewActiveSlotIndex);
10: UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
11: class WITCHPT_API UWitchPTQuickBarComponent : public UActorComponent
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 
17: 	UWitchPTQuickBarComponent();
18: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
19: 
20: 	UFUNCTION(Server, Reliable, BlueprintCallable, Category="QuickBar")
21: 	void SetActiveSlotIndex(int32 NewIndex);
22: 
23: 	virtual void BeginPlay() override;
24: 
25: 	UFUNCTION()
26: 	void AddItemToSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* Item);
27: 
28: 
29: 	FOnActiveSlotChangedSignature OnActiveSlotChanged;
30: 
31: private:
32: 	void EquipItemInSlot();
33: 	void UnequipItemInSlot();
34: 
35: protected:
36: 	UPROPERTY()
37: 	int32 NumSlots = 4;
38: 
39: 	UFUNCTION()
40: 	void OnRep_Slots();
41: 
42: 	UFUNCTION()
43: 	void OnRep_ActiveSlotIndex();
44: 
45: private:
46: 	UPROPERTY(ReplicatedUsing=OnRep_Slots, VisibleAnywhere, Category="QuickBar")
47: 	TArray<TObjectPtr<UWitchPTInventoryItemInstance>> Slots;
48: 
49: 	UPROPERTY(ReplicatedUsing=OnRep_ActiveSlotIndex, VisibleAnywhere, Category="QuickBar")
50: 	int32 ActiveSlotIndex = -1;
51: 
52: 	UPROPERTY(VisibleAnywhere, Category="QuickBar")
53: 	TObjectPtr<UWitchPTInventoryItemInstance> EquippedItem;
54: 
55: };

================
File: Source/WitchPT/Public/Inventory/Collectable.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "UObject/Interface.h"
 7: #include "UObject/ObjectPtr.h"
 8: #include "Collectable.generated.h"
 9: template <typename InterfaceType> class TScriptInterface;
10: 
11: 
12: class AActor;
13: class UWitchPTInventoryItemDefinition;
14: class UWitchPTInventoryItemInstance;
15: class UWitchPTInventoryManagerComponent;
16: class UObject;
17: struct FFrame;
18: 
19: USTRUCT(BlueprintType)
20: struct FItemManifest
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 	UPROPERTY(EditAnywhere)
26: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
27: };
28: 
29: 
30: UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
31: class UCollectable : public UInterface
32: {
33: 	GENERATED_BODY()
34: };
35: 
36: 
37: 
38: 
39: class WITCHPT_API ICollectable
40: {
41: 	GENERATED_BODY()
42: 
43: public:
44: 
45: 
46: 
47: 	UFUNCTION(BlueprintCallable)
48: 	virtual FItemManifest GetPickupInventory() const = 0;
49: };
50: 
51: UCLASS()
52: class UCollectableStatics : public UBlueprintFunctionLibrary
53: {
54: 	GENERATED_BODY()
55: 
56: public:
57: 	UCollectableStatics();
58: 
59: 	UFUNCTION(BlueprintPure)
60: 	static TScriptInterface<ICollectable> GetFirstPickupableFromActor(AActor* Actor);
61: 
62: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
63: 	static void AddPickupToInventory(UWitchPTInventoryManagerComponent* InventoryComponent, TScriptInterface<ICollectable> Collectable);
64: };

================
File: Source/WitchPT/Public/Item/Ritual/RitualFunctionLibrary.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Kismet/BlueprintFunctionLibrary.h"
 5: #include "UI/WidgetControllers/CauldronWidgetController.h"
 6: #include "RitualFunctionLibrary.generated.h"
 7: 
 8: class UWitchPTWidgetController;
 9: class URitualWidgetController;
10: 
11: 
12: 
13: UCLASS()
14: class WITCHPT_API URitualFunctionLibrary : public UBlueprintFunctionLibrary
15: {
16: 	GENERATED_BODY()
17: public:
18: 	UFUNCTION(Category="Ritual")
19: 	static URitualWidgetController* SetRitualWidgetController(const UObject* WorldContextObject);
20: 	UFUNCTION(Category="Cauldron")
21: 	static UCauldronWidgetController* SetCauldronWidgetController(const UObject* WorldContextObject);
22: };

================
File: Source/WitchPT/WitchPT.Build.cs
================
 1: using UnrealBuildTool;
 2: 
 3: public class WitchPT : ModuleRules
 4: {
 5: 	public WitchPT(ReadOnlyTargetRules Target) : base(Target)
 6: 	{
 7: 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
 8: 
 9: 		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "GameplayAbilities", "UMG"  });
10: 
11: 		PrivateDependencyModuleNames.AddRange(new string[] { "GameplayTags", "GameplayTasks", "NavigationSystem", "Niagara", "NetCore" });
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 	}
21: }

================
File: Source/WitchPT/Public/Item/RitualPosition.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Item/BaseInteractionPosition.h"
 5: #include "GameplayTagContainer.h"
 6: #include "MechanicsInterface.h"
 7: #include "PositionInterface.h"
 8: #include "RitualPosition.generated.h"
 9: 
10: 
11: class ARitualAltar;
12: class UAbilitySystemComponent;
13: struct FGameplayAbilitySpec;
14: class AController;
15: class UGameplayAbility;
16: class UBoxComponent;
17: class ACharacter;
18: 
19: UCLASS()
20: class WITCHPT_API ARitualPosition : public ABaseInteractionPosition, public IPositionInterface
21: {
22: 	GENERATED_BODY()
23: 
24: public:
25: 
26: 	ARitualPosition();
27: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
28: 
29: 
30: 	virtual void BeginPlay() override;
31: 
32: 
33: 
34: 	virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
35: 
36: 
37: 
38: 	virtual ARitualAltar* GetRitualAltarActor_Implementation() const override;
39: 
40: 
41: 	void SetRitualAltar(ARitualAltar* Altar) { RitualAltar = Altar; }
42: 	virtual bool IsOccupied_Implementation() override;
43: 
44: protected:
45: 
46: 	UPROPERTY(EditInstanceOnly, Replicated)
47: 	TObjectPtr<ARitualAltar> RitualAltar;
48: 
49: 
50: 	virtual void HandleInteraction(ACharacter* InteractingCharacter) override;
51: 
52: private:
53: 
54: 
55: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/QuickBarWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "QuickBarWidgetController.generated.h"
 6: 
 7: class UWitchPTInventoryItemInstance;
 8: class UWitchPTQuickBarComponent;
 9: 
10: 
11: 
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnQuickBarSlotChangedSignature, int32, NewActiveSlotIndex);
13: DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEquipableItemDragStartSignature);
14: UCLASS(BlueprintType, Blueprintable)
15: class WITCHPT_API UQuickBarWidgetController : public UWitchPTWidgetController
16: {
17: 	GENERATED_BODY()
18: public:
19: 	virtual void BroadcastInitialValues() override;
20: 	virtual void BindCallbacksToDependencies() override;
21: 
22: 
23: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
24: 	void AddItemToQuickBarSlot(int32 SlotIndex, UWitchPTInventoryItemInstance* ItemInstance);
25: 
26: 
27: 	UPROPERTY(BlueprintAssignable, Category = "QuickBar")
28: 	FOnQuickBarSlotChangedSignature OnActiveSlotChangedDelegate;
29: 	UPROPERTY(BlueprintAssignable, Category = "QuickBar")
30: 	FOnEquipableItemDragStartSignature OnEquipableItemDragStartDelegate;
31: 
32: 
33: protected:
34: 	UFUNCTION()
35: 	void OnActiveSlotChanged(int32 NewActiveSlotIndex);
36: 
37: 
38: private:
39: 	UFUNCTION()
40: 	void OnEquipableItemDragStart(const UWitchPTInventoryItemInstance* ItemInstance);
41: 
42: 
43: 
44: };

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryItemInstance.cpp
================
 1: #include "Inventory/WitchPTInventoryItemInstance.h"
 2: 
 3: #include "GameplayTagContainer.h"
 4: #include "Inventory/WitchPTInventoryItemDefinition.h"
 5: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
 6: #include "Net/UnrealNetwork.h"
 7: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryItemInstance)
 8: class FLifetimeProperty;
 9: UWitchPTInventoryItemInstance::UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
10: 	:Super(ObjectInitializer)
11: {
12: }
13: 
14: void UWitchPTInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
15: {
16: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
17: 
18: 	DOREPLIFETIME(ThisClass, ItemDef);
19: 	DOREPLIFETIME(ThisClass, TotalStackCount);
20: }
21: 
22: 
23: 
24: void UWitchPTInventoryItemInstance::SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef)
25: {
26: 	ItemDef = InDef;
27: }
28: 
29: 
30: const UWitchPTInventoryItemFragment* UWitchPTInventoryItemInstance::FindFragmentByClass(
31: 	TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const
32: {
33: 	if ((ItemDef != nullptr) && (FragmentClass != nullptr))
34: 	{
35: 		return GetDefault<UWitchPTInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
36: 	}
37: 
38: 	return nullptr;
39: }

================
File: Source/WitchPT/Public/Character/WitchPTCharacter.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTCharacterBase.h"
 5: #include "Item/CauldronAltar.h"
 6: #include "Item/MechanicsInterface.h"
 7: #include "Blueprint/UserWidget.h"
 8: #include "Components/WidgetComponent.h"
 9: #include "UObject/ConstructorHelpers.h"
10: #include "WitchPTCharacter.generated.h"
11: 
12: class UWitchPTEquipmentManagerComponent;
13: class UWitchPTMechanicComponent;
14: class ACauldronAltar;
15: class ARitualPosition;
16: 
17: UCLASS()
18: class WITCHPT_API AWitchPTCharacter : public AWitchPTCharacterBase
19: {
20: 	GENERATED_BODY()
21: 
22: public:
23: 
24: 	AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer);
25: 	virtual void PossessedBy(AController* NewController) override;
26: 	virtual void OnRep_PlayerState() override;
27: 
28: 	UWitchPTEquipmentManagerComponent* GetEquipmentManager() const { return EquipmentManagerComponent; }
29: 
30: 
31: 	virtual void InitAbilityActorInfo() override;
32: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
33: 	TObjectPtr<UWitchPTMechanicComponent> MechanicComponent;
34: 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
35: 	TObjectPtr<UWitchPTEquipmentManagerComponent> EquipmentManagerComponent;
36: 
37: 
38: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/CauldronWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "CauldronWidgetController.generated.h"
 6: 
 7: class ACauldronAltar;
 8: class UWitchPTInventoryItemInstance;
 9: 
10: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBaseIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, BaseIngredientIcon);
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
13: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPrincipalIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, PrincipalIngredientIcon);
14: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientSetSignature_WC, UWitchPTInventoryItemInstance*, IngredientInstance);
15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnModifierIngredientIconSetSignature_WC, TSubclassOf<UUserWidget>, ModifierIngredientIcon);
16: 
17: 
18: 
19: UCLASS(BlueprintType, Blueprintable)
20: class WITCHPT_API UCauldronWidgetController : public UWitchPTWidgetController
21: {
22: 	GENERATED_BODY()
23: public:
24: 	UCauldronWidgetController();
25: 	virtual void BroadcastInitialValues() override;
26: 	virtual void BindCallbacksToDependencies() override;
27: 	void UnbindCallbacksFromDependencies();
28: 
29: 
30: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
31: 	FOnBaseIngredientSetSignature_WC OnBaseIngredientSet;
32: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
33: 	FOnBaseIngredientIconSetSignature_WC OnBaseIngredientIconSet;
34: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
35: 	FOnPrincipalIngredientSetSignature_WC OnPrincipalIngredientSet;
36: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
37: 	FOnPrincipalIngredientIconSetSignature_WC OnPrincipalIngredientIconSet;
38: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
39: 	FOnModifierIngredientSetSignature_WC OnModifierIngredientSet;
40: 	UPROPERTY(BlueprintAssignable, Category = "Cauldron")
41: 	FOnModifierIngredientIconSetSignature_WC OnModifierIngredientIconSet;
42: 
43: 	UFUNCTION(Category = "Cauldron")
44: 	void SetCauldronAltar(ACauldronAltar* InCauldronAltar);
45: 
46: 
47: 	UFUNCTION(BlueprintPure, Category = "Cauldron")
48: 	ACauldronAltar* GetCauldronAltar() const { return CauldronAltar; }
49: 
50: 
51: protected:
52: 
53: 	UPROPERTY(BlueprintReadOnly, Category = "Cauldron")
54: 	TObjectPtr<ACauldronAltar> CauldronAltar;
55: 
56: 	UFUNCTION(Category = "Cauldron")
57: 	void HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
58: 	UFUNCTION(Category = "Cauldron")
59: 	void HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon);
60: 	UFUNCTION(Category = "Cauldron")
61: 	void HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
62: 	UFUNCTION(Category = "Cauldron")
63: 	void HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon);
64: 	UFUNCTION(Category = "Cauldron")
65: 	void HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance);
66: 	UFUNCTION(Category = "Cauldron")
67: 	void HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon);
68: };

================
File: Source/WitchPT/Private/Character/WitchPTCharacter.cpp
================
 1: #include "Character/WitchPTCharacter.h"
 2: 
 3: #include "AbilitySystemComponent.h"
 4: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
 5: #include "AbilitySystem/WitchPTAttributeSet.h"
 6: #include "Character/Components/WitchPTMechanicComponent.h"
 7: #include "Equipment/WitchPTEquipmentManagerComponent.h"
 8: #include "Item/RitualAltar.h"
 9: #include "Item/RitualPosition.h"
10: #include "Player/WitchPTPlayerController.h"
11: #include "Player/WitchPTPlayerState.h"
12: #include "UI/HUD/WitchPTHUD.h"
13: #include "WitchPT/WitchPT.h"
14: 
15: 
16: 
17: AWitchPTCharacter::AWitchPTCharacter(const class FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
18: {
19: 
20: 	PrimaryActorTick.bCanEverTick = true;
21: 
22: 	MechanicComponent = CreateDefaultSubobject<UWitchPTMechanicComponent>(TEXT("MechanicComponent"));
23: 
24: 	EquipmentManagerComponent = CreateDefaultSubobject<UWitchPTEquipmentManagerComponent>(TEXT("EquipmentManagerComponent"));
25: 
26: }
27: 
28: void AWitchPTCharacter::PossessedBy(AController* NewController)
29: {
30: 	Super::PossessedBy(NewController);
31: 
32: 
33: 	InitAbilityActorInfo();
34: 
35: 
36: 
37: 	if (AbilitySystemComponent)
38: 	{
39: 		GrantStartupAbilities();
40: 		AddStartupEffects();
41: 	}
42: }
43: 
44: void AWitchPTCharacter::OnRep_PlayerState()
45: {
46: 	Super::OnRep_PlayerState();
47: 
48: 	InitAbilityActorInfo();
49: 	AddStartupEffects();
50: }
51: 
52: void AWitchPTCharacter::InitAbilityActorInfo()
53: {
54: 	Super::InitAbilityActorInfo();
55: 	AWitchPTPlayerState* WitchPtPlayerState = GetPlayerState<AWitchPTPlayerState>();
56: 
57: 	if (!WitchPtPlayerState)
58: 	{
59: 		return;
60: 	}
61: 
62: 	WitchPtPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(WitchPtPlayerState, this);
63: 
64: 	AbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(WitchPtPlayerState->GetAbilitySystemComponent());
65: 	if (!AbilitySystemComponent)
66: 	{
67: 		return;
68: 	}
69: 
70: 	AbilitySystemComponent->AbilityActorInfoHaveBeenSet();
71: 	AttributeSet = Cast<UWitchPTAttributeSet>( WitchPtPlayerState->GetAttributeSet());
72: 
73: 
74: 
75: 
76: 
77: 
78: 
79: 	if (AWitchPTPlayerController* WitchPT_PC = Cast<AWitchPTPlayerController>(GetController()))
80: 	{
81: 		if (AWitchPTHUD* WitchPT_HUD = Cast<AWitchPTHUD>(WitchPT_PC->GetHUD()))
82: 		{
83: 
84: 
85: 
86: 
87: 
88: 		}
89: 	}
90: 	InitializeDefaultAttributes();
91: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/InventoryWidgetController.cpp
================
  1: #include "UI/WidgetControllers/InventoryWidgetController.h"
  2: 
  3: #include "Equipment/WitchPTEquipmentManagerComponent.h"
  4: #include "GameFramework/Character.h"
  5: #include "Inventory/WitchPTInventoryItemInstance.h"
  6: #include "Inventory/WitchPTInventoryManagerComponent.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment_EquippableItem.h"
  8: #include "Player/WitchPTPlayerController.h"
  9: #include "Subsystems/WidgetCommunicatorSubsystem.h"
 10: 
 11: class UWitchPTEquipmentInstance;
 12: class UWitchPTEquipmentManagerComponent;
 13: 
 14: void UInventoryWidgetController::BindCallbacksToDependencies()
 15: {
 16: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 17: 	if (WitchPtPlayerController)
 18: 	{
 19: 		UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 20: 		if (InventoryManager)
 21: 		{
 22: 			InventoryManager->OnItemAdded.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 23: 			{
 24: 				OnItemAddedDelegate.Broadcast(ItemAdded);
 25: 			});
 26: 			InventoryManager->OnItemStackChanged.AddLambda([this](UWitchPTInventoryItemInstance* ItemAdded)
 27: 			{
 28: 				OnItemStackChangedDelegate.Broadcast(ItemAdded);
 29: 			});
 30: 			InventoryManager->OnItemRemoved.AddLambda([this](UWitchPTInventoryItemInstance* ItemRemoved)
 31: 			{
 32: 				OnItemRemovedDelegate.Broadcast(ItemRemoved);
 33: 			});
 34: 		}
 35: 	}
 36: }
 37: 
 38: void UInventoryWidgetController::RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
 39: {
 40: 	if (!ItemInstance)
 41: 	{
 42: 		return;
 43: 	}
 44: 
 45: 	AWitchPTPlayerController* WitchPtPlayerController = Cast<AWitchPTPlayerController>(PlayerController);
 46: 	if (!WitchPtPlayerController)
 47: 	{
 48: 		return;
 49: 	}
 50: 
 51: 	UWitchPTInventoryManagerComponent* InventoryManager = WitchPtPlayerController->GetInventoryManager();
 52: 	if (!InventoryManager)
 53: 	{
 54: 		return;
 55: 	}
 56: 
 57: 	const int32 CurrentStackCount = ItemInstance->GetTotalStackCount();
 58: 
 59: 
 60: 	if (CurrentStackCount <= 1 && AmountToRemove >= 1)
 61: 	{
 62: 		InventoryManager->Server_RemoveItemInstance(ItemInstance);
 63: 	}
 64: 	else
 65: 	{
 66: 
 67: 		InventoryManager->Server_RemoveItemStacks(ItemInstance, AmountToRemove);
 68: 	}
 69: }
 70: 
 71: void UInventoryWidgetController::OnItemDragStart(UWitchPTInventoryItemInstance* ItemInstance)
 72: {
 73: 
 74: 	if (ULocalPlayer* LocalPlayer = PlayerController->GetLocalPlayer())
 75: 	{
 76: 		if (UWidgetCommunicatorSubsystem* WidgetCommunicator = LocalPlayer->GetSubsystem<UWidgetCommunicatorSubsystem>())
 77: 		{
 78: 			WidgetCommunicator->OnItemDragged(ItemInstance);
 79: 		}
 80: 	}
 81: 	else
 82: 	{
 83: 		UE_LOG(LogTemp, Warning, TEXT("WidgetCommunicatorSubsystem not found in the world!"));
 84: 	}
 85: }
 86: 
 87: void UInventoryWidgetController::EquipItem(UWitchPTInventoryItemInstance* ItemInstance)
 88: {
 89: 	if (ItemInstance)
 90: 	{
 91: 		ACharacter* OwningCharacter = Cast<ACharacter>(PlayerController->GetPawn());
 92: 		if (OwningCharacter)
 93: 		{
 94: 			UWitchPTEquipmentManagerComponent* EquipmentManager = OwningCharacter->FindComponentByClass<UWitchPTEquipmentManagerComponent>();
 95: 			if (EquipmentManager)
 96: 			{
 97: 				UWitchPTEquipmentInstance* EquipmentInstance = EquipmentManager->FindEquipmentByInventoryItem(ItemInstance);
 98: 				if (EquipmentInstance)
 99: 				{
100: 					EquipmentManager->UnequipItem(EquipmentInstance);
101: 				}
102: 				else
103: 				{
104: 					const UWitchPTInventoryItemFragment* BaseFragment = ItemInstance->FindFragmentByClass(UWitchPTInventoryItemFragment_EquippableItem::StaticClass());
105: 					const UWitchPTInventoryItemFragment_EquippableItem* EquippableFragment = Cast<const UWitchPTInventoryItemFragment_EquippableItem>(BaseFragment);
106: 					EquipmentManager->EquipItem(EquippableFragment->EquipmentDefinition);
107: 				}
108: 			}
109: 		}
110: 		else
111: 		{
112: 			UE_LOG(LogTemp, Warning, TEXT("Owning character is not a valid ACharacter instance."));
113: 		}
114: 	}
115: }

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryItemInstance.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Systems/GameplayTagStack.h"
 5: #include "Templates/SubclassOf.h"
 6: #include "WitchPTInventoryItemInstance.generated.h"
 7: class UWitchPTInventoryItemFragment;
 8: class UWitchPTInventoryItemDefinition;
 9: struct FFrame;
10: struct FGameplayTag;
11: 
12: 
13: 
14: 
15: UCLASS(BlueprintType)
16: class WITCHPT_API UWitchPTInventoryItemInstance : public UObject
17: {
18: 	GENERATED_BODY()
19: public:
20: 	UWitchPTInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
21: 	friend struct FWitchPTInventoryList;
22: 
23: 
24: 	virtual bool IsSupportedForNetworking() const override { return true; }
25: 
26: 
27: 
28: 	UFUNCTION(BlueprintCallable)
29: 	int32 GetTotalStackCount() const { return TotalStackCount; }
30: 
31: 	void SetTotalStackCount(int32 Count) { TotalStackCount = Count; }
32: 	UFUNCTION(BlueprintCallable)
33: 	TSubclassOf<UWitchPTInventoryItemDefinition> GetItemDef() const
34: 	{
35: 		return ItemDef;
36: 	}
37: 
38: 	UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
39: 	const UWitchPTInventoryItemFragment* FindFragmentByClass(TSubclassOf<UWitchPTInventoryItemFragment> FragmentClass) const;
40: 
41: 	template <typename ResultClass>
42: 	const ResultClass* FindFragmentByClass() const
43: 	{
44: 		return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
45: 	}
46: 
47: 	void SetItemDef(TSubclassOf<UWitchPTInventoryItemDefinition> InDef);
48: 
49: 
50: private:
51: 	UPROPERTY(Replicated)
52: 	int32 TotalStackCount{0};
53: 
54: 	UPROPERTY(Replicated)
55: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef;
56: 
57: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/InventoryWidgetController.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "WitchPTWidgetController.h"
 5: #include "InventoryWidgetController.generated.h"
 6: 
 7: class UWitchPTInventoryItemInstance;
 8: 
 9: 
10: 
11: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemAddedSignature, UWitchPTInventoryItemInstance*, ItemAdded);
12: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemovedSignature, UWitchPTInventoryItemInstance*, ItemRemoved);
13: 
14: UCLASS(BlueprintType, Blueprintable)
15: class WITCHPT_API UInventoryWidgetController : public UWitchPTWidgetController
16: {
17: 	GENERATED_BODY()
18: 
19: public:
20: 	UFUNCTION(BlueprintCallable)
21: 	virtual void BindCallbacksToDependencies() override;
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 	UFUNCTION(BlueprintCallable, Category = "Inventory")
30: 	void RemoveItemStack(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove = 1);
31: 
32: 	UFUNCTION(BlueprintCallable, Category= "UI Utils")
33: 	void OnItemDragStart(UWitchPTInventoryItemInstance* ItemInstance);
34: 
35: 	UFUNCTION(BlueprintCallable, Category = "Equipment")
36: 	void EquipItem(UWitchPTInventoryItemInstance* ItemInstance);
37: 
38: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
39: 	FOnItemAddedSignature OnItemAddedDelegate;
40: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
41: 	FOnItemAddedSignature OnItemStackChangedDelegate;
42: 	UPROPERTY(BlueprintAssignable, Category="Inventory")
43: 	FOnItemRemovedSignature OnItemRemovedDelegate;
44: };

================
File: Source/WitchPT/Private/UI/WidgetControllers/CauldronWidgetController.cpp
================
 1: #include "UI/WidgetControllers/CauldronWidgetController.h"
 2: 
 3: #include "Item/CauldronAltar.h"
 4: #include "Item/Components/CauldronCraftComponent.h"
 5: 
 6: UCauldronWidgetController::UCauldronWidgetController()
 7: {
 8: }
 9: 
10: void UCauldronWidgetController::BroadcastInitialValues()
11: {
12: 	if(CauldronAltar)
13: 	{
14: 		OnBaseIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredient());
15: 		OnBaseIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetBaseIngredientIcon());
16: 		OnPrincipalIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredient());
17: 		OnPrincipalIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetPrincipalIngredientIcon());
18: 		OnModifierIngredientSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredient());
19: 		OnModifierIngredientIconSet.Broadcast(CauldronAltar->CauldronCraftComponent->GetModifierIngredientIcon());
20: 	}
21: 
22: }
23: 
24: void UCauldronWidgetController::BindCallbacksToDependencies()
25: {
26: 	Super::BindCallbacksToDependencies();
27: 	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
28: 	{
29: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
30: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
31: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
32: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
33: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
34: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.AddDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
35: 	}
36: }
37: 
38: void UCauldronWidgetController::UnbindCallbacksFromDependencies()
39: {
40: 	if(CauldronAltar && CauldronAltar->CauldronCraftComponent)
41: 	{
42: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientSet);
43: 		CauldronAltar->CauldronCraftComponent->OnBaseIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleBaseIngredientIconSet);
44: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientSet);
45: 		CauldronAltar->CauldronCraftComponent->OnPrincipalIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandlePrincipalIngredientIconSet);
46: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientSet);
47: 		CauldronAltar->CauldronCraftComponent->OnModifierIngredientIconSetDelegate.RemoveDynamic(this, &UCauldronWidgetController::HandleModifierIngredientIconSet);
48: 	}
49: }
50: void UCauldronWidgetController::SetCauldronAltar(ACauldronAltar* InCauldronAltar)
51: {
52: 	if (InCauldronAltar != nullptr)
53: 	{
54: 		CauldronAltar = InCauldronAltar;
55: 	}
56: 
57: }
58: 
59: void UCauldronWidgetController::HandleBaseIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
60: {
61: 	OnBaseIngredientSet.Broadcast(IngredientInstance);
62: }
63: 
64: void UCauldronWidgetController::HandleBaseIngredientIconSet(TSubclassOf<UUserWidget> BaseIngredientIcon)
65: {
66: 	OnBaseIngredientIconSet.Broadcast(BaseIngredientIcon);
67: }
68: 
69: void UCauldronWidgetController::HandlePrincipalIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
70: {
71: 	OnPrincipalIngredientSet.Broadcast(IngredientInstance);
72: }
73: 
74: void UCauldronWidgetController::HandlePrincipalIngredientIconSet(TSubclassOf<UUserWidget> PrincipalIngredientIcon)
75: {
76: 	OnPrincipalIngredientIconSet.Broadcast(PrincipalIngredientIcon);
77: }
78: 
79: void UCauldronWidgetController::HandleModifierIngredientSet(UWitchPTInventoryItemInstance* IngredientInstance)
80: {
81: 	OnModifierIngredientSet.Broadcast(IngredientInstance);
82: }
83: 
84: void UCauldronWidgetController::HandleModifierIngredientIconSet(TSubclassOf<UUserWidget> ModifierIngredientIcon)
85: {
86: 	OnModifierIngredientIconSet.Broadcast(ModifierIngredientIcon);
87: }

================
File: Source/WitchPT/Public/FWitchPTGameplayTags.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: 
  6: 
  7: 
  8: 
  9: 
 10: 
 11: 
 12: struct FWitchPTGameplayTags
 13: {
 14: public:
 15: 	static FWitchPTGameplayTags& Get() { return GameplayTags; }
 16: 	static void InitializeGameplayTags();
 17: 
 18: 
 19: 
 20: 
 21: 
 22: 	FGameplayTag Attributes_Primary_Health;
 23: 	FGameplayTag Attributes_Primary_Age;
 24: 	FGameplayTag Attributes_Secondary_Mana;
 25: 	FGameplayTag Attributes_Secondary_Stamina;
 26: 
 27: 	FGameplayTag Character_State_Movement_Sprinting;
 28: 	FGameplayTag Character_State_Movement_Crouching;
 29: 	FGameplayTag Character_State_Movement_MovingToPosition;
 30: 	FGameplayTag Character_State_Dead;
 31: 	FGameplayTag Character_State_Aim;
 32: 	FGameplayTag Character_State_Blocked;
 33: 
 34: 	FGameplayTag Character_State_Cauldron_InPosition;
 35: 	FGameplayTag Character_State_Cauldron_Carrying;
 36: 	FGameplayTag Character_State_Cauldron_Placing;
 37: 	FGameplayTag Character_State_Cauldron_InGame;
 38: 	FGameplayTag Character_State_Cauldron_BrewingPotion;
 39: 
 40: 	FGameplayTag Character_State_Ritual_InPosition;
 41: 	FGameplayTag Character_State_Ritual_InGame;
 42: 
 43: 
 44: 	FGameplayTag Ability_Interact;
 45: 	FGameplayTag Ability_Sprint;
 46: 	FGameplayTag Ability_Jump;
 47: 	FGameplayTag Ability_Crouch;
 48: 	FGameplayTag Ability_Ritual_GoToPosition;
 49: 	FGameplayTag Ability_Ritual_ParticipatingInRitual;
 50: 	FGameplayTag Ability_Ritual_CancelParticipatingInRitual;
 51: 	FGameplayTag Ability_Ritual_Start;
 52: 	FGameplayTag Ability_Ritual_SendInput;
 53: 
 54: 
 55: 
 56: 
 57: 
 58: 
 59: 	FGameplayTag Ability_Cauldron_ParticipatingInCauldron;
 60: 	FGameplayTag Ability_Cauldron_CancelParticipatingInCauldron;
 61: 	FGameplayTag Ability_Cauldron_CarryingCauldron;
 62: 	FGameplayTag Ability_Cauldron_LookingForPlaceCauldron;
 63: 	FGameplayTag Ability_Cauldron_SetInPlace;
 64: 	FGameplayTag Ability_Cauldron_CancelSetInPlace;
 65: 
 66: 
 67: 
 68: 
 69: 
 70: 
 71: 
 72: 	FGameplayTag InputTag_LMB;
 73: 	FGameplayTag InputTag_RMB;
 74: 	FGameplayTag InputTag_1;
 75: 	FGameplayTag InputTag_2;
 76: 	FGameplayTag InputTag_3;
 77: 	FGameplayTag InputTag_4;
 78: 	FGameplayTag InputTag_5;
 79: 	FGameplayTag InputTag_6;
 80: 	FGameplayTag InputTag_7;
 81: 	FGameplayTag InputTag_8;
 82: 	FGameplayTag InputTag_9;
 83: 	FGameplayTag InputTag_0;
 84: 	FGameplayTag InputTag_Ctrl;
 85: 	FGameplayTag InputTag_Alt;
 86: 	FGameplayTag InputTag_Shift;
 87: 	FGameplayTag InputTag_Tab;
 88: 
 89: 	FGameplayTag UI_Layer_Game;
 90: 	FGameplayTag UI_Layer_GameMenu;
 91: 	FGameplayTag UI_Layer_Menu;
 92: 	FGameplayTag UI_Layer_Modal;
 93: 
 94: 
 95: 
 96: 	FGameplayTag Ritual_Position_1;
 97: 	FGameplayTag Ritual_Position_2;
 98: 	FGameplayTag Ritual_Position_3;
 99: 	FGameplayTag Ritual_Position_4;
100: 
101: 	FGameplayTag Ritual_Input_Up;
102: 	FGameplayTag Ritual_Input_Down;
103: 	FGameplayTag Ritual_Input_Left;
104: 	FGameplayTag Ritual_Input_Right;
105: 
106: 
107: 	FGameplayTag Event_Ritual_InputSuccess;
108: 	FGameplayTag Event_Ritual_InputFailure;
109: 	FGameplayTag Event_Ritual_SequenceSuccess;
110: 	FGameplayTag Event_Ritual_SequenceFailure;
111: 	FGameplayTag Event_Ritual_CatastrophicFailure;
112: 
113: 
114: 
115: 
116: 	FGameplayTag Event_Ritual_InputReceived;
117: 	FGameplayTag Event_Ritual_TurnAdvanced;
118: 	FGameplayTag Event_Ritual_SequenceFail;
119: 	FGameplayTag Event_Ritual_CatastrophicFail;
120: 
121: 
122: 	FGameplayTag Cauldron_State_Empty;
123: 	FGameplayTag Cauldron_State_Full;
124: 	FGameplayTag Cauldron_State_PotionReady;
125: 	FGameplayTag Event_Cauldron_CharacterPositioned;
126: 
127: 
128: 
129: 	FGameplayTag Communication_Message;
130: 
131: 
132: 	FGameplayTag Item;
133: 	FGameplayTag Item_Consumable;
134: 	FGameplayTag Item_Consumable_Potion;
135: 	FGameplayTag Item_Consumable_Potion_Tier_0;
136: 	FGameplayTag Item_Consumable_Potion_Tier_1;
137: 	FGameplayTag Item_Consumable_Potion_Tier_2;
138: 	FGameplayTag Item_Consumable_Potion_Tier_3;
139: 
140: 	FGameplayTag Item_Consumable_Ingredient;
141: 	FGameplayTag Item_Consumable_Ingredient_Tier_0;
142: 	FGameplayTag Item_Consumable_Ingredient_Tier_1;
143: 	FGameplayTag Item_Consumable_Ingredient_Tier_2;
144: 	FGameplayTag Item_Consumable_Ingredient_Tier_3;
145: 
146: 
147: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot;
148: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot;
149: 	FGameplayTag Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot;
150: 
151: 	FGameplayTag Item_Consumable_Ingredient_Category_Base;
152: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water;
153: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil;
154: 	FGameplayTag Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood;
155: 
156: 
157: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal;
158: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Herbal;
159: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Mineral;
160: 	FGameplayTag Item_Consumable_Ingredient_Category_Principal_Animal;
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier;
169: 
170: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float;
171: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage;
172: 
173: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float;
174: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage;
175: 
176: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float;
177: 
178: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Self;
179: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Other;
180: 	FGameplayTag Item_Consumable_Ingredient_Category_Modifier_Target_Area;
181: 
182: 
183: 
184: 
185: 
186: private:
187: 	static FWitchPTGameplayTags GameplayTags;
188: 
189: 
190: };

================
File: Source/WitchPT/Public/FWitchPTGameplayTags.cpp
================
  1: #include "FWitchPTGameplayTags.h"
  2: 
  3: #include "GameplayTagsManager.h"
  4: 
  5: FWitchPTGameplayTags FWitchPTGameplayTags::GameplayTags;
  6: 
  7: void FWitchPTGameplayTags::InitializeGameplayTags()
  8: {
  9: 	GameplayTags.Attributes_Primary_Health = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Health"));
 10: 	GameplayTags.Attributes_Primary_Age = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Age"));
 11: 	GameplayTags.Attributes_Secondary_Mana = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Mana"));
 12: 	GameplayTags.Attributes_Secondary_Stamina = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Attributes.Vital.Stamina"));
 13: 	GameplayTags.Character_State_Movement_Sprinting = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Sprinting"));
 14: 	GameplayTags.Character_State_Movement_Crouching = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.Crouching"));
 15: 	GameplayTags.Character_State_Movement_MovingToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Movement.MovingToPosition"));
 16: 	GameplayTags.Character_State_Dead = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Dead"));
 17: 	GameplayTags.Character_State_Aim = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Aim"));
 18: 	GameplayTags.Character_State_Blocked = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Blocked"));
 19: 	GameplayTags.Character_State_Cauldron_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InPosition"));
 20: 	GameplayTags.Character_State_Cauldron_Carrying = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Carrying"));
 21: 	GameplayTags.Character_State_Cauldron_Placing = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.Placing"));
 22: 	GameplayTags.Character_State_Cauldron_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.InGame"));
 23: 	GameplayTags.Character_State_Cauldron_BrewingPotion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Cauldron.BrewingPotion"));
 24: 	GameplayTags.Character_State_Ritual_InPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InPosition"));
 25: 	GameplayTags.Character_State_Ritual_InGame = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Character.State.Ritual.InGame"));
 26: 
 27: 	GameplayTags.Ability_Interact = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Interact"));
 28: 	GameplayTags.Ability_Sprint = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Sprint"));
 29: 	GameplayTags.Ability_Jump = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Jump"));
 30: 	GameplayTags.Ability_Crouch = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Crouch"));
 31: 
 32: 	GameplayTags.Ability_Ritual_GoToPosition = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.GoToPosition"));
 33: 	GameplayTags.Ability_Ritual_ParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.ParticipatingInRitual"));
 34: 	GameplayTags.Ability_Ritual_CancelParticipatingInRitual = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.CancelParticipatingInRitual"));
 35: 	GameplayTags.Ability_Ritual_Start = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.Start"));
 36: 	GameplayTags.Ability_Ritual_SendInput = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Ritual.SendInput"));
 37: 
 38: 	GameplayTags.Ability_Cauldron_ParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.ParticipatingInCauldron"));
 39: 	GameplayTags.Ability_Cauldron_CancelParticipatingInCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelParticipatingInCauldron"));
 40: 	GameplayTags.Ability_Cauldron_CarryingCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CarryingCauldron"));
 41: 	GameplayTags.Ability_Cauldron_LookingForPlaceCauldron = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.LookingForPlaceCauldron"));
 42: 	GameplayTags.Ability_Cauldron_SetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.SetInPlace"));
 43: 	GameplayTags.Ability_Cauldron_CancelSetInPlace = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ability.Cauldron.CancelSetInPlace"));
 44: 	GameplayTags.Event_Cauldron_CharacterPositioned = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Cauldron.CharacterPositioned"));
 45: 
 46: 
 47: 
 48: 
 49: 	GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.LMB"));
 50: 	GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.RMB"));
 51: 	GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.1"));
 52: 	GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.2"));
 53: 	GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.3"));
 54: 	GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.4"));
 55: 	GameplayTags.InputTag_5 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.5"));
 56: 	GameplayTags.InputTag_6 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.6"));
 57: 	GameplayTags.InputTag_7 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.7"));
 58: 	GameplayTags.InputTag_8 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.8"));
 59: 	GameplayTags.InputTag_9 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.9"));
 60: 	GameplayTags.InputTag_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.0"));
 61: 	GameplayTags.InputTag_Ctrl = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Ctrl"));
 62: 	GameplayTags.InputTag_Alt = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Alt"));
 63: 	GameplayTags.InputTag_Shift = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Shift"));
 64: 	GameplayTags.InputTag_Tab = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("InputTag.Tab"));
 65: 
 66: 	GameplayTags.UI_Layer_Game = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Game"));
 67: 	GameplayTags.UI_Layer_GameMenu = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.GameMenu"));
 68: 	GameplayTags.UI_Layer_Menu = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Menu"));
 69: 	GameplayTags.UI_Layer_Modal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("UI.Layer.Modal"));
 70: 
 71: 	GameplayTags.Ritual_Position_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.1"));
 72: 	GameplayTags.Ritual_Position_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.2"));
 73: 	GameplayTags.Ritual_Position_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.3"));
 74: 	GameplayTags.Ritual_Position_4 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Position.4"));
 75: 
 76: 	GameplayTags.Ritual_Input_Up = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Up"));
 77: 	GameplayTags.Ritual_Input_Down = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Down"));
 78: 	GameplayTags.Ritual_Input_Left = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Left"));
 79: 	GameplayTags.Ritual_Input_Right = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Ritual.Input.Right"));
 80: 
 81: 
 82: 	GameplayTags.Event_Ritual_InputSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputSuccess"));
 83: 	GameplayTags.Event_Ritual_InputFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputFailure"));
 84: 	GameplayTags.Event_Ritual_SequenceSuccess = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceSuccess"));
 85: 	GameplayTags.Event_Ritual_SequenceFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.SequenceFailure"));
 86: 	GameplayTags.Event_Ritual_CatastrophicFailure = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.CatastrophicFailure"));
 87: 	GameplayTags.Event_Ritual_InputReceived = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.InputReceived"));
 88: 	GameplayTags.Event_Ritual_TurnAdvanced = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Event.Ritual.TurnAdvanced"));
 89: 
 90: 
 91: 
 92: 	GameplayTags.Cauldron_State_Empty = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Empty"));
 93: 	GameplayTags.Cauldron_State_Full = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.Full"));
 94: 	GameplayTags.Cauldron_State_PotionReady = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Cauldron.State.PotionReady"));
 95: 
 96: 
 97: 
 98: 
 99: 	GameplayTags.Communication_Message = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Communication.Message"));
100: 
101: 
102: 	GameplayTags.Item = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item"));
103: 	GameplayTags.Item_Consumable = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable"));
104: 	GameplayTags.Item_Consumable_Potion = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion"));
105: 	GameplayTags.Item_Consumable_Potion_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_0"));
106: 	GameplayTags.Item_Consumable_Potion_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_1"));
107: 	GameplayTags.Item_Consumable_Potion_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_2"));
108: 	GameplayTags.Item_Consumable_Potion_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Potion.Tier_3"));
109: 
110: 	GameplayTags.Item_Consumable_Ingredient = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient"));
111: 	GameplayTags.Item_Consumable_Ingredient_Tier_0 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_0"));
112: 	GameplayTags.Item_Consumable_Ingredient_Tier_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_1"));
113: 	GameplayTags.Item_Consumable_Ingredient_Tier_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_2"));
114: 	GameplayTags.Item_Consumable_Ingredient_Tier_3 = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Tier_3"));
115: 
116: 
117: 
118: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_BaseSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.BaseSlot"));
119: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_PrincipalSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.PrincipalSlot"));
120: 	GameplayTags.Item_Consumable_Ingredient_CanBeUsedIn_ModifierSlot = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.CanBeUsedIn.ModifierSlot"));
121: 
122: 
123: 	GameplayTags.Item_Consumable_Ingredient_Category_Base = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base"));
124: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Water = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Water"));
125: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Oil = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Oil"));
126: 	GameplayTags.Item_Consumable_Ingredient_Category_Base_LiquidSolvent_Blood = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Base.LiquidSolvent.Blood"));
127: 
128: 
129: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal"));
130: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Herbal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Herbal"));
131: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Mineral = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Mineral"));
132: 	GameplayTags.Item_Consumable_Ingredient_Category_Principal_Animal = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Principal.Animal"));
133: 
134: 
135: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier"));
136: 
137: 
138: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Float"));
139: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Potency_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Potency.Increase.Percentage"));
140: 
141: 
142: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Float"));
143: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Duration_Increase_Percentage = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Duration.Increase.Percentage"));
144: 
145: 
146: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Charges_Increase_Float = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Charges.Increase.Float"));
147: 
148: 
149: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Self = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Self"));
150: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Other = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Other"));
151: 	GameplayTags.Item_Consumable_Ingredient_Category_Modifier_Target_Area = UGameplayTagsManager::Get().AddNativeGameplayTag(FName("Item.Consumable.Ingredient.Category.Modifier.Target.Area"));
152: 
153: }

================
File: Source/WitchPT/Public/UI/HUD/WitchPTHUD.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/HUD.h"
  5: #include "WitchPTHUD.generated.h"
  6: 
  7: class UWitchPTPrimaryLayout;
  8: class UQuickBarWidgetController;
  9: class UCauldronWidgetController;
 10: class UWitchPTWidgetController;
 11: class URitualWidgetController;
 12: class UAbilitySystemComponent;
 13: class UAttributeSet;
 14: class UWitchPTUserWidget;
 15: class UInventoryWidgetController;
 16: struct FWidgetControllerParams;
 17: class UOverlayWidgetController;
 18: 
 19: 
 20: 
 21: UCLASS()
 22: class WITCHPT_API AWitchPTHUD : public AHUD
 23: {
 24: 	GENERATED_BODY()
 25: public:
 26: 
 27: 
 28: 	virtual void BeginPlay() override;
 29: 
 30: 	UPROPERTY(VisibleAnywhere)
 31: 	TArray<UUserWidget*> GameMenuWidgets;
 32: 	UFUNCTION(BlueprintCallable)
 33: 	UWitchPTUserWidget* GetMenuWidgetByCass(TSubclassOf<UWitchPTUserWidget> WidgetClass);
 34: 	UOverlayWidgetController* SetOverlayWidgetController(const FWidgetControllerParams& WCParams);
 35: 	UInventoryWidgetController* SetInventoryWidgetController(const FWidgetControllerParams& WCParams);
 36: 	URitualWidgetController* SetRitualWidgetController(const FWidgetControllerParams& WCParams);
 37: 	UCauldronWidgetController* SetCauldronWidgetController(const FWidgetControllerParams& WCParams);
 38: 	UQuickBarWidgetController* SetQuickBarWidgetController(const FWidgetControllerParams& WCParams);
 39: 
 40: 
 41: 	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 42: 	void InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 43: 	void InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 44: 	void InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 45: 	void InitQuickBarWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);
 46: 	UFUNCTION(BlueprintCallable)
 47: 	void ToggleGameMenu(TSubclassOf<UWitchPTUserWidget> WidgetClass);
 48: 
 49: 	void ShowOverlayWidget();
 50: 	void HideOverlayWidget();
 51: 	void ShowRitualWidget(class ARitualAltar* RitualAltar);
 52: 	void HideRitualWidget();
 53: 	void ShowInventoryWidget();
 54: 	void HideInventoryWidget();
 55: 	void ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar);
 56: 	void HideCauldronWithInventory();
 57: 
 58: 
 59: 
 60: 	UWitchPTPrimaryLayout* GetPrimaryLayout() const { return PrimaryLayout; }
 61: 
 62: 
 63: 
 64: 
 65: private:
 66: 
 67: 	UPROPERTY()
 68: 	TObjectPtr<UWitchPTPrimaryLayout> PrimaryLayout;
 69: 	UPROPERTY(EditAnywhere)
 70: 	TSubclassOf<UWitchPTUserWidget> PrimaryLayoutClass;
 71: 
 72: 	UPROPERTY()
 73: 	TObjectPtr<UWitchPTUserWidget> QuickBarUserWidget;
 74: 	UPROPERTY(EditAnywhere)
 75: 	TSubclassOf<UWitchPTUserWidget> QuickBarUserWidgetClass;
 76: 
 77: 	UPROPERTY()
 78: 	TObjectPtr<UWitchPTUserWidget> OverlayWidget;
 79: 	UPROPERTY(EditAnywhere)
 80: 	TSubclassOf<UWitchPTUserWidget> OverlayWidgetClass;
 81: 
 82: 	UPROPERTY()
 83: 	TObjectPtr<UWitchPTUserWidget> InventoryWidget;
 84: 	UPROPERTY(EditAnywhere)
 85: 	TSubclassOf<UWitchPTUserWidget> InventoryWidgetClass;
 86: 
 87: 	UPROPERTY()
 88: 	TObjectPtr<UWitchPTUserWidget> CauldronWidget;
 89: 	UPROPERTY(EditAnywhere)
 90: 	TSubclassOf<UWitchPTUserWidget> CauldronWidgetClass;
 91: 	bool bCauldronWidgetVisible = false;
 92: 
 93: 	UPROPERTY()
 94: 	TObjectPtr<UWitchPTUserWidget> RitualWidget;
 95: 	UPROPERTY(EditAnywhere)
 96: 	TSubclassOf<UWitchPTUserWidget> RitualWidgetClass;
 97: 
 98: 
 99: 
100: 	UPROPERTY()
101: 	TObjectPtr<UQuickBarWidgetController> QuickBarWidgetController;
102: 	UPROPERTY(EditAnywhere)
103: 	TSubclassOf<UQuickBarWidgetController> QuickBarWidgetControllerClass;
104: 
105: 	UPROPERTY()
106: 	TObjectPtr<UOverlayWidgetController> OverlayWidgetController;
107: 	UPROPERTY(EditAnywhere)
108: 	TSubclassOf<UOverlayWidgetController> OverlayWidgetControllerClass;
109: 
110: 	UPROPERTY()
111: 	TObjectPtr<UInventoryWidgetController> InventoryWidgetController;
112: 	UPROPERTY(EditAnywhere)
113: 	TSubclassOf<UInventoryWidgetController> InventoryWidgetControllerClass;
114: 
115: 	UPROPERTY()
116: 	TObjectPtr<URitualWidgetController> RitualWidgetController;
117: 	UPROPERTY(EditAnywhere)
118: 	TSubclassOf<URitualWidgetController> RitualWidgetControllerClass;
119: 
120: 	UPROPERTY()
121: 	TObjectPtr<UCauldronWidgetController> CauldronWidgetController;
122: 	UPROPERTY(EditAnywhere)
123: 	TSubclassOf<UCauldronWidgetController> CauldronWidgetControllerClass;
124: };

================
File: Source/WitchPT/Private/Item/BaseInteractableAltar.cpp
================
  1: #include "Item/BaseInteractableAltar.h"
  2: 
  3: #include "FWitchPTGameplayTags.h"
  4: #include "Item/BaseInteractionPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Item/RitualAltar.h"
  8: #include "Item/RitualPosition.h"
  9: 
 10: 
 11: ABaseInteractableAltar::ABaseInteractableAltar()
 12: {
 13: 
 14:     PrimaryActorTick.bCanEverTick = true;
 15: 
 16: 
 17:     bReplicates = true;
 18:     bAlwaysRelevant = true;
 19: 
 20:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_1);
 21:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_2);
 22:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_3);
 23:     TagsPositions.Add(FWitchPTGameplayTags::Get().Ritual_Position_4);
 24: 
 25: }
 26: 
 27: void ABaseInteractableAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 28: {
 29:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 30: 
 31:     DOREPLIFETIME(ABaseInteractableAltar, CurrentState);
 32:     DOREPLIFETIME(ABaseInteractableAltar, ParticipatingPlayers);
 33:     DOREPLIFETIME(ABaseInteractableAltar, PlayerPositionTags);
 34:     DOREPLIFETIME(ABaseInteractableAltar, InteractionPositions);
 35: 
 36: }
 37: 
 38: 
 39: void ABaseInteractableAltar::BeginPlay()
 40: {
 41:     Super::BeginPlay();
 42: 
 43: 
 44:     CreateAltarPositions();
 45: }
 46: 
 47: 
 48: void ABaseInteractableAltar::Tick(float DeltaTime)
 49: {
 50:     Super::Tick(DeltaTime);
 51: 
 52: 
 53: }
 54: 
 55: 
 56: 
 57: void ABaseInteractableAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 58: {
 59:     if (!Player || !Position || !HasAuthority())
 60:     {
 61:         return;
 62:     }
 63: 
 64:     Position->SetOccupied(nullptr);
 65: 
 66: 
 67:     ParticipatingPlayers.Remove(Player);
 68: 
 69: }
 70: void ABaseInteractableAltar::CreateAltarPositions()
 71: {
 72:     if (!HasAuthority() || !PositionClass)
 73:     {
 74:         return;
 75:     }
 76: 
 77: 
 78:     DestroyAltarPositions();
 79: 
 80:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Creating %d brewing positions"), PositionTransforms.Num());
 81:     int positionIndex = 0;
 82: 
 83:     for (const FTransform& PosTransform : PositionTransforms)
 84:     {
 85: 
 86:         FTransform WorldTransform = PosTransform * GetActorTransform();
 87: 
 88: 
 89:         FVector Location = WorldTransform.GetLocation();
 90:         FRotator Rotation = WorldTransform.Rotator();
 91: 
 92: 
 93:         FActorSpawnParameters SpawnParams;
 94:         SpawnParams.Owner = this;
 95:         SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
 96: 
 97: 
 98:         ABaseInteractionPosition* NewPosition = GetWorld()->SpawnActor<ABaseInteractionPosition>(
 99:             PositionClass,
100:             Location,
101:             Rotation,
102:             SpawnParams);
103: 
104:         if (NewPosition)
105:         {
106: 
107: 
108: 
109:             NewPosition->SetPositionTag(TagsPositions[positionIndex]);
110:             ARitualPosition* RitualPosition = Cast<ARitualPosition>(NewPosition);
111:             if (RitualPosition)
112:             {
113:                 RitualPosition->SetRitualAltar(Cast<ARitualAltar>(this));
114:             }
115:             positionIndex++;
116: 
117: 
118: 
119:             InteractionPositions.Add(NewPosition);
120: 
121:             UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CreateBrewingPositions: Created position at %s"), *Location.ToString());
122:         }
123:     }
124: }
125: 
126: 
127: 
128: void ABaseInteractableAltar::DestroyAltarPositions()
129: {
130: 
131:     if (!HasAuthority())
132:     {
133:         return;
134:     }
135: 
136: 
137:     for (ABaseInteractionPosition* Position : InteractionPositions)
138:     {
139:         if (Position)
140:         {
141:             Position->Destroy();
142:         }
143:     }
144: 
145: 
146:     InteractionPositions.Empty();
147: 
148:     UE_LOG(LogTemp, Log, TEXT("Altar::DestroyAltarPositions: All altar positions destroyed"));
149: }
150: 
151: 
152: void ABaseInteractableAltar::Multicast_OnStateChanged_Implementation(EInteractionState NewState)
153: {
154: 
155:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] State changed to %d"), static_cast<int32>(NewState));
156: }
157: 
158: void ABaseInteractableAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
159: {
160: 
161:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input success feedback for player %s"), *Character->GetName());
162: }
163: 
164: void ABaseInteractableAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
165: {
166: 
167:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Input failed feedback for player %s"), *Character->GetName());
168: }
169: 
170: 
171: 
172: void ABaseInteractableAltar::OnRep_ParticipatingPlayers()
173: {
174: 
175: }
176: 
177: 
178: void ABaseInteractableAltar::HandleInputSuccess(ACharacter* Player)
179: {
180: 
181:     UE_LOG(LogTemp, Log, TEXT("[BaseInteractableAltar] Handling successful input from %s"), *Player->GetName());
182: }
183: 
184: void ABaseInteractableAltar::HandleInputFailure(ACharacter* Player)
185: {
186: 
187: }
188: 
189: void ABaseInteractableAltar::CheckState()
190: {
191: 
192: 
193: }
194: 
195: void ABaseInteractableAltar::CleanupInteraction()
196: {
197: 
198: }
199: 
200: void ABaseInteractableAltar::SpawnReward()
201: {
202: 
203: }
204: 
205: void ABaseInteractableAltar::SpawnDemon()
206: {
207: 
208: }
209: 
210: bool ABaseInteractableAltar::IsPlayerEligibleForInteraction(ACharacter* Player) const
211: {
212: 
213: 
214:     return Player && ParticipatingPlayers.Contains(Player);
215: }

================
File: Source/WitchPT/Public/Item/BaseInteractableAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/Actor.h"
  5: #include "GameplayTagContainer.h"
  6: #include "BaseInteractableAltar.generated.h"
  7: 
  8: class UWitchPTUserWidget;
  9: class ABaseInteractionPosition;
 10: class ACharacter;
 11: 
 12: 
 13: 
 14: 
 15: UENUM(BlueprintType)
 16: enum class EInteractionState : uint8
 17: {
 18:     Inactive    UMETA(DisplayName = "Inactive"),
 19:     WaitingForPlayers UMETA(DisplayName = "Waiting For Players"),
 20:     Preparing   UMETA(DisplayName = "Preparing"),
 21:     Active      UMETA(DisplayName = "Active"),
 22:     Succeeded   UMETA(DisplayName = "Succeeded"),
 23:     Failed      UMETA(DisplayName = "Failed"),
 24:     FailedCatastrophically UMETA(DisplayName = "Failed Catastrophically")
 25: };
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInteractionCompleted, bool, bWasSuccessful);
 28: DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInputReceived, ACharacter*, Character, bool, bWasCorrect);
 29: 
 30: 
 31: USTRUCT(BlueprintType)
 32: struct FPlayerPositionTagEntry
 33: {
 34:     GENERATED_BODY();
 35: 
 36:     UPROPERTY(BlueprintReadWrite)
 37:     TObjectPtr<ACharacter> Player = nullptr;
 38: 
 39:     UPROPERTY(BlueprintReadWrite)
 40:     FGameplayTag PositionTag;
 41: };
 42: 
 43: 
 44: 
 45: 
 46: UCLASS(Abstract)
 47: class WITCHPT_API ABaseInteractableAltar : public AActor
 48: {
 49:     GENERATED_BODY()
 50: 
 51: public:
 52: 
 53:     ABaseInteractableAltar();
 54:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 55: 
 56: 
 57:     UPROPERTY(Replicated, BlueprintReadOnly, Category = "Interaction|State")
 58:     EInteractionState CurrentState = EInteractionState::Inactive;
 59: 
 60: 
 61:     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Altar|Positions", meta = (MakeEditWidget = true))
 62:     TArray<FTransform> PositionTransforms;
 63: 
 64: 
 65:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Brewing")
 66:     TSubclassOf<ABaseInteractionPosition> PositionClass;
 67: 
 68:     UPROPERTY(EditDefaultsOnly, Category = "Ritual|Config")
 69:     TArray<FGameplayTag> TagsPositions;
 70: 
 71: 
 72:     UPROPERTY(ReplicatedUsing = OnRep_ParticipatingPlayers, BlueprintReadWrite, VisibleAnywhere, Category = "Interaction")
 73:     TArray<TObjectPtr<ACharacter>> ParticipatingPlayers;
 74: 
 75: 
 76: 
 77:     UPROPERTY(Replicated, EditAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 78:     TArray<TObjectPtr<ABaseInteractionPosition>> InteractionPositions;
 79: 
 80:     UPROPERTY(Replicated, VisibleAnywhere, BlueprintReadWrite, Category = "Interaction|Setup")
 81:     TArray<FPlayerPositionTagEntry> PlayerPositionTags;
 82: 
 83: 
 84: 
 85:     virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
 86: 
 87: 
 88:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 89:     virtual void CreateAltarPositions();
 90: 
 91: 
 92:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
 93:     virtual void DestroyAltarPositions();
 94: 
 95: 
 96: 
 97: 
 98:     UFUNCTION(NetMulticast, Reliable)
 99:     void Multicast_OnStateChanged(EInteractionState NewState);
100: 
101:     UFUNCTION(NetMulticast, Reliable)
102:     virtual void Multicast_OnInputSuccess(ACharacter* Character);
103: 
104:     UFUNCTION(NetMulticast, Reliable)
105:     virtual void Multicast_OnInputFailed(ACharacter* Character);
106: 
107: 
108: 
109:     UFUNCTION(BlueprintPure, Category = "Interaction")
110:     EInteractionState GetCurrentState() const { return CurrentState; }
111: 
112:     UPROPERTY(EditDefaultsOnly)
113:     TSubclassOf<UWitchPTUserWidget> AltarUserWidgetClass;
114: 
115: protected:
116:     virtual void BeginPlay() override;
117:     virtual void Tick(float DeltaTime) override;
118: 
119: 
120: 
121:     UFUNCTION()
122:     virtual void OnRep_ParticipatingPlayers();
123: 
124: 
125: 
126:     virtual void HandleInputSuccess(ACharacter* Player);
127:     virtual void HandleInputFailure(ACharacter* Player);
128:     virtual void CheckState();
129:     virtual void CleanupInteraction();
130:     virtual void SpawnReward();
131:     virtual void SpawnDemon();
132:     virtual bool IsPlayerEligibleForInteraction(ACharacter* Player) const;
133: 
134: };

================
File: Source/WitchPT/Public/Character/Components/WitchPTMechanicComponent.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "Components/ActorComponent.h"
 5: #include "Item/MechanicsInterface.h"
 6: #include "WitchPTMechanicComponent.generated.h"
 7: 
 8: class ACauldronAltar;
 9: 
10: UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
11: class WITCHPT_API UWitchPTMechanicComponent : public UActorComponent, public IMechanicsInterface
12: {
13: 	GENERATED_BODY()
14: 
15: public:
16: 
17: 	UWitchPTMechanicComponent();
18: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
19: 
20: 
21: 	virtual void RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar) override;
22: 	virtual void RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar) override;
23: 	virtual void RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
24: 	virtual void RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal) override;
25: 	virtual void RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar) override;
26: 	virtual void RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar) override;
27: 	virtual void RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron) override;
28: 
29: 	virtual void RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef) override;
30: 	virtual void RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar) override;
31: 	virtual void RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar) override;
32: 
33: 	UFUNCTION(Server, Reliable)
34: 	void Server_RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
35: 	UFUNCTION(Server, Reliable)
36: 	void Server_RequestCraftPotion(ACauldronAltar* TargetAltar);
37: 
38: 
39: 
40: 
41: 
42: 	virtual void RequestStartRitual_Implementation(ARitualAltar* TargetAltar) override;
43: 	virtual void RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag) override;
44: 	virtual void RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
45: 	virtual void RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position) override;
46: 
47: };

================
File: Source/WitchPT/Public/Inventory/WitchPTInventoryManagerComponent.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Components/ActorComponent.h"
  5: #include "FastArray/FastArrayList.h"
  6: #include "Net/Serialization/FastArraySerializer.h"
  7: #include "WitchPTInventoryManagerComponent.generated.h"
  8: 
  9: class UInventoryUserWidget;
 10: class UWitchPTInventoryItemDefinition;
 11: class UWitchPTInventoryItemInstance;
 12: class UWitchPTInventoryManagerComponent;
 13: class UObject;
 14: struct FFrame;
 15: struct FNetDeltaSerializeInfo;
 16: struct FWitchPTInventoryList;
 17: struct FReplicationFlags;
 18: 
 19: 
 20: 
 21: 
 22: 
 23: 
 24: DECLARE_MULTICAST_DELEGATE_OneParam(FOnItemChanged, UWitchPTInventoryItemInstance*);
 25: 
 26: 
 27: 
 28: 
 29: 
 30: 
 31: 
 32: 
 33: UCLASS(BlueprintType)
 34: class WITCHPT_API UWitchPTInventoryManagerComponent : public UActorComponent
 35: {
 36: 	GENERATED_BODY()
 37: protected:
 38: 	virtual void BeginPlay() override;
 39: 
 40: public:
 41: 
 42: 	UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
 43: 
 44: 
 45: 	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category="Inventory")
 46: 	bool TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 47: 
 48: 
 49: 	UFUNCTION(Server, Reliable)
 50: 	void Server_AddItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 51: 
 52: 
 53: 	UFUNCTION(Server, Reliable)
 54: 	void Server_AddStacksToItem(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef);
 55: 
 56: 
 57: 	UFUNCTION(Server, Reliable)
 58: 	void Server_UpdateItemStackCount(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount);
 59: 
 60: 
 61: 	UFUNCTION(Server, Reliable)
 62: 	void Server_RemoveItemInstance(UWitchPTInventoryItemInstance* ItemInstance);
 63: 
 64: 
 65: 	UFUNCTION(Server, Reliable)
 66: 	void Server_RemoveItemStacks(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove);
 67: 
 68: 
 69: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
 70: 	TArray<UWitchPTInventoryItemInstance*> GetAllItems() const;
 71: 
 72: 
 73: 	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
 74: 	UWitchPTInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 75: 
 76: 
 77: 	int32 GetTotalItemCountByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const;
 78: 
 79: 
 80: 	bool ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef, int32 NumToConsume);
 81: 
 82: 
 83: 
 84: 
 85: 	FOnItemChanged OnItemAdded;
 86: 
 87: 
 88: 	FOnItemChanged OnItemStackChanged;
 89: 
 90: 
 91: 	FOnItemChanged OnItemRemoved;
 92: 
 93: 
 94: 
 95: 
 96: 
 97: 
 98: 	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 99: 
100: 
101: 
102: 
103: 
104: 	virtual void ReadyForReplication() override;
105: 
106: 
107: 
108: 
109: private:
110: 
111: 
112: 
113: 
114: 	UPROPERTY(Replicated)
115: 	FWitchPTInventoryList InventoryList;
116: 
117: 
118: 	TWeakObjectPtr<APlayerController> OwningController;
119: 
120: 
121: };

================
File: Source/WitchPT/Public/UI/WidgetControllers/RitualWidgetController.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameplayTagContainer.h"
  5: #include "WitchPTWidgetController.h"
  6: #include "Item/RitualAltar.h"
  7: #include "RitualWidgetController.generated.h"
  8: 
  9: enum class ERitualInput : uint8;
 10: class ARitualAltar;
 11: class ACharacter;
 12: enum class EInteractionState : uint8;
 13: 
 14: 
 15: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualExpectedInputChangedSignature_WC, FGameplayTag, ExpectedInput);
 16: 
 17: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChangedSignature_WC, FRitualReadyPlayersData, ReadyPlayersData);
 18: 
 19: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCountdownTickSignature_WC, int32, CountdownValue);
 20: 
 21: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChangedSignature_WC, FUIRitualData, TurnData);
 22: 
 23: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChangedSignature_WC, EInteractionState, NewState);
 24: 
 25: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCorruptionChangedSignature_WC, float, CorruptionPercentage);
 26: 
 27: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualSequenceProgressChangedSignature_WC, float, ProgressPercentage);
 28: 
 29: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompletedSignature_WC, bool, bWasSuccessful);
 30: 
 31: 
 32: 
 33: 
 34: UCLASS(BlueprintType, Blueprintable)
 35: class WITCHPT_API URitualWidgetController : public UWitchPTWidgetController
 36: {
 37: 	GENERATED_BODY()
 38: 
 39: public:
 40: 	URitualWidgetController();
 41: 
 42: 	virtual void BroadcastInitialValues() override;
 43: 	virtual void BindCallbacksToDependencies() override;
 44: 
 45: 
 46: 	UFUNCTION(Category = "Ritual")
 47: 	void SetRitualAltar(ARitualAltar* InRitualAltar);
 48: 
 49: 
 50: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 51: 	ARitualAltar* GetRitualAltar() const { return RitualAltar; }
 52: 
 53: 
 54: 	UFUNCTION(BlueprintPure, Category = "Ritual")
 55: 	bool IsLocalPlayerActive() const;
 56: 
 57: 
 58: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 59: 	FOnRitualExpectedInputChangedSignature_WC OnRitualExpectedInputChanged;
 60: 
 61: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 62: 	FOnReadyPlayersChangedSignature_WC OnReadyPlayersChanged;
 63: 
 64: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 65: 	FOnRitualCountdownTickSignature_WC OnRitualCountdownTick;
 66: 
 67: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 68: 	FOnTurnDataChangedSignature_WC OnTurnDataChanged;
 69: 
 70: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 71: 	FOnRitualStateChangedSignature_WC OnRitualStateChanged;
 72: 
 73: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 74: 	FOnRitualCorruptionChangedSignature_WC OnRitualCorruptionChanged;
 75: 
 76: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 77: 	FOnRitualSequenceProgressChangedSignature_WC OnRitualSequenceProgressChanged;
 78: 
 79: 	UPROPERTY(BlueprintAssignable, Category = "Ritual")
 80: 	FOnRitualCompletedSignature_WC OnRitualCompleted;
 81: 
 82: protected:
 83: 
 84: 	UPROPERTY(BlueprintReadOnly, Category = "Ritual")
 85: 	TObjectPtr<ARitualAltar> RitualAltar;
 86: 
 87: 
 88: 	UFUNCTION()
 89: 	void HandleRitualStateChanged(EInteractionState NewState);
 90: 
 91: 	UFUNCTION()
 92: 	void HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData);
 93: 
 94: 	UFUNCTION()
 95: 	void HandleCountdownTick(int32 CountdownValue);
 96: 
 97: 	UFUNCTION()
 98: 	void HandleTurnDataChanged(FUIRitualData TurnData);
 99: 
100: 	UFUNCTION()
101: 	void HandleCorruptionChanged(float CorruptionPercentage);
102: 
103: 	UFUNCTION()
104: 	void HandleSequenceProgressChanged(float ProgressPercentage);
105: 
106: 	UFUNCTION()
107: 	void HandleRitualCompleted(bool bWasSuccessful);
108: 
109: private:
110: 
111: 	FUIRitualData ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const;
112: };

================
File: Source/WitchPT/Private/Character/Components/WitchPTMechanicComponent.cpp
================
  1: #include "Character/Components/WitchPTMechanicComponent.h"
  2: #include "Item/CauldronAltar.h"
  3: #include "Net/UnrealNetwork.h"
  4: #include "GameFramework/Character.h"
  5: #include "Item/RitualAltar.h"
  6: #include "Item/Components/CauldronCraftComponent.h"
  7: 
  8: 
  9: UWitchPTMechanicComponent::UWitchPTMechanicComponent()
 10: {
 11: 
 12: 	PrimaryComponentTick.bCanEverTick = true;
 13: 	SetIsReplicatedByDefault(true);
 14: }
 15: 
 16: void UWitchPTMechanicComponent::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 17: {
 18: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 19: 
 20: 
 21: }
 22: 
 23: 
 24: 
 25: 
 26: void UWitchPTMechanicComponent::RequestStartBrewingPotion_Implementation(ACauldronAltar* TargetAltar)
 27: {
 28: 	if (!TargetAltar)
 29: 	{
 30: 		return;
 31: 	}
 32: 
 33: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 34: 	if (!Character)
 35: 	{
 36: 		return;
 37: 	}
 38: 
 39: 	if (Character->HasAuthority())
 40: 	{
 41: 		TargetAltar->StartBrewingPotion(Character);
 42: 	}
 43: }
 44: 
 45: void UWitchPTMechanicComponent::RequestStartCarryCauldron_Implementation(ACauldronAltar* TargetAltar)
 46: {
 47: 	if (!TargetAltar)
 48: 	{
 49: 		return;
 50: 	}
 51: 
 52: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 53: 	if (!Character)
 54: 	{
 55: 		return;
 56: 	}
 57: 
 58: 	if (GetOwnerRole() == ROLE_Authority)
 59: 	{
 60: 
 61: 		TargetAltar->StartCarryCauldron(Character);
 62: 	}
 63: 
 64: }
 65: 
 66: void UWitchPTMechanicComponent::RequestStartPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
 67: {
 68: 	if (!TargetAltar)
 69: 	{
 70: 		return;
 71: 	}
 72: 
 73: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
 74: 	if (!Character)
 75: 	{
 76: 		return;
 77: 	}
 78: 
 79: 	if (GetOwnerRole() == ROLE_Authority)
 80: 	{
 81: 
 82: 		TargetAltar->StartPlacementPreview(Character);
 83: 	}
 84: }
 85: 
 86: void UWitchPTMechanicComponent::RequestUpdatePlacementPreview_Implementation(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal)
 87: {
 88: 	if (!TargetAltar)
 89: 	{
 90: 		return;
 91: 	}
 92: 
 93: 	if (GetOwnerRole() == ROLE_Authority)
 94: 	{
 95: 
 96: 		TargetAltar->UpdatePlacementPreview(HitLocation, HitNormal);
 97: 	}
 98: }
 99: 
100: void UWitchPTMechanicComponent::RequestCancelPlacementPreview_Implementation(ACauldronAltar* TargetAltar)
101: {
102: 	if (!TargetAltar)
103: 	{
104: 		return;
105: 	}
106: 
107: 	if (GetOwnerRole() == ROLE_Authority)
108: 	{
109: 
110: 		TargetAltar->CancelPlacement();
111: 	}
112: 
113: }
114: 
115: void UWitchPTMechanicComponent::RequestFinalizePlacement_Implementation(ACauldronAltar* TargetAltar)
116: {
117: 	if (!TargetAltar)
118: 	{
119: 		return;
120: 	}
121: 
122: 	if (GetOwnerRole() == ROLE_Authority)
123: 	{
124: 
125: 		TargetAltar->FinalizePlacement();
126: 	}
127: 
128: }
129: 
130: void UWitchPTMechanicComponent::RequestUnOccupyPositionInCauldron_Implementation(ACauldronAltar* TargetCauldron)
131: {
132: 	if (!TargetCauldron) return;
133: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
134: 	if (GetOwnerRole() == ROLE_Authority)
135: 	{
136: 		TargetCauldron->UnoccupyPosition(Character, nullptr);
137: 	}
138: }
139: 
140: void UWitchPTMechanicComponent::RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
141: 	TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
142: {
143: 	if (!TargetAltar) return;
144: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
145: 
146: 
147: 	if(GetOwnerRole() == ROLE_Authority)
148: 	{
149: 		TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
150: 	}
151: 	else
152: 	{
153: 		Server_RequestSetIngredientInSlot(TargetAltar, IngredientItemDef);
154: 	}
155: 
156: 
157: 
158: }
159: 
160: void UWitchPTMechanicComponent::RequestPrintDebugData_Implementation(ACauldronAltar* TargetAltar)
161: {
162: 	if (!TargetAltar) return;
163: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
164: 
165: 	if (GetOwnerRole() == ROLE_Authority)
166: 	{
167: 		FVector SpawnLocation = TargetAltar->GetActorLocation();
168: 		FPotionResult Result = TargetAltar->CauldronCraftComponent->CraftPotion(false, nullptr, SpawnLocation);
169: 	}
170: }
171: 
172: void UWitchPTMechanicComponent::RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
173: {
174: 	if (!TargetAltar) return;
175: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
176: 	if (GetOwnerRole() == ROLE_Authority)
177: 	{
178: 		TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
179: 	}
180: 	else
181: 	{
182: 		Server_RequestCraftPotion(TargetAltar);
183: 	}
184: 
185: }
186: 
187: void UWitchPTMechanicComponent::Server_RequestSetIngredientInSlot_Implementation(ACauldronAltar* TargetAltar,
188:                                                                                  TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef)
189: {
190: 	if (!TargetAltar) return;
191: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
192: 
193: 	TargetAltar->TrySetIngredientInSlot(Character, IngredientItemDef);
194: 
195: }
196: 
197: void UWitchPTMechanicComponent::RequestOccupyPosition_Implementation(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position)
198: {
199: 
200: 	if (!TargetAltar) return;
201: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
202: 
203: 	if (GetOwnerRole() == ROLE_Authority)
204: 	{
205: 		TargetAltar->OccupyPosition(Character, Position);
206: 	}
207: 
208: }
209: 
210: void UWitchPTMechanicComponent::RequestUnOccupyPositionInRitual_Implementation(ARitualAltar* TargetAltar,
211: 	ABaseInteractionPosition* Position)
212: {
213: 	if (!TargetAltar) return;
214: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
215: 	if (GetOwnerRole() == ROLE_Authority)
216: 	{
217: 		TargetAltar->UnoccupyPosition(Character, Position);
218: 	}
219: 
220: }
221: 
222: void UWitchPTMechanicComponent::Server_RequestCraftPotion_Implementation(ACauldronAltar* TargetAltar)
223: {
224: 	if (!TargetAltar) return;
225: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
226: 	TargetAltar->CauldronCraftComponent->CraftPotion(false, Character, TargetAltar->GetActorLocation());
227: }
228: 
229: void UWitchPTMechanicComponent::RequestStartRitual_Implementation(ARitualAltar* TargetAltar)
230: {
231: 	if (!TargetAltar) return;
232: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
233: 	if (GetOwnerRole() == ROLE_Authority)
234: 	{
235: 		TargetAltar->StartRitual(Character);
236: 	}
237: }
238: 
239: void UWitchPTMechanicComponent::RequestRitualInput_Implementation(ARitualAltar* TargetAltar, const FGameplayTag& InputTag)
240: {
241: 	if (!TargetAltar) return;
242: 	ACharacter* Character = Cast<ACharacter>(GetOwner());
243: 	if (GetOwnerRole() == ROLE_Authority)
244: 	{
245: 		TargetAltar->HandlePlayerInput(Character, InputTag);
246: 	}
247: }

================
File: Source/WitchPT/Private/Inventory/WitchPTInventoryManagerComponent.cpp
================
  1: #include "Inventory/WitchPTInventoryManagerComponent.h"
  2: 
  3: #include "Blueprint/UserWidget.h"
  4: #include "Components/PanelWidget.h"
  5: #include "Engine/ActorChannel.h"
  6: #include "Inventory/WitchPTInventoryItemDefinition.h"
  7: #include "Inventory/Fragments/WitchPTInventoryItemFragment.h"
  8: #include "Inventory/WitchPTInventoryItemInstance.h"
  9: #include "Inventory/Fragments/WitchPTInventoryFragment_Stackable.h"
 10: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 11: #include "Net/UnrealNetwork.h"
 12: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 13: #include "Inventory/InventoryFunctionLibrary.h"
 14: #include "UI/WidgetControllers/InventoryWidgetController.h"
 15: 
 16: 
 17: #include UE_INLINE_GENERATED_CPP_BY_NAME(WitchPTInventoryManagerComponent)
 18: 
 19: 
 20: void UWitchPTInventoryManagerComponent::BeginPlay()
 21: {
 22: 	Super::BeginPlay();
 23: 
 24: }
 25: 
 26: UWitchPTInventoryManagerComponent::UWitchPTInventoryManagerComponent(const FObjectInitializer& ObjectInitializer)
 27: : Super(ObjectInitializer)
 28: 	, InventoryList(this)
 29: {
 30: 	PrimaryComponentTick.bCanEverTick = false;
 31: 	SetIsReplicatedByDefault(true);
 32: 	bReplicateUsingRegisteredSubObjectList = true;
 33: }
 34: void UWitchPTInventoryManagerComponent::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const
 35: {
 36: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 37: 
 38: 	DOREPLIFETIME(ThisClass, InventoryList);
 39: }
 40: 
 41: 
 42: 
 43: void UWitchPTInventoryManagerComponent::Server_AddStacksToItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
 44: {
 45: 	if(IsValid(ItemDef))
 46: 	{
 47: 		UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
 48: 		const UWitchPTInventoryItemFragment* BaseFragment = FoundItem->FindFragmentByClass(UWitchPTInventoryFragment_Stackable::StaticClass());
 49: 		const UWitchPTInventoryFragment_Stackable* StackableFragment = Cast<UWitchPTInventoryFragment_Stackable>(BaseFragment);
 50: 
 51: 		int32 NewStackCount = FoundItem->GetTotalStackCount() + StackableFragment->GetStackCount();
 52: 		Server_UpdateItemStackCount(FoundItem, NewStackCount);
 53: 	}
 54: }
 55: 
 56: void UWitchPTInventoryManagerComponent::Server_UpdateItemStackCount_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 NewCount)
 57: {
 58: 	if (IsValid(ItemInstance))
 59: 	{
 60: 		ItemInstance->SetTotalStackCount(NewCount);
 61: 
 62: 
 63: 		for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
 64: 		{
 65: 			if (Entry.Instance == ItemInstance)
 66: 			{
 67: 				InventoryList.MarkItemDirty(Entry);
 68: 				break;
 69: 			}
 70: 		}
 71: 
 72: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 73: 		{
 74: 			OnItemStackChanged.Broadcast(ItemInstance);
 75: 		}
 76: 	}
 77: }
 78: 
 79: void UWitchPTInventoryManagerComponent::Server_RemoveItemInstance_Implementation(UWitchPTInventoryItemInstance* ItemInstance)
 80: {
 81: 	if (IsValid(ItemInstance))
 82: 	{
 83: 
 84: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
 85: 		{
 86: 			OnItemRemoved.Broadcast(ItemInstance);
 87: 		}
 88: 
 89: 
 90: 		InventoryList.RemoveEntry(ItemInstance);
 91: 
 92: 
 93: 		if (IsUsingRegisteredSubObjectList())
 94: 		{
 95: 			RemoveReplicatedSubObject(ItemInstance);
 96: 		}
 97: 	}
 98: }
 99: 
100: void UWitchPTInventoryManagerComponent::Server_RemoveItemStacks_Implementation(UWitchPTInventoryItemInstance* ItemInstance, int32 AmountToRemove)
101: {
102: 	if (IsValid(ItemInstance))
103: 	{
104: 		const int32 CurrentCount = ItemInstance->GetTotalStackCount();
105: 		const int32 NewCount = FMath::Max(0, CurrentCount - AmountToRemove);
106: 
107: 
108: 		if (NewCount <= 0)
109: 		{
110: 			Server_RemoveItemInstance(ItemInstance);
111: 		}
112: 		else
113: 		{
114: 
115: 			Server_UpdateItemStackCount(ItemInstance, NewCount);
116: 		}
117: 	}
118: }
119: 
120: TArray<UWitchPTInventoryItemInstance*> UWitchPTInventoryManagerComponent::GetAllItems() const
121: {
122: 	return InventoryList.GetAllItems();
123: }
124: 
125: bool UWitchPTInventoryManagerComponent::TryAddItemDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
126: {
127: 	if (!ItemDef)
128: 	{
129: 		return false;
130: 	}
131: 
132: 	UWitchPTInventoryItemInstance* FoundItem = FindFirstItemStackByDefinition(ItemDef);
133: 	if (FoundItem)
134: 	{
135: 		Server_AddStacksToItem(ItemDef);
136: 		return false;
137: 	}
138: 	else
139: 	{
140: 		Server_AddItem(ItemDef);
141: 		return true;
142: 	}
143: }
144: 
145: 
146: 
147: void UWitchPTInventoryManagerComponent::Server_AddItem_Implementation(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef)
148: {
149: 	UWitchPTInventoryItemInstance* NewItem = nullptr;
150: 	if (ItemDef != nullptr)
151: 	{
152: 		NewItem = InventoryList.AddEntry(ItemDef);
153: 		if (GetOwner()->GetNetMode() == NM_ListenServer || GetOwner()->GetNetMode() == NM_Standalone)
154: 		{
155: 			OnItemAdded.Broadcast(NewItem);
156: 		}
157: 
158: 		if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && NewItem)
159: 		{
160: 			AddReplicatedSubObject(NewItem);
161: 		}
162: 	}
163: 
164: }
165: 
166: 
167: 
168: 
169: 
170: 
171: 
172: 
173: 
174: 
175: 
176: 
177: 
178: 
179: UWitchPTInventoryItemInstance* UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(
180: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
181: {
182: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
183: 	{
184: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
185: 
186: 		if (IsValid(Instance))
187: 		{
188: 			if (Instance->GetItemDef() == ItemDef)
189: 			{
190: 				return Instance;
191: 			}
192: 		}
193: 	}
194: 
195: 	return nullptr;
196: }
197: 
198: int32 UWitchPTInventoryManagerComponent::GetTotalItemCountByDefinition(
199: 	TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef) const
200: {
201: 	int32 TotalCount = 0;
202: 	for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
203: 	{
204: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
205: 
206: 		if (IsValid(Instance))
207: 		{
208: 			if (Instance->GetItemDef() == ItemDef)
209: 			{
210: 				++TotalCount;
211: 			}
212: 		}
213: 	}
214: 
215: 	return TotalCount;
216: }
217: 
218: bool UWitchPTInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<UWitchPTInventoryItemDefinition> ItemDef,
219: 	int32 NumToConsume)
220: {
221: 	AActor* OwningActor = GetOwner();
222: 	if (!OwningActor || !OwningActor->HasAuthority())
223: 	{
224: 		return false;
225: 	}
226: 
227: 
228: 	int32 TotalConsumed = 0;
229: 	while (TotalConsumed < NumToConsume)
230: 	{
231: 		if (UWitchPTInventoryItemInstance* Instance = UWitchPTInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
232: 		{
233: 			InventoryList.RemoveEntry(Instance);
234: 			++TotalConsumed;
235: 		}
236: 		else
237: 		{
238: 			return false;
239: 		}
240: 	}
241: 
242: 	return TotalConsumed == NumToConsume;
243: }
244: 
245: 
246: bool UWitchPTInventoryManagerComponent::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
247:                                                             FReplicationFlags* RepFlags)
248: {
249: 	bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
250: 
251: 	for (FWitchPTInventoryEntry& Entry : InventoryList.Entries)
252: 	{
253: 		UWitchPTInventoryItemInstance* Instance = Entry.Instance;
254: 
255: 		if (Instance && IsValid(Instance))
256: 		{
257: 			WroteSomething |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
258: 		}
259: 	}
260: 
261: 	return WroteSomething;
262: }
263: 
264: void UWitchPTInventoryManagerComponent::ReadyForReplication()
265: {
266: 	Super::ReadyForReplication();
267: 
268: 	if (IsUsingRegisteredSubObjectList())
269: 	{
270: 		for (const FWitchPTInventoryEntry& Entry : InventoryList.Entries)
271: 		{
272: 			UWitchPTInventoryItemInstance* Instance = Entry.Instance;
273: 
274: 			if (IsValid(Instance))
275: 			{
276: 				AddReplicatedSubObject(Instance);
277: 			}
278: 		}
279: 	}
280: }

================
File: Source/WitchPT/Private/UI/HUD/WitchPTHUD.cpp
================
  1: #include "UI/HUD/WitchPTHUD.h"
  2: 
  3: #include "Inventory/WitchPTInventoryManagerComponent.h"
  4: #include "Player/WitchPTPlayerController.h"
  5: #include "UI/WidgetControllers/CauldronWidgetController.h"
  6: #include "UI/WidgetControllers/InventoryWidgetController.h"
  7: #include "UI/WidgetControllers/OverlayWidgetController.h"
  8: #include "UI/WidgetControllers/QuickBarWidgetController.h"
  9: #include "UI/WidgetControllers/RitualWidgetController.h"
 10: #include "UI/Widgets/WitchPTPrimaryLayout.h"
 11: #include "UI/Widgets/WitchPTUserWidget.h"
 12: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 13: 
 14: void AWitchPTHUD::BeginPlay()
 15: {
 16: 	Super::BeginPlay();
 17: 	if (PrimaryLayout == nullptr)
 18: 	{
 19: 		UUserWidget* PrimaryLayoutInstance = CreateWidget<UUserWidget>(GetOwningPlayerController(), PrimaryLayoutClass);
 20: 		PrimaryLayout = Cast<UWitchPTPrimaryLayout>(PrimaryLayoutInstance);
 21: 		PrimaryLayout->AddToViewport();
 22: 
 23: 	}
 24: }
 25: 
 26: UWitchPTUserWidget* AWitchPTHUD::GetMenuWidgetByCass(TSubclassOf<UWitchPTUserWidget> WidgetClass)
 27: {
 28: 	if (WidgetClass)
 29: 	{
 30: 		for (UUserWidget* Widget : GameMenuWidgets)
 31: 		{
 32: 			if (Widget && Widget->IsA(WidgetClass))
 33: 			{
 34: 				return Cast<UWitchPTUserWidget>(Widget);
 35: 			}
 36: 		}
 37: 	}
 38: 	return nullptr;
 39: }
 40: 
 41: UOverlayWidgetController* AWitchPTHUD::SetOverlayWidgetController(const FWidgetControllerParams& WCParams)
 42: {
 43: 	if (OverlayWidgetController == nullptr)
 44: 	{
 45: 		OverlayWidgetController = NewObject<UOverlayWidgetController>(this, OverlayWidgetControllerClass);
 46: 		OverlayWidgetController->SetWidgetControllerParams(WCParams);
 47: 		OverlayWidgetController->BindCallbacksToDependencies();
 48: 	}
 49: 	return OverlayWidgetController;
 50: }
 51: 
 52: UCauldronWidgetController* AWitchPTHUD::SetCauldronWidgetController(const FWidgetControllerParams& WCParams)
 53: {
 54: 	if (CauldronWidgetController == nullptr)
 55: 	{
 56: 		CauldronWidgetController = NewObject<UCauldronWidgetController>(this, CauldronWidgetControllerClass);
 57: 		CauldronWidgetController->SetWidgetControllerParams(WCParams);
 58: 
 59: 	}
 60: 	return CauldronWidgetController;
 61: }
 62: 
 63: UQuickBarWidgetController* AWitchPTHUD::SetQuickBarWidgetController(const FWidgetControllerParams& WCParams)
 64: {
 65: 	if (QuickBarWidgetController == nullptr)
 66: 	{
 67: 		QuickBarWidgetController = NewObject<UQuickBarWidgetController>(this, QuickBarWidgetControllerClass);
 68: 		QuickBarWidgetController->SetWidgetControllerParams(WCParams);
 69: 		QuickBarWidgetController->BindCallbacksToDependencies();
 70: 
 71: 	}
 72: 	return QuickBarWidgetController;
 73: }
 74: 
 75: UInventoryWidgetController* AWitchPTHUD::SetInventoryWidgetController(const FWidgetControllerParams& WCParams)
 76: {
 77: 	if (InventoryWidgetController == nullptr)
 78: 	{
 79: 		InventoryWidgetController = NewObject<UInventoryWidgetController>(this, InventoryWidgetControllerClass);
 80: 		InventoryWidgetController->SetWidgetControllerParams(WCParams);
 81: 		InventoryWidgetController->BindCallbacksToDependencies();
 82: 	}
 83: 	return InventoryWidgetController;
 84: }
 85: 
 86: URitualWidgetController* AWitchPTHUD::SetRitualWidgetController(const FWidgetControllerParams& WCParams)
 87: {
 88: 	if (RitualWidgetController == nullptr)
 89: 	{
 90: 		RitualWidgetController = NewObject<URitualWidgetController>(this, RitualWidgetControllerClass);
 91: 		RitualWidgetController->SetWidgetControllerParams(WCParams);
 92: 	}
 93: 	return RitualWidgetController;
 94: }
 95: 
 96: void AWitchPTHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
 97: {
 98: 	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out BP_WitchPTHUD"));
 99: 	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out BP_WitchPTHUD"));
100: 
101: 
102: 	UUserWidget* OverlayWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
103: 	OverlayWidget = Cast<UWitchPTUserWidget>(OverlayWidgetInstance);
104: 
105: 	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
106: 	UOverlayWidgetController* WidgetController = SetOverlayWidgetController(WidgetControllerParams);
107: 
108: 	OverlayWidget->SetWidgetController(WidgetController);
109: 	WidgetController->BroadcastInitialValues();
110: 
111: 
112: 
113: 
114: }
115: 
116: void AWitchPTHUD::InitRitualWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
117: 	UAttributeSet* AS)
118: {
119: 	if (RitualWidgetClass)
120: 	{
121: 
122: 		UUserWidget* RitualWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), RitualWidgetClass);
123: 		RitualWidget = Cast<UWitchPTUserWidget>(RitualWidgetInstance);
124: 
125: 		if (RitualWidget)
126: 		{
127: 			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
128: 
129: 			URitualWidgetController* RitualController = SetRitualWidgetController(WidgetControllerParams);
130: 			RitualWidget->SetWidgetController(RitualController);
131: 
132: 
133: 			RitualWidgetInstance->AddToViewport();
134: 			GameMenuWidgets.Add(RitualWidgetInstance);
135: 		}
136: 	}
137: }
138: 
139: void AWitchPTHUD::InitInventoryWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
140: 	UAttributeSet* AS)
141: {
142: 	if (InventoryWidgetClass && !InventoryWidget)
143: 	{
144: 		UUserWidget* InventoryWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), InventoryWidgetClass);
145: 		InventoryWidget = Cast<UWitchPTUserWidget>(InventoryWidgetInstance);
146: 
147: 		if (InventoryWidget)
148: 		{
149: 			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
150: 			UInventoryWidgetController* Controller = SetInventoryWidgetController(WidgetControllerParams);
151: 			InventoryWidget->SetWidgetController(Controller);
152: 			InventoryWidgetInstance->AddToViewport();
153: 			GameMenuWidgets.Add(InventoryWidgetInstance);
154: 		}
155: 	}
156: }
157: 
158: void AWitchPTHUD::InitCauldronWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
159: {
160: 	if (CauldronWidgetClass && !CauldronWidget)
161: 	{
162: 		UUserWidget* CauldronWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), CauldronWidgetClass);
163: 		CauldronWidget = Cast<UWitchPTUserWidget>(CauldronWidgetInstance);
164: 
165: 		if (CauldronWidget)
166: 		{
167: 			const FWidgetControllerParams WCParams(PC, PS, ASC, AS);
168: 			UCauldronWidgetController* Controller = SetCauldronWidgetController(WCParams);
169: 			CauldronWidget->SetWidgetController(Controller);
170: 			CauldronWidgetInstance->AddToViewport();
171: 			GameMenuWidgets.Add(CauldronWidgetInstance);
172: 		}
173: 	}
174: }
175: 
176: void AWitchPTHUD::InitQuickBarWidget(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC,
177: 	UAttributeSet* AS)
178: {
179: 	if (QuickBarUserWidgetClass && !QuickBarUserWidget)
180: 	{
181: 		UUserWidget* QuickBarWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), QuickBarUserWidgetClass);
182: 		QuickBarUserWidget = Cast<UWitchPTUserWidget>(QuickBarWidgetInstance);
183: 		if (QuickBarUserWidget)
184: 		{
185: 			const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
186: 			UQuickBarWidgetController* Controller = SetQuickBarWidgetController(WidgetControllerParams);
187: 			QuickBarUserWidget->SetWidgetController(Controller);
188: 
189: 			QuickBarWidgetInstance->AddToViewport();
190: 			GameMenuWidgets.Add(QuickBarWidgetInstance);
191: 		}
192: 	}
193: 
194: 
195: }
196: 
197: void AWitchPTHUD::ToggleGameMenu(TSubclassOf<UWitchPTUserWidget> WidgetClass)
198: {
199: 
200: 	if (WidgetClass)
201: 	{
202: 		UWitchPTUserWidget* WidgetToToggle = nullptr;
203: 		for (UUserWidget* Widget : GameMenuWidgets)
204: 		{
205: 			if (Widget->IsA(WidgetClass))
206: 			{
207: 				WidgetToToggle = Cast<UWitchPTUserWidget>(Widget);
208: 				break;
209: 			}
210: 		}
211: 		if (!WidgetToToggle) return;
212: 		const bool bIsTargetWidgetAlreadyVisible = WidgetToToggle->IsVisible();
213: 
214: 		for (auto& MenuWidget : GameMenuWidgets)
215: 		{
216: 			if (MenuWidget && MenuWidget->IsVisible())
217: 			{
218: 				MenuWidget->SetVisibility(ESlateVisibility::Collapsed);
219: 			}
220: 		}
221: 		APlayerController* PC = GetOwningPlayerController();
222: 
223: 		if (bIsTargetWidgetAlreadyVisible)
224: 		{
225: 			if (PC)
226: 			{
227: 				PC->SetInputMode(FInputModeGameOnly());
228: 				PC->bShowMouseCursor = false;
229: 			}
230: 		} else
231: 		{
232: 
233: 			WidgetToToggle->SetVisibility(ESlateVisibility::Visible);
234: 			FInputModeGameAndUI InputMode;
235: 			InputMode.SetWidgetToFocus(WidgetToToggle->TakeWidget());
236: 			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
237: 			PC->SetInputMode(InputMode);
238: 			PC->SetShowMouseCursor(true);
239: 		}
240: 	}
241: 
242: 
243: }
244: 
245: void AWitchPTHUD::ShowOverlayWidget()
246: {
247: 	OverlayWidget->SetVisibility(ESlateVisibility::Visible);
248: }
249: 
250: void AWitchPTHUD::HideOverlayWidget()
251: {
252: 	OverlayWidget->SetVisibility(ESlateVisibility::Collapsed);
253: }
254: 
255: void AWitchPTHUD::ShowRitualWidget(class ARitualAltar* RitualAltar)
256: {
257: 	if (RitualWidget && RitualWidgetController)
258: 	{
259: 
260: 
261: 		RitualWidgetController->SetRitualAltar(RitualAltar);
262: 
263: 
264: 		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
265: 		if (RitualUserWidget)
266: 		{
267: 			RitualUserWidget->ShowForRitual(RitualAltar);
268: 		}
269: 
270: 
271: 		RitualWidget->SetVisibility(ESlateVisibility::Visible);
272: 
273: 
274: 		APlayerController* PC = GetOwningPlayerController();
275: 		if (PC)
276: 		{
277: 			FInputModeGameAndUI InputMode;
278: 			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
279: 			InputMode.SetHideCursorDuringCapture(false);
280: 			PC->SetInputMode(InputMode);
281: 			PC->bShowMouseCursor = true;
282: 		}
283: 	}
284: }
285: 
286: void AWitchPTHUD::HideRitualWidget()
287: {
288: 	if (RitualWidget)
289: 	{
290: 
291: 		URitualUserWidget* RitualUserWidget = Cast<URitualUserWidget>(RitualWidget);
292: 		if (RitualUserWidget)
293: 		{
294: 			RitualUserWidget->HideFromRitual();
295: 		}
296: 
297: 
298: 		RitualWidget->SetVisibility(ESlateVisibility::Collapsed);
299: 
300: 
301: 		if (RitualWidgetController)
302: 		{
303: 			RitualWidgetController->SetRitualAltar(nullptr);
304: 		}
305: 
306: 
307: 		APlayerController* PC = GetOwningPlayerController();
308: 		if (PC)
309: 		{
310: 			PC->SetInputMode(FInputModeGameOnly());
311: 			PC->bShowMouseCursor = false;
312: 		}
313: 	}
314: }
315: 
316: void AWitchPTHUD::ShowInventoryWidget()
317: {
318: 	if (InventoryWidget)
319: 	{
320: 		InventoryWidget->SetVisibility(ESlateVisibility::Visible);
321: 
322: 		APlayerController* PC = GetOwningPlayerController();
323: 		if (PC)
324: 		{
325: 			FInputModeGameAndUI InputMode;
326: 			PC->SetInputMode(InputMode);
327: 			PC->SetShowMouseCursor(true);
328: 		}
329: 	}
330: 
331: }
332: 
333: void AWitchPTHUD::HideInventoryWidget()
334: {
335: 	if (InventoryWidget)
336: 	{
337: 		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
338: 
339: 		APlayerController* PC = GetOwningPlayerController();
340: 		if (PC)
341: 		{
342: 			PC->SetInputMode(FInputModeGameOnly());
343: 			PC->SetShowMouseCursor(false);
344: 		}
345: 	}
346: }
347: 
348: void AWitchPTHUD::ShowCauldronWithInventory(class ACauldronAltar* CauldronAltar)
349: {
350: 	if (CauldronWidget && InventoryWidget && CauldronWidgetController)
351: 	{
352: 
353: 		CauldronWidgetController->SetCauldronAltar(CauldronAltar);
354: 		CauldronWidgetController->BindCallbacksToDependencies();
355: 		CauldronWidgetController->BroadcastInitialValues();
356: 
357: 
358: 		CauldronWidget->SetVisibility(ESlateVisibility::Visible);
359: 
360: 		bCauldronWidgetVisible = true;
361: 
362: 
363: 		APlayerController* PC = GetOwningPlayerController();
364: 		if (PC)
365: 		{
366: 			FInputModeGameAndUI InputMode;
367: 			PC->SetInputMode(InputMode);
368: 			PC->SetShowMouseCursor(true);
369: 		}
370: 	}
371: }
372: 
373: void AWitchPTHUD::HideCauldronWithInventory()
374: {
375: 	if (CauldronWidget && InventoryWidget)
376: 	{
377: 		CauldronWidget->SetVisibility(ESlateVisibility::Collapsed);
378: 		InventoryWidget->SetVisibility(ESlateVisibility::Collapsed);
379: 
380: 		bCauldronWidgetVisible = false;
381: 
382: 
383: 		if (CauldronWidgetController)
384: 		{
385: 			CauldronWidgetController->SetCauldronAltar(nullptr);
386: 			CauldronWidgetController->UnbindCallbacksFromDependencies();
387: 		}
388: 
389: 
390: 		APlayerController* PC = GetOwningPlayerController();
391: 		if (PC)
392: 		{
393: 			PC->SetInputMode(FInputModeGameOnly());
394: 			PC->SetShowMouseCursor(false);
395: 		}
396: 	}
397: }

================
File: Source/WitchPT/Private/UI/WidgetControllers/RitualWidgetController.cpp
================
  1: #include "UI/WidgetControllers/RitualWidgetController.h"
  2: #include "Item/RitualAltar.h"
  3: #include "GameFramework/Character.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "AbilitySystemComponent.h"
  6: #include "AbilitySystemBlueprintLibrary.h"
  7: #include "FWitchPTGameplayTags.h"
  8: 
  9: URitualWidgetController::URitualWidgetController()
 10: {
 11: 
 12: }
 13: 
 14: void URitualWidgetController::BroadcastInitialValues()
 15: {
 16: 
 17:     if (!IsValid(RitualAltar))
 18:     {
 19:         UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BroadcastInitialValues called with invalid altar"));
 20:         return;
 21:     }
 22: 
 23: 
 24:     OnRitualStateChanged.Broadcast(RitualAltar->GetCurrentRitualState());
 25: 
 26: 
 27:     FRitualReadyPlayersData ReadyPlayersData;
 28:     ReadyPlayersData.TotalPlayers = RitualAltar->GetNumberOfTotalPlayers();
 29:     ReadyPlayersData.ReadyPlayers = RitualAltar->GetNumberOfReadyPlayers();
 30:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
 31: 
 32: 
 33:     FUIRitualData CurrentTurnData = RitualAltar->GetCurrentTurnData();
 34:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(CurrentTurnData);
 35:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
 36: 
 37: 
 38:     OnRitualCorruptionChanged.Broadcast(RitualAltar->GetCorruptionPercentage());
 39: 
 40: 
 41:     OnRitualSequenceProgressChanged.Broadcast(RitualAltar->GetCurrentSequenceProgress());
 42: 
 43:     UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Initial values broadcasted"));
 44: }
 45: 
 46: void URitualWidgetController::BindCallbacksToDependencies()
 47: {
 48: 
 49:     if (!IsValid(RitualAltar))
 50:     {
 51:         UE_LOG(LogTemp, Warning, TEXT("[RitualWidgetController] BindCallbacksToDependencies called with invalid altar"));
 52:         return;
 53:     }
 54: 
 55: 
 56:     RitualAltar->OnRitualStateChangedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualStateChanged);
 57:     RitualAltar->OnReadyPlayersChangedEvent.AddDynamic(this, &URitualWidgetController::HandleReadyPlayersChanged);
 58:     RitualAltar->OnCountdownTickEvent.AddDynamic(this, &URitualWidgetController::HandleCountdownTick);
 59:     RitualAltar->OnTurnDataChangedEvent.AddDynamic(this, &URitualWidgetController::HandleTurnDataChanged);
 60:     RitualAltar->OnCorruptionChangedEvent.AddDynamic(this, &URitualWidgetController::HandleCorruptionChanged);
 61:     RitualAltar->OnSequenceProgressChangedEvent.AddDynamic(this, &URitualWidgetController::HandleSequenceProgressChanged);
 62:     RitualAltar->OnRitualCompletedEvent.AddDynamic(this, &URitualWidgetController::HandleRitualCompleted);
 63: 
 64:     UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Callbacks bound to dependencies"));
 65: }
 66: 
 67: void URitualWidgetController::SetRitualAltar(ARitualAltar* InRitualAltar)
 68: {
 69: 
 70: 
 71: 
 72:     if (IsValid(RitualAltar))
 73:     {
 74:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
 75:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
 76:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
 77:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
 78:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
 79:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
 80:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
 81: 
 82:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound callbacks from previous altar"));
 83:     }
 84: 
 85: 
 86:     RitualAltar = InRitualAltar;
 87: 
 88: 
 89:     if (IsValid(RitualAltar))
 90:     {
 91:         BindCallbacksToDependencies();
 92:         BroadcastInitialValues();
 93:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Set new ritual altar and bound callbacks"));
 94:     }
 95:     else
 96:     {
 97:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Cleared ritual altar reference"));
 98:     }
 99: }
100: 
101: bool URitualWidgetController::IsLocalPlayerActive() const
102: {
103: 
104:     if (!IsValid(RitualAltar) || !IsValid(PlayerController))
105:     {
106:         return false;
107:     }
108: 
109: 
110:     ACharacter* LocalCharacter = Cast<ACharacter>(PlayerController->GetPawn());
111:     if (!IsValid(LocalCharacter))
112:     {
113:         return false;
114:     }
115: 
116: 
117:     ACharacter* ActivePlayer = RitualAltar->GetCurrentActivePlayer();
118:     return IsValid(ActivePlayer) && ActivePlayer == LocalCharacter;
119: }
120: 
121: FUIRitualData URitualWidgetController::ProcessTurnDataForLocalPlayer(const FUIRitualData& InTurnData) const
122: {
123:     FUIRitualData ProcessedData = InTurnData;
124: 
125: 
126:     ProcessedData.bIsMyTurn = IsLocalPlayerActive();
127: 
128: 
129:     if (!ProcessedData.bIsMyTurn)
130:     {
131:         ProcessedData.ExpectedInput = FGameplayTag::EmptyTag;
132:         ProcessedData.CurrentInputTimeRemaining = 0.0f;
133:     }
134: 
135:     return ProcessedData;
136: }
137: 
138: 
139: 
140: void URitualWidgetController::HandleRitualStateChanged(EInteractionState NewState)
141: {
142:     OnRitualStateChanged.Broadcast(NewState);
143: }
144: 
145: void URitualWidgetController::HandleReadyPlayersChanged(FRitualReadyPlayersData ReadyPlayersData)
146: {
147:     OnReadyPlayersChanged.Broadcast(ReadyPlayersData);
148: }
149: 
150: void URitualWidgetController::HandleCountdownTick(int32 CountdownValue)
151: {
152:     OnRitualCountdownTick.Broadcast(CountdownValue);
153: }
154: 
155: void URitualWidgetController::HandleTurnDataChanged(FUIRitualData TurnData)
156: {
157: 
158:     FUIRitualData ProcessedTurnData = ProcessTurnDataForLocalPlayer(TurnData);
159:     OnTurnDataChanged.Broadcast(ProcessedTurnData);
160: 
161: 
162:     if (ProcessedTurnData.bIsMyTurn)
163:     {
164:         OnRitualExpectedInputChanged.Broadcast(ProcessedTurnData.ExpectedInput);
165:     }
166:     else
167:     {
168:         OnRitualExpectedInputChanged.Broadcast(FGameplayTag::EmptyTag);
169:     }
170: }
171: 
172: void URitualWidgetController::HandleCorruptionChanged(float CorruptionPercentage)
173: {
174:     OnRitualCorruptionChanged.Broadcast(CorruptionPercentage);
175: }
176: 
177: void URitualWidgetController::HandleSequenceProgressChanged(float ProgressPercentage)
178: {
179:     OnRitualSequenceProgressChanged.Broadcast(ProgressPercentage);
180: }
181: 
182: void URitualWidgetController::HandleRitualCompleted(bool bWasSuccessful)
183: {
184:     OnRitualCompleted.Broadcast(bWasSuccessful);
185: 
186: 
187:     if (IsValid(RitualAltar))
188:     {
189:         RitualAltar->OnRitualStateChangedEvent.RemoveAll(this);
190:         RitualAltar->OnReadyPlayersChangedEvent.RemoveAll(this);
191:         RitualAltar->OnCountdownTickEvent.RemoveAll(this);
192:         RitualAltar->OnTurnDataChangedEvent.RemoveAll(this);
193:         RitualAltar->OnCorruptionChangedEvent.RemoveAll(this);
194:         RitualAltar->OnSequenceProgressChangedEvent.RemoveAll(this);
195:         RitualAltar->OnRitualCompletedEvent.RemoveAll(this);
196: 
197:         UE_LOG(LogTemp, Log, TEXT("[RitualWidgetController] Unbound all delegates after ritual completion"));
198:     }
199: 
200: 
201:     RitualAltar = nullptr;
202: }

================
File: Source/WitchPT/Public/Item/MechanicsInterface.h
================
 1: #pragma once
 2: 
 3: #include "CoreMinimal.h"
 4: #include "GameplayTagContainer.h"
 5: #include "UObject/Interface.h"
 6: #include "MechanicsInterface.generated.h"
 7: 
 8: class UWitchPTInventoryItemDefinition;
 9: class UWitchPTInventoryItemInstance;
10: class ABaseInteractionPosition;
11: class ACauldronAltar;
12: class ARitualPosition;
13: class ARitualAltar;
14: class ACharacter;
15: 
16: 
17: UINTERFACE(MinimalAPI)
18: class UMechanicsInterface : public UInterface
19: {
20: 	GENERATED_BODY()
21: };
22: 
23: 
24: 
25: 
26: class WITCHPT_API IMechanicsInterface
27: {
28: 	GENERATED_BODY()
29: 
30: 
31: 
32: public:
33: 
34: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
35: 	void RequestStartRitual(ARitualAltar* TargetAltar);
36: 
37: 
38: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
39: 	void RequestRitualInput(ARitualAltar* TargetAltar, const FGameplayTag& InputTag);
40: 
41: 
42: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
43: 	void RequestOccupyPosition(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
44: 
45: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Ritual")
46: 	void RequestUnOccupyPositionInRitual(ARitualAltar* TargetAltar, ABaseInteractionPosition* Position);
47: 
48: 
49: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
50: 	void RequestStartBrewingPotion(ACauldronAltar* TargetAltar);
51: 
52: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
53: 	void RequestStartCarryCauldron(ACauldronAltar* TargetAltar);
54: 
55: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
56: 	void RequestStartPlacementPreview(ACauldronAltar* TargetAltar);
57: 
58: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
59: 	void RequestUpdatePlacementPreview(ACauldronAltar* TargetAltar, const FVector& HitLocation, const FVector& HitNormal);
60: 
61: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
62: 	void RequestCancelPlacementPreview(ACauldronAltar* TargetAltar);
63: 
64: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
65: 	void RequestFinalizePlacement(ACauldronAltar* TargetAltar);
66: 
67: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
68: 	void RequestUnOccupyPositionInCauldron(ACauldronAltar* TargetCauldron);
69: 
70: 
71: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
72: 	void RequestSetIngredientInSlot(ACauldronAltar* TargetAltar, TSubclassOf<UWitchPTInventoryItemDefinition> IngredientItemDef);
73: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
74: 	void RequestPrintDebugData(ACauldronAltar* TargetAltar);
75: 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Mechanics|Cauldron")
76: 	void RequestCraftPotion(ACauldronAltar* TargetAltar);
77: 
78: 
79: 
80: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
81: 	ARitualAltar* GetRitualAltarActor() const;
82: 
83: 	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Mechanics|Query")
84: 	bool IsOccuppied() const;
85: 
86: };

================
File: Source/WitchPT/Public/Player/WitchPTPlayerController.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "GameFramework/PlayerController.h"
  5: #include "UI/Widgets/PointerWidget.h"
  6: #include "WitchPTPlayerController.generated.h"
  7: 
  8: class UWitchPTQuickBarComponent;
  9: class UCauldronUserWidget;
 10: class ABaseInteractableAltar;
 11: class ACauldronAltar;
 12: class ARitualAltar;
 13: class UWitchPTInventoryManagerComponent;
 14: struct FGameplayTag;
 15: class UWitchPTAbilitySystemComponent;
 16: class UWitchPTInputConfig;
 17: struct FInputActionValue;
 18: class UInputAction;
 19: class UInputMappingContext;
 20: 
 21: 
 22: 
 23: UCLASS()
 24: class WITCHPT_API AWitchPTPlayerController : public APlayerController
 25: {
 26: 	GENERATED_BODY()
 27: public:
 28: 	AWitchPTPlayerController();
 29: 	virtual void PlayerTick(float DeltaTime) override;
 30: 	virtual void PreProcessInput(const float DeltaTime, const bool bGamePaused) override;
 31: 	virtual void PostProcessInput(const float DeltaTime, const bool bGamePaused) override;
 32: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 33: 
 34: 	void LocalShowRitualWidget(ABaseInteractableAltar* Altar);
 35: 	void LocalHideRitualWidget();
 36: 	bool IsRitualWidgetVisible();
 37: 	void LocalToggleCauldronMenu();
 38: 
 39: 
 40: 
 41: 
 42: 	UFUNCTION(Client, Reliable)
 43: 	void Client_ShowRitualWidget(ABaseInteractableAltar* Altar);
 44: 
 45: 	UFUNCTION(Client, Reliable)
 46: 	void Client_HideRitualWidget();
 47: 
 48: 	UFUNCTION(Client, Reliable)
 49: 	void Client_ToggleCauldronMenu();
 50: 
 51: 	UFUNCTION(BlueprintCallable, Category= "Overlay")
 52: 	void ShowOverlayWidget();
 53: 	UFUNCTION(BlueprintCallable, Category= "Overlay")
 54: 	void HideOverlayWidget();
 55: 
 56: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 57: 	void OpenInventoryMenu();
 58: 	UFUNCTION(BlueprintCallable, Category= "Inventory")
 59: 	void CloseInventoryMenu();
 60: 
 61: 
 62: 	UFUNCTION(Exec, Category = "Debug")
 63: 	void ShowRitualWidgetDebug();
 64: 	UFUNCTION(Exec, Category = "Debug")
 65: 	void HideRitualWidgetDebug();
 66: 	UFUNCTION(Exec, Category = "Debug")
 67: 	void ToggleRitualWidgetDebug();
 68: 
 69: 
 70: 	UPROPERTY(Replicated, VisibleAnywhere)
 71: 	TObjectPtr<UWitchPTInventoryManagerComponent> InventoryManager;
 72: 	UPROPERTY()
 73: 	TObjectPtr<UPointerWidget> HUDWidget;
 74: 	UWitchPTInventoryManagerComponent* GetInventoryManager() { return InventoryManager; }
 75: 	UWitchPTQuickBarComponent* GetQuickBarComponent() { return QuickBarComponent; }
 76: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "QuickBar")
 77: 	TObjectPtr<UWitchPTQuickBarComponent> QuickBarComponent;
 78: protected:
 79: 	virtual void BeginPlay() override;
 80: 	virtual void SetupInputComponent() override;
 81: 
 82: 
 83: 	UPROPERTY(EditAnywhere, Category="Input")
 84: 	TObjectPtr<UInputMappingContext> WitchPtiInputMappingContext;
 85: 	UPROPERTY(EditAnywhere, Category="Input")
 86: 	TObjectPtr<UInputAction> MoveAction;
 87: 	UPROPERTY(EditAnywhere, Category= "Input")
 88: 	TObjectPtr<UInputAction> LookAction;
 89: 
 90: 	UPROPERTY(EditDefaultsOnly, Category= "Input")
 91: 	TObjectPtr<UWitchPTInputConfig> InputConfig;
 92: 
 93: 
 94: 	UPROPERTY()
 95: 	TObjectPtr<UWitchPTAbilitySystemComponent> WitchPtAbilitySystemComponent;
 96: 
 97: 	UWitchPTAbilitySystemComponent* GetASC();
 98: 
 99: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
100: 	TSubclassOf<UPointerWidget> HUDWidgetClass;
101: 
102: 	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
103: 	TSubclassOf<UCauldronUserWidget> CauldronAltarWidgetClass;
104: 
105: 
106: 
107: private:
108: 
109: 	void Move(const FInputActionValue& InputActionValue);
110: 
111: 	void Look(const FInputActionValue& Value);
112: 
113: 	void AbilityInputTagPressed(FGameplayTag InputTag);
114: 	void AbilityInputTagReleased(FGameplayTag InputTag);
115: 	void AbilityInputTagHeld(FGameplayTag InputTag);
116: 
117: 
118: 	void CreateHUDWidget();
119: 	void OpenCauldronMenu();
120: 	void CloseCauldronMenu();
121: 	bool bCauldronMenuOpen = false;
122: 
123: 
124: 	bool bRitualWidgetVisible = false;
125: 
126: 
127: };

================
File: Source/WitchPT/Private/Player/WitchPTPlayerController.cpp
================
  1: #include "Player/WitchPTPlayerController.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "EnhancedInputSubsystems.h"
  5: #include "InputActionValue.h"
  6: #include "AbilitySystem/WitchPTAbilitySystemComponent.h"
  7: #include "Blueprint/UserWidget.h"
  8: #include "Equipment/WitchPTQuickBarComponent.h"
  9: #include "Input/WitchPTInputComponent.h"
 10: #include "Inventory/WitchPTInventoryManagerComponent.h"
 11: #include "Item/CauldronAltar.h"
 12: #include "Item/RitualAltar.h"
 13: #include "Item/Ritual/RitualFunctionLibrary.h"
 14: #include "Kismet/GameplayStatics.h"
 15: #include "Net/UnrealNetwork.h"
 16: #include "UI/HUD/WitchPTHUD.h"
 17: #include "UI/WidgetControllers/CauldronWidgetController.h"
 18: #include "UI/WidgetControllers/RitualWidgetController.h"
 19: #include "UI/Widgets/CauldronUserWidget.h"
 20: #include "UI/Widgets/Inventory/InventoryUserWidget.h"
 21: #include "UI/Widgets/Inventory/RitualUserWidget.h"
 22: #include "WitchPT/WitchPT.h"
 23: 
 24: AWitchPTPlayerController::AWitchPTPlayerController()
 25: {
 26: 	bReplicates = true;
 27: 	InventoryManager = CreateDefaultSubobject<UWitchPTInventoryManagerComponent>("InventoryManager");
 28: 	InventoryManager->SetIsReplicated(true);
 29: 	QuickBarComponent = CreateDefaultSubobject<UWitchPTQuickBarComponent>("QuickBarComponent");
 30: 	QuickBarComponent->SetIsReplicated(true);
 31: 
 32: 
 33: }
 34: 
 35: void AWitchPTPlayerController::PlayerTick(float DeltaTime)
 36: {
 37: 	Super::PlayerTick(DeltaTime);
 38: }
 39: 
 40: void AWitchPTPlayerController::PreProcessInput(const float DeltaTime, const bool bGamePaused)
 41: {
 42: 	Super::PreProcessInput(DeltaTime, bGamePaused);
 43: }
 44: 
 45: void AWitchPTPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused)
 46: {
 47: 	if (WitchPtAbilitySystemComponent)
 48: 	{
 49: 		WitchPtAbilitySystemComponent->ProcessAbilityInput(DeltaTime, bGamePaused);
 50: 	}
 51: 	Super::PostProcessInput(DeltaTime, bGamePaused);
 52: }
 53: 
 54: void AWitchPTPlayerController::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 55: {
 56: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 57: 	DOREPLIFETIME(AWitchPTPlayerController, InventoryManager);
 58: }
 59: void AWitchPTPlayerController::LocalToggleCauldronMenu()
 60: {
 61: 
 62: 	if (bCauldronMenuOpen)
 63: 	{
 64: 		CloseCauldronMenu();
 65: 	}
 66: 	else
 67: 	{
 68: 		OpenCauldronMenu();
 69: 	}
 70: }
 71: void AWitchPTPlayerController::OpenInventoryMenu()
 72: {
 73: 	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
 74: 	{
 75: 		WitchPTHUD->ShowInventoryWidget();
 76: 	}
 77: }
 78: 
 79: void AWitchPTPlayerController::CloseInventoryMenu()
 80: {
 81: 	if (AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD()))
 82: 	{
 83: 		WitchPTHUD->HideInventoryWidget();
 84: 	}
 85: }
 86: 
 87: void AWitchPTPlayerController::LocalShowRitualWidget(ABaseInteractableAltar* Altar)
 88: {
 89: 	if (!Altar || !IsLocalController())
 90: 	{
 91: 		UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Invalid altar or not local controller!"));
 92: 		return;
 93: 	}
 94: 
 95: 	if (Altar->IsA<ARitualAltar>())
 96: 	{
 97: 
 98: 		ARitualAltar* RitualAltar = Cast<ARitualAltar>(Altar);
 99: 
100: 
101: 		AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
102: 		if (WitchPTHUD)
103: 		{
104: 			WitchPTHUD->ShowRitualWidget(RitualAltar);
105: 			bRitualWidgetVisible = true;
106: 			UE_LOG(LogTemp, Log, TEXT("LocalShowRitualWidget: Ritual widget shown for altar %s"), *RitualAltar->GetName());
107: 		}
108: 		else
109: 		{
110: 			UE_LOG(LogTemp, Error, TEXT("LocalShowRitualWidget: Failed to get WitchPTHUD!"));
111: 		}
112: 	}
113: }
114: 
115: void AWitchPTPlayerController::LocalHideRitualWidget()
116: {
117: 	if (!IsLocalController())
118: 	{
119: 		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Not local controller!"));
120: 		return;
121: 	}
122: 
123: 
124: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
125: 	if (WitchPTHUD)
126: 	{
127: 		WitchPTHUD->HideRitualWidget();
128: 		bRitualWidgetVisible = false;
129: 		UE_LOG(LogTemp, Log, TEXT("LocalHideRitualWidget: Ritual widget hidden"));
130: 	}
131: 	else
132: 	{
133: 		UE_LOG(LogTemp, Error, TEXT("LocalHideRitualWidget: Failed to get WitchPTHUD!"));
134: 	}
135: }
136: 
137: bool AWitchPTPlayerController::IsRitualWidgetVisible()
138: {
139: 	return bRitualWidgetVisible;
140: }
141: 
142: void AWitchPTPlayerController::OpenCauldronMenu()
143: {
144: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
145: 	if (WitchPTHUD)
146: 	{
147: 
148: 		ACauldronAltar* CauldronAltar = Cast<ACauldronAltar>(
149: 			UGameplayStatics::GetActorOfClass(this, ACauldronAltar::StaticClass())
150: 		);
151: 
152: 		if (CauldronAltar)
153: 		{
154: 			WitchPTHUD->ShowCauldronWithInventory(CauldronAltar);
155: 			bCauldronMenuOpen = true;
156: 		}
157: 	}
158: }
159: 
160: void AWitchPTPlayerController::CloseCauldronMenu()
161: {
162: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
163: 	if (WitchPTHUD)
164: 	{
165: 		WitchPTHUD->HideCauldronWithInventory();
166: 		bCauldronMenuOpen = false;
167: 	}
168: }
169: 
170: void AWitchPTPlayerController::Client_ShowRitualWidget_Implementation(ABaseInteractableAltar* Altar)
171: {
172: 
173: 	LocalShowRitualWidget(Altar);
174: }
175: 
176: void AWitchPTPlayerController::Client_HideRitualWidget_Implementation()
177: {
178: 
179: 	LocalHideRitualWidget();
180: }
181: 
182: void AWitchPTPlayerController::ShowOverlayWidget()
183: {
184: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
185: 	if (WitchPTHUD)
186: 	{
187: 		WitchPTHUD->ShowOverlayWidget();
188: 	}
189: }
190: 
191: void AWitchPTPlayerController::HideOverlayWidget()
192: {
193: 	AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(GetHUD());
194: 	if (WitchPTHUD)
195: 	{
196: 		WitchPTHUD->HideOverlayWidget();
197: 	}
198: }
199: 
200: void AWitchPTPlayerController::Client_ToggleCauldronMenu_Implementation()
201: {
202: 	LocalToggleCauldronMenu();
203: }
204: void AWitchPTPlayerController::BeginPlay()
205: {
206: 	Super::BeginPlay();
207: 	check(WitchPtiInputMappingContext)
208: 	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer());
209: 	if (Subsystem)
210: 	{
211: 		Subsystem->AddMappingContext(WitchPtiInputMappingContext, 1);
212: 	}
213: 	CreateHUDWidget();
214: }
215: 
216: void AWitchPTPlayerController::SetupInputComponent()
217: {
218: 	Super::SetupInputComponent();
219: 	UWitchPTInputComponent* WitchPtInputComponent = CastChecked<UWitchPTInputComponent>(InputComponent);
220: 	WitchPtInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Move);
221: 	WitchPtInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AWitchPTPlayerController::Look);
222: 	WitchPtInputComponent->BindAbilityActions(InputConfig, this, &ThisClass::AbilityInputTagPressed, &ThisClass::AbilityInputTagReleased, &ThisClass::AbilityInputTagHeld);
223: 
224: }
225: 
226: void AWitchPTPlayerController::Move(const FInputActionValue& InputActionValue)
227: {
228: 	const FVector2D InputAxisVector = InputActionValue.Get<FVector2D>();
229: 	const FRotator Rotation = GetControlRotation();
230: 	const FRotator YawRotation(0.f, Rotation.Yaw, 0.f);
231: 
232: 	const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
233: 	const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
234: 
235: 	if (APawn* ControlledPawn = GetPawn<APawn>())
236: 	{
237: 		ControlledPawn->AddMovementInput(ForwardDirection, InputAxisVector.Y);
238: 		ControlledPawn->AddMovementInput(RightDirection, InputAxisVector.X);
239: 	}
240: 
241: }
242: 
243: void AWitchPTPlayerController::Look(const FInputActionValue& Value)
244: {
245: 
246: 	FVector2D LookAxisVector = Value.Get<FVector2D>();
247: 
248: 	if (APawn* ControlledPawn = GetPawn<APawn>())
249: 	{
250: 
251: 		ControlledPawn->AddControllerYawInput(LookAxisVector.X);
252: 		ControlledPawn->AddControllerPitchInput(LookAxisVector.Y);
253: 	}
254: }
255: 
256: void AWitchPTPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
257: {
258: 	if (GetASC())
259: 	{
260: 		GetASC()->AbilityInputTagPressed(InputTag);
261: 	}
262: }
263: 
264: void AWitchPTPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
265: {
266: 	if (GetASC())
267: 	{
268: 		GetASC()->AbilityInputTagReleased(InputTag);
269: 	}
270: }
271: 
272: void AWitchPTPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
273: {
274: 	if (GetASC())
275: 	{
276: 		GetASC()->AbilityInputTagHeld(InputTag);
277: 	}
278: }
279: 
280: void AWitchPTPlayerController::CreateHUDWidget()
281: {
282: 	if (!IsLocalController()) return;
283: 	HUDWidget = CreateWidget<UPointerWidget>(this, HUDWidgetClass);
284: 	if (IsValid(HUDWidget))
285: 	{
286: 		HUDWidget->AddToViewport();
287: 	}
288: }
289: 
290: 
291: UWitchPTAbilitySystemComponent* AWitchPTPlayerController::GetASC()
292: {
293: 	if (WitchPtAbilitySystemComponent == nullptr)
294: 	{
295: 		WitchPtAbilitySystemComponent = Cast<UWitchPTAbilitySystemComponent>(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn<APawn>()));
296: 	}
297: 	return WitchPtAbilitySystemComponent;
298: }
299: 
300: 
301: void AWitchPTPlayerController::ShowRitualWidgetDebug()
302: {
303: 
304: 	ARitualAltar* TestAltar = Cast<ARitualAltar>(UGameplayStatics::GetActorOfClass(this, ARitualAltar::StaticClass()));
305: 	if (TestAltar)
306: 	{
307: 		LocalShowRitualWidget(TestAltar);
308: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: Showing ritual widget for test altar"));
309: 	}
310: 	else
311: 	{
312: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG] ShowRitualWidgetDebug: No ritual altar found in level"));
313: 	}
314: }
315: 
316: void AWitchPTPlayerController::HideRitualWidgetDebug()
317: {
318: 	LocalHideRitualWidget();
319: 	UE_LOG(LogTemp, Warning, TEXT("[DEBUG] HideRitualWidgetDebug: Hiding ritual widget"));
320: }
321: 
322: void AWitchPTPlayerController::ToggleRitualWidgetDebug()
323: {
324: 	if (IsRitualWidgetVisible())
325: 	{
326: 		HideRitualWidgetDebug();
327: 	}
328: 	else
329: 	{
330: 		ShowRitualWidgetDebug();
331: 	}
332: }

================
File: Source/WitchPT/Private/Item/CauldronAltar.cpp
================
  1: #include "Item/CauldronAltar.h"
  2: 
  3: #include "AbilitySystemBlueprintLibrary.h"
  4: #include "Item/CauldronPosition.h"
  5: #include "Net/UnrealNetwork.h"
  6: #include "GameFramework/Character.h"
  7: #include "Kismet/GameplayStatics.h"
  8: #include "TimerManager.h"
  9: #include "Components/SkeletalMeshComponent.h"
 10: #include "Components/CapsuleComponent.h"
 11: #include "Components/StaticMeshComponent.h"
 12: #include "Engine/World.h"
 13: #include "DrawDebugHelpers.h"
 14: #include "FWitchPTGameplayTags.h"
 15: #include "Engine/ActorChannel.h"
 16: #include "Inventory/WitchPTInventoryItemDefinition.h"
 17: #include "Inventory/WitchPTInventoryItemInstance.h"
 18: #include "Inventory/WitchPTInventoryManagerComponent.h"
 19: #include "Inventory/Fragments/WitchPTInventoryFragment_UIDetails.h"
 20: #include "Inventory/Fragments/WitchPTInventoryItemFragment_IngredientCraftingProperties.h"
 21: #include "Item/Components/CauldronCraftComponent.h"
 22: #include "Player/WitchPTPlayerController.h"
 23: #include "UI/HUD/WitchPTHUD.h"
 24: #include "UI/Widgets/CauldronUserWidget.h"
 25: 
 26: 
 27: ACauldronAltar::ACauldronAltar()
 28: {
 29: 
 30:     PrimaryActorTick.bCanEverTick = true;
 31: 
 32: 
 33:     bReplicates = true;
 34:     bAlwaysRelevant = true;
 35:     CauldronPhysicState = ECauldronPhysicState::Static;
 36:     CarryingCharacter = nullptr;
 37:     CurrentPlacementState = ECauldronPlacementState::None;
 38:     bReplicateUsingRegisteredSubObjectList = true;
 39: 
 40: 
 41:     CauldronCraftComponent = CreateDefaultSubobject<UCauldronCraftComponent>(TEXT("CauldronCraftComponent"));
 42: }
 43: 
 44: void ACauldronAltar::GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder)
 45: {
 46: 
 47:     FInteractionOption InteractionOption = Option;
 48: 
 49: 
 50:     InteractionOption.bSupportsHoldInteraction = true;
 51: 
 52: 
 53:     OptionBuilder.AddInteractionOption(InteractionOption);
 54: }
 55: 
 56: void ACauldronAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
 57: {
 58:     Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 59: 
 60:     DOREPLIFETIME(ACauldronAltar, CauldronPhysicState);
 61:     DOREPLIFETIME(ACauldronAltar, CarryingCharacter);
 62:     DOREPLIFETIME(ACauldronAltar, CurrentPlacementState);
 63:     DOREPLIFETIME(ACauldronAltar, CauldronCraftComponent);
 64: }
 65: 
 66: void ACauldronAltar::OnRep_CauldronPhysicState()
 67: {
 68: 
 69:     if (CauldronPhysicState == ECauldronPhysicState::Moving)
 70:     {
 71: 
 72:         SetActorEnableCollision(false);
 73:     }
 74:     else if (CauldronPhysicState == ECauldronPhysicState::Previewing)
 75:     {
 76: 
 77:         SetActorEnableCollision(false);
 78:     }
 79: }
 80: 
 81: 
 82: 
 83: void ACauldronAltar::StartBrewingPotion(ACharacter* InteractingCharacter)
 84: {
 85:     if (!InteractingCharacter)
 86:     {
 87:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartBrewingPotion: Invalid character"));
 88:         return;
 89:     }
 90: 
 91: 
 92:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
 93:     {
 94:         FinalizePlacement();
 95:         return;
 96:     }
 97: 
 98: 
 99:     PositionCharacterForBrewing(InteractingCharacter);
100: }
101: 
102: void ACauldronAltar::TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef)
103: {
104:     if (!CauldronCraftComponent)
105:     {
106:         UE_LOG(LogTemp, Error, TEXT("ACauldronAltar::TrySetIngredientInSlot: CauldronCraftComponent is null"));
107:         return;
108:     }
109: 
110:     if (CauldronPhysicState != ECauldronPhysicState::Static)
111:     {
112:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::TrySetIngredientInSlot: Cauldron is not in a static state"));
113:         return;
114:     }
115: 
116: 
117:     CauldronCraftComponent->TrySetIngredientInSlot(RequestingCharacter, IngredientItemDef);
118: }
119: 
120: void ACauldronAltar::BeginPlay()
121: {
122:     Super::BeginPlay();
123:     SetReplicateMovement(true);
124: }
125: 
126: bool ACauldronAltar::ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch,
127:     FReplicationFlags* RepFlags)
128: {
129:     bool bWroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);
130: 
131: 
132:     if (CauldronCraftComponent)
133:     {
134:         bWroteSomething |= Channel->ReplicateSubobject(CauldronCraftComponent, *Bunch, *RepFlags);
135:     }
136: 
137:     return bWroteSomething;
138: }
139: 
140: void ACauldronAltar::StartCarryCauldron(ACharacter* InteractingCharacter)
141: {
142:     if (!InteractingCharacter)
143:     {
144:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Invalid character"));
145:         return;
146:     }
147: 
148: 
149:     if (IsInPlacementPreview() && CarryingCharacter == InteractingCharacter)
150:     {
151:         CancelPlacement();
152:         return;
153:     }
154: 
155: 
156:     if (!CanBePickedUp())
157:     {
158:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::StartCarryCauldron: Cauldron cannot be picked up"));
159:         return;
160:     }
161: 
162: 
163:     AttachToCharacter(InteractingCharacter);
164: }
165: 
166: bool ACauldronAltar::CanBePickedUp() const
167: {
168: 
169:     if (IsBeingCarried() || IsInPlacementPreview())
170:     {
171:         return false;
172:     }
173: 
174: 
175: 
176:     return true;
177: }
178: 
179: bool ACauldronAltar::IsBeingCarried() const
180: {
181:     return CauldronPhysicState == ECauldronPhysicState::Moving && CarryingCharacter != nullptr;
182: }
183: 
184: bool ACauldronAltar::IsInPlacementPreview() const
185: {
186:     return CauldronPhysicState == ECauldronPhysicState::Previewing && CarryingCharacter != nullptr;
187: }
188: 
189: ACharacter* ACauldronAltar::GetCarryingCharacter() const
190: {
191:     return CarryingCharacter;
192: }
193: 
194: void ACauldronAltar::AttachToCharacter(ACharacter* Character)
195: {
196:     if (!Character || !HasAuthority())
197:     {
198:         return;
199:     }
200: 
201: 
202:     DestroyAltarPositions();
203: 
204: 
205:     CauldronPhysicState = ECauldronPhysicState::Moving;
206:     CarryingCharacter = Character;
207: 
208: 
209:     FAttachmentTransformRules AttachRules(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget,
210:                                           EAttachmentRule::KeepWorld, true);
211: 
212: 
213:     USkeletalMeshComponent* CharacterMesh = Character->GetMesh();
214:     if (CharacterMesh && CharacterMesh->DoesSocketExist(BackAttachSocketName))
215:     {
216: 
217:         AttachToComponent(CharacterMesh, AttachRules, BackAttachSocketName);
218: 
219: 
220:         SetActorEnableCollision(false);
221: 
222: 
223:         SetActorScale3D(FVector(0.5f, 0.5f, 0.5f));
224: 
225:         UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::AttachToCharacter: Cauldron attached to %s"), *Character->GetName());
226:     }
227: }
228: 
229: void ACauldronAltar::DetachFromCharacter(ACharacter* Character)
230: {
231:     if (!Character || !HasAuthority() || Character != CarryingCharacter)
232:     {
233:         return;
234:     }
235: 
236: 
237:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
238: 
239: 
240:     FVector CharacterLocation = Character->GetActorLocation();
241:     FRotator CharacterRotation = Character->GetActorRotation();
242:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
243: 
244: 
245:     SetActorLocation(CharacterLocation + PlacementOffset);
246: 
247: 
248:     CauldronPhysicState = ECauldronPhysicState::Static;
249:     CarryingCharacter = nullptr;
250: 
251: 
252:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
253: 
254: 
255:     SetActorEnableCollision(true);
256: 
257: 
258:     CreateAltarPositions();
259: 
260:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::DetachFromCharacter: Cauldron detached from %s"), *Character->GetName());
261: 
262: 
263: 
264: }
265: 
266: void ACauldronAltar::PositionCharacterForBrewing(ACharacter* Character)
267: {
268:     if (!Character || !HasAuthority())
269:     {
270:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::PositionCharacterForBrewing: Invalid character"));
271:         return;
272:     }
273: 
274: 
275:     ABaseInteractionPosition* BrewingPosition = GetAvailableBrewingPosition(Character);
276: 
277:     if (BrewingPosition)
278:     {
279:         Character->SetActorLocationAndRotation(BrewingPosition->GetActorLocation(), BrewingPosition->GetActorRotation(), false, nullptr, ETeleportType::TeleportPhysics);
280:         ParticipatingPlayers.Add(Character);
281: 
282:         if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
283:         {
284: 
285:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
286:             {
287: 
288:             }
289: 
290:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
291:         {
292: 
293:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
294:             {
295: 
296:             }
297:         }
298:         FGameplayEventData Payload;
299:         Payload.OptionalObject = Character;
300:         FGameplayTag GameplayTag = FWitchPTGameplayTags::Get().Event_Cauldron_CharacterPositioned;
301:         UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, GameplayTag, Payload);
302:         return BrewingPosition->SetOccupied(Character);
303: 
304: 
305:     }
306: 
307: 
308: }
309: 
310: ABaseInteractionPosition* ACauldronAltar::GetAvailableBrewingPosition(ACharacter* Character)
311: {
312: 
313:     if (InteractionPositions.Num() == 0)
314:     {
315:         UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: No brewing positions available"));
316:         return nullptr;
317:     }
318: 
319: 
320:     for (ABaseInteractionPosition* Position : InteractionPositions)
321:     {
322:         if (Position && !Position->IsOccupied())
323:         {
324:             return Position;
325:         }
326:     }
327: 
328: 
329:     UE_LOG(LogTemp, Warning, TEXT("ACauldronAltar::GetAvailableBrewingPosition: All positions are occupied"));
330: 
331:     return nullptr;
332: }
333: 
334: 
335: 
336: void ACauldronAltar::StartPlacementPreview(ACharacter* Character)
337: {
338:     if (!Character || Character != CarryingCharacter || !HasAuthority())
339:     {
340:         return;
341:     }
342: 
343: 
344:     DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
345: 
346: 
347:     CauldronPhysicState = ECauldronPhysicState::Previewing;
348: 
349: 
350:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
351:     if (MeshComponent)
352:     {
353:         OriginalMaterials.Empty();
354:         for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
355:         {
356:             OriginalMaterials.Add(MeshComponent->GetMaterial(i));
357:         }
358:     }
359: 
360: 
361:     CurrentPlacementState = ECauldronPlacementState::Invalid;
362: 
363: 
364: 
365:     SetActorEnableCollision(false);
366: 
367: 
368:     FVector CharacterLocation = Character->GetActorLocation();
369:     FRotator CharacterRotation = Character->GetActorRotation();
370:     FVector PlacementOffset = CharacterRotation.RotateVector(DetachmentOffset);
371: 
372: 
373:     PreviewLocation = CharacterLocation + PlacementOffset;
374: 
375: 
376:     PreviewRotation.Pitch = 0;
377:     PreviewRotation.Roll = 0;
378:     PreviewRotation.Yaw = 0;
379: 
380:     SetActorLocation(PreviewLocation);
381:     SetActorRotation(PreviewRotation);
382: 
383: 
384:     Multicast_FinalizePlacement();
385: }
386: 
387: void ACauldronAltar::Client_UpdatePlacementPreview_Implementation(const FVector& HitLocation, const FVector& HitNormal)
388: {
389: 
390: 
391: }
392: 
393: void ACauldronAltar::UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal)
394: {
395: 
396: 
397:     if (!IsInPlacementPreview())
398:     {
399:         return;
400:     }
401: 
402: 
403:     PreviewLocation = HitLocation;
404: 
405: 
406:     FRotator SurfaceAlignedRotation = HitNormal.Rotation();
407: 
408: 
409: 
410:     FRotator AdjustedRotation = FRotator(SurfaceAlignedRotation.Pitch, PreviewRotation.Yaw, SurfaceAlignedRotation.Roll);
411: 
412: 
413:     if (FMath::Abs(AdjustedRotation.Pitch) > 15.0f)
414:     {
415:         AdjustedRotation.Pitch = FMath::Clamp(AdjustedRotation.Pitch, 0.f, 0.f);
416:     }
417: 
418:     if (FMath::Abs(AdjustedRotation.Roll) > 15.0f)
419:     {
420:         AdjustedRotation.Roll = FMath::Clamp(AdjustedRotation.Roll, 0.f, 0.f);
421:     }
422: 
423:     PreviewRotation = AdjustedRotation;
424:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
425:     SetActorLocation(PreviewLocation);
426: 
427: 
428:     CurrentPlacementState = IsPlacementValid() ? ECauldronPlacementState::Valid : ECauldronPlacementState::Invalid;
429: }
430: 
431: void ACauldronAltar::FinalizePlacement()
432: {
433:     if (!IsInPlacementPreview() || !HasAuthority())
434:     {
435:         return;
436:     }
437: 
438: 
439:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
440:     SetActorLocation(PreviewLocation);
441:     SetActorRotation(PreviewRotation);
442: 
443: 
444:     RestoreOriginalMaterials();
445: 
446: 
447:     SetActorEnableCollision(true);
448: 
449: 
450:     CauldronPhysicState = ECauldronPhysicState::Static;
451:     CarryingCharacter = nullptr;
452:     CurrentPlacementState = ECauldronPlacementState::None;
453: 
454:     OnECauldronPhysicStateChanged.Broadcast(ECauldronPhysicState::Static);
455: 
456: 
457:     CreateAltarPositions();
458: 
459: 
460:     Multicast_FinalizePlacement();
461: 
462:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::FinalizePlacement: Cauldron placed successfully"));
463: }
464: 
465: void ACauldronAltar::CancelPlacement()
466: {
467:     if (!IsInPlacementPreview() || !HasAuthority())
468:     {
469:         return;
470:     }
471: 
472: 
473:     RestoreOriginalMaterials();
474: 
475: 
476:     ACharacter* Character = CarryingCharacter;
477: 
478: 
479:     CauldronPhysicState = ECauldronPhysicState::Moving;
480:     CarryingCharacter = nullptr;
481:     CurrentPlacementState = ECauldronPlacementState::None;
482: 
483: 
484:     if (Character)
485:     {
486:         AttachToCharacter(Character);
487:     }
488: 
489:     UE_LOG(LogTemp, Log, TEXT("ACauldronAltar::CancelPlacement: Placement canceled"));
490: }
491: 
492: void ACauldronAltar::UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position)
493: {
494: 
495:     for(ABaseInteractionPosition* PositionOccupied : InteractionPositions)
496:     {
497:         if(PositionOccupied->GetOccupyingCharacter() == Character)
498:         {
499: 
500:              if (Character->GetLocalRole() == ROLE_Authority && Character->IsLocallyControlled())
501:         {
502: 
503:             if (AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
504:             {
505: 
506:                 AWitchPTHUD* WitchPTHUD = Cast<AWitchPTHUD>(PC->GetHUD());
507:                 if (WitchPTHUD)
508:                 {
509:                     WitchPTHUD->ToggleGameMenu(UCauldronUserWidget::StaticClass());
510:                 }
511:             }
512:         } else if (Character->HasAuthority() && !Character->IsLocallyControlled())
513:         {
514: 
515:             if ( AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Character->GetOwner()))
516:             {
517: 
518: 
519:             }
520:         }
521:             PositionOccupied->SetOccupied(nullptr);
522:             break;
523:         }
524:     }
525: }
526: 
527: void ACauldronAltar::Multicast_FinalizePlacement_Implementation()
528: {
529: 
530:     SetActorScale3D(FVector(1.0f, 1.0f, 1.0f));
531:     SetActorEnableCollision(true);
532: }
533: 
534: ECauldronPlacementState ACauldronAltar::GetPlacementState() const
535: {
536:     return CurrentPlacementState;
537: }
538: 
539: void ACauldronAltar::ApplyPlacementPreviewMaterial()
540: {
541:     UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
542:     if (!MeshComponent)
543:     {
544:         return;
545:     }
546: 
547: 
548:     UMaterialInterface* MaterialToApply = CurrentPlacementState == ECauldronPlacementState::Valid ?
549:         ValidPlacementMaterial : InvalidPlacementMaterial;
550: 
551: 
552:     if (!MaterialToApply)
553:     {
554:         return;
555:     }
556: 
557: 
558:     for (int32 i = 0; i < MeshComponent->GetNumMaterials(); i++)
559:     {
560:         MeshComponent->SetMaterial(i, MaterialToApply);
561:     }
562: }
563: 
564: void ACauldronAltar::RestoreOriginalMaterials()
565: {
566: 
567:     if (CauldronPhysicState != ECauldronPhysicState::Previewing)
568:     {
569:         UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();
570:         if (MeshComponent && OriginalMaterials.Num() > 0)
571:         {
572:             for (int32 i = 0; i < FMath::Min(MeshComponent->GetNumMaterials(), OriginalMaterials.Num()); i++)
573:             {
574:                 if (OriginalMaterials[i])
575:                 {
576:                     MeshComponent->SetMaterial(i, OriginalMaterials[i]);
577:                 }
578:             }
579:         }
580:     }
581: }
582: 
583: bool ACauldronAltar::IsPlacementValid() const
584: {
585:     if (!GetWorld())
586:     {
587:         return false;
588:     }
589: 
590: 
591:     TArray<FOverlapResult> Overlaps;
592:     FCollisionQueryParams QueryParams;
593:     QueryParams.AddIgnoredActor(this);
594: 
595:     if (CarryingCharacter)
596:     {
597:         QueryParams.AddIgnoredActor(CarryingCharacter);
598:     }
599: 
600:     bool bHasOverlaps = GetWorld()->OverlapMultiByObjectType(
601:         Overlaps,
602:         PreviewLocation,
603:         FQuat::Identity,
604:         FCollisionObjectQueryParams::AllObjects,
605:         FCollisionShape::MakeSphere(PlacementCollisionCheckRadius),
606:         QueryParams
607:     );
608: 
609:     if (bHasOverlaps)
610:     {
611: 
612:         for (const FOverlapResult& Overlap : Overlaps)
613:         {
614: 
615:             if (Overlap.GetActor() && Overlap.GetActor()->GetActorEnableCollision())
616:             {
617: 
618:                 return false;
619:             }
620:         }
621:     }
622: 
623: 
624: 
625:     FHitResult HitResult;
626:     FVector TraceStart = PreviewLocation;
627:     FVector TraceEnd = TraceStart - FVector(0, 0, MaxGroundAlignmentHeight * 2.0f);
628: 
629:     bool bHitGround = GetWorld()->LineTraceSingleByChannel(
630:         HitResult,
631:         TraceStart,
632:         TraceEnd,
633:         ECC_Visibility,
634:         QueryParams
635:     );
636: 
637:     if (!bHitGround)
638:     {
639: 
640:         return false;
641:     }
642: 
643: 
644:     float DistanceToGround = (HitResult.Location - TraceStart).Size();
645:     if (DistanceToGround > MaxGroundAlignmentHeight)
646:     {
647: 
648:         return false;
649:     }
650: 
651: 
652:     return true;
653: }
654: 
655: 
656: 
657: void ACauldronAltar::PrintCauldronDebugData() const
658: {
659:     UE_LOG(LogTemp, Warning, TEXT("=== CAULDRON ALTAR DEBUG DATA ==="));
660:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Name: %s"), *GetName());
661:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Location: %s"), *GetActorLocation().ToString());
662:     UE_LOG(LogTemp, Warning, TEXT("Cauldron Physics State: %s"),
663:            CauldronPhysicState == ECauldronPhysicState::Static ? TEXT("Static") :
664:            CauldronPhysicState == ECauldronPhysicState::Moving ? TEXT("Moving") :
665:            CauldronPhysicState == ECauldronPhysicState::Previewing ? TEXT("Previewing") : TEXT("Unknown"));
666:     UE_LOG(LogTemp, Warning, TEXT("Carrying Character: %s"),
667:            CarryingCharacter ? *CarryingCharacter->GetName() : TEXT("None"));
668:     UE_LOG(LogTemp, Warning, TEXT("Placement State: %s"),
669:            CurrentPlacementState == ECauldronPlacementState::Valid ? TEXT("Valid") :
670:            CurrentPlacementState == ECauldronPlacementState::Invalid ? TEXT("Invalid") :
671:            CurrentPlacementState == ECauldronPlacementState::None ? TEXT("None") : TEXT("Unknown"));
672:     UE_LOG(LogTemp, Warning, TEXT("Number of Interaction Positions: %d"), InteractionPositions.Num());
673:     UE_LOG(LogTemp, Warning, TEXT("Number of Participating Players: %d"), ParticipatingPlayers.Num());
674: 
675: 
676:     if (CauldronCraftComponent)
677:     {
678:         UE_LOG(LogTemp, Warning, TEXT("CauldronCraftComponent: Valid"));
679:         CauldronCraftComponent->PrintIngredientDebugData();
680:     }
681:     else
682:     {
683:         UE_LOG(LogTemp, Error, TEXT("CauldronCraftComponent: NULL - This should not happen!"));
684:     }
685: 
686:     UE_LOG(LogTemp, Warning, TEXT("=== END CAULDRON ALTAR DEBUG DATA ==="));
687: }

================
File: Source/WitchPT/Public/Item/CauldronAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "MechanicsInterface.h"
  7: #include "AbilitySystem/Interaction/IInteractableTarget.h"
  8: #include "CauldronAltar.generated.h"
  9: 
 10: class UCauldronCraftComponent;
 11: class UWitchPTInventoryItemFragment_IngredientCraftingProperties;
 12: class UWitchPTInventoryItemFragment;
 13: class UCauldronUserWidget;
 14: class ACauldronPosition;
 15: class ACharacter;
 16: 
 17: 
 18: USTRUCT(BlueprintType)
 19: struct FIngredientSequence
 20: {
 21:     GENERATED_BODY()
 22: 
 23:     UPROPERTY(BlueprintReadOnly)
 24:     TArray<FGameplayTag> Ingredients;
 25: };
 26: 
 27: 
 28: UENUM(BlueprintType)
 29: enum class ECauldronInput : uint8
 30: {
 31:     Ingredient1 UMETA(DisplayName = "Ingredient 1"),
 32:     Ingredient2 UMETA(DisplayName = "Ingredient 2"),
 33:     Ingredient3 UMETA(DisplayName = "Ingredient 3"),
 34:     Ingredient4 UMETA(DisplayName = "Ingredient 4"),
 35:     Ingredient5 UMETA(DisplayName = "Ingredient 5"),
 36:     None        UMETA(DisplayName = "None")
 37: };
 38: 
 39: UENUM(BlueprintType)
 40: enum ECauldronPhysicState
 41: {
 42:     Static UMETA(DisplayName = "InPlace"),
 43:     Moving UMETA(DisplayName = "Moving"),
 44:     Previewing UMETA(DisplayName = "Previewing")
 45: };
 46: 
 47: 
 48: UENUM(BlueprintType)
 49: enum class ECauldronPlacementState : uint8
 50: {
 51:     Valid UMETA(DisplayName = "Valid"),
 52:     Invalid UMETA(DisplayName = "Invalid"),
 53:     None UMETA(DisplayName = "None")
 54: };
 55: 
 56: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnECauldronPhysicStateChanged, ECauldronPhysicState, PhysicState);
 57: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterPositioned, bool, bWasSuccessful);
 58: 
 59: 
 60: 
 61: 
 62: UCLASS()
 63: class WITCHPT_API ACauldronAltar : public ABaseInteractableAltar, public IInteractableTarget, public IMechanicsInterface
 64: {
 65:     GENERATED_BODY()
 66: 
 67: public:
 68: 
 69:     ACauldronAltar();
 70: 
 71: 
 72:     virtual void BeginPlay() override;
 73:     virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
 74:     virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) override;
 75:     virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 76:     virtual void UnoccupyPosition(ACharacter* Character, ABaseInteractionPosition* Position) override;
 77: 
 78: 
 79:     UPROPERTY(EditAnywhere)
 80:     FInteractionOption Option;
 81: 
 82:     UPROPERTY(ReplicatedUsing = OnRep_CauldronPhysicState, BlueprintReadWrite, VisibleAnywhere, Category = "Cauldron")
 83:     TEnumAsByte<ECauldronPhysicState> CauldronPhysicState;
 84: 
 85:     UPROPERTY(EditAnywhere, Replicated)
 86:     TObjectPtr<UCauldronCraftComponent> CauldronCraftComponent;
 87: 
 88: 
 89:     UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Potion Crafting")
 90:     TSubclassOf<UWitchPTInventoryItemDefinition> BasePotionItemDefinition;
 91: 
 92: 
 93: 
 94: 
 95:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 96:     FOnECauldronPhysicStateChanged OnECauldronPhysicStateChanged;
 97: 
 98:     UPROPERTY(BlueprintAssignable, Category = "Cauldron|Placement")
 99:     FOnCharacterPositioned OnCharacterPositioned;
100: 
101: 
102:     UPROPERTY(EditDefaultsOnly, Category= "Cauldron|UI")
103:     TSubclassOf<UCauldronUserWidget> CauldronUserWidgetClass;
104: 
105: 
106:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
107:     UMaterialInterface* ValidPlacementMaterial;
108: 
109:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
110:     UMaterialInterface* InvalidPlacementMaterial;
111: 
112:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
113:     float PlacementCollisionCheckRadius = 50.0f;
114: 
115:     UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Cauldron|Placement")
116:     float MaxGroundAlignmentHeight = 20.0f;
117: 
118: 
119: 
120:     void StartBrewingPotion(ACharacter* InteractingCharacter);
121: 
122:     void TrySetIngredientInSlot(const ACharacter* RequestingCharacter, const TSubclassOf<UWitchPTInventoryItemDefinition>& IngredientItemDef);
123: 
124: 
125: 
126:     UFUNCTION()
127:     void OnRep_CauldronPhysicState();
128: 
129:     UFUNCTION()
130:     void PositionCharacterForBrewing(ACharacter* Character);
131: 
132:     UFUNCTION(BlueprintCallable, Category = "Cauldron|Brewing")
133:     ABaseInteractionPosition* GetAvailableBrewingPosition(ACharacter* Character);
134: 
135: 
136: 
137:     void StartCarryCauldron(ACharacter* InteractingCharacter);
138: 
139:     UFUNCTION()
140:     void AttachToCharacter(ACharacter* Character);
141: 
142:     UFUNCTION()
143:     void DetachFromCharacter(ACharacter* Character);
144: 
145: 
146:     void StartPlacementPreview(ACharacter* Character);
147:     void UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
148:     void FinalizePlacement();
149:     void CancelPlacement();
150:     void ApplyPlacementPreviewMaterial();
151: 
152:     UFUNCTION(Client, Unreliable)
153:     void Client_UpdatePlacementPreview(const FVector& HitLocation, const FVector& HitNormal);
154: 
155:     UFUNCTION(NetMulticast, Reliable)
156:     void Multicast_FinalizePlacement();
157: 
158: 
159:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
160:     bool CanBePickedUp() const;
161: 
162:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
163:     bool IsBeingCarried() const;
164: 
165:     UFUNCTION(BlueprintPure, Category = "Cauldron|State")
166:     ACharacter* GetCarryingCharacter() const;
167: 
168:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
169:     ECauldronPlacementState GetPlacementState() const;
170: 
171:     UFUNCTION(BlueprintPure, Category = "Cauldron|Placement")
172:     bool IsInPlacementPreview() const;
173: 
174: 
175:     UFUNCTION(BlueprintCallable, Category = "Debug|Cauldron")
176:     void PrintCauldronDebugData() const;
177: 
178: private:
179:     UPROPERTY(Replicated)
180:     TObjectPtr<ACharacter> CarryingCharacter;
181: 
182:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
183:     FName BackAttachSocketName = "BackpackSocket";
184: 
185:     UPROPERTY(EditDefaultsOnly, Category = "Cauldron|Movement")
186:     FVector DetachmentOffset = FVector(100.0f, 0.0f, 0.0f);
187: 
188: 
189:     UPROPERTY(Replicated)
190:     ECauldronPlacementState CurrentPlacementState;
191: 
192:     UPROPERTY()
193:     TArray<UMaterialInterface*> OriginalMaterials;
194: 
195:     FVector PreviewLocation;
196:     FRotator PreviewRotation;
197: 
198: 
199:     void RestoreOriginalMaterials();
200:     bool IsPlacementValid() const;
201: };

================
File: Source/WitchPT/Public/Item/RitualAltar.h
================
  1: #pragma once
  2: 
  3: #include "CoreMinimal.h"
  4: #include "Item/BaseInteractableAltar.h"
  5: #include "GameplayTagContainer.h"
  6: #include "RitualAltar.generated.h"
  7: 
  8: class URitualUserWidget;
  9: class ARitualPosition;
 10: 
 11: 
 12: UENUM(BlueprintType)
 13: enum class ERitualInput : uint8
 14: {
 15: 	Up		UMETA(DisplayName = "Up"),
 16: 	Down	UMETA(DisplayName = "Down"),
 17: 	Left	UMETA(DisplayName = "Left"),
 18: 	Right	UMETA(DisplayName = "Right"),
 19: 	None	UMETA(DisplayName = "None")
 20: };
 21: 
 22: USTRUCT(BlueprintType)
 23: struct FUIRitualData
 24: {
 25: 	GENERATED_BODY()
 26: 	UPROPERTY(BlueprintReadOnly)
 27: 	bool bIsMyTurn = false;
 28: 	UPROPERTY(BlueprintReadOnly)
 29: 	FGameplayTag ExpectedInput = FGameplayTag::EmptyTag;
 30: 	UPROPERTY(BlueprintReadOnly)
 31: 	float RitualPercentageCompleted = 0.0f;
 32: 	UPROPERTY(BlueprintReadOnly)
 33: 	float CorruptionPercentage = 0.0f;
 34: 	UPROPERTY(BlueprintReadOnly)
 35: 	float CurrentInputTimeRemaining = 0.0f;
 36: };
 37: 
 38: 
 39: USTRUCT(BlueprintType)
 40: struct FRitualReadyPlayersData
 41: {
 42: 	GENERATED_BODY()
 43: 
 44: 	UPROPERTY(BlueprintReadOnly)
 45: 	int32 TotalPlayers = 0;
 46: 
 47: 	UPROPERTY(BlueprintReadOnly)
 48: 	int32 ReadyPlayers = 0;
 49: 
 50: 	bool operator==(const FRitualReadyPlayersData& Other) const
 51: 	{
 52: 		return TotalPlayers == Other.TotalPlayers && ReadyPlayers == Other.ReadyPlayers;
 53: 	}
 54: 
 55: 	bool operator!=(const FRitualReadyPlayersData& Other) const
 56: 	{
 57: 		return !(*this == Other);
 58: 	}
 59: };
 60: 
 61: 
 62: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualStateChanged, EInteractionState, NewState);
 63: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnReadyPlayersChanged, FRitualReadyPlayersData, ReadyPlayersData);
 64: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCountdownTick, int32, CountdownValue);
 65: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnDataChanged, FUIRitualData, TurnData);
 66: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCorruptionChanged, float, CorruptionPercentage);
 67: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSequenceProgressChanged, float, ProgressPercentage);
 68: DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRitualCompleted, bool, bWasSuccessful);
 69: 
 70: UCLASS()
 71: class WITCHPT_API ARitualAltar : public ABaseInteractableAltar
 72: {
 73: 	GENERATED_BODY()
 74: 
 75: public:
 76: 
 77: 	ARitualAltar();
 78: 	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
 79: 
 80: 
 81: 
 82: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentRitualState, Category = "Ritual|State", VisibleAnywhere)
 83: 	EInteractionState CurrentRitualState = EInteractionState::Inactive;
 84: 
 85: 
 86: 	UPROPERTY(Replicated, Category = "Ritual", VisibleAnywhere)
 87: 	TArray<FGameplayTag> InputSequence;
 88: 
 89: 
 90: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentSequenceIndex, Category = "Ritual", VisibleAnywhere)
 91: 	int32 CurrentSequenceIndex = -1;
 92: 
 93: 
 94: 	UPROPERTY(Replicated, Category = "Ritual|State", VisibleAnywhere)
 95: 	TArray<TObjectPtr<ACharacter>> ReadyPlayers;
 96: 
 97: 
 98: 	UPROPERTY(ReplicatedUsing = OnRep_ReadyPlayersData, Category = "Ritual|State", VisibleAnywhere)
 99: 	FRitualReadyPlayersData ReadyPlayersData;
100: 
101: 
102: 	UPROPERTY(ReplicatedUsing = OnRep_StartCountdown, Category = "Ritual|State", VisibleAnywhere)
103: 	int32 StartCountdown = 3;
104: 
105: 
106: 	UPROPERTY(ReplicatedUsing = OnRep_CurrentActivePlayer, VisibleAnywhere, Category = "Ritual|State")
107: 	TObjectPtr<ACharacter> CurrentActivePlayer;
108: 
109: 
110: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual")
111: 	float CurrentInputTimer;
112: 
113: 
114: 	UPROPERTY(ReplicatedUsing = OnRep_TurnData, VisibleAnywhere, Category = "Ritual|UI")
115: 	FUIRitualData CurrentTurnData;
116: 
117: 
118: 	UPROPERTY(ReplicatedUsing = OnRep_CorruptionAmount, VisibleAnywhere, Category = "Ritual")
119: 	float CorruptionAmount = 0.0f;
120: 
121: 
122: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
123: 	float MaxCorruption = 100.0f;
124: 
125: 
126: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
127: 	float CorruptionIncreasePerFail = 10.0f;
128: 
129: 
130: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
131: 	float BaseInputTimeWindow = 10.0f;
132: 
133: 
134: 	UPROPERTY(Replicated, EditDefaultsOnly, Category = "Ritual|Configuration")
135: 	float DifficultyScalingMultiplier = 1.0f;
136: 
137: 
138: 	UPROPERTY(ReplicatedUsing = OnRep_RitualCompleted, VisibleAnywhere, Category = "Ritual|State")
139: 	bool bRitualCompleted = false;
140: 
141: 	UPROPERTY(Replicated, VisibleAnywhere, Category = "Ritual|State")
142: 	bool bRitualWasSuccessful = false;
143: 
144: 
145: 	FOnRitualStateChanged OnRitualStateChangedEvent;
146: 
147: 	FOnReadyPlayersChanged OnReadyPlayersChangedEvent;
148: 
149: 	FOnCountdownTick OnCountdownTickEvent;
150: 
151: 	FOnTurnDataChanged OnTurnDataChangedEvent;
152: 
153: 	FOnCorruptionChanged OnCorruptionChangedEvent;
154: 
155: 	FOnSequenceProgressChanged OnSequenceProgressChangedEvent;
156: 	UPROPERTY(BlueprintAssignable)
157: 	FOnRitualCompleted OnRitualCompletedEvent;
158: 
159: 
160: 	UFUNCTION()
161: 	void OnRep_CurrentRitualState();
162: 
163: 	UFUNCTION()
164: 	void OnRep_CurrentSequenceIndex();
165: 
166: 	UFUNCTION()
167: 	void OnRep_ReadyPlayersData();
168: 
169: 	UFUNCTION()
170: 	void OnRep_StartCountdown();
171: 
172: 	UFUNCTION()
173: 	void OnRep_CurrentActivePlayer();
174: 
175: 	UFUNCTION()
176: 	void OnRep_TurnData();
177: 
178: 	UFUNCTION()
179: 	void OnRep_CorruptionAmount();
180: 
181: 	UFUNCTION()
182: 	void OnRep_RitualCompleted();
183: 
184: 
185: 	UFUNCTION(NetMulticast, Reliable)
186: 	void Multicast_NumberOfPlayersReadyHasChanged(int32 TotalPlayers, int32 PlayersReady);
187: 
188: 	void StartRitual(ACharacter* RequestingCharacter);
189: 	void HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag);
190: 
191: 
192: 	UFUNCTION(BlueprintPure, Category = "Ritual")
193: 	bool IsPlayerReady(ACharacter* Player) const;
194: 
195: 
196: 	UFUNCTION(BlueprintPure, Category = "Ritual")
197: 	bool AreAllPlayersReady() const;
198: 
199: 	virtual void Multicast_OnInputSuccess_Implementation(ACharacter* Character) override;
200: 	virtual void Multicast_OnInputFailed_Implementation(ACharacter* Character) override;
201: 
202: 
203: 	UFUNCTION(NetMulticast, Reliable)
204: 	void Multicast_OnRitualSucceeded();
205: 
206: 	UFUNCTION(NetMulticast, Reliable)
207: 	void Multicast_OnRitualCatastrophicFail();
208: 
209: 
210: 	UFUNCTION(NetMulticast, Reliable)
211: 	void Multicast_OnCountdownTick(int32 CountdownValue);
212: 
213: 	void OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position);
214: 
215: 
216: 	virtual void UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position) override;
217: 
218: 
219: 	EInteractionState GetCurrentRitualState() const { return CurrentRitualState; }
220: 	ACharacter* GetCurrentActivePlayer() const { return CurrentActivePlayer; }
221: 	float GetCorruptionPercentage() const;
222: 	float GetCurrentInputTimeRemaining() const { return CurrentInputTimer; }
223: 	float GetCurrentSequenceProgress() const;
224: 	FGameplayTag GetCurrentExpectedInput() const;
225: 	int32 GetNumberOfReadyPlayers() const { return ReadyPlayers.Num(); }
226: 	int32 GetNumberOfTotalPlayers() const { return ParticipatingPlayers.Num(); }
227: 	FUIRitualData GetCurrentTurnData() const { return CurrentTurnData; }
228: 
229: 
230: protected:
231: 	virtual void BeginPlay() override;
232: 	virtual void Tick(float DeltaTime) override;
233: 
234: 
235: 	FTimerHandle RitualStartCountdownHandle;
236: 
237: 
238: 	FTimerHandle InputTimerHandle;
239: 
240: 
241: 	void GenerateInputSequence();
242: 	void AdvanceToNextPlayer();
243: 	virtual void HandleInputSuccess(ACharacter* Player) override;
244: 	virtual void HandleInputFailure(ACharacter* Player) override;
245: 	void ApplyAgePenalty(ACharacter* Player, bool bCatastrophic = false);
246: 	void StartInputTimer();
247: 	void OnInputTimerExpired();
248: 	void CheckRitualState();
249: 	FGameplayTag ConvertERitualInputToTag(ERitualInput Input);
250: 	ERitualInput ConvertTagToERitualInput(const FGameplayTag& Tag);
251: 	void CleanupRitual();
252: 	void SpawnReward();
253: 	void SpawnDemon();
254: 	bool IsPlayerEligibleForTurn(ACharacter* Player) const;
255: 	void UpdateTurnData();
256: 	void UpdateReadyPlayersData();
257: 
258: 
259: 	void ProcessRitualReadyRequest(ACharacter* RequestingCharacter);
260: 	void StartRitualCountdown();
261: 	void ProcessCountdownTick();
262: 	void ActivateRitual();
263: 
264: 
265: 
266: 	void BroadcastRitualStateChanged();
267: 	void BroadcastReadyPlayersChanged();
268: 	void BroadcastCountdownTick();
269: 	void BroadcastTurnDataChanged();
270: 	void BroadcastCorruptionChanged();
271: 	void BroadcastSequenceProgressChanged();
272: 	void BroadcastRitualCompleted();
273: 
274: 
275: 
276: 	void HideRitualWidgetForAllPlayers();
277: 
278: 	UPROPERTY(EditDefaultsOnly)
279: 	TObjectPtr<UAnimMontage> PrimaryAnimMontage;
280: 	UPROPERTY(EditDefaultsOnly)
281: 	TObjectPtr<UAnimMontage> SecondaryAnimMontage;
282: 	UPROPERTY(EditDefaultsOnly)
283: 	TObjectPtr<UAnimMontage> FailedAnimMontage;
284: 	UPROPERTY(EditDefaultsOnly)
285: 	TObjectPtr<UAnimMontage> FailedCatastrophicallyAnimMontage;
286: 
287: 
288: 	UPROPERTY(EditDefaultsOnly)
289: 	TObjectPtr<UAnimMontage> RitualWaitingAnimMontage;
290: 	UPROPERTY(EditDefaultsOnly)
291: 	TObjectPtr<UAnimMontage> RitualActiveAnimMontage;
292: };

================
File: Source/WitchPT/Private/Item/RitualAltar.cpp
================
   1: #include "Item/RitualAltar.h"
   2: #include "Net/UnrealNetwork.h"
   3: #include "Item/RitualPosition.h"
   4: #include "GameFramework/Character.h"
   5: #include "AbilitySystemComponent.h"
   6: #include "AbilitySystemBlueprintLibrary.h"
   7: #include "FWitchPTGameplayTags.h"
   8: #include "Player/WitchPTPlayerController.h"
   9: 
  10: 
  11: ARitualAltar::ARitualAltar()
  12: {
  13: 
  14: 	PrimaryActorTick.bCanEverTick = true;
  15: 
  16: 	bReplicates = true;
  17: 
  18: 
  19: 	CurrentRitualState = EInteractionState::Inactive;
  20: 	CurrentSequenceIndex = -1;
  21: 	CurrentInputTimer = 0.0f;
  22: 	CorruptionAmount = 0.0f;
  23: 	MaxCorruption = 100.0f;
  24: 	StartCountdown = 3;
  25: 	bRitualCompleted = false;
  26: 	bRitualWasSuccessful = false;
  27: }
  28: 
  29: void ARitualAltar::BeginPlay()
  30: {
  31: 	Super::BeginPlay();
  32: 
  33: 
  34: 
  35: 
  36: 
  37: 
  38: 
  39: 
  40: 
  41: 
  42: 
  43: 
  44: 
  45: 
  46: 
  47: 
  48: 
  49: }
  50: 
  51: void ARitualAltar::Tick(float DeltaTime)
  52: {
  53: 	Super::Tick(DeltaTime);
  54: }
  55: 
  56: void ARitualAltar::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
  57: {
  58: 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  59: 
  60: 	DOREPLIFETIME(ARitualAltar, CurrentRitualState);
  61: 	DOREPLIFETIME(ARitualAltar, InputSequence);
  62: 	DOREPLIFETIME(ARitualAltar, CurrentSequenceIndex);
  63: 	DOREPLIFETIME(ARitualAltar, ParticipatingPlayers);
  64: 	DOREPLIFETIME(ARitualAltar, CurrentActivePlayer);
  65: 	DOREPLIFETIME(ARitualAltar, CurrentInputTimer);
  66: 	DOREPLIFETIME(ARitualAltar, CurrentTurnData);
  67: 	DOREPLIFETIME(ARitualAltar, CorruptionAmount);
  68: 	DOREPLIFETIME(ARitualAltar, MaxCorruption);
  69: 	DOREPLIFETIME(ARitualAltar, CorruptionIncreasePerFail);
  70: 	DOREPLIFETIME(ARitualAltar, BaseInputTimeWindow);
  71: 	DOREPLIFETIME(ARitualAltar, DifficultyScalingMultiplier);
  72: 	DOREPLIFETIME(ARitualAltar, ReadyPlayers);
  73: 	DOREPLIFETIME(ARitualAltar, ReadyPlayersData);
  74: 	DOREPLIFETIME(ARitualAltar, StartCountdown);
  75: 	DOREPLIFETIME(ARitualAltar, bRitualCompleted);
  76: 	DOREPLIFETIME(ARitualAltar, bRitualWasSuccessful);
  77: }
  78: 
  79: 
  80: 
  81: void ARitualAltar::OnRep_CurrentRitualState()
  82: {
  83: 	BroadcastRitualStateChanged();
  84: }
  85: 
  86: void ARitualAltar::OnRep_CurrentSequenceIndex()
  87: {
  88: 
  89: 	BroadcastSequenceProgressChanged();
  90: }
  91: 
  92: void ARitualAltar::OnRep_ReadyPlayersData()
  93: {
  94: 	BroadcastReadyPlayersChanged();
  95: }
  96: 
  97: void ARitualAltar::OnRep_StartCountdown()
  98: {
  99: 	BroadcastCountdownTick();
 100: }
 101: 
 102: void ARitualAltar::OnRep_CurrentActivePlayer()
 103: {
 104: 
 105: 
 106: }
 107: 
 108: void ARitualAltar::OnRep_TurnData()
 109: {
 110: 	BroadcastTurnDataChanged();
 111: }
 112: 
 113: void ARitualAltar::OnRep_CorruptionAmount()
 114: {
 115: 	BroadcastCorruptionChanged();
 116: }
 117: 
 118: void ARitualAltar::OnRep_RitualCompleted()
 119: {
 120: 	if (bRitualCompleted)
 121: 	{
 122: 		BroadcastRitualCompleted();
 123: 	}
 124: }
 125: 
 126: 
 127: 
 128: void ARitualAltar::BroadcastRitualStateChanged()
 129: {
 130: 	OnRitualStateChangedEvent.Broadcast(CurrentRitualState);
 131: }
 132: 
 133: void ARitualAltar::BroadcastReadyPlayersChanged()
 134: {
 135: 	OnReadyPlayersChangedEvent.Broadcast(ReadyPlayersData);
 136: }
 137: 
 138: void ARitualAltar::BroadcastCountdownTick()
 139: {
 140: 	OnCountdownTickEvent.Broadcast(StartCountdown);
 141: }
 142: 
 143: void ARitualAltar::BroadcastTurnDataChanged()
 144: {
 145: 	OnTurnDataChangedEvent.Broadcast(CurrentTurnData);
 146: }
 147: 
 148: void ARitualAltar::BroadcastCorruptionChanged()
 149: {
 150: 	float CorruptionPercentage = GetCorruptionPercentage();
 151: 	OnCorruptionChangedEvent.Broadcast(CorruptionPercentage);
 152: }
 153: 
 154: void ARitualAltar::BroadcastSequenceProgressChanged()
 155: {
 156: 	float Progress = GetCurrentSequenceProgress();
 157: 	OnSequenceProgressChangedEvent.Broadcast(Progress);
 158: }
 159: 
 160: void ARitualAltar::BroadcastRitualCompleted()
 161: {
 162: 	OnRitualCompletedEvent.Broadcast(bRitualWasSuccessful);
 163: }
 164: 
 165: 
 166: 
 167: void ARitualAltar::UpdateTurnData()
 168: {
 169: 
 170: 
 171: 
 172: 
 173: 	FUIRitualData NewTurnData;
 174: 	NewTurnData.RitualPercentageCompleted = GetCurrentSequenceProgress();
 175: 	NewTurnData.CorruptionPercentage = GetCorruptionPercentage();
 176: 	NewTurnData.CurrentInputTimeRemaining = CurrentInputTimer;
 177: 
 178: 
 179: 	if (CurrentActivePlayer && InputSequence.IsValidIndex(CurrentSequenceIndex))
 180: 	{
 181: 		NewTurnData.ExpectedInput = InputSequence[CurrentSequenceIndex];
 182: 	}
 183: 	else
 184: 	{
 185: 		NewTurnData.ExpectedInput = FGameplayTag::EmptyTag;
 186: 	}
 187: 
 188: 
 189: 	NewTurnData.bIsMyTurn = false;
 190: 
 191: 
 192: 	if (HasAuthority())
 193: 	{
 194: 
 195: 		if (!(CurrentTurnData.bIsMyTurn == NewTurnData.bIsMyTurn &&
 196: 			  CurrentTurnData.ExpectedInput == NewTurnData.ExpectedInput &&
 197: 			  FMath::IsNearlyEqual(CurrentTurnData.RitualPercentageCompleted, NewTurnData.RitualPercentageCompleted, 0.01f) &&
 198: 			  FMath::IsNearlyEqual(CurrentTurnData.CorruptionPercentage, NewTurnData.CorruptionPercentage, 0.01f) &&
 199: 			  FMath::IsNearlyEqual(CurrentTurnData.CurrentInputTimeRemaining, NewTurnData.CurrentInputTimeRemaining, 0.1f)))
 200: 		{
 201: 			CurrentTurnData = NewTurnData;
 202: 
 203: 			BroadcastTurnDataChanged();
 204: 		}
 205: 	}
 206: 	else
 207: 	{
 208: 
 209: 		CurrentTurnData = NewTurnData;
 210: 		BroadcastTurnDataChanged();
 211: 	}
 212: }
 213: 
 214: void ARitualAltar::UpdateReadyPlayersData()
 215: {
 216: 	if (!HasAuthority())
 217: 	{
 218: 		return;
 219: 	}
 220: 
 221: 	FRitualReadyPlayersData NewData;
 222: 	NewData.TotalPlayers = ParticipatingPlayers.Num();
 223: 	NewData.ReadyPlayers = ReadyPlayers.Num();
 224: 
 225: 	if (ReadyPlayersData != NewData)
 226: 	{
 227: 		ReadyPlayersData = NewData;
 228: 
 229: 		BroadcastReadyPlayersChanged();
 230: 	}
 231: }
 232: 
 233: 
 234: 
 235: void ARitualAltar::Multicast_NumberOfPlayersReadyHasChanged_Implementation(int32 TotalPlayers, int32 PlayersReady)
 236: {
 237: 
 238: 	UpdateReadyPlayersData();
 239: }
 240: 
 241: void ARitualAltar::StartRitual(ACharacter* RequestingCharacter)
 242: {
 243: 	if (!HasAuthority() || !RequestingCharacter)
 244: 	{
 245: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: invalid player or no authority"));
 246: 		return;
 247: 	}
 248: 
 249: 
 250: 	if (CurrentRitualState != EInteractionState::Inactive &&
 251: 	    CurrentRitualState != EInteractionState::WaitingForPlayers)
 252: 	{
 253: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Cannot start ritual: already in state %d"), static_cast<int32>(CurrentRitualState));
 254: 		return;
 255: 	}
 256: 
 257: 
 258: 	ProcessRitualReadyRequest(RequestingCharacter);
 259: }
 260: 
 261: void ARitualAltar::ProcessRitualReadyRequest(ACharacter* RequestingCharacter)
 262: {
 263: 	if (!HasAuthority() || !RequestingCharacter)
 264: 	{
 265: 		return;
 266: 	}
 267: 
 268: 
 269: 	if (ReadyPlayers.Contains(RequestingCharacter))
 270: 	{
 271: 
 272: 		ReadyPlayers.Remove(RequestingCharacter);
 273: 		UpdateReadyPlayersData();
 274: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s canceled ready status"), *RequestingCharacter->GetName());
 275: 		return;
 276: 	}
 277: 
 278: 
 279: 	ReadyPlayers.Add(RequestingCharacter);
 280: 	UpdateReadyPlayersData();
 281: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Player %s is ready"), *RequestingCharacter->GetName());
 282: 
 283: 
 284: 	if (AreAllPlayersReady())
 285: 	{
 286: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] All players are ready. Starting countdown!"));
 287: 		StartRitualCountdown();
 288: 	}
 289: }
 290: 
 291: bool ARitualAltar::IsPlayerReady(ACharacter* Player) const
 292: {
 293: 	return ReadyPlayers.Contains(Player);
 294: }
 295: 
 296: bool ARitualAltar::AreAllPlayersReady() const
 297: {
 298: 
 299: 	if (ParticipatingPlayers.Num() == 0 || ReadyPlayers.Num() == 0)
 300: 	{
 301: 		return false;
 302: 	}
 303: 
 304: 	for (ACharacter* Player : ParticipatingPlayers)
 305: 	{
 306: 		if (!ReadyPlayers.Contains(Player))
 307: 		{
 308: 			return false;
 309: 		}
 310: 	}
 311: 
 312: 	return true;
 313: }
 314: 
 315: void ARitualAltar::StartRitualCountdown()
 316: {
 317: 	if (!HasAuthority())
 318: 	{
 319: 		return;
 320: 	}
 321: 
 322: 
 323: 	CurrentRitualState = EInteractionState::Preparing;
 324: 
 325: 	BroadcastRitualStateChanged();
 326: 
 327: 
 328: 	GenerateInputSequence();
 329: 
 330: 
 331: 	StartCountdown = 3;
 332: 
 333: 	BroadcastCountdownTick();
 334: 
 335: 
 336: 	GetWorldTimerManager().SetTimer(
 337: 		RitualStartCountdownHandle,
 338: 		this,
 339: 		&ARitualAltar::ProcessCountdownTick,
 340: 		1.0f,
 341: 		true
 342: 	);
 343: }
 344: 
 345: void ARitualAltar::ProcessCountdownTick()
 346: {
 347: 	if (!HasAuthority())
 348: 	{
 349: 		return;
 350: 	}
 351: 
 352: 
 353: 	StartCountdown--;
 354: 
 355: 	BroadcastCountdownTick();
 356: 
 357: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Countdown: %d"), StartCountdown);
 358: 
 359: 	if (StartCountdown <= 0)
 360: 	{
 361: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 362: 		ActivateRitual();
 363: 	}
 364: }
 365: 
 366: void ARitualAltar::ActivateRitual()
 367: {
 368: 	if (!HasAuthority())
 369: 	{
 370: 		return;
 371: 	}
 372: 
 373: 
 374: 	int32 RandomStartingPlayer = FMath::RandRange(0, ReadyPlayers.Num() - 1);
 375: 
 376: 
 377: 	CurrentActivePlayer = ParticipatingPlayers[RandomStartingPlayer];
 378: 	CurrentSequenceIndex = 0;
 379: 	CurrentRitualState = EInteractionState::Active;
 380: 
 381: 
 382: 	StartInputTimer();
 383: 
 384: 
 385: 	UpdateTurnData();
 386: 
 387: 
 388: 	BroadcastRitualStateChanged();
 389: }
 390: 
 391: void ARitualAltar::Multicast_OnCountdownTick_Implementation(int32 CountdownValue)
 392: {
 393: 
 394: 	StartCountdown = CountdownValue;
 395: }
 396: 
 397: void ARitualAltar::GenerateInputSequence()
 398: {
 399: 	if (!HasAuthority())
 400: 	{
 401: 		return;
 402: 	}
 403: 
 404: 	InputSequence.Empty();
 405: 
 406: 
 407: 	int32 SequenceLength = FMath::Max(5, FMath::RoundToInt(5.0f * ParticipatingPlayers.Num() * DifficultyScalingMultiplier));
 408: 
 409: 
 410: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 411: 
 412: 	TArray<FGameplayTag> PossibleInputs;
 413: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Up);
 414: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Down);
 415: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Left);
 416: 	PossibleInputs.Add(WitchPtGameplayTags.Ritual_Input_Right);
 417: 
 418: 
 419: 	for (int32 i = 0; i < SequenceLength; ++i)
 420: 	{
 421: 		int32 RandomIndex = FMath::RandRange(0, PossibleInputs.Num() - 1);
 422: 		InputSequence.Add(PossibleInputs[RandomIndex]);
 423: 	}
 424: 
 425: 
 426: 
 427: 
 428: }
 429: 
 430: void ARitualAltar::HandlePlayerInput(ACharacter* Character, const FGameplayTag& InputTag)
 431: {
 432: 	if (!Character || !HasAuthority())
 433: 	{
 434: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input: no authority or invalid character"));
 435: 		return;
 436: 	}
 437: 
 438: 
 439: 	if (CurrentRitualState != EInteractionState::Active)
 440: 	{
 441: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: ritual not active (state=%d)"),
 442: 			*Character->GetName(), static_cast<int32>(CurrentRitualState));
 443: 		return;
 444: 	}
 445: 
 446: 
 447: 	if (Character != CurrentActivePlayer)
 448: 	{
 449: 		UE_LOG(LogTemp, Warning, TEXT("[DEBUG-RITUAL] Rejected input from %s: not their turn (current active=%s)"),
 450: 			*Character->GetName(), CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"));
 451: 		return;
 452: 	}
 453: 
 454: 
 455: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 456: 	{
 457: 		UE_LOG(LogTemp, Error, TEXT("[DEBUG-RITUAL] Input validation error: invalid sequence state (index=%d, sequence length=%d)"),
 458: 			CurrentSequenceIndex, InputSequence.Num());
 459: 		return;
 460: 	}
 461: 
 462: 
 463: 	FGameplayTag ExpectedInput = InputSequence[CurrentSequenceIndex];
 464: 
 465: 
 466: 
 467: 	if (InputTag == ExpectedInput)
 468: 	{
 469: 		HandleInputSuccess(Character);
 470: 	}
 471: 	else
 472: 	{
 473: 		HandleInputFailure(Character);
 474: 	}
 475: }
 476: 
 477: void ARitualAltar::Multicast_OnInputSuccess_Implementation(ACharacter* Character)
 478: {
 479: 
 480: 	if (Character)
 481: 	{
 482: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 483: 		if (ASC)
 484: 		{
 485: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 486: 			FGameplayEventData EventData;
 487: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 488: 			EventData.Instigator = this;
 489: 			EventData.Target = Character;
 490: 
 491: 
 492: 			FGameplayTag* PositionTag = nullptr;
 493: 			for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 494: 			{
 495: 				if (Entry.Player == Character)
 496: 				{
 497: 					PositionTag = &Entry.PositionTag;
 498: 					break;
 499: 				}
 500: 			}
 501: 			if (PositionTag && PositionTag->MatchesTag(WitchPtGameplayTags.Get().Ritual_Position_1))
 502: 			{
 503: 				EventData.OptionalObject = PrimaryAnimMontage;
 504: 			} else
 505: 			{
 506: 				EventData.OptionalObject = SecondaryAnimMontage;
 507: 			}
 508: 
 509: 
 510: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputSuccess, EventData);
 511: 		}
 512: 
 513: 
 514: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 515: 	}
 516: }
 517: 
 518: void ARitualAltar::HandleInputSuccess(ACharacter* Player)
 519: {
 520: 	if (!HasAuthority() || !Player)
 521: 	{
 522: 		return;
 523: 	}
 524: 
 525: 
 526: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 527: 
 528: 
 529: 	CurrentSequenceIndex++;
 530: 
 531: 
 532: 	Multicast_OnInputSuccess(Player);
 533: 
 534: 
 535: 	if (CurrentSequenceIndex >= InputSequence.Num())
 536: 	{
 537: 
 538: 		CurrentRitualState = EInteractionState::Succeeded;
 539: 		bRitualCompleted = true;
 540: 		bRitualWasSuccessful = true;
 541: 
 542: 
 543: 		UpdateTurnData();
 544: 
 545: 
 546: 		BroadcastRitualStateChanged();
 547: 		BroadcastRitualCompleted();
 548: 
 549: 
 550: 		SpawnReward();
 551: 		Multicast_OnRitualSucceeded();
 552: 
 553: 
 554: 		CleanupRitual();
 555: 	}
 556: 	else
 557: 	{
 558: 
 559: 		AdvanceToNextPlayer();
 560: 
 561: 
 562: 		StartInputTimer();
 563: 
 564: 
 565: 		UpdateTurnData();
 566: 	}
 567: }
 568: 
 569: void ARitualAltar::HandleInputFailure(ACharacter* Player)
 570: {
 571: 	if (!HasAuthority() || !Player)
 572: 	{
 573: 		return;
 574: 	}
 575: 
 576: 
 577: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 578: 
 579: 
 580: 	CorruptionAmount += CorruptionIncreasePerFail;
 581: 
 582: 	BroadcastCorruptionChanged();
 583: 
 584: 
 585: 
 586: 
 587: 
 588: 	ApplyAgePenalty(Player);
 589: 
 590: 
 591: 	Multicast_OnInputFailed(Player);
 592: 
 593: 
 594: 	if (CorruptionAmount >= MaxCorruption)
 595: 	{
 596: 
 597: 		CurrentRitualState = EInteractionState::FailedCatastrophically;
 598: 		bRitualCompleted = true;
 599: 		bRitualWasSuccessful = false;
 600: 
 601: 
 602: 		UpdateTurnData();
 603: 
 604: 
 605: 		BroadcastRitualStateChanged();
 606: 		BroadcastRitualCompleted();
 607: 
 608: 
 609: 		for (ACharacter* ParticipatingPlayer : ParticipatingPlayers)
 610: 		{
 611: 			if (ParticipatingPlayer)
 612: 			{
 613: 				ApplyAgePenalty(ParticipatingPlayer, true);
 614: 			}
 615: 		}
 616: 
 617: 
 618: 		SpawnDemon();
 619: 		Multicast_OnRitualCatastrophicFail();
 620: 
 621: 
 622: 		CleanupRitual();
 623: 	}
 624: 	else
 625: 	{
 626: 
 627: 		AdvanceToNextPlayer();
 628: 
 629: 
 630: 		StartInputTimer();
 631: 
 632: 
 633: 		UpdateTurnData();
 634: 	}
 635: }
 636: 
 637: void ARitualAltar::StartInputTimer()
 638: {
 639: 	if (!HasAuthority())
 640: 	{
 641: 		return;
 642: 	}
 643: 
 644: 
 645: 	float ProgressDifficulty = FMath::Clamp(CurrentSequenceIndex / (float)InputSequence.Num(), 0.0f, 1.0f);
 646: 	float ScaledTimeWindow = BaseInputTimeWindow * (1.0f - (ProgressDifficulty * 0.5f));
 647: 
 648: 
 649: 	CurrentInputTimer = ScaledTimeWindow;
 650: 
 651: 
 652: 
 653: 	GetWorldTimerManager().SetTimer(
 654: 		InputTimerHandle,
 655: 		this,
 656: 		&ARitualAltar::OnInputTimerExpired,
 657: 		ScaledTimeWindow,
 658: 		false
 659: 	);
 660: 
 661: 	UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Started input timer: %.2f seconds for player %s, input %d/%d"),
 662: 		ScaledTimeWindow, CurrentActivePlayer ? *CurrentActivePlayer->GetName() : TEXT("None"),
 663: 		CurrentSequenceIndex, InputSequence.Num()-1);
 664: 
 665: 
 666: 	if (InputSequence.IsValidIndex(CurrentSequenceIndex))
 667: 	{
 668: 		UE_LOG(LogTemp, Log, TEXT("[DEBUG-RITUAL] Current expected input: %s"),
 669: 			*InputSequence[CurrentSequenceIndex].ToString());
 670: 	}
 671: }
 672: 
 673: void ARitualAltar::OnInputTimerExpired()
 674: {
 675: 	if (!HasAuthority() || CurrentRitualState != EInteractionState::Active)
 676: 	{
 677: 		return;
 678: 	}
 679: 
 680: 
 681: 	if (CurrentActivePlayer)
 682: 	{
 683: 		HandleInputFailure(CurrentActivePlayer);
 684: 	}
 685: 	else
 686: 	{
 687: 
 688: 		UE_LOG(LogTemp, Error, TEXT("[RitualAltar] Timer expired but no active player!"));
 689: 		AdvanceToNextPlayer();
 690: 		StartInputTimer();
 691: 	}
 692: }
 693: 
 694: void ARitualAltar::AdvanceToNextPlayer()
 695: {
 696: 	if (!HasAuthority() || ParticipatingPlayers.Num() == 0)
 697: 	{
 698: 		return;
 699: 	}
 700: 
 701: 
 702: 
 703: 	int32 CurrentPlayerIndex = ParticipatingPlayers.IndexOfByKey(CurrentActivePlayer);
 704: 
 705: 
 706: 	if (CurrentPlayerIndex == INDEX_NONE || CurrentPlayerIndex >= ParticipatingPlayers.Num() - 1)
 707: 	{
 708: 		CurrentPlayerIndex = 0;
 709: 	}
 710: 	else
 711: 	{
 712: 		CurrentPlayerIndex++;
 713: 	}
 714: 
 715: 
 716: 	int32 StartIndex = CurrentPlayerIndex;
 717: 	bool bFoundEligiblePlayer = false;
 718: 
 719: 
 720: 	do
 721: 	{
 722: 		ACharacter* NextPlayer = ParticipatingPlayers[CurrentPlayerIndex];
 723: 		if (NextPlayer && IsPlayerEligibleForTurn(NextPlayer))
 724: 		{
 725: 			CurrentActivePlayer = NextPlayer;
 726: 			bFoundEligiblePlayer = true;
 727: 			break;
 728: 		}
 729: 
 730: 
 731: 		CurrentPlayerIndex = (CurrentPlayerIndex + 1) % ParticipatingPlayers.Num();
 732: 	}
 733: 	while (CurrentPlayerIndex != StartIndex && !bFoundEligiblePlayer);
 734: 
 735: 
 736: 	if (!bFoundEligiblePlayer && ParticipatingPlayers.Num() > 0)
 737: 	{
 738: 		CurrentActivePlayer = ParticipatingPlayers[0];
 739: 	}
 740: }
 741: 
 742: bool ARitualAltar::IsPlayerEligibleForTurn(ACharacter* Player) const
 743: {
 744: 	if (!Player)
 745: 	{
 746: 		return false;
 747: 	}
 748: 
 749: 
 750: 	bool bIsInPosition = false;
 751: 	for (const ABaseInteractionPosition* Position : InteractionPositions)
 752: 	{
 753: 		if (Position && Position->IsOccupied() && Position->GetOccupyingCharacter() == Player)
 754: 		{
 755: 			bIsInPosition = true;
 756: 			break;
 757: 		}
 758: 	}
 759: 
 760: 
 761: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 762: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 763: 	bool bHasPositionTag = ASC && ASC->HasMatchingGameplayTag(WitchPtGameplayTags.Character_State_Ritual_InPosition);
 764: 
 765: 	return bIsInPosition && bHasPositionTag;
 766: }
 767: 
 768: 
 769: void ARitualAltar::ApplyAgePenalty(ACharacter* Player, bool bCatastrophic)
 770: {
 771: 	if (!HasAuthority() || !Player)
 772: 	{
 773: 		return;
 774: 	}
 775: 
 776: 
 777: 	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Player);
 778: 	if (!ASC)
 779: 	{
 780: 		return;
 781: 	}
 782: 
 783: 
 784: 
 785: 
 786: 
 787: 
 788: 
 789: 
 790: 
 791: 
 792: 
 793: 
 794: 
 795: 
 796: 
 797: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Applied %s age penalty to %s"),
 798: 		bCatastrophic ? TEXT("catastrophic") : TEXT("standard"), *Player->GetName());
 799: }
 800: 
 801: void ARitualAltar::SpawnReward()
 802: {
 803: 	if (!HasAuthority())
 804: 	{
 805: 		return;
 806: 	}
 807: 
 808: 
 809: 
 810: 
 811: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned ritual reward"));
 812: }
 813: 
 814: void ARitualAltar::SpawnDemon()
 815: {
 816: 	if (!HasAuthority())
 817: 	{
 818: 		return;
 819: 	}
 820: 
 821: 
 822: 
 823: 
 824: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Spawned demon"));
 825: }
 826: 
 827: void ARitualAltar::CleanupRitual()
 828: {
 829: 	if (!HasAuthority())
 830: 	{
 831: 		return;
 832: 	}
 833: 
 834: 
 835: 	GetWorldTimerManager().ClearTimer(InputTimerHandle);
 836: 	GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
 837: 
 838: 
 839: 	HideRitualWidgetForAllPlayers();
 840: 
 841: 
 842: 	CurrentSequenceIndex = 0;
 843: 	InputSequence.Empty();
 844: 	CurrentActivePlayer = nullptr;
 845: 	ReadyPlayers.Empty();
 846: 
 847: 
 848: 
 849: 
 850: 
 851: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual cleaned up and widgets hidden"));
 852: }
 853: 
 854: float ARitualAltar::GetCurrentSequenceProgress() const
 855: {
 856: 	if (InputSequence.Num() == 0)
 857: 	{
 858: 		return 0.0f;
 859: 	}
 860: 
 861: 	return static_cast<float>(CurrentSequenceIndex) / static_cast<float>(InputSequence.Num());
 862: }
 863: 
 864: FGameplayTag ARitualAltar::GetCurrentExpectedInput() const
 865: {
 866: 	if (InputSequence.Num() == 0 || CurrentSequenceIndex >= InputSequence.Num())
 867: 	{
 868: 
 869: 		return FGameplayTag();
 870: 	}
 871: 
 872: 	return InputSequence[CurrentSequenceIndex];
 873: }
 874: 
 875: 
 876: 
 877: FGameplayTag ARitualAltar::ConvertERitualInputToTag(ERitualInput Input)
 878: {
 879: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 880: 
 881: 	switch (Input)
 882: 	{
 883: 	case ERitualInput::Up:
 884: 		return WitchPtGameplayTags.Ritual_Input_Up;
 885: 	case ERitualInput::Down:
 886: 		return WitchPtGameplayTags.Ritual_Input_Down;
 887: 	case ERitualInput::Left:
 888: 		return WitchPtGameplayTags.Ritual_Input_Left;
 889: 	case ERitualInput::Right:
 890: 		return WitchPtGameplayTags.Ritual_Input_Right;
 891: 	default:
 892: 		return FGameplayTag();
 893: 	}
 894: }
 895: 
 896: ERitualInput ARitualAltar::ConvertTagToERitualInput(const FGameplayTag& Tag)
 897: {
 898: 	const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 899: 
 900: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Up)
 901: 		return ERitualInput::Up;
 902: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Down)
 903: 		return ERitualInput::Down;
 904: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Left)
 905: 		return ERitualInput::Left;
 906: 	if (Tag == WitchPtGameplayTags.Ritual_Input_Right)
 907: 		return ERitualInput::Right;
 908: 
 909: 	return ERitualInput::None;
 910: }
 911: 
 912: void ARitualAltar::Multicast_OnInputFailed_Implementation(ACharacter* Character)
 913: {
 914: 	if (Character)
 915: 	{
 916: 		UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Character);
 917: 		if (ASC)
 918: 		{
 919: 			const FWitchPTGameplayTags& WitchPtGameplayTags = FWitchPTGameplayTags::Get();
 920: 			FGameplayEventData EventData;
 921: 			EventData.EventTag = WitchPtGameplayTags.Event_Ritual_InputSuccess;
 922: 			EventData.Instigator = this;
 923: 			EventData.Target = Character;
 924: 
 925: 			EventData.OptionalObject = FailedAnimMontage;
 926: 
 927: 			UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Character, WitchPtGameplayTags.Event_Ritual_InputFailure, EventData);
 928: 
 929: 		}
 930: 
 931: 
 932: 
 933: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Input success feedback for player %s"), *Character->GetName());
 934: 	}
 935: 
 936: 
 937: }
 938: 
 939: 
 940: 
 941: void ARitualAltar::OccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
 942: {
 943: 
 944: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player LocalRole Role: %s"), *UEnum::GetValueAsString(Player->GetLocalRole()));
 945: 	UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player RemoteRole Role: %s"), *UEnum::GetValueAsString(Player->GetRemoteRole()));
 946: 	if (Player->IsLocallyControlled())
 947: 	{
 948: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is locally controlled"));
 949: 	}
 950: 	else
 951: 	{
 952: 		UE_LOG(LogTemp, Warning, TEXT("[RitualAltar] Player is NOT locally controlled"));
 953: 	}
 954: 
 955: 	if (!Player || !Position || !HasAuthority())
 956: 	{
 957: 		return;
 958: 	}
 959: 
 960: 
 961: 	if (Position->IsOccupied())
 962: 	{
 963: 
 964: 		return;
 965: 	}
 966: 	Position->SetOccupied(Player);
 967: 
 968: 	bool bFound = false;
 969: 	for (FPlayerPositionTagEntry& Entry : PlayerPositionTags)
 970: 	{
 971: 		if (Entry.Player == Player)
 972: 		{
 973: 			Entry.PositionTag = Position->GetPositionTag();
 974: 			bFound = true;
 975: 			break;
 976: 		}
 977: 	}
 978: 	if (!bFound)
 979: 	{
 980: 		FPlayerPositionTagEntry NewEntry;
 981: 		NewEntry.Player = Player;
 982: 		NewEntry.PositionTag = Position->GetPositionTag();
 983: 		PlayerPositionTags.Add(NewEntry);
 984: 	}
 985: 
 986: 
 987: 	if (!ParticipatingPlayers.Contains(Player))
 988: 	{
 989: 		ParticipatingPlayers.Add(Player);
 990: 	}
 991: 	CurrentRitualState = EInteractionState::WaitingForPlayers;
 992: 
 993: 
 994: 	if (HasAuthority())
 995: 	{
 996: 		BroadcastRitualStateChanged();
 997: 	}
 998: 
 999: 
1000: 	UpdateReadyPlayersData();
1001: 
1002: 
1003: 	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1004: 	if (PC)
1005: 	{
1006: 		if (Player->IsLocallyControlled())
1007: 		{
1008: 
1009: 			PC->LocalShowRitualWidget(this);
1010: 		}
1011: 		else
1012: 		{
1013: 
1014: 			PC->Client_ShowRitualWidget(this);
1015: 		}
1016: 
1017: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Showing ritual widget for player %s"), *Player->GetName());
1018: 	}
1019: }
1020: 
1021: void ARitualAltar::Multicast_OnRitualSucceeded_Implementation()
1022: {
1023: 
1024: 
1025: 
1026: 
1027: 
1028: 
1029: 
1030: 
1031: 	bRitualCompleted = true;
1032: 	bRitualWasSuccessful = true;
1033: 
1034: 
1035: 	if (HasAuthority())
1036: 	{
1037: 		HideRitualWidgetForAllPlayers();
1038: 	}
1039: 
1040: 	DestroyAltarPositions();
1041: 
1042: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual succeeded feedback and widgets hidden"));
1043: }
1044: 
1045: void ARitualAltar::Multicast_OnRitualCatastrophicFail_Implementation()
1046: {
1047: 
1048: 
1049: 
1050: 
1051: 
1052: 
1053: 
1054: 
1055: 	bRitualCompleted = true;
1056: 	bRitualWasSuccessful = false;
1057: 
1058: 
1059: 	if (HasAuthority())
1060: 	{
1061: 		HideRitualWidgetForAllPlayers();
1062: 	}
1063: 
1064: 	UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Ritual catastrophically failed feedback and widgets hidden"));
1065: }
1066: 
1067: float ARitualAltar::GetCorruptionPercentage() const
1068: {
1069: 	if (MaxCorruption == 0.0f)
1070: 	{
1071: 		return 0.0f;
1072: 	}
1073: 
1074: 	return CorruptionAmount / MaxCorruption;
1075: }
1076: 
1077: void ARitualAltar::HideRitualWidgetForAllPlayers()
1078: {
1079: 
1080: 	for (ACharacter* Player : ParticipatingPlayers)
1081: 	{
1082: 		if (Player)
1083: 		{
1084: 			AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1085: 			if (PC)
1086: 			{
1087: 
1088: 			if (Player->IsLocallyControlled())
1089: 			{
1090: 
1091: 				PC->LocalHideRitualWidget();
1092: 			}
1093: 			else
1094: 			{
1095: 
1096: 				PC->Client_HideRitualWidget();
1097: 			}
1098: 
1099: 				UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for player %s"), *Player->GetName());
1100: 			}
1101: 		}
1102: 	}
1103: }
1104: 
1105: void ARitualAltar::UnoccupyPosition(ACharacter* Player, ABaseInteractionPosition* Position)
1106: {
1107: 	if (!Player || !HasAuthority())
1108: 	{
1109: 		return;
1110: 	}
1111: 
1112: 
1113: 	AWitchPTPlayerController* PC = Cast<AWitchPTPlayerController>(Player->GetController());
1114: 	if (PC)
1115: 	{
1116: 
1117: 		if (Player->IsLocallyControlled())
1118: 		{
1119: 
1120: 			PC->LocalHideRitualWidget();
1121: 		}
1122: 		else
1123: 		{
1124: 
1125: 			PC->Client_HideRitualWidget();
1126: 		}
1127: 
1128: 		UE_LOG(LogTemp, Log, TEXT("[RitualAltar] Hidden ritual widget for leaving player %s"), *Player->GetName());
1129: 	}
1130: 
1131: 
1132: 	Super::UnoccupyPosition(Player, Position);
1133: 
1134: 
1135: 	ReadyPlayers.Remove(Player);
1136: 	UpdateReadyPlayersData();
1137: 
1138: 
1139: 	if (ParticipatingPlayers.Num() == 0)
1140: 	{
1141: 
1142: 		CurrentRitualState = EInteractionState::Inactive;
1143: 		BroadcastRitualStateChanged();
1144: 
1145: 
1146: 		CurrentSequenceIndex = 0;
1147: 		InputSequence.Empty();
1148: 		CurrentActivePlayer = nullptr;
1149: 		ReadyPlayers.Empty();
1150: 		UpdateReadyPlayersData();
1151: 
1152: 
1153: 		GetWorldTimerManager().ClearTimer(RitualStartCountdownHandle);
1154: 		GetWorldTimerManager().ClearTimer(InputTimerHandle);
1155: 	}
1156: }




================================================================
End of Codebase
================================================================
